/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ ((module) => {

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

module.exports = _assertThisInitialized;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ ((module) => {

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

module.exports = _classCallCheck;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ ((module) => {

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

module.exports = _createClass;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/defineProperty.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/defineProperty.js ***!
  \***************************************************************/
/***/ ((module) => {

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

module.exports = _defineProperty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ ((module) => {

function _getPrototypeOf(o) {
  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

module.exports = _getPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf */ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) setPrototypeOf(subClass, superClass);
}

module.exports = _inherits;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/objectDestructuringEmpty.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/objectDestructuringEmpty.js ***!
  \*************************************************************************/
/***/ ((module) => {

function _objectDestructuringEmpty(obj) {
  if (obj == null) throw new TypeError("Cannot destructure undefined");
}

module.exports = _objectDestructuringEmpty;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var _typeof = __webpack_require__(/*! ../helpers/typeof */ "./node_modules/@babel/runtime/helpers/typeof.js");

var assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized */ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js");

function _possibleConstructorReturn(self, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  }

  return assertThisInitialized(self);
}

module.exports = _possibleConstructorReturn;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ ((module) => {

function _setPrototypeOf(o, p) {
  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

module.exports = _setPrototypeOf;

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ ((module) => {

function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    module.exports = _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    module.exports = _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

module.exports = _typeof;

/***/ }),

/***/ "./src/levels/Main/index.js":
/*!**********************************!*\
  !*** ./src/levels/Main/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WHITE": () => (/* binding */ WHITE),
/* harmony export */   "SUNLIGHT": () => (/* binding */ SUNLIGHT),
/* harmony export */   "DARKER_GROUND": () => (/* binding */ DARKER_GROUND),
/* harmony export */   "GROUND": () => (/* binding */ GROUND),
/* harmony export */   "BACKGROUND": () => (/* binding */ BACKGROUND),
/* harmony export */   "default": () => (/* binding */ Main)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ "./node_modules/@babel/runtime/helpers/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ "./node_modules/@babel/runtime/helpers/createClass.js");
/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ "./node_modules/@babel/runtime/helpers/inherits.js");
/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var mage_engine__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! mage-engine */ "./node_modules/mage-engine/dist/mage.js");






function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_4___default()(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_3___default()(this, result); }; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }


var WHITE = 0xffffff;
var SUNLIGHT = 0xffeaa7;
var DARKER_GROUND = 0X78e08f;
var GROUND = 0xb8e994;
var BACKGROUND = 0xdff9fb; //0xddf3f5;

var DOF_OPTIONS = {
  focus: 1.0,
  aperture: .0003,
  //0.0002,//0.0001,
  maxblur: 0.006 //0.01

};
var SATURATION_OPTIONS = {
  saturation: 0.2
};
var EFFECTS = mage_engine__WEBPACK_IMPORTED_MODULE_5__.constants.EFFECTS,
    MATERIALS = mage_engine__WEBPACK_IMPORTED_MODULE_5__.constants.MATERIALS,
    TEXTURES = mage_engine__WEBPACK_IMPORTED_MODULE_5__.constants.TEXTURES;

var Main = /*#__PURE__*/function (_Level) {
  _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_2___default()(Main, _Level);

  var _super = _createSuper(Main);

  function Main() {
    _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0___default()(this, Main);

    return _super.apply(this, arguments);
  }

  _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1___default()(Main, [{
    key: "onCreate",
    value: function onCreate() {
      mage_engine__WEBPACK_IMPORTED_MODULE_5__.Scene.getCamera().setPosition({
        x: 0,
        y: 0,
        z: 0
      });
      mage_engine__WEBPACK_IMPORTED_MODULE_5__.Scene.setClearColor(0x091a28, 0.0);
      mage_engine__WEBPACK_IMPORTED_MODULE_5__.Scene.setBackground(0x091a28);
      mage_engine__WEBPACK_IMPORTED_MODULE_5__.Scene.getCamera().setPosition({
        x: 2,
        y: 4,
        z: 0
      });
      var orbit = mage_engine__WEBPACK_IMPORTED_MODULE_5__.Controls.setOrbitControl();
      orbit.setTarget({
        x: 0,
        y: 0,
        z: 0
      });
      orbit.setMinPolarAngle(0);
      orbit.setMaxPolarAngle(Math.PI / 2.5);
      orbit.setMaxDistance(15);
      mage_engine__WEBPACK_IMPORTED_MODULE_5__.Cube.create(5, 0xff0000).setWireframe(true);
    }
  }]);

  return Main;
}(mage_engine__WEBPACK_IMPORTED_MODULE_5__.Level);



/***/ }),

/***/ "./src/ui/blobs/index.js":
/*!*******************************!*\
  !*** ./src/ui/blobs/index.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_0__);


var Blobs = function Blobs() {
  return (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createFragment)([(0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "div", "first-blob"), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "div", "second-blob")], 4);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Blobs);

/***/ }),

/***/ "./src/ui/footer/index.js":
/*!********************************!*\
  !*** ./src/ui/footer/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_0__);


var Footer = function Footer() {
  return (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "footer", null, "Something goes here", 16);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Footer);

/***/ }),

/***/ "./src/ui/header/NavigationLink.js":
/*!*****************************************!*\
  !*** ./src/ui/header/NavigationLink.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_0__);


var NavigationLink = function NavigationLink(_ref) {
  var link = _ref.link,
      label = _ref.label,
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? '_blank' : _ref$target;
  return (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "a", null, label, 0, {
    "href": link,
    "target": target
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NavigationLink);

/***/ }),

/***/ "./src/ui/header/index.js":
/*!********************************!*\
  !*** ./src/ui/header/index.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ "./node_modules/@babel/runtime/helpers/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _NavigationLink__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NavigationLink */ "./src/ui/header/NavigationLink.js");



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_0___default()(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


var links = [{
  link: 'https://mage.studio/docs/',
  label: 'DOCS'
}, {
  link: 'https://github.com/MageStudio/Mage',
  label: 'GITHUB'
}];

var Header = function Header() {
  return (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "header", null, [(0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "div", 'logo-container', (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "img", null, null, 1, {
    "src": '/img/logo.png',
    "height": 40,
    "width": 40
  }), 2), (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "nav", null, (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "ul", "navigation-links", links.map(function (linkDetails) {
    return (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createVNode)(1, "li", null, (0,xferno__WEBPACK_IMPORTED_MODULE_1__.normalizeProps)((0,xferno__WEBPACK_IMPORTED_MODULE_1__.createComponentVNode)(2, _NavigationLink__WEBPACK_IMPORTED_MODULE_2__.default, _objectSpread({}, linkDetails))), 2);
  }), 0), 2)], 4);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Header);

/***/ }),

/***/ "./src/ui/hero/CTA.js":
/*!****************************!*\
  !*** ./src/ui/hero/CTA.js ***!
  \****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_0__);


var CallToAction = function CallToAction() {
  return (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "a", 'cta', "Read the docs", 16, {
    "href": 'https://www.mage.studio/docs'
  });
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CallToAction);

/***/ }),

/***/ "./src/ui/hero/index.js":
/*!******************************!*\
  !*** ./src/ui/hero/index.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _CTA__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CTA */ "./src/ui/hero/CTA.js");



var Hero = function Hero() {
  return (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "div", "hero", [(0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "p", null, (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "span", null, [(0,xferno__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("A Physics ready,"), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "br"), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Webgl powered,"), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createVNode)(1, "br"), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createTextVNode)("Javascript Game Engine.")], 4), 2), (0,xferno__WEBPACK_IMPORTED_MODULE_0__.createComponentVNode)(2, _CTA__WEBPACK_IMPORTED_MODULE_1__.default)], 4);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Hero);

/***/ }),

/***/ "./src/ui/reducers/index.js":
/*!**********************************!*\
  !*** ./src/ui/reducers/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({});

/***/ }),

/***/ "./src/ui/root.js":
/*!************************!*\
  !*** ./src/ui/root.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/objectDestructuringEmpty */ "./node_modules/@babel/runtime/helpers/objectDestructuringEmpty.js");
/* harmony import */ var _babel_runtime_helpers_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_helpers_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! xferno */ "./node_modules/xferno/dist/xferno.js");
/* harmony import */ var xferno__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(xferno__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var mage_engine__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! mage-engine */ "./node_modules/mage-engine/dist/mage.js");
/* harmony import */ var _blobs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./blobs */ "./src/ui/blobs/index.js");
/* harmony import */ var _footer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./footer */ "./src/ui/footer/index.js");
/* harmony import */ var _header__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./header */ "./src/ui/header/index.js");
/* harmony import */ var _hero__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hero */ "./src/ui/hero/index.js");








var Root = function Root(_ref) {
  var loadingScreenVisible = _ref.loadingScreenVisible,
      tileStats = _ref.tileStats,
      energy = _ref.energy,
      selection = _ref.selection,
      option = _ref.option,
      onOptionClick = _ref.onOptionClick;
  return (// loadingScreenVisible ?
    //     <LoadingScreen/> :
    //     <Game
    //         option={option}
    //         tileStats={tileStats}
    //         energy={energy}
    //         selection={selection}
    //         onOptionClick={onOptionClick}/>
    (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createFragment)([(0,xferno__WEBPACK_IMPORTED_MODULE_1__.createComponentVNode)(2, _header__WEBPACK_IMPORTED_MODULE_5__.default), (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createComponentVNode)(2, _blobs__WEBPACK_IMPORTED_MODULE_3__.default), (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createComponentVNode)(2, _hero__WEBPACK_IMPORTED_MODULE_6__.default), (0,xferno__WEBPACK_IMPORTED_MODULE_1__.createComponentVNode)(2, _footer__WEBPACK_IMPORTED_MODULE_4__.default)], 4)
  );
};

var mapStateToProps = function mapStateToProps(_ref2) {
  _babel_runtime_helpers_objectDestructuringEmpty__WEBPACK_IMPORTED_MODULE_0___default()(_ref2);

  return {};
};

var mapDispatchToProps = function mapDispatchToProps(dispatch) {
  return {};
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,mage_engine__WEBPACK_IMPORTED_MODULE_2__.connect)(mapStateToProps, mapDispatchToProps)(Root));

/***/ }),

/***/ "./node_modules/inferno/dist/index.esm.js":
/*!************************************************!*\
  !*** ./node_modules/inferno/dist/index.esm.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* binding */ Component),
/* harmony export */   "EMPTY_OBJ": () => (/* binding */ EMPTY_OBJ),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "_CI": () => (/* binding */ createClassComponentInstance),
/* harmony export */   "_HI": () => (/* binding */ normalizeRoot),
/* harmony export */   "_M": () => (/* binding */ mount),
/* harmony export */   "_MCCC": () => (/* binding */ mountClassComponentCallbacks),
/* harmony export */   "_ME": () => (/* binding */ mountElement),
/* harmony export */   "_MFCC": () => (/* binding */ mountFunctionalComponentCallbacks),
/* harmony export */   "_MP": () => (/* binding */ mountProps),
/* harmony export */   "_MR": () => (/* binding */ mountRef),
/* harmony export */   "_RFC": () => (/* binding */ renderFunctionalComponent),
/* harmony export */   "__render": () => (/* binding */ __render),
/* harmony export */   "createComponentVNode": () => (/* binding */ createComponentVNode),
/* harmony export */   "createFragment": () => (/* binding */ createFragment),
/* harmony export */   "createPortal": () => (/* binding */ createPortal),
/* harmony export */   "createRef": () => (/* binding */ createRef),
/* harmony export */   "createRenderer": () => (/* binding */ createRenderer),
/* harmony export */   "createTextVNode": () => (/* binding */ createTextVNode),
/* harmony export */   "createVNode": () => (/* binding */ createVNode),
/* harmony export */   "directClone": () => (/* binding */ directClone),
/* harmony export */   "findDOMfromVNode": () => (/* binding */ findDOMfromVNode),
/* harmony export */   "forwardRef": () => (/* binding */ forwardRef),
/* harmony export */   "getFlagsForElementVnode": () => (/* binding */ getFlagsForElementVnode),
/* harmony export */   "linkEvent": () => (/* binding */ linkEvent),
/* harmony export */   "normalizeProps": () => (/* binding */ normalizeProps),
/* harmony export */   "options": () => (/* binding */ options),
/* harmony export */   "render": () => (/* binding */ render),
/* harmony export */   "rerender": () => (/* binding */ rerender),
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
var isArray = Array.isArray;
function isStringOrNumber(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isNull(o) {
    return o === null;
}
function isUndefined(o) {
    return o === void 0;
}
function combineFrom(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

/**
 * Links given data to event as first parameter
 * @param {*} data data to be linked, it will be available in function as first parameter
 * @param {Function} event Function to be called when event occurs
 * @returns {{data: *, event: Function}}
 */
function linkEvent(data, event) {
    if (isFunction(event)) {
        return { data: data, event: event };
    }
    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers
}
// object.event should always be function, otherwise its badly created object.
function isLinkEventObject(o) {
    return !isNull(o) && typeof o === 'object';
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ = {};
var Fragment = '$F';
function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
    parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
    if (isNull(nextNode)) {
        appendChild(parentDOM, newNode);
    }
    else {
        parentDOM.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement(tag, isSVG) {
    if (isSVG) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
    parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
    parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
    for (var i = 0; i < arrayFn.length; i++) {
        arrayFn[i]();
    }
}
function findChildVNode(vNode, startEdge, flags) {
    var children = vNode.children;
    if (flags & 4 /* ComponentClass */) {
        return children.$LI;
    }
    if (flags & 8192 /* Fragment */) {
        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];
    }
    return children;
}
function findDOMfromVNode(vNode, startEdge) {
    var flags;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        vNode = findChildVNode(vNode, startEdge, flags);
    }
    return null;
}
function removeVNodeDOM(vNode, parentDOM) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            removeChild(parentDOM, vNode.dom);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    removeVNodeDOM(children[i], parentDOM);
                }
                return;
            }
        }
    } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            insertOrAppend(parentDOM, vNode.dom, nextNode);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    moveVNodeDOM(children[i], parentDOM, nextNode);
                }
                return;
            }
        }
    } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
    if (instance.constructor.getDerivedStateFromProps) {
        return combineFrom(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
    }
    return state;
}
var renderCheck = {
    v: false
};
var options = {
    componentComparator: null,
    createVNode: null,
    renderComplete: null
};
function setTextContent(dom, children) {
    dom.textContent = children;
}
// Calling this function assumes, nextValue is linkEvent
function isLastValueSameLinkEvent(lastValue, nextValue) {
    return (isLinkEventObject(lastValue) &&
        lastValue.event === nextValue.event &&
        lastValue.data === nextValue.data);
}
function mergeUnsetProperties(to, from) {
    for (var propName in from) {
        if (isUndefined(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}
function safeCall1(method, arg1) {
    return !!isFunction(method) && (method(arg1), true);
}

var keyPrefix = '$';
function V(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef(defaultProps)) {
        return props;
    }
    if (isNullOrUndef(props)) {
        return combineFrom(defaultProps, null);
    }
    return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode(flags, type, props, key, ref) {
    flags = resolveComponentFlags(flags, type);
    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);
    if (options.createVNode) {
        options.createVNode(vNode);
    }
    return vNode;
}
function createTextVNode(text, key) {
    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment(children, childFlags, key) {
    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
function normalizeProps(vNode) {
    var props = vNode.props;
    if (props) {
        var flags = vNode.flags;
        if (flags & 481 /* Element */) {
            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
                normalizeChildren(vNode, props.children);
            }
            if (props.className !== void 0) {
                if (isNullOrUndef(vNode.className)) {
                    vNode.className = props.className || null;
                }
                props.className = undefined;
            }
        }
        if (props.key !== void 0) {
            vNode.key = props.key;
            props.key = undefined;
        }
        if (props.ref !== void 0) {
            if (flags & 8 /* ComponentFunction */) {
                vNode.ref = combineFrom(vNode.ref, props.ref);
            }
            else {
                vNode.ref = props.ref;
            }
            props.ref = undefined;
        }
    }
    return vNode;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment(vNodeToClone) {
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    return createFragment(childFlags === 2 /* HasVNodeChildren */ ? directClone(oldChildren) : oldChildren.map(directClone), childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
    return createTextVNode('', null);
}
function createPortal(children, container) {
    var normalizedRoot = normalizeRoot(children);
    return createVNode(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);
}
function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid(n)) {
            var newKey = currentKey + keyPrefix + index;
            if (isArray(n)) {
                _normalizeVNodes(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber(n)) {
                    n = createTextVNode(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function getFlagsForElementVnode(type) {
    switch (type) {
        case 'svg':
            return 32 /* SvgElement */;
        case 'input':
            return 64 /* InputElement */;
        case 'select':
            return 256 /* SelectElement */;
        case 'textarea':
            return 128 /* TextareaElement */;
        case Fragment:
            return 8192 /* Fragment */;
        default:
            return 1 /* HtmlElement */;
    }
}
function normalizeChildren(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid(n) || isArray(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode(n, keyPrefix + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull(key);
                var isPrefixed = isString(key) && key[0] === keyPrefix;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}
function normalizeRoot(input) {
    if (isInvalid(input) || isStringOrNumber(input)) {
        return createTextVNode(input, null);
    }
    if (isArray(input)) {
        return createFragment(input, 0 /* UnknownChildren */, null);
    }
    return input.flags & 16384 /* InUse */ ? directClone(input) : input;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var namespaces = {
    'xlink:actuate': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:href': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
};

function getDelegatedEventObject(v) {
    return {
        onClick: v,
        onDblClick: v,
        onFocusIn: v,
        onFocusOut: v,
        onKeyDown: v,
        onKeyPress: v,
        onKeyUp: v,
        onMouseDown: v,
        onMouseMove: v,
        onMouseUp: v,
        onTouchEnd: v,
        onTouchMove: v,
        onTouchStart: v
    };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (!eventsObject) {
        eventsObject = dom.$EV = getDelegatedEventObject(null);
    }
    if (!eventsObject[name]) {
        if (++attachedEventCounts[name] === 1) {
            attachedEvents[name] = attachEventToDocument(name);
        }
    }
    return eventsObject;
}
function unmountSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (eventsObject && eventsObject[name]) {
        if (--attachedEventCounts[name] === 0) {
            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
            attachedEvents[name] = null;
        }
        eventsObject[name] = null;
    }
}
function handleSyntheticEvent(name, lastEvent, nextEvent, dom) {
    if (isFunction(nextEvent)) {
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else if (isLinkEventObject(nextEvent)) {
        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
            return;
        }
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else {
        unmountSyntheticEvent(name, dom);
    }
}
// When browsers fully support event.composedPath we could loop it through instead of using parentNode property
function getTargetNode(event) {
    return isFunction(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name, eventData) {
    var dom = getTargetNode(event);
    do {
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (isClick && dom.disabled) {
            return;
        }
        var eventsObject = dom.$EV;
        if (eventsObject) {
            var currentEvent = eventsObject[name];
            if (currentEvent) {
                // linkEvent object
                eventData.dom = dom;
                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }
        dom = dom.parentNode;
    } while (!isNull(dom));
}
function stopPropagation() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
        this.stopImmediatePropagation();
    }
}
function isDefaultPrevented() {
    return this.defaultPrevented;
}
function isPropagationStopped() {
    return this.cancelBubble;
}
function extendEventProperties(event) {
    // Event data needs to be object to save reference to currentTarget getter
    var eventData = {
        dom: document
    };
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    event.stopPropagation = stopPropagation;
    Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
            return eventData.dom;
        }
    });
    return eventData;
}
function rootClickEvent(name) {
    return function (event) {
        if (event.button !== 0) {
            // Firefox incorrectly triggers click event for mid/right mouse buttons.
            // This bug has been active for 17 years.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
            event.stopPropagation();
            return;
        }
        dispatchEvents(event, true, name, extendEventProperties(event));
    };
}
function rootEvent(name) {
    return function (event) {
        dispatchEvents(event, false, name, extendEventProperties(event));
    };
}
function attachEventToDocument(name) {
    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);
    document.addEventListener(normalizeEventName(name), attachedEvent);
    return attachedEvent;
}

function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}

function triggerEventListener(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ;
        var dom = vNode.dom;
        if (isString(methodName)) {
            triggerEventListener(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener(props, methodName[i], e);
            }
        }
        if (isFunction(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function attachEvent(dom, eventName, handler) {
    var previousKey = "$" + eventName;
    var previousArgs = dom[previousKey];
    if (previousArgs) {
        if (previousArgs[1].wrapped) {
            return;
        }
        dom.removeEventListener(previousArgs[0], previousArgs[1]);
        dom[previousKey] = null;
    }
    if (isFunction(handler)) {
        dom.addEventListener(eventName, handler);
        dom[previousKey] = [eventName, handler];
    }
}

function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
}
var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
/* tslint:disable-next-line:no-empty */
function emptywrapper(event) {
    event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
    if (isCheckedType(nextPropsOrEmpty.type)) {
        attachEvent(dom, 'change', wrappedOnChange);
        attachEvent(dom, 'click', emptywrapper);
    }
    else {
        attachEvent(dom, 'input', onTextInputChange);
    }
}
function applyValueInput(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions(children[i], value);
            }
        }
    }
}
function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
        dom.selected = props.selected || false;
    }
}
var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
function selectEvents(dom) {
    attachEvent(dom, 'change', onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions(vNode, value);
    }
}

var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction('onChange');
function textAreaEvents(dom, nextPropsOrEmpty) {
    attachEvent(dom, 'input', onTextareaInputChange);
    if (nextPropsOrEmpty.onChange) {
        attachEvent(dom, 'change', wrappedOnChange$1);
    }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
        applyValueInput(nextPropsOrEmpty, dom);
    }
    else if (flags & 256 /* SelectElement */) {
        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
    }
    else if (flags & 128 /* TextareaElement */) {
        applyValueTextArea(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
        dom.$V = vNode;
    }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
        inputEvents(dom, nextPropsOrEmpty);
    }
    else if (flags & 256 /* SelectElement */) {
        selectEvents(dom);
    }
    else if (flags & 128 /* TextareaElement */) {
        textAreaEvents(dom, nextPropsOrEmpty);
    }
}
function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}

function createRef() {
    return {
        current: null
    };
}
function forwardRef(render) {
    // @ts-ignore
    return {
        render: render
    };
}
function unmountRef(ref) {
    if (ref) {
        if (!safeCall1(ref, null) && ref.current) {
            ref.current = null;
        }
    }
}
function mountRef(ref, value, lifecycle) {
    if (ref && (isFunction(ref) || ref.current !== void 0)) {
        lifecycle.push(function () {
            if (!safeCall1(ref, value) && ref.current !== void 0) {
                ref.current = value;
            }
        });
    }
}

function remove(vNode, parentDOM) {
    unmount(vNode);
    removeVNodeDOM(vNode, parentDOM);
}
function unmount(vNode) {
    var flags = vNode.flags;
    var children = vNode.children;
    var ref;
    if (flags & 481 /* Element */) {
        ref = vNode.ref;
        var props = vNode.props;
        unmountRef(ref);
        var childFlags = vNode.childFlags;
        if (!isNull(props)) {
            var keys = Object.keys(props);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                if (syntheticEvents[key]) {
                    unmountSyntheticEvent(key, vNode.dom);
                }
            }
        }
        if (childFlags & 12 /* MultipleChildren */) {
            unmountAllChildren(children);
        }
        else if (childFlags === 2 /* HasVNodeChildren */) {
            unmount(children);
        }
    }
    else if (children) {
        if (flags & 4 /* ComponentClass */) {
            if (isFunction(children.componentWillUnmount)) {
                children.componentWillUnmount();
            }
            unmountRef(vNode.ref);
            children.$UN = true;
            unmount(children.$LI);
        }
        else if (flags & 8 /* ComponentFunction */) {
            ref = vNode.ref;
            if (!isNullOrUndef(ref) && isFunction(ref.onComponentWillUnmount)) {
                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
            }
            unmount(children);
        }
        else if (flags & 1024 /* Portal */) {
            remove(children, vNode.ref);
        }
        else if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren(children);
            }
        }
    }
}
function unmountAllChildren(children) {
    for (var i = 0, len = children.length; i < len; ++i) {
        unmount(children[i]);
    }
}
function clearDOM(dom) {
    // Optimization for clearing dom
    dom.textContent = '';
}
function removeAllChildren(dom, vNode, children) {
    unmountAllChildren(children);
    if (vNode.flags & 8192 /* Fragment */) {
        removeVNodeDOM(vNode, dom);
    }
    else {
        clearDOM(dom);
    }
}

function wrapLinkEvent(nextValue) {
    // This variable makes sure there is no "this" context in callback
    var ev = nextValue.event;
    return function (e) {
        ev(nextValue.data, e);
    };
}
function patchEvent(name, lastValue, nextValue, dom) {
    if (isLinkEventObject(nextValue)) {
        if (isLastValueSameLinkEvent(lastValue, nextValue)) {
            return;
        }
        nextValue = wrapLinkEvent(nextValue);
    }
    attachEvent(dom, normalizeEventName(name), nextValue);
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    if (isNullOrUndef(nextAttrValue)) {
        dom.removeAttribute('style');
        return;
    }
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle.setProperty(style, value);
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef(nextAttrValue[style])) {
                domStyle.removeProperty(style);
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle.setProperty(style, value);
        }
    }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
    var lastHtml = (lastValue && lastValue.__html) || '';
    var nextHtml = (nextValue && nextValue.__html) || '';
    if (lastHtml !== nextHtml) {
        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
            if (!isNull(lastVNode)) {
                if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                    unmountAllChildren(lastVNode.children);
                }
                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                    unmount(lastVNode.children);
                }
                lastVNode.children = null;
                lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }
            dom.innerHTML = nextHtml;
        }
    }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
        case 'children':
        case 'childrenType':
        case 'className':
        case 'defaultValue':
        case 'key':
        case 'multiple':
        case 'ref':
        case 'selectedIndex':
            break;
        case 'autoFocus':
            dom.autofocus = !!nextValue;
            break;
        case 'allowfullscreen':
        case 'autoplay':
        case 'capture':
        case 'checked':
        case 'controls':
        case 'default':
        case 'disabled':
        case 'hidden':
        case 'indeterminate':
        case 'loop':
        case 'muted':
        case 'novalidate':
        case 'open':
        case 'readOnly':
        case 'required':
        case 'reversed':
        case 'scoped':
        case 'seamless':
        case 'selected':
            dom[prop] = !!nextValue;
            break;
        case 'defaultChecked':
        case 'value':
        case 'volume':
            if (hasControlledValue && prop === 'value') {
                break;
            }
            var value = isNullOrUndef(nextValue) ? '' : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
            break;
        case 'style':
            patchStyle(lastValue, nextValue, dom);
            break;
        case 'dangerouslySetInnerHTML':
            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
            break;
        default:
            if (syntheticEvents[prop]) {
                handleSyntheticEvent(prop, lastValue, nextValue, dom);
            }
            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
                patchEvent(prop, lastValue, nextValue, dom);
            }
            else if (isNullOrUndef(nextValue)) {
                dom.removeAttribute(prop);
            }
            else if (isSVG && namespaces[prop]) {
                // We optimize for isSVG being false
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces[prop], prop, nextValue);
            }
            else {
                dom.setAttribute(prop, nextValue);
            }
            break;
    }
}
function mountProps(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
        hasControlledValue = isControlledFormElement(props);
        if (hasControlledValue) {
            addFormElementEventHandlers(flags, dom, props);
        }
    }
    for (var prop in props) {
        // do not add a hasOwnProperty check here, it affects performance
        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
        processElement(flags, vNode, dom, props, true, hasControlledValue);
    }
}

function renderNewInput(instance, props, context) {
    var nextInput = normalizeRoot(instance.render(props, instance.state, context));
    var childContext = context;
    if (isFunction(instance.getChildContext)) {
        childContext = combineFrom(context, instance.getChildContext());
    }
    instance.$CX = childContext;
    return nextInput;
}
function createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {
    var instance = new Component(props, context);
    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));
    instance.$SVG = isSVG;
    instance.$L = lifecycle;
    vNode.children = instance;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ) {
        instance.props = props;
    }
    if (!usesNewAPI) {
        if (isFunction(instance.componentWillMount)) {
            instance.$BR = true;
            instance.componentWillMount();
            var pending = instance.$PS;
            if (!isNull(pending)) {
                var state = instance.state;
                if (isNull(state)) {
                    instance.state = pending;
                }
                else {
                    for (var key in pending) {
                        state[key] = pending[key];
                    }
                }
                instance.$PS = null;
            }
            instance.$BR = false;
        }
    }
    else {
        instance.state = createDerivedState(instance, props, instance.state);
    }
    instance.$LI = renderNewInput(instance, props, context);
    return instance;
}
function renderFunctionalComponent(vNode, context) {
    var props = vNode.props || EMPTY_OBJ;
    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(props, vNode.ref, context) : vNode.type(props, context);
}

function mount(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 481 /* Element */) {
        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 4 /* ComponentClass */) {
        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 8 /* ComponentFunction */) {
        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
        mountFunctionalComponentCallbacks(vNode, lifecycle);
    }
    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {
        mountText(vNode, parentDOM, nextNode);
    }
    else if (flags & 8192 /* Fragment */) {
        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
    }
    else if (flags & 1024 /* Portal */) {
        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);
    }
    else ;
}
function mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {
    mount(vNode.children, vNode.ref, context, false, null, lifecycle);
    var placeHolderVNode = createVoidVNode();
    mountText(placeHolderVNode, parentDOM, nextNode);
    vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {
        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;
        children = vNode.children = createVoidVNode();
    }
    if (childFlags === 2 /* HasVNodeChildren */) {
        mount(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else {
        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
}
function mountText(vNode, parentDOM, nextNode) {
    var dom = (vNode.dom = document.createTextNode(vNode.children));
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
}
function mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = vNode.flags;
    var props = vNode.props;
    var className = vNode.className;
    var childFlags = vNode.childFlags;
    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));
    var children = vNode.children;
    if (!isNullOrUndef(className) && className !== '') {
        if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
    }
    if (childFlags === 16 /* HasTextChildren */) {
        setTextContent(dom, children);
    }
    else if (childFlags !== 1 /* HasInvalidChildren */) {
        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (children.flags & 16384 /* InUse */) {
                vNode.children = children = directClone(children);
            }
            mount(children, dom, context, childrenIsSVG, null, lifecycle);
        }
        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {
            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);
        }
    }
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
    if (!isNull(props)) {
        mountProps(vNode, flags, props, dom, isSVG);
    }
    mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child.flags & 16384 /* InUse */) {
            children[i] = child = directClone(child);
        }
        mount(child, dom, context, isSVG, nextNode, lifecycle);
    }
}
function mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);
    mount(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    mount((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
    return function () {
        instance.componentDidMount();
    };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
    mountRef(ref, instance, lifecycle);
    if (isFunction(instance.componentDidMount)) {
        lifecycle.push(createClassMountCallback(instance));
    }
}
function createOnMountCallback(ref, vNode) {
    return function () {
        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
    };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
    var ref = vNode.ref;
    if (!isNullOrUndef(ref)) {
        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
        if (isFunction(ref.onComponentDidMount)) {
            lifecycle.push(createOnMountCallback(ref, vNode));
        }
    }
}

function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    unmount(lastVNode);
    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {
        mount(nextVNode, null, context, isSVG, null, lifecycle);
        // Single DOM operation, when we have dom references available
        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
    }
    else {
        mount(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
        removeVNodeDOM(lastVNode, parentDOM);
    }
}
function patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);
    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {
        if (lastVNode.flags & 16384 /* InUse */) {
            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
        }
        else {
            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one
            mount(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (nextFlags & 481 /* Element */) {
        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
    }
    else if (nextFlags & 4 /* ComponentClass */) {
        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 8 /* ComponentFunction */) {
        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 16 /* Text */) {
        patchText(lastVNode, nextVNode);
    }
    else if (nextFlags & 512 /* Void */) {
        nextVNode.dom = lastVNode.dom;
    }
    else if (nextFlags & 8192 /* Fragment */) {
        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    }
    else {
        patchPortal(lastVNode, nextVNode, context, lifecycle);
    }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
    if (lastChildren !== nextChildren) {
        if (lastChildren !== '') {
            parentDOM.firstChild.nodeValue = nextChildren;
        }
        else {
            setTextContent(parentDOM, nextChildren);
        }
    }
}
function patchContentEditableChildren(dom, nextChildren) {
    if (dom.textContent !== nextChildren) {
        dom.textContent = nextChildren;
    }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastChildFlags = lastVNode.childFlags;
    var nextChildFlags = nextVNode.childFlags;
    var nextNode = null;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {
        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;
        nextChildren = nextVNode.children = createVoidVNode();
    }
    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;
    if (lastChildFlags & 12 /* MultipleChildren */) {
        var lastLen = lastChildren.length;
        // We need to know Fragment's edge node when
        if (
        // It uses keyed algorithm
        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||
            // It transforms from many to single
            nextIsSingle ||
            // It will append more nodes
            (!nextIsSingle && nextChildren.length > lastLen)) {
            // When fragment has multiple children there is always at least one vNode
            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
        }
    }
    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context, lifecycle) {
    var lastContainer = lastVNode.ref;
    var nextContainer = nextVNode.ref;
    var nextChildren = nextVNode.children;
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
        var node = nextChildren.dom;
        removeChild(lastContainer, node);
        appendChild(nextContainer, node);
    }
}
function patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
    var dom = (nextVNode.dom = lastVNode.dom);
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var isFormElement = false;
    var hasControlledValue = false;
    var nextPropsOrEmpty;
    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
    // inlined patchProps  -- starts --
    if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ;
        if (nextPropsOrEmpty !== EMPTY_OBJ) {
            isFormElement = (nextFlags & 448 /* FormElement */) > 0;
            if (isFormElement) {
                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
            }
            for (var prop in nextPropsOrEmpty) {
                var lastValue = lastPropsOrEmpty[prop];
                var nextValue = nextPropsOrEmpty[prop];
                if (lastValue !== nextValue) {
                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ) {
            for (var prop$1 in lastPropsOrEmpty) {
                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
    }
    var nextChildren = nextVNode.children;
    var nextClassName = nextVNode.className;
    // inlined patchProps  -- ends --
    if (lastVNode.className !== nextClassName) {
        if (isNullOrUndef(nextClassName)) {
            dom.removeAttribute('class');
        }
        else if (isSVG) {
            dom.setAttribute('class', nextClassName);
        }
        else {
            dom.className = nextClassName;
        }
    }
    if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren(dom, nextChildren);
    }
    else {
        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);
    }
    if (isFormElement) {
        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
    }
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, dom, lifecycle);
    }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
    unmount(lastChildren);
    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
    removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
    switch (lastChildFlags) {
        case 2 /* HasVNodeChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    remove(lastChildren, parentDOM);
                    break;
                case 16 /* HasTextChildren */:
                    unmount(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
                    break;
            }
            break;
        case 1 /* HasInvalidChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    break;
                case 16 /* HasTextChildren */:
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        case 16 /* HasTextChildren */:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);
                    break;
                case 2 /* HasVNodeChildren */:
                    clearDOM(parentDOM);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    clearDOM(parentDOM);
                    break;
                default:
                    clearDOM(parentDOM);
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        default:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    unmountAllChildren(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                case 2 /* HasVNodeChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    mount(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    break;
                default:
                    var lastLength = lastChildren.length | 0;
                    var nextLength = nextChildren.length | 0;
                    // Fast path's for both algorithms
                    if (lastLength === 0) {
                        if (nextLength > 0) {
                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                        }
                    }
                    else if (nextLength === 0) {
                        removeAllChildren(parentDOM, parentVNode, lastChildren);
                    }
                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
                    }
                    else {
                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
                    }
                    break;
            }
            break;
    }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
    lifecycle.push(function () {
        instance.componentDidUpdate(lastProps, lastState, snapshot);
    });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
    var lastState = instance.state;
    var lastProps = instance.props;
    var usesNewAPI = Boolean(instance.$N);
    var hasSCU = isFunction(instance.shouldComponentUpdate);
    if (usesNewAPI) {
        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom(lastState, nextState) : nextState);
    }
    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {
        if (!usesNewAPI && isFunction(instance.componentWillUpdate)) {
            instance.componentWillUpdate(nextProps, nextState, context);
        }
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
        var snapshot = null;
        var nextInput = renderNewInput(instance, nextProps, context);
        if (usesNewAPI && isFunction(instance.getSnapshotBeforeUpdate)) {
            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
        }
        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
        // Dont update Last input, until patch has been succesfully executed
        instance.$LI = nextInput;
        if (isFunction(instance.componentDidUpdate)) {
            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
        }
    }
    else {
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
    }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = (nextVNode.children = lastVNode.children);
    // If Component has crashed, ignore it to stay functional
    if (isNull(instance)) {
        return;
    }
    instance.$L = lifecycle;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    var nextState = instance.state;
    if (!instance.$N) {
        if (isFunction(instance.componentWillReceiveProps)) {
            instance.$BR = true;
            instance.componentWillReceiveProps(nextProps, context);
            // If instance component was removed during its own update do nothing.
            if (instance.$UN) {
                return;
            }
            instance.$BR = false;
        }
        if (!isNull(instance.$PS)) {
            nextState = combineFrom(nextState, instance.$PS);
            instance.$PS = null;
        }
    }
    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, instance, lifecycle);
    }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var shouldUpdate = true;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastProps = lastVNode.props;
    var nextHooksDefined = !isNullOrUndef(nextRef);
    var lastInput = lastVNode.children;
    if (nextHooksDefined && isFunction(nextRef.onComponentShouldUpdate)) {
        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
    }
    if (shouldUpdate !== false) {
        if (nextHooksDefined && isFunction(nextRef.onComponentWillUpdate)) {
            nextRef.onComponentWillUpdate(lastProps, nextProps);
        }
        var nextInput = normalizeRoot(renderFunctionalComponent(nextVNode, context));
        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
        nextVNode.children = nextInput;
        if (nextHooksDefined && isFunction(nextRef.onComponentDidUpdate)) {
            nextRef.onComponentDidUpdate(lastProps, nextProps);
        }
    }
    else {
        nextVNode.children = lastInput;
    }
}
function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = (nextVNode.dom = lastVNode.dom);
    if (nextText !== lastVNode.children) {
        dom.nodeValue = nextText;
    }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; ++i) {
        nextChild = nextChildren[i];
        lastChild = lastChildren[i];
        if (nextChild.flags & 16384 /* InUse */) {
            nextChild = nextChildren[i] = directClone(nextChild);
        }
        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
        lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; ++i) {
            nextChild = nextChildren[i];
            if (nextChild.flags & 16384 /* InUse */) {
                nextChild = nextChildren[i] = directClone(nextChild);
            }
            mount(nextChild, dom, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; ++i) {
            remove(lastChildren[i], dom);
        }
    }
}
function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    var nextNode;
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[j] = bNode;
            ++j;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[j];
            bNode = b[j];
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
        // Sync nodes with the same key at the end.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[bEnd] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[aEnd] = bNode;
            aEnd--;
            bEnd--;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[aEnd];
            bNode = b[bEnd];
        }
    }
    if (j > aEnd) {
        if (j <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
            while (j <= bEnd) {
                bNode = b[j];
                if (bNode.flags & 16384 /* InUse */) {
                    b[j] = bNode = directClone(bNode);
                }
                ++j;
                mount(bNode, dom, context, isSVG, nextNode, lifecycle);
            }
        }
    }
    else if (j > bEnd) {
        while (j <= aEnd) {
            remove(a[j++], dom);
        }
    }
    else {
        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
    }
}
function patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
    var aNode;
    var bNode;
    var nextPos;
    var i = 0;
    var aStart = j;
    var bStart = j;
    var aLeft = aEnd - j + 1;
    var bLeft = bEnd - j + 1;
    var sources = new Int32Array(bLeft + 1);
    // Keep track if its possible to remove whole DOM using textContent = '';
    var canRemoveWholeContent = aLeft === aLength;
    var moved = false;
    var pos = 0;
    var patched = 0;
    // When sizes are small, just loop them through
    if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                for (j = bStart; j <= bEnd; j++) {
                    bNode = b[j];
                    if (aNode.key === bNode.key) {
                        sources[j - bStart] = i + 1;
                        if (canRemoveWholeContent) {
                            canRemoveWholeContent = false;
                            while (aStart < i) {
                                remove(a[aStart++], dom);
                            }
                        }
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        if (bNode.flags & 16384 /* InUse */) {
                            b[j] = bNode = directClone(bNode);
                        }
                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                        ++patched;
                        break;
                    }
                }
                if (!canRemoveWholeContent && j > bEnd) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; ++i) {
            keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                j = keyIndex[aNode.key];
                if (j !== void 0) {
                    if (canRemoveWholeContent) {
                        canRemoveWholeContent = false;
                        while (i > aStart) {
                            remove(a[aStart++], dom);
                        }
                    }
                    sources[j - bStart] = i + 1;
                    if (pos > j) {
                        moved = true;
                    }
                    else {
                        pos = j;
                    }
                    bNode = b[j];
                    if (bNode.flags & 16384 /* InUse */) {
                        b[j] = bNode = directClone(bNode);
                    }
                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                    ++patched;
                }
                else if (!canRemoveWholeContent) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    // fast-path: if nothing patched remove all old and add all new
    if (canRemoveWholeContent) {
        removeAllChildren(dom, parentVNode, a);
        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);
    }
    else if (moved) {
        var seq = lis_algorithm(sources);
        j = seq.length - 1;
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
            else if (j < 0 || i !== seq[j]) {
                pos = i + bStart;
                bNode = b[pos];
                nextPos = pos + 1;
                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
            }
            else {
                j--;
            }
        }
    }
    else if (patched !== bLeft) {
        // when patched count doesn't match b length we need to insert those new ones
        // loop backwards so we can use insertBefore
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
        }
    }
}
var result;
var p;
var maxLen = 0;
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm(arr) {
    var arrI = 0;
    var i = 0;
    var j = 0;
    var k = 0;
    var u = 0;
    var v = 0;
    var c = 0;
    var len = arr.length;
    if (len > maxLen) {
        maxLen = len;
        result = new Int32Array(len);
        p = new Int32Array(len);
    }
    for (; i < len; ++i) {
        arrI = arr[i];
        if (arrI !== 0) {
            j = result[k];
            if (arr[j] < arrI) {
                p[i] = j;
                result[++k] = i;
                continue;
            }
            u = 0;
            v = k;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = k + 1;
    var seq = new Int32Array(u);
    v = result[u - 1];
    while (u-- > 0) {
        seq[u] = v;
        v = p[v];
        result[u] = 0;
    }
    return seq;
}

var hasDocumentAvailable = typeof document !== 'undefined';
if (hasDocumentAvailable) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}
function __render(input, parentDOM, callback, context) {
    var lifecycle = [];
    var rootInput = parentDOM.$V;
    renderCheck.v = true;
    if (isNullOrUndef(rootInput)) {
        if (!isNullOrUndef(input)) {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            mount(input, parentDOM, context, false, null, lifecycle);
            parentDOM.$V = input;
            rootInput = input;
        }
    }
    else {
        if (isNullOrUndef(input)) {
            remove(rootInput, parentDOM);
            parentDOM.$V = null;
        }
        else {
            if (input.flags & 16384 /* InUse */) {
                input = directClone(input);
            }
            patch(rootInput, input, parentDOM, context, false, null, lifecycle);
            rootInput = parentDOM.$V = input;
        }
    }
    callAll(lifecycle);
    renderCheck.v = false;
    if (isFunction(callback)) {
        callback();
    }
    if (isFunction(options.renderComplete)) {
        options.renderComplete(rootInput, parentDOM);
    }
}
function render(input, parentDOM, callback, context) {
    if ( callback === void 0 ) callback = null;
    if ( context === void 0 ) context = EMPTY_OBJ;

    __render(input, parentDOM, callback, context);
}
function createRenderer(parentDOM) {
    return function renderer(lastInput, nextInput, callback, context) {
        if (!parentDOM) {
            parentDOM = lastInput;
        }
        render(nextInput, parentDOM, callback, context);
    };
}

var QUEUE = [];
var nextTick = typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
    var pending = component.$PS;
    if (isFunction(newState)) {
        newState = newState(pending ? combineFrom(component.state, pending) : component.state, component.props, component.context);
    }
    if (isNullOrUndef(pending)) {
        component.$PS = newState;
    }
    else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component.$BR) {
        if (!renderCheck.v) {
            if (QUEUE.length === 0) {
                applyState(component, force);
                if (isFunction(callback)) {
                    callback.call(component);
                }
                return;
            }
        }
        if (QUEUE.indexOf(component) === -1) {
            QUEUE.push(component);
        }
        if (force) {
            component.$F = true;
        }
        if (!microTaskPending) {
            microTaskPending = true;
            nextTick(rerender);
        }
        if (isFunction(callback)) {
            var QU = component.$QU;
            if (!QU) {
                QU = component.$QU = [];
            }
            QU.push(callback);
        }
    }
    else if (isFunction(callback)) {
        component.$L.push(callback.bind(component));
    }
}
function callSetStateCallbacks(component) {
    var queue = component.$QU;
    for (var i = 0; i < queue.length; ++i) {
        queue[i].call(component);
    }
    component.$QU = null;
}
function rerender() {
    var component;
    microTaskPending = false;
    while ((component = QUEUE.shift())) {
        if (!component.$UN) {
            var force = component.$F;
            component.$F = false;
            applyState(component, force);
            if (component.$QU) {
                callSetStateCallbacks(component);
            }
        }
    }
}
function applyState(component, force) {
    if (force || !component.$BR) {
        var pendingState = component.$PS;
        component.$PS = null;
        var lifecycle = [];
        renderCheck.v = true;
        updateClassComponent(component, combineFrom(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
        callAll(lifecycle);
        renderCheck.v = false;
    }
    else {
        component.state = component.$PS;
        component.$PS = null;
    }
}
var Component = function Component(props, context) {
    // Public
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$QU = null; // QUEUE
    this.$N = false; // Uses new lifecycle API Flag
    this.$L = null; // Current lifecycle of this component
    this.$SVG = false; // Flag to keep track if component is inside SVG tree
    this.$F = false; // Force update flag
    this.props = props || EMPTY_OBJ;
    this.context = context || EMPTY_OBJ; // context should not be mutable
};
Component.prototype.forceUpdate = function forceUpdate (callback) {
    if (this.$UN) {
        return;
    }
    // Do not allow double render during force update
    queueStateChanges(this, {}, callback, true);
};
Component.prototype.setState = function setState (newState, callback) {
    if (this.$UN) {
        return;
    }
    if (!this.$BS) {
        queueStateChanges(this, newState, callback, false);
    }
};
Component.prototype.render = function render (_nextProps, _nextState, _nextContext) {
    return null;
};

var version = "7.4.11";




/***/ }),

/***/ "./node_modules/inferno/index.esm.js":
/*!*******************************************!*\
  !*** ./node_modules/inferno/index.esm.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Component": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.Component),
/* harmony export */   "EMPTY_OBJ": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_OBJ),
/* harmony export */   "Fragment": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "_CI": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._CI),
/* harmony export */   "_HI": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._HI),
/* harmony export */   "_M": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._M),
/* harmony export */   "_MCCC": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._MCCC),
/* harmony export */   "_ME": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._ME),
/* harmony export */   "_MFCC": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._MFCC),
/* harmony export */   "_MP": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._MP),
/* harmony export */   "_MR": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._MR),
/* harmony export */   "_RFC": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__._RFC),
/* harmony export */   "__render": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.__render),
/* harmony export */   "createComponentVNode": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createComponentVNode),
/* harmony export */   "createFragment": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createFragment),
/* harmony export */   "createPortal": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createPortal),
/* harmony export */   "createRef": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createRef),
/* harmony export */   "createRenderer": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createRenderer),
/* harmony export */   "createTextVNode": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createTextVNode),
/* harmony export */   "createVNode": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.createVNode),
/* harmony export */   "directClone": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.directClone),
/* harmony export */   "findDOMfromVNode": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.findDOMfromVNode),
/* harmony export */   "forwardRef": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.forwardRef),
/* harmony export */   "getFlagsForElementVnode": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.getFlagsForElementVnode),
/* harmony export */   "linkEvent": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.linkEvent),
/* harmony export */   "normalizeProps": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.normalizeProps),
/* harmony export */   "options": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.options),
/* harmony export */   "render": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.render),
/* harmony export */   "rerender": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.rerender),
/* harmony export */   "version": () => (/* reexport safe */ _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__.version)
/* harmony export */ });
/* harmony import */ var _dist_index_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.esm.js */ "./node_modules/inferno/dist/index.esm.js");


if (true) {
  console.warn('You are running production build of Inferno in development mode. Use dev:module entry point.');
}


/***/ }),

/***/ "./node_modules/mage-engine/dist/mage.js":
/*!***********************************************!*\
  !*** ./node_modules/mage-engine/dist/mage.js ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AUDIO_RAMPS": () => (/* binding */ AUDIO_RAMPS),
/* harmony export */   "AmbientLight": () => (/* binding */ AmbientLight),
/* harmony export */   "Atmosphere": () => (/* binding */ Atmosphere),
/* harmony export */   "Audio": () => (/* binding */ Audio$1),
/* harmony export */   "Axes": () => (/* binding */ Axes),
/* harmony export */   "BUILTIN": () => (/* binding */ BUILTIN),
/* harmony export */   "BackgroundSound": () => (/* binding */ BackgroundSound),
/* harmony export */   "BaseScript": () => (/* binding */ BaseScript),
/* harmony export */   "Box": () => (/* binding */ Box),
/* harmony export */   "Camera": () => (/* binding */ Camera),
/* harmony export */   "Color": () => (/* binding */ Color),
/* harmony export */   "Config": () => (/* binding */ Config$1),
/* harmony export */   "Controls": () => (/* binding */ Controls$1),
/* harmony export */   "Cube": () => (/* binding */ Cube),
/* harmony export */   "CurveLine": () => (/* binding */ CurveLine),
/* harmony export */   "Cylinder": () => (/* binding */ Cylinder),
/* harmony export */   "DirectionalSound": () => (/* binding */ DirectionalSound),
/* harmony export */   "ENTITY_EVENTS": () => (/* binding */ ENTITY_EVENTS),
/* harmony export */   "ENTITY_TYPES": () => (/* binding */ ENTITY_TYPES),
/* harmony export */   "Element": () => (/* binding */ Element$1),
/* harmony export */   "Entity": () => (/* binding */ Entity),
/* harmony export */   "EventDispatcher": () => (/* binding */ EventDispatcher),
/* harmony export */   "FEATURES": () => (/* binding */ FEATURES),
/* harmony export */   "Features": () => (/* binding */ Features$1),
/* harmony export */   "GameRunner": () => (/* binding */ GameRunner$1),
/* harmony export */   "Grid": () => (/* binding */ Grid),
/* harmony export */   "HemisphereLight": () => (/* binding */ HemisphereLight),
/* harmony export */   "INPUT_EVENTS": () => (/* binding */ INPUT_EVENTS),
/* harmony export */   "Images": () => (/* binding */ Images$1),
/* harmony export */   "Input": () => (/* binding */ Input$1),
/* harmony export */   "Label": () => (/* binding */ Label),
/* harmony export */   "LabelComponent": () => (/* binding */ LabelComponent),
/* harmony export */   "Level": () => (/* binding */ Level),
/* harmony export */   "LightLoader": () => (/* binding */ LightLoader$1),
/* harmony export */   "Lights": () => (/* binding */ Lights$1),
/* harmony export */   "Line": () => (/* binding */ Line),
/* harmony export */   "MeshLoader": () => (/* binding */ MeshLoader$1),
/* harmony export */   "Mirror": () => (/* binding */ Mirror),
/* harmony export */   "Models": () => (/* binding */ Models$1),
/* harmony export */   "Ocean": () => (/* binding */ Ocean),
/* harmony export */   "PALETTES": () => (/* binding */ PALETTES),
/* harmony export */   "PARTICLES": () => (/* binding */ PARTICLES),
/* harmony export */   "PHYSICS_CONSTANTS": () => (/* binding */ constants$1),
/* harmony export */   "PHYSICS_EVENTS": () => (/* binding */ PHYSICS_EVENTS),
/* harmony export */   "ParticleEmitter": () => (/* binding */ ParticleEmitter),
/* harmony export */   "ParticleEmitterGroup": () => (/* binding */ ParticleEmitterGroup),
/* harmony export */   "Particles": () => (/* binding */ Particles$1),
/* harmony export */   "Partykals": () => (/* binding */ index$1),
/* harmony export */   "Physics": () => (/* binding */ Physics$1),
/* harmony export */   "Plane": () => (/* binding */ Plane),
/* harmony export */   "PointLight": () => (/* binding */ PointLight),
/* harmony export */   "PostProcessing": () => (/* binding */ PostProcessing$1),
/* harmony export */   "Proton": () => (/* binding */ Proton),
/* harmony export */   "ProtonParticleEmitter": () => (/* binding */ ProtonParticleEmitter),
/* harmony export */   "Provider": () => (/* binding */ Provider),
/* harmony export */   "Router": () => (/* binding */ Router$1),
/* harmony export */   "Scene": () => (/* binding */ Scene$1),
/* harmony export */   "Scripts": () => (/* binding */ Scripts$1),
/* harmony export */   "Shader": () => (/* binding */ Shader),
/* harmony export */   "Sky": () => (/* binding */ Sky),
/* harmony export */   "Skybox": () => (/* binding */ Skybox),
/* harmony export */   "Sound": () => (/* binding */ Sound),
/* harmony export */   "Sphere": () => (/* binding */ Sphere),
/* harmony export */   "SpotLight": () => (/* binding */ SpotLight),
/* harmony export */   "Sprite": () => (/* binding */ Sprite),
/* harmony export */   "Stats": () => (/* binding */ Stats$1),
/* harmony export */   "SunLight": () => (/* binding */ SunLight),
/* harmony export */   "THREE": () => (/* binding */ three_module),
/* harmony export */   "Universe": () => (/* binding */ Universe$1),
/* harmony export */   "Vector3": () => (/* binding */ Vector3$1),
/* harmony export */   "Water": () => (/* binding */ Water),
/* harmony export */   "author": () => (/* binding */ author),
/* harmony export */   "connect": () => (/* binding */ connect),
/* harmony export */   "constants": () => (/* binding */ constants),
/* harmony export */   "createElement": () => (/* binding */ createElement),
/* harmony export */   "functions": () => (/* binding */ functions),
/* harmony export */   "hitboxUtils": () => (/* binding */ hitbox),
/* harmony export */   "inferno": () => (/* binding */ index_esm),
/* harmony export */   "math": () => (/* binding */ math),
/* harmony export */   "physicsUtils": () => (/* binding */ utils),
/* harmony export */   "rxjs": () => (/* binding */ index$2),
/* harmony export */   "store": () => (/* binding */ index),
/* harmony export */   "strings": () => (/* binding */ strings),
/* harmony export */   "uuid": () => (/* binding */ uuid$1),
/* harmony export */   "workers": () => (/* binding */ workers)
/* harmony export */ });
/* module decorator */ module = __webpack_require__.hmd(module);
function ownKeys$1(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function _typeof$1(obj) {
  "@babel/helpers - typeof";

  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof$1(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};

  var target = _objectWithoutPropertiesLoose(source, excluded);

  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = _getPrototypeOf(object);
    if (object === null) break;
  }

  return object;
}

function _get() {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    _get = Reflect.get;
  } else {
    _get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);

      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(arguments.length < 3 ? target : receiver);
      }

      return desc.value;
    };
  }

  return _get.apply(this, arguments);
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}var between = {exports: {}};/* Between.js v0.1.2-fix.2 */

(function (module, exports) {
!function(t,n){module.exports=n();}(commonjsGlobal,function(){function O(t){return (O="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(t){return typeof t}:function(t){return t&&"function"==typeof Symbol&&t.constructor===Symbol&&t!==Symbol.prototype?"symbol":typeof t})(t)}function r(t,n){for(var e=0;e<n.length;e++){var r=n[e];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r);}}function n(t,n,e){return n&&r(t.prototype,n),e&&r(t,e),t}function M(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function I(t){return (I=Object.getPrototypeOf||function(t){return t.__proto__})(t)}function o(t,n){return (o=Object.setPrototypeOf||function(t,n){return t.__proto__=n,t})(t,n)}function u(t,n,e){return (u="undefined"!=typeof Reflect&&Reflect.construct?Reflect.construct:function(t,n,e){var r=[null];r.push.apply(r,n);var u=new(t.bind.apply(t,r));return e&&o(u,e.prototype),u}).apply(null,arguments)}function _(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}var t=function(o){var a={},i=[];(o=o||this).on=function(t,n,e){return (a[t]=a[t]||[]).push([n,e]),o},o.off=function(t,n){t||(a={});for(var e=a[t]||i,r=e.length=n?e.length:0;r--;)n==e[r][0]&&e.splice(r,1);return o},o.emit=function(t){for(var n,e=a[t]||i,r=0<e.length?e.slice(0,e.length):e,u=0;n=r[u++];)n[0].apply(n[1],i.slice.call(arguments,1));return o};};var V=function(t,n,e){return t*(1-e)+n*e},e="undefined"!=typeof window?window:"undefined"!=typeof commonjsGlobal?commonjsGlobal:"undefined"!=typeof self?self:{};function a(t,n){return t(n={exports:{}},n.exports),n.exports}for(var i=a(function(t){var n=t.exports={Linear:{None:function(t){return t}},Quadratic:{In:function(t){return t*t},Out:function(t){return t*(2-t)},InOut:function(t){return (t*=2)<1?.5*t*t:-.5*(--t*(t-2)-1)}},Cubic:{In:function(t){return t*t*t},Out:function(t){return --t*t*t+1},InOut:function(t){return (t*=2)<1?.5*t*t*t:.5*((t-=2)*t*t+2)}},Quartic:{In:function(t){return t*t*t*t},Out:function(t){return 1- --t*t*t*t},InOut:function(t){return (t*=2)<1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2)}},Quintic:{In:function(t){return t*t*t*t*t},Out:function(t){return --t*t*t*t*t+1},InOut:function(t){return (t*=2)<1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2)}},Sinusoidal:{In:function(t){return 1-Math.cos(t*Math.PI/2)},Out:function(t){return Math.sin(t*Math.PI/2)},InOut:function(t){return .5*(1-Math.cos(Math.PI*t))}},Exponential:{In:function(t){return 0===t?0:Math.pow(1024,t-1)},Out:function(t){return 1===t?1:1-Math.pow(2,-10*t)},InOut:function(t){return 0===t?0:1===t?1:(t*=2)<1?.5*Math.pow(1024,t-1):.5*(2-Math.pow(2,-10*(t-1)))}},Circular:{In:function(t){return 1-Math.sqrt(1-t*t)},Out:function(t){return Math.sqrt(1- --t*t)},InOut:function(t){return (t*=2)<1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1)}},Elastic:{In:function(t){var n,e=.1;return 0===t?0:1===t?1:(!e||e<1?(e=1,n=.1):n=.4*Math.asin(1/e)/(2*Math.PI),-e*Math.pow(2,10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/.4))},Out:function(t){var n,e=.1;return 0===t?0:1===t?1:(!e||e<1?(e=1,n=.1):n=.4*Math.asin(1/e)/(2*Math.PI),e*Math.pow(2,-10*t)*Math.sin((t-n)*(2*Math.PI)/.4)+1)},InOut:function(t){var n,e=.1;return 0===t?0:1===t?1:(!e||e<1?(e=1,n=.1):n=.4*Math.asin(1/e)/(2*Math.PI),(t*=2)<1?e*Math.pow(2,10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/.4)*-.5:e*Math.pow(2,-10*(t-=1))*Math.sin((t-n)*(2*Math.PI)/.4)*.5+1)}},Back:{In:function(t){return t*t*(2.70158*t-1.70158)},Out:function(t){return --t*t*(2.70158*t+1.70158)+1},InOut:function(t){var n=2.5949095;return (t*=2)<1?t*t*((n+1)*t-n)*.5:.5*((t-=2)*t*((n+1)*t+n)+2)}},Bounce:{In:function(t){return 1-n.Bounce.Out(1-t)},Out:function(t){return t<1/2.75?7.5625*t*t:t<2/2.75?7.5625*(t-=1.5/2.75)*t+.75:t<2.5/2.75?7.5625*(t-=2.25/2.75)*t+.9375:7.5625*(t-=2.625/2.75)*t+.984375},InOut:function(t){return t<.5?.5*n.Bounce.In(2*t):.5*n.Bounce.Out(2*t-1)+.5}}};}),c=(i.Linear,i.Quadratic,i.Cubic,i.Quartic,i.Quintic,i.Sinusoidal,i.Exponential,i.Circular,i.Elastic,i.Back,i.Bounce,a(function(a){(function(){var t,n,e,r,u,o;"undefined"!=typeof performance&&null!==performance&&performance.now?a.exports=function(){return performance.now()}:"undefined"!=typeof process&&null!==process&&process.hrtime?(a.exports=function(){return (t()-u)/1e6},n=process.hrtime,r=(t=function(){var t;return 1e9*(t=n())[0]+t[1]})(),o=1e9*process.uptime(),u=r-o):Date.now?(a.exports=function(){return Date.now()-e},e=Date.now()):(a.exports=function(){return (new Date).getTime()-e},e=(new Date).getTime());}).call(e);})),l="undefined"==typeof window?e:window,f=["moz","webkit"],s="AnimationFrame",p=l["request"+s],h=l["cancel"+s]||l["cancelRequest"+s],m=0;!p&&m<f.length;m++)p=l[f[m]+"Request"+s],h=l[f[m]+"Cancel"+s]||l[f[m]+"CancelRequest"+s];if(!p||!h){var d=0,y=0,v=[];p=function(t){if(0===v.length){var n=c(),e=Math.max(0,1e3/60-(n-d));d=e+n,setTimeout(function(){for(var t=v.slice(0),n=v.length=0;n<t.length;n++)if(!t[n].cancelled)try{t[n].callback(d);}catch(t){setTimeout(function(){throw t},0);}},Math.round(e));}return v.push({handle:++y,callback:t,cancelled:!1}),y},h=function(t){for(var n=0;n<v.length;n++)v[n].handle===t&&(v[n].cancelled=!0);};}var b=function(t){return p.call(l,t)};b.cancel=function(){h.apply(l,arguments);},b.polyfill=function(t){t||(t=l),t.requestAnimationFrame=p,t.cancelAnimationFrame=h;};var w,k,P=[],T=Symbol("type"),j=Symbol("start_time"),x=Symbol("completed"),D=Symbol("paused"),g=requestAnimationFrame||b,A=Date.now();!function t(){g(t),w=Date.now(),k=w-A;for(var n=0;n<P.length;n++)P[n][x]||P[n](k,Date.now()-P[n][j]);A=w;}();var E=function(t){function g(e,t){var n,r,u,o;!function(t,n){if(!(t instanceof n))throw new TypeError("Cannot call a class as a function")}(this,g),u=this,o=I(g).call(this),M(_(_(r=!o||"object"!=typeof o&&"function"!=typeof o?_(u):o)),"update",function(){var e=_(_(r))._updateValue;return function(t,n){r[x]||r[D]||(0===r.localTime&&r.emit("start",r.value,_(_(r))),e(r.ease(r.loopFunction.progress(Math.min(1,(n||r.localTime)/r.duration)))),r.emit("update",r.value,_(_(r)),t),r.localTime>=r.duration&&r.loopFunction.complete(function(){r[x]=!0,r.emit("complete",r.value,_(_(r)));}),r.localTime+=t);}});var a=r.plugin=Object.values(g._plugins).reduce(function(t,n){return t||n&&n.test&&n.test(e)&&n},!1),i=a&&a.name||("object"===O(e)?Array.isArray(e)?"array":"object":"number");if(a){var c=a.initialize(e,t);e=c.startValue,t=c.destValue,r.data=c.data;}switch(Object.assign(_(_(r)),(M(n={duration:1e3,localTime:0,startValue:e,destValue:t,loopMode:"once",loopFunction:g.DEFAULT_LOOP,ease:function(t){return t},value:"array"===i?[].concat(e):"object"===i?Object.assign({},e):e},x,!1),M(n,T,i),M(n,j,Date.now()),M(n,D,!1),n)),r[T]){case"number":r._updateValue=function(t){r.value=V(r.startValue,r.destValue,t);};break;case"array":var l=r.value.length,f=_(_(r)),s=f.startValue,p=f.destValue,h=f.value;r._updateValue=function(t){for(var n=0;n<l;n++)h[n]=V(s[n],p[n],t);};break;case"object":var m=Object.keys(r.startValue),d=m.length,y=_(_(r)),v=y.startValue,b=y.destValue,w=y.value;r._updateValue=function(t){for(var n=0;n<d;n++){var e=m[n];w[e]=V(v[e],b[e],t);}};break;default:r.plugin?r._updateValue=function(t){r.value=r.plugin.interpolate(r.startValue,r.destValue,t,r.data);}:(console.warn("Between: startValue type was unrecognized."),r._updateValue=function(){return null});}return P.push(r.update()),r}return n(g,null,[{key:"between",value:function(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return u(g,n)}}]),n(g,[{key:"pause",value:function(){return this[D]=!0,this.emit("pause",this.value,this,k),this}},{key:"play",value:function(){return this[D]=!1,this.emit("play",this.value,this,k),this}},{key:"easing",value:function(t){return this.ease=t,this}},{key:"time",value:function(t){return this.duration=t,this}},{key:"loop",value:function(){for(var t=0<arguments.length&&void 0!==arguments[0]?arguments[0]:"once",n="__loop_".concat(t),e=arguments.length,r=new Array(1<e?e-1:0),u=1;u<e;u++)r[u-1]=arguments[u];return this.loopFunction=n in this?Object.assign({},g.DEFAULT_LOOP,this[n].apply(this,r)):g.DEFAULT_LOOP,this}},{key:"__loop_repeat",value:function(t){var n=this,e=t;return this.times=0,{complete:function(t){n.localTime=0,Number.isInteger(e)&&++n.times===e?t():Number.isInteger(e)||++n.times;}}}},{key:"__loop_bounce",value:function(t){var n=this,e=t,r=1;return this.times=0,{complete:function(t){n.localTime=0,r=-r,Number.isInteger(e)&&++n.times===e?t():Number.isInteger(e)||++n.times;},progress:function(t){return 0<r?t:1-t}}}},{key:"isPaused",get:function(){return this[D]}}]),function(t,n){if("function"!=typeof n&&null!==n)throw new TypeError("Super expression must either be null or a function");o(t.prototype,n&&n.prototype),n&&o(t,n);}(g,t),g}(t);return M(E,"DEFAULT_LOOP",{complete:function(t){return t()},progress:function(t){return t}}),E.Easing=i,E._plugins={},E});
}(between));

var Between = between.exports;/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var __assign = function () {
  __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];

      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }

    return t;
  };

  return __assign.apply(this, arguments);
};

function __rest(s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
}

function __values(o) {
  var m = typeof Symbol === "function" && o[Symbol.iterator],
      i = 0;
  if (m) return m.call(o);
  return {
    next: function () {
      if (o && i >= o.length) o = void 0;
      return {
        value: o && o[i++],
        done: !o
      };
    }
  };
}

function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o),
      r,
      ar = [],
      e;

  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = {
      error: error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }

  return ar;
}

function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));

  return ar;
}var STATE_DELIMITER = '.';
var EMPTY_ACTIVITY_MAP = {};
var DEFAULT_GUARD_TYPE = 'xstate.guard';
var TARGETLESS_KEY = '';var IS_PRODUCTION = "production" === 'production';function keys(value) {
  return Object.keys(value);
}

function matchesState(parentStateId, childStateId, delimiter) {
  if (delimiter === void 0) {
    delimiter = STATE_DELIMITER;
  }

  var parentStateValue = toStateValue(parentStateId, delimiter);
  var childStateValue = toStateValue(childStateId, delimiter);

  if (isString$4(childStateValue)) {
    if (isString$4(parentStateValue)) {
      return childStateValue === parentStateValue;
    } // Parent more specific than child


    return false;
  }

  if (isString$4(parentStateValue)) {
    return parentStateValue in childStateValue;
  }

  return keys(parentStateValue).every(function (key) {
    if (!(key in childStateValue)) {
      return false;
    }

    return matchesState(parentStateValue[key], childStateValue[key]);
  });
}

function getEventType(event) {
  try {
    return isString$4(event) || typeof event === 'number' ? "" + event : event.type;
  } catch (e) {
    throw new Error('Events must be strings or objects with a string event.type property.');
  }
}

function toStatePath(stateId, delimiter) {
  try {
    if (isArray$4(stateId)) {
      return stateId;
    }

    return stateId.toString().split(delimiter);
  } catch (e) {
    throw new Error("'" + stateId + "' is not a valid state path.");
  }
}

function isStateLike(state) {
  return typeof state === 'object' && 'value' in state && 'context' in state && 'event' in state && '_event' in state;
}

function toStateValue(stateValue, delimiter) {
  if (isStateLike(stateValue)) {
    return stateValue.value;
  }

  if (isArray$4(stateValue)) {
    return pathToStateValue(stateValue);
  }

  if (typeof stateValue !== 'string') {
    return stateValue;
  }

  var statePath = toStatePath(stateValue, delimiter);
  return pathToStateValue(statePath);
}

function pathToStateValue(statePath) {
  if (statePath.length === 1) {
    return statePath[0];
  }

  var value = {};
  var marker = value;

  for (var i = 0; i < statePath.length - 1; i++) {
    if (i === statePath.length - 2) {
      marker[statePath[i]] = statePath[i + 1];
    } else {
      marker[statePath[i]] = {};
      marker = marker[statePath[i]];
    }
  }

  return value;
}

function mapValues(collection, iteratee) {
  var result = {};
  var collectionKeys = keys(collection);

  for (var i = 0; i < collectionKeys.length; i++) {
    var key = collectionKeys[i];
    result[key] = iteratee(collection[key], key, collection, i);
  }

  return result;
}

function mapFilterValues(collection, iteratee, predicate) {
  var e_1, _a;

  var result = {};

  try {
    for (var _b = __values(keys(collection)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var item = collection[key];

      if (!predicate(item)) {
        continue;
      }

      result[key] = iteratee(item, key, collection);
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  return result;
}
/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */


var path$1 = function (props) {
  return function (object) {
    var e_2, _a;

    var result = object;

    try {
      for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
        var prop = props_1_1.value;
        result = result[prop];
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (props_1_1 && !props_1_1.done && (_a = props_1.return)) _a.call(props_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    return result;
  };
};
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */


function nestedPath(props, accessorProp) {
  return function (object) {
    var e_3, _a;

    var result = object;

    try {
      for (var props_2 = __values(props), props_2_1 = props_2.next(); !props_2_1.done; props_2_1 = props_2.next()) {
        var prop = props_2_1.value;
        result = result[accessorProp][prop];
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (props_2_1 && !props_2_1.done && (_a = props_2.return)) _a.call(props_2);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    return result;
  };
}

function toStatePaths(stateValue) {
  if (!stateValue) {
    return [[]];
  }

  if (isString$4(stateValue)) {
    return [[stateValue]];
  }

  var result = flatten$1(keys(stateValue).map(function (key) {
    var subStateValue = stateValue[key];

    if (typeof subStateValue !== 'string' && (!subStateValue || !Object.keys(subStateValue).length)) {
      return [[key]];
    }

    return toStatePaths(stateValue[key]).map(function (subPath) {
      return [key].concat(subPath);
    });
  }));
  return result;
}

function flatten$1(array) {
  var _a;

  return (_a = []).concat.apply(_a, __spread(array));
}

function toArrayStrict(value) {
  if (isArray$4(value)) {
    return value;
  }

  return [value];
}

function toArray$1(value) {
  if (value === undefined) {
    return [];
  }

  return toArrayStrict(value);
}

function mapContext(mapper, context, _event) {
  var e_5, _a;

  if (isFunction$4(mapper)) {
    return mapper(context, _event.data);
  }

  var result = {};

  try {
    for (var _b = __values(keys(mapper)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var subMapper = mapper[key];

      if (isFunction$4(subMapper)) {
        result[key] = subMapper(context, _event.data);
      } else {
        result[key] = subMapper;
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return result;
}

function isBuiltInEvent(eventType) {
  return /^(done|error)\./.test(eventType);
}

function isPromiseLike(value) {
  if (value instanceof Promise) {
    return true;
  } // Check if shape matches the Promise/A+ specification for a "thenable".


  if (value !== null && (isFunction$4(value) || typeof value === 'object') && isFunction$4(value.then)) {
    return true;
  }

  return false;
}

function partition$1(items, predicate) {
  var e_6, _a;

  var _b = __read([[], []], 2),
      truthy = _b[0],
      falsy = _b[1];

  try {
    for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
      var item = items_1_1.value;

      if (predicate(item)) {
        truthy.push(item);
      } else {
        falsy.push(item);
      }
    }
  } catch (e_6_1) {
    e_6 = {
      error: e_6_1
    };
  } finally {
    try {
      if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
    } finally {
      if (e_6) throw e_6.error;
    }
  }

  return [truthy, falsy];
}

function updateHistoryStates(hist, stateValue) {
  return mapValues(hist.states, function (subHist, key) {
    if (!subHist) {
      return undefined;
    }

    var subStateValue = (isString$4(stateValue) ? undefined : stateValue[key]) || (subHist ? subHist.current : undefined);

    if (!subStateValue) {
      return undefined;
    }

    return {
      current: subStateValue,
      states: updateHistoryStates(subHist, subStateValue)
    };
  });
}

function updateHistoryValue(hist, stateValue) {
  return {
    current: stateValue,
    states: updateHistoryStates(hist, stateValue)
  };
}

function updateContext(context, _event, assignActions, state) {

  var updatedContext = context ? assignActions.reduce(function (acc, assignAction) {
    var e_7, _a;

    var assignment = assignAction.assignment;
    var meta = {
      state: state,
      action: assignAction,
      _event: _event
    };
    var partialUpdate = {};

    if (isFunction$4(assignment)) {
      partialUpdate = assignment(acc, _event.data, meta);
    } else {
      try {
        for (var _b = __values(keys(assignment)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          var propAssignment = assignment[key];
          partialUpdate[key] = isFunction$4(propAssignment) ? propAssignment(acc, _event.data, meta) : propAssignment;
        }
      } catch (e_7_1) {
        e_7 = {
          error: e_7_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_7) throw e_7.error;
        }
      }
    }

    return Object.assign({}, acc, partialUpdate);
  }, context) : context;
  return updatedContext;
} // tslint:disable-next-line:no-empty


var warn = function () {};

function isArray$4(value) {
  return Array.isArray(value);
} // tslint:disable-next-line:ban-types


function isFunction$4(value) {
  return typeof value === 'function';
}

function isString$4(value) {
  return typeof value === 'string';
} // export function memoizedGetter<T, TP extends { prototype: object }>(
//   o: TP,
//   property: string,
//   getter: () => T
// ): void {
//   Object.defineProperty(o.prototype, property, {
//     get: getter,
//     enumerable: false,
//     configurable: false
//   });
// }


function toGuard(condition, guardMap) {
  if (!condition) {
    return undefined;
  }

  if (isString$4(condition)) {
    return {
      type: DEFAULT_GUARD_TYPE,
      name: condition,
      predicate: guardMap ? guardMap[condition] : undefined
    };
  }

  if (isFunction$4(condition)) {
    return {
      type: DEFAULT_GUARD_TYPE,
      name: condition.name,
      predicate: condition
    };
  }

  return condition;
}

function isObservable$1(value) {
  try {
    return 'subscribe' in value && isFunction$4(value.subscribe);
  } catch (e) {
    return false;
  }
}

var symbolObservable =
/*#__PURE__*/
function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
}();

function isMachine(value) {
  try {
    return '__xstatenode' in value;
  } catch (e) {
    return false;
  }
}

function toEventObject(event, payload // id?: TEvent['type']
) {
  if (isString$4(event) || typeof event === 'number') {
    return __assign({
      type: event
    }, payload);
  }

  return event;
}

function toSCXMLEvent(event, scxmlEvent) {
  if (!isString$4(event) && '$$type' in event && event.$$type === 'scxml') {
    return event;
  }

  var eventObject = toEventObject(event);
  return __assign({
    name: eventObject.type,
    data: eventObject,
    $$type: 'scxml',
    type: 'external'
  }, scxmlEvent);
}

function toTransitionConfigArray(event, configLike) {
  var transitions = toArrayStrict(configLike).map(function (transitionLike) {
    if (typeof transitionLike === 'undefined' || typeof transitionLike === 'string' || isMachine(transitionLike)) {
      // @ts-ignore until Type instantiation is excessively deep and possibly infinite bug is fixed
      return {
        target: transitionLike,
        event: event
      };
    }

    return __assign(__assign({}, transitionLike), {
      event: event
    });
  });
  return transitions;
}

function normalizeTarget(target) {
  if (target === undefined || target === TARGETLESS_KEY) {
    return undefined;
  }

  return toArray$1(target);
}var ActionTypes$1;

(function (ActionTypes) {
  ActionTypes["Start"] = "xstate.start";
  ActionTypes["Stop"] = "xstate.stop";
  ActionTypes["Raise"] = "xstate.raise";
  ActionTypes["Send"] = "xstate.send";
  ActionTypes["Cancel"] = "xstate.cancel";
  ActionTypes["NullEvent"] = "";
  ActionTypes["Assign"] = "xstate.assign";
  ActionTypes["After"] = "xstate.after";
  ActionTypes["DoneState"] = "done.state";
  ActionTypes["DoneInvoke"] = "done.invoke";
  ActionTypes["Log"] = "xstate.log";
  ActionTypes["Init"] = "xstate.init";
  ActionTypes["Invoke"] = "xstate.invoke";
  ActionTypes["ErrorExecution"] = "error.execution";
  ActionTypes["ErrorCommunication"] = "error.communication";
  ActionTypes["ErrorPlatform"] = "error.platform";
  ActionTypes["ErrorCustom"] = "xstate.error";
  ActionTypes["Update"] = "xstate.update";
  ActionTypes["Pure"] = "xstate.pure";
})(ActionTypes$1 || (ActionTypes$1 = {}));

var SpecialTargets;

(function (SpecialTargets) {
  SpecialTargets["Parent"] = "#_parent";
  SpecialTargets["Internal"] = "#_internal";
})(SpecialTargets || (SpecialTargets = {}));var start$1 = ActionTypes$1.Start;
var stop$1 = ActionTypes$1.Stop;
var raise$1 = ActionTypes$1.Raise;
var send$1 = ActionTypes$1.Send;
var cancel$1 = ActionTypes$1.Cancel;
var nullEvent = ActionTypes$1.NullEvent;
var assign = ActionTypes$1.Assign;
ActionTypes$1.After;
ActionTypes$1.DoneState;
var log = ActionTypes$1.Log;
var init = ActionTypes$1.Init;
var invoke = ActionTypes$1.Invoke;
ActionTypes$1.ErrorExecution;
var errorPlatform = ActionTypes$1.ErrorPlatform;
var error$1 = ActionTypes$1.ErrorCustom;
var update = ActionTypes$1.Update;
var pure = ActionTypes$1.Pure;var initEvent =
/*#__PURE__*/
toSCXMLEvent({
  type: init
});

function getActionFunction(actionType, actionFunctionMap) {
  return actionFunctionMap ? actionFunctionMap[actionType] || undefined : undefined;
}

function toActionObject(action, actionFunctionMap) {
  var actionObject;

  if (isString$4(action) || typeof action === 'number') {
    var exec = getActionFunction(action, actionFunctionMap);

    if (isFunction$4(exec)) {
      actionObject = {
        type: action,
        exec: exec
      };
    } else if (exec) {
      actionObject = exec;
    } else {
      actionObject = {
        type: action,
        exec: undefined
      };
    }
  } else if (isFunction$4(action)) {
    actionObject = {
      // Convert action to string if unnamed
      type: action.name || action.toString(),
      exec: action
    };
  } else {
    var exec = getActionFunction(action.type, actionFunctionMap);

    if (isFunction$4(exec)) {
      actionObject = __assign(__assign({}, action), {
        exec: exec
      });
    } else if (exec) {
      var type = action.type,
          other = __rest(action, ["type"]);

      actionObject = __assign(__assign({
        type: type
      }, exec), other);
    } else {
      actionObject = action;
    }
  }

  Object.defineProperty(actionObject, 'toString', {
    value: function () {
      return actionObject.type;
    },
    enumerable: false,
    configurable: true
  });
  return actionObject;
}

var toActionObjects = function (action, actionFunctionMap) {
  if (!action) {
    return [];
  }

  var actions = isArray$4(action) ? action : [action];
  return actions.map(function (subAction) {
    return toActionObject(subAction, actionFunctionMap);
  });
};

function toActivityDefinition(action) {
  var actionObject = toActionObject(action);
  return __assign(__assign({
    id: isString$4(action) ? action : actionObject.id
  }, actionObject), {
    type: actionObject.type
  });
}
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 *
 * @param eventType The event to raise.
 */


function raise(event) {
  if (!isString$4(event)) {
    return send(event, {
      to: SpecialTargets.Internal
    });
  }

  return {
    type: raise$1,
    event: event
  };
}

function resolveRaise(action) {
  return {
    type: raise$1,
    _event: toSCXMLEvent(action.event)
  };
}
/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 *
 * @param event The event to send.
 * @param options Options to pass into the send event:
 *  - `id` - The unique send event identifier (used with `cancel()`).
 *  - `delay` - The number of milliseconds to delay the sending of the event.
 *  - `to` - The target of this event (by default, the machine the event was sent from).
 */


function send(event, options) {
  return {
    to: options ? options.to : undefined,
    type: send$1,
    event: isFunction$4(event) ? event : toEventObject(event),
    delay: options ? options.delay : undefined,
    id: options && options.id !== undefined ? options.id : isFunction$4(event) ? event.name : getEventType(event)
  };
}

function resolveSend(action, ctx, _event, delaysMap) {
  var meta = {
    _event: _event
  }; // TODO: helper function for resolving Expr

  var resolvedEvent = toSCXMLEvent(isFunction$4(action.event) ? action.event(ctx, _event.data, meta) : action.event);
  var resolvedDelay;

  if (isString$4(action.delay)) {
    var configDelay = delaysMap && delaysMap[action.delay];
    resolvedDelay = isFunction$4(configDelay) ? configDelay(ctx, _event.data, meta) : configDelay;
  } else {
    resolvedDelay = isFunction$4(action.delay) ? action.delay(ctx, _event.data, meta) : action.delay;
  }

  var resolvedTarget = isFunction$4(action.to) ? action.to(ctx, _event.data, meta) : action.to;
  return __assign(__assign({}, action), {
    to: resolvedTarget,
    _event: resolvedEvent,
    event: resolvedEvent.data,
    delay: resolvedDelay
  });
}

var resolveLog = function (action, ctx, _event) {
  return __assign(__assign({}, action), {
    value: isString$4(action.expr) ? action.expr : action.expr(ctx, _event.data, {
      _event: _event
    })
  });
};
/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 *
 * @param sendId The `id` of the `send(...)` action to cancel.
 */


var cancel = function (sendId) {
  return {
    type: cancel$1,
    sendId: sendId
  };
};
/**
 * Starts an activity.
 *
 * @param activity The activity to start.
 */


function start(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: ActionTypes$1.Start,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Stops an activity.
 *
 * @param activity The activity to stop.
 */


function stop(activity) {
  var activityDef = toActivityDefinition(activity);
  return {
    type: ActionTypes$1.Stop,
    activity: activityDef,
    exec: undefined
  };
}
/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 *
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */


function after(delayRef, id) {
  var idSuffix = id ? "#" + id : '';
  return ActionTypes$1.After + "(" + delayRef + ")" + idSuffix;
}
/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 *
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */


function done(id, data) {
  var type = ActionTypes$1.DoneState + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}
/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 *
 * @param id The final state node ID
 * @param data The data to pass into the event
 */


function doneInvoke(id, data) {
  var type = ActionTypes$1.DoneInvoke + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}

function error(id, data) {
  var type = ActionTypes$1.ErrorPlatform + "." + id;
  var eventObject = {
    type: type,
    data: data
  };

  eventObject.toString = function () {
    return type;
  };

  return eventObject;
}var isLeafNode = function (stateNode) {
  return stateNode.type === 'atomic' || stateNode.type === 'final';
};

function getChildren(stateNode) {
  return keys(stateNode.states).map(function (key) {
    return stateNode.states[key];
  });
}

function getAllStateNodes(stateNode) {
  var stateNodes = [stateNode];

  if (isLeafNode(stateNode)) {
    return stateNodes;
  }

  return stateNodes.concat(flatten$1(getChildren(stateNode).map(getAllStateNodes)));
}

function getConfiguration(prevStateNodes, stateNodes) {
  var e_1, _a, e_2, _b, e_3, _c, e_4, _d;

  var prevConfiguration = new Set(prevStateNodes);
  var prevAdjList = getAdjList(prevConfiguration);
  var configuration = new Set(stateNodes);

  try {
    // add all ancestors
    for (var configuration_1 = __values(configuration), configuration_1_1 = configuration_1.next(); !configuration_1_1.done; configuration_1_1 = configuration_1.next()) {
      var s = configuration_1_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_1_1) {
    e_1 = {
      error: e_1_1
    };
  } finally {
    try {
      if (configuration_1_1 && !configuration_1_1.done && (_a = configuration_1.return)) _a.call(configuration_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }

  var adjList = getAdjList(configuration);

  try {
    // add descendants
    for (var configuration_2 = __values(configuration), configuration_2_1 = configuration_2.next(); !configuration_2_1.done; configuration_2_1 = configuration_2.next()) {
      var s = configuration_2_1.value; // if previously active, add existing child nodes

      if (s.type === 'compound' && (!adjList.get(s) || !adjList.get(s).length)) {
        if (prevAdjList.get(s)) {
          prevAdjList.get(s).forEach(function (sn) {
            return configuration.add(sn);
          });
        } else {
          s.initialStateNodes.forEach(function (sn) {
            return configuration.add(sn);
          });
        }
      } else {
        if (s.type === 'parallel') {
          try {
            for (var _e = (e_3 = void 0, __values(getChildren(s))), _f = _e.next(); !_f.done; _f = _e.next()) {
              var child = _f.value;

              if (child.type === 'history') {
                continue;
              }

              if (!configuration.has(child)) {
                configuration.add(child);

                if (prevAdjList.get(child)) {
                  prevAdjList.get(child).forEach(function (sn) {
                    return configuration.add(sn);
                  });
                } else {
                  child.initialStateNodes.forEach(function (sn) {
                    return configuration.add(sn);
                  });
                }
              }
            }
          } catch (e_3_1) {
            e_3 = {
              error: e_3_1
            };
          } finally {
            try {
              if (_f && !_f.done && (_c = _e.return)) _c.call(_e);
            } finally {
              if (e_3) throw e_3.error;
            }
          }
        }
      }
    }
  } catch (e_2_1) {
    e_2 = {
      error: e_2_1
    };
  } finally {
    try {
      if (configuration_2_1 && !configuration_2_1.done && (_b = configuration_2.return)) _b.call(configuration_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }

  try {
    // add all ancestors
    for (var configuration_3 = __values(configuration), configuration_3_1 = configuration_3.next(); !configuration_3_1.done; configuration_3_1 = configuration_3.next()) {
      var s = configuration_3_1.value;
      var m = s.parent;

      while (m && !configuration.has(m)) {
        configuration.add(m);
        m = m.parent;
      }
    }
  } catch (e_4_1) {
    e_4 = {
      error: e_4_1
    };
  } finally {
    try {
      if (configuration_3_1 && !configuration_3_1.done && (_d = configuration_3.return)) _d.call(configuration_3);
    } finally {
      if (e_4) throw e_4.error;
    }
  }

  return configuration;
}

function getValueFromAdj(baseNode, adjList) {
  var childStateNodes = adjList.get(baseNode);

  if (!childStateNodes) {
    return {}; // todo: fix?
  }

  if (baseNode.type === 'compound') {
    var childStateNode = childStateNodes[0];

    if (childStateNode) {
      if (isLeafNode(childStateNode)) {
        return childStateNode.key;
      }
    } else {
      return {};
    }
  }

  var stateValue = {};
  childStateNodes.forEach(function (csn) {
    stateValue[csn.key] = getValueFromAdj(csn, adjList);
  });
  return stateValue;
}

function getAdjList(configuration) {
  var e_5, _a;

  var adjList = new Map();

  try {
    for (var configuration_4 = __values(configuration), configuration_4_1 = configuration_4.next(); !configuration_4_1.done; configuration_4_1 = configuration_4.next()) {
      var s = configuration_4_1.value;

      if (!adjList.has(s)) {
        adjList.set(s, []);
      }

      if (s.parent) {
        if (!adjList.has(s.parent)) {
          adjList.set(s.parent, []);
        }

        adjList.get(s.parent).push(s);
      }
    }
  } catch (e_5_1) {
    e_5 = {
      error: e_5_1
    };
  } finally {
    try {
      if (configuration_4_1 && !configuration_4_1.done && (_a = configuration_4.return)) _a.call(configuration_4);
    } finally {
      if (e_5) throw e_5.error;
    }
  }

  return adjList;
}

function getValue(rootNode, configuration) {
  var config = getConfiguration([rootNode], configuration);
  return getValueFromAdj(rootNode, getAdjList(config));
}

function has(iterable, item) {
  if (Array.isArray(iterable)) {
    return iterable.some(function (member) {
      return member === item;
    });
  }

  if (iterable instanceof Set) {
    return iterable.has(item);
  }

  return false; // TODO: fix
}

function nextEvents(configuration) {
  return flatten$1(__spread(new Set(configuration.map(function (sn) {
    return sn.ownEvents;
  }))));
}

function isInFinalState(configuration, stateNode) {
  if (stateNode.type === 'compound') {
    return getChildren(stateNode).some(function (s) {
      return s.type === 'final' && has(configuration, s);
    });
  }

  if (stateNode.type === 'parallel') {
    return getChildren(stateNode).every(function (sn) {
      return isInFinalState(configuration, sn);
    });
  }

  return false;
}function stateValuesEqual(a, b) {
  if (a === b) {
    return true;
  }

  if (a === undefined || b === undefined) {
    return false;
  }

  if (isString$4(a) || isString$4(b)) {
    return a === b;
  }

  var aKeys = keys(a);
  var bKeys = keys(b);
  return aKeys.length === bKeys.length && aKeys.every(function (key) {
    return stateValuesEqual(a[key], b[key]);
  });
}

function isState(state) {
  if (isString$4(state)) {
    return false;
  }

  return 'value' in state && 'history' in state;
}

function bindActionToState(action, state) {
  var exec = action.exec;

  var boundAction = __assign(__assign({}, action), {
    exec: exec !== undefined ? function () {
      return exec(state.context, state.event, {
        action: action,
        state: state,
        _event: state._event
      });
    } : undefined
  });

  return boundAction;
}

var State =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new State instance.
   * @param value The state value
   * @param context The extended state
   * @param historyValue The tree representing historical values of the state nodes
   * @param history The previous state
   * @param actions An array of action objects to execute as side-effects
   * @param activities A mapping of activities and whether they are started (`true`) or stopped (`false`).
   * @param meta
   * @param events Internal event queue. Should be empty with run-to-completion semantics.
   * @param configuration
   */
  function State(config) {
    var _this = this;

    this.actions = [];
    this.activities = EMPTY_ACTIVITY_MAP;
    this.meta = {};
    this.events = [];
    this.value = config.value;
    this.context = config.context;
    this._event = config._event;
    this._sessionid = config._sessionid;
    this.event = this._event.data;
    this.historyValue = config.historyValue;
    this.history = config.history;
    this.actions = config.actions || [];
    this.activities = config.activities || EMPTY_ACTIVITY_MAP;
    this.meta = config.meta || {};
    this.events = config.events || [];
    this.matches = this.matches.bind(this);
    this.toStrings = this.toStrings.bind(this);
    this.configuration = config.configuration;
    this.transitions = config.transitions;
    this.children = config.children;
    this.done = !!config.done;
    Object.defineProperty(this, 'nextEvents', {
      get: function () {
        return nextEvents(_this.configuration);
      }
    });
  }
  /**
   * Creates a new State instance for the given `stateValue` and `context`.
   * @param stateValue
   * @param context
   */


  State.from = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (stateValue.context !== context) {
        return new State({
          value: stateValue.value,
          context: context,
          _event: stateValue._event,
          _sessionid: null,
          historyValue: stateValue.historyValue,
          history: stateValue.history,
          actions: [],
          activities: stateValue.activities,
          meta: {},
          events: [],
          configuration: [],
          transitions: [],
          children: {}
        });
      }

      return stateValue;
    }

    var _event = initEvent;
    return new State({
      value: stateValue,
      context: context,
      _event: _event,
      _sessionid: null,
      historyValue: undefined,
      history: undefined,
      actions: [],
      activities: undefined,
      meta: undefined,
      events: [],
      configuration: [],
      transitions: [],
      children: {}
    });
  };
  /**
   * Creates a new State instance for the given `config`.
   * @param config The state config
   */


  State.create = function (config) {
    return new State(config);
  };
  /**
   * Creates a new `State` instance for the given `stateValue` and `context` with no actions (side-effects).
   * @param stateValue
   * @param context
   */


  State.inert = function (stateValue, context) {
    if (stateValue instanceof State) {
      if (!stateValue.actions.length) {
        return stateValue;
      }

      var _event = initEvent;
      return new State({
        value: stateValue.value,
        context: context,
        _event: _event,
        _sessionid: null,
        historyValue: stateValue.historyValue,
        history: stateValue.history,
        activities: stateValue.activities,
        configuration: stateValue.configuration,
        transitions: [],
        children: {}
      });
    }

    return State.from(stateValue, context);
  };
  /**
   * Returns an array of all the string leaf state node paths.
   * @param stateValue
   * @param delimiter The character(s) that separate each subpath in the string state node path.
   */


  State.prototype.toStrings = function (stateValue, delimiter) {
    var _this = this;

    if (stateValue === void 0) {
      stateValue = this.value;
    }

    if (delimiter === void 0) {
      delimiter = '.';
    }

    if (isString$4(stateValue)) {
      return [stateValue];
    }

    var valueKeys = keys(stateValue);
    return valueKeys.concat.apply(valueKeys, __spread(valueKeys.map(function (key) {
      return _this.toStrings(stateValue[key], delimiter).map(function (s) {
        return key + delimiter + s;
      });
    })));
  };

  State.prototype.toJSON = function () {
    var _a = this;
        _a.configuration;
        _a.transitions;
        var jsonValues = __rest(_a, ["configuration", "transitions"]);

    return jsonValues;
  };
  /**
   * Whether the current state value is a subset of the given parent state value.
   * @param parentStateValue
   */


  State.prototype.matches = function (parentStateValue) {
    return matchesState(parentStateValue, this.value);
  };

  return State;
}();function createNullActor(id) {
  return {
    id: id,
    send: function () {
      return void 0;
    },
    subscribe: function () {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    },
    toJSON: function () {
      return {
        id: id
      };
    }
  };
}
/**
 * Creates a null actor that is able to be invoked given the provided
 * invocation information in its `.meta` value.
 *
 * @param invokeDefinition The meta information needed to invoke the actor.
 */


function createInvocableActor(invokeDefinition) {
  var tempActor = createNullActor(invokeDefinition.id);
  tempActor.meta = invokeDefinition;
  return tempActor;
}

function isActor(item) {
  try {
    return typeof item.send === 'function';
  } catch (e) {
    return false;
  }
}var NULL_EVENT = '';
var STATE_IDENTIFIER = '#';
var WILDCARD = '*';
var EMPTY_OBJECT = {};

var isStateId = function (str) {
  return str[0] === STATE_IDENTIFIER;
};

var createDefaultOptions = function () {
  return {
    actions: {},
    guards: {},
    services: {},
    activities: {},
    delays: {}
  };
};

var validateArrayifiedTransitions = function (stateNode, event, transitions) {
  var hasNonLastUnguardedTarget = transitions.slice(0, -1).some(function (transition) {
    return !('cond' in transition) && !('in' in transition) && (isString$4(transition.target) || isMachine(transition.target));
  });
  var eventText = event === NULL_EVENT ? 'the transient event' : "event '" + event + "'";
  warn(!hasNonLastUnguardedTarget, "One or more transitions for " + eventText + " on state '" + stateNode.id + "' are unreachable. " + "Make sure that the default transition is the last one defined.");
};

var StateNode =
/*#__PURE__*/

/** @class */
function () {
  function StateNode(
  /**
   * The raw config used to create the machine.
   */
  config, options,
  /**
   * The initial extended state
   */
  context) {
    var _this = this;

    this.config = config;
    this.context = context;
    /**
     * The order this state node appears. Corresponds to the implicit SCXML document order.
     */

    this.order = -1;
    this.__xstatenode = true;
    this.__cache = {
      events: undefined,
      relativeValue: new Map(),
      initialStateValue: undefined,
      initialState: undefined,
      on: undefined,
      transitions: undefined,
      candidates: {},
      delayedTransitions: undefined
    };
    this.idMap = {};
    this.options = Object.assign(createDefaultOptions(), options);
    this.parent = this.options._parent;
    this.key = this.config.key || this.options._key || this.config.id || '(machine)';
    this.machine = this.parent ? this.parent.machine : this;
    this.path = this.parent ? this.parent.path.concat(this.key) : [];
    this.delimiter = this.config.delimiter || (this.parent ? this.parent.delimiter : STATE_DELIMITER);
    this.id = this.config.id || __spread([this.machine.key], this.path).join(this.delimiter);
    this.version = this.parent ? this.parent.version : this.config.version;
    this.type = this.config.type || (this.config.parallel ? 'parallel' : this.config.states && keys(this.config.states).length ? 'compound' : this.config.history ? 'history' : 'atomic');

    this.initial = this.config.initial;
    this.states = this.config.states ? mapValues(this.config.states, function (stateConfig, key) {
      var _a;

      var stateNode = new StateNode(stateConfig, {
        _parent: _this,
        _key: key
      });
      Object.assign(_this.idMap, __assign((_a = {}, _a[stateNode.id] = stateNode, _a), stateNode.idMap));
      return stateNode;
    }) : EMPTY_OBJECT; // Document order

    var order = 0;

    function dfs(stateNode) {
      var e_1, _a;

      stateNode.order = order++;

      try {
        for (var _b = __values(getChildren(stateNode)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var child = _c.value;
          dfs(child);
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
    }

    dfs(this); // History config

    this.history = this.config.history === true ? 'shallow' : this.config.history || false;
    this._transient = !this.config.on ? false : Array.isArray(this.config.on) ? this.config.on.some(function (_a) {
      var event = _a.event;
      return event === NULL_EVENT;
    }) : NULL_EVENT in this.config.on;
    this.strict = !!this.config.strict; // TODO: deprecate (entry)

    this.onEntry = toArray$1(this.config.entry || this.config.onEntry).map(function (action) {
      return toActionObject(action);
    }); // TODO: deprecate (exit)

    this.onExit = toArray$1(this.config.exit || this.config.onExit).map(function (action) {
      return toActionObject(action);
    });
    this.meta = this.config.meta;
    this.data = this.type === 'final' ? this.config.data : undefined;
    this.invoke = toArray$1(this.config.invoke).map(function (invokeConfig, i) {
      var _a, _b;

      if (isMachine(invokeConfig)) {
        _this.machine.options.services = __assign((_a = {}, _a[invokeConfig.id] = invokeConfig, _a), _this.machine.options.services);
        return {
          type: invoke,
          src: invokeConfig.id,
          id: invokeConfig.id
        };
      } else if (typeof invokeConfig.src !== 'string') {
        var invokeSrc = _this.id + ":invocation[" + i + "]"; // TODO: util function

        _this.machine.options.services = __assign((_b = {}, _b[invokeSrc] = invokeConfig.src, _b), _this.machine.options.services);
        return __assign(__assign({
          type: invoke,
          id: invokeSrc
        }, invokeConfig), {
          src: invokeSrc
        });
      } else {
        return __assign(__assign({}, invokeConfig), {
          type: invoke,
          id: invokeConfig.id || invokeConfig.src,
          src: invokeConfig.src
        });
      }
    });
    this.activities = toArray$1(this.config.activities).concat(this.invoke).map(function (activity) {
      return toActivityDefinition(activity);
    });
    this.transition = this.transition.bind(this);
  }

  StateNode.prototype._init = function () {
    if (this.__cache.transitions) {
      return;
    }

    getAllStateNodes(this).forEach(function (stateNode) {
      return stateNode.on;
    });
  };
  /**
   * Clones this state machine with custom options and context.
   *
   * @param options Options (actions, guards, activities, services) to recursively merge with the existing options.
   * @param context Custom context (will override predefined context)
   */


  StateNode.prototype.withConfig = function (options, context) {
    if (context === void 0) {
      context = this.context;
    }

    var _a = this.options,
        actions = _a.actions,
        activities = _a.activities,
        guards = _a.guards,
        services = _a.services,
        delays = _a.delays;
    return new StateNode(this.config, {
      actions: __assign(__assign({}, actions), options.actions),
      activities: __assign(__assign({}, activities), options.activities),
      guards: __assign(__assign({}, guards), options.guards),
      services: __assign(__assign({}, services), options.services),
      delays: __assign(__assign({}, delays), options.delays)
    }, context);
  };
  /**
   * Clones this state machine with custom context.
   *
   * @param context Custom context (will override predefined context, not recursive)
   */


  StateNode.prototype.withContext = function (context) {
    return new StateNode(this.config, this.options, context);
  };

  Object.defineProperty(StateNode.prototype, "definition", {
    /**
     * The well-structured state node definition.
     */
    get: function () {
      return {
        id: this.id,
        key: this.key,
        version: this.version,
        context: this.context,
        type: this.type,
        initial: this.initial,
        history: this.history,
        states: mapValues(this.states, function (state) {
          return state.definition;
        }),
        on: this.on,
        transitions: this.transitions,
        entry: this.onEntry,
        exit: this.onExit,
        activities: this.activities || [],
        meta: this.meta,
        order: this.order || -1,
        data: this.data,
        invoke: this.invoke
      };
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.toJSON = function () {
    return this.definition;
  };

  Object.defineProperty(StateNode.prototype, "on", {
    /**
     * The mapping of events to transitions.
     */
    get: function () {
      if (this.__cache.on) {
        return this.__cache.on;
      }

      var transitions = this.transitions;
      return this.__cache.on = transitions.reduce(function (map, transition) {
        map[transition.eventType] = map[transition.eventType] || [];
        map[transition.eventType].push(transition);
        return map;
      }, {});
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "after", {
    get: function () {
      return this.__cache.delayedTransitions || (this.__cache.delayedTransitions = this.getDelayedTransitions(), this.__cache.delayedTransitions);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "transitions", {
    /**
     * All the transitions that can be taken from this state node.
     */
    get: function () {
      return this.__cache.transitions || (this.__cache.transitions = this.formatTransitions(), this.__cache.transitions);
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.getCandidates = function (eventName) {
    if (this.__cache.candidates[eventName]) {
      return this.__cache.candidates[eventName];
    }

    var transient = eventName === NULL_EVENT;
    var candidates = this.transitions.filter(function (transition) {
      var sameEventType = transition.eventType === eventName; // null events should only match against eventless transitions

      return transient ? sameEventType : sameEventType || transition.eventType === WILDCARD;
    });
    this.__cache.candidates[eventName] = candidates;
    return candidates;
  };
  /**
   * All delayed transitions from the config.
   */


  StateNode.prototype.getDelayedTransitions = function () {
    var _this = this;

    var afterConfig = this.config.after;

    if (!afterConfig) {
      return [];
    }

    var mutateEntryExit = function (delay, i) {
      var delayRef = isFunction$4(delay) ? _this.id + ":delay[" + i + "]" : delay;
      var eventType = after(delayRef, _this.id);

      _this.onEntry.push(send(eventType, {
        delay: delay
      }));

      _this.onExit.push(cancel(eventType));

      return eventType;
    };

    var delayedTransitions = isArray$4(afterConfig) ? afterConfig.map(function (transition, i) {
      var eventType = mutateEntryExit(transition.delay, i);
      return __assign(__assign({}, transition), {
        event: eventType
      });
    }) : flatten$1(keys(afterConfig).map(function (delay, i) {
      var configTransition = afterConfig[delay];
      var resolvedTransition = isString$4(configTransition) ? {
        target: configTransition
      } : configTransition;
      var resolvedDelay = !isNaN(+delay) ? +delay : delay;
      var eventType = mutateEntryExit(resolvedDelay, i);
      return toArray$1(resolvedTransition).map(function (transition) {
        return __assign(__assign({}, transition), {
          event: eventType,
          delay: resolvedDelay
        });
      });
    }));
    return delayedTransitions.map(function (delayedTransition) {
      var delay = delayedTransition.delay;
      return __assign(__assign({}, _this.formatTransition(delayedTransition)), {
        delay: delay
      });
    });
  };
  /**
   * Returns the state nodes represented by the current state value.
   *
   * @param state The state value or State instance
   */


  StateNode.prototype.getStateNodes = function (state) {
    var _a;

    var _this = this;

    if (!state) {
      return [];
    }

    var stateValue = state instanceof State ? state.value : toStateValue(state, this.delimiter);

    if (isString$4(stateValue)) {
      var initialStateValue = this.getStateNode(stateValue).initial;
      return initialStateValue !== undefined ? this.getStateNodes((_a = {}, _a[stateValue] = initialStateValue, _a)) : [this.states[stateValue]];
    }

    var subStateKeys = keys(stateValue);
    var subStateNodes = subStateKeys.map(function (subStateKey) {
      return _this.getStateNode(subStateKey);
    });
    return subStateNodes.concat(subStateKeys.reduce(function (allSubStateNodes, subStateKey) {
      var subStateNode = _this.getStateNode(subStateKey).getStateNodes(stateValue[subStateKey]);

      return allSubStateNodes.concat(subStateNode);
    }, []));
  };
  /**
   * Returns `true` if this state node explicitly handles the given event.
   *
   * @param event The event in question
   */


  StateNode.prototype.handles = function (event) {
    var eventType = getEventType(event);
    return this.events.includes(eventType);
  };
  /**
   * Resolves the given `state` to a new `State` instance relative to this machine.
   *
   * This ensures that `.events` and `.nextEvents` represent the correct values.
   *
   * @param state The state to resolve
   */


  StateNode.prototype.resolveState = function (state) {
    var configuration = Array.from(getConfiguration([], this.getStateNodes(state.value)));
    return new State(__assign(__assign({}, state), {
      value: this.resolve(state.value),
      configuration: configuration
    }));
  };

  StateNode.prototype.transitionLeafNode = function (stateValue, state, _event) {
    var stateNode = this.getStateNode(stateValue);
    var next = stateNode.next(state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionCompoundNode = function (stateValue, state, _event) {
    var subStateKeys = keys(stateValue);
    var stateNode = this.getStateNode(subStateKeys[0]);

    var next = stateNode._transition(stateValue[subStateKeys[0]], state, _event);

    if (!next || !next.transitions.length) {
      return this.next(state, _event);
    }

    return next;
  };

  StateNode.prototype.transitionParallelNode = function (stateValue, state, _event) {
    var e_2, _a;

    var transitionMap = {};

    try {
      for (var _b = __values(keys(stateValue)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var subStateKey = _c.value;
        var subStateValue = stateValue[subStateKey];

        if (!subStateValue) {
          continue;
        }

        var subStateNode = this.getStateNode(subStateKey);

        var next = subStateNode._transition(subStateValue, state, _event);

        if (next) {
          transitionMap[subStateKey] = next;
        }
      }
    } catch (e_2_1) {
      e_2 = {
        error: e_2_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }

    var stateTransitions = keys(transitionMap).map(function (key) {
      return transitionMap[key];
    });
    var enabledTransitions = flatten$1(stateTransitions.map(function (st) {
      return st.transitions;
    }));
    var willTransition = stateTransitions.some(function (st) {
      return st.transitions.length > 0;
    });

    if (!willTransition) {
      return this.next(state, _event);
    }

    var entryNodes = flatten$1(stateTransitions.map(function (t) {
      return t.entrySet;
    }));
    var configuration = flatten$1(keys(transitionMap).map(function (key) {
      return transitionMap[key].configuration;
    }));
    return {
      transitions: enabledTransitions,
      entrySet: entryNodes,
      exitSet: flatten$1(stateTransitions.map(function (t) {
        return t.exitSet;
      })),
      configuration: configuration,
      source: state,
      actions: flatten$1(keys(transitionMap).map(function (key) {
        return transitionMap[key].actions;
      }))
    };
  };

  StateNode.prototype._transition = function (stateValue, state, _event) {
    // leaf node
    if (isString$4(stateValue)) {
      return this.transitionLeafNode(stateValue, state, _event);
    } // hierarchical node


    if (keys(stateValue).length === 1) {
      return this.transitionCompoundNode(stateValue, state, _event);
    } // orthogonal node


    return this.transitionParallelNode(stateValue, state, _event);
  };

  StateNode.prototype.next = function (state, _event) {
    var e_3, _a;

    var _this = this;

    var eventName = _event.name;
    var actions = [];
    var nextStateNodes = [];
    var selectedTransition;

    try {
      for (var _b = __values(this.getCandidates(eventName)), _c = _b.next(); !_c.done; _c = _b.next()) {
        var candidate = _c.value;
        var cond = candidate.cond,
            stateIn = candidate.in;
        var resolvedContext = state.context;
        var isInState = stateIn ? isString$4(stateIn) && isStateId(stateIn) ? // Check if in state by ID
        state.matches(toStateValue(this.getStateNodeById(stateIn).path, this.delimiter)) : // Check if in state by relative grandparent
        matchesState(toStateValue(stateIn, this.delimiter), path$1(this.path.slice(0, -2))(state.value)) : true;
        var guardPassed = false;

        try {
          guardPassed = !cond || this.evaluateGuard(cond, resolvedContext, _event, state);
        } catch (err) {
          throw new Error("Unable to evaluate guard '" + (cond.name || cond.type) + "' in transition for event '" + eventName + "' in state node '" + this.id + "':\n" + err.message);
        }

        if (guardPassed && isInState) {
          if (candidate.target !== undefined) {
            nextStateNodes = candidate.target;
          }

          actions.push.apply(actions, __spread(candidate.actions));
          selectedTransition = candidate;
          break;
        }
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    if (!selectedTransition) {
      return undefined;
    }

    if (!nextStateNodes.length) {
      return {
        transitions: [selectedTransition],
        entrySet: [],
        exitSet: [],
        configuration: state.value ? [this] : [],
        source: state,
        actions: actions
      };
    }

    var allNextStateNodes = flatten$1(nextStateNodes.map(function (stateNode) {
      return _this.getRelativeStateNodes(stateNode, state.historyValue);
    }));
    var isInternal = !!selectedTransition.internal;
    var reentryNodes = isInternal ? [] : flatten$1(allNextStateNodes.map(function (n) {
      return _this.nodesFromChild(n);
    }));
    return {
      transitions: [selectedTransition],
      entrySet: reentryNodes,
      exitSet: isInternal ? [] : [this],
      configuration: allNextStateNodes,
      source: state,
      actions: actions
    };
  };

  StateNode.prototype.nodesFromChild = function (childStateNode) {
    if (childStateNode.escapes(this)) {
      return [];
    }

    var nodes = [];
    var marker = childStateNode;

    while (marker && marker !== this) {
      nodes.push(marker);
      marker = marker.parent;
    }

    nodes.push(this); // inclusive

    return nodes;
  };
  /**
   * Whether the given state node "escapes" this state node. If the `stateNode` is equal to or the parent of
   * this state node, it does not escape.
   */


  StateNode.prototype.escapes = function (stateNode) {
    if (this === stateNode) {
      return false;
    }

    var parent = this.parent;

    while (parent) {
      if (parent === stateNode) {
        return false;
      }

      parent = parent.parent;
    }

    return true;
  };

  StateNode.prototype.evaluateGuard = function (guard, context, _event, state) {
    var guards = this.machine.options.guards;
    var guardMeta = {
      state: state,
      cond: guard,
      _event: _event
    }; // TODO: do not hardcode!

    if (guard.type === DEFAULT_GUARD_TYPE) {
      return guard.predicate(context, _event.data, guardMeta);
    }

    var condFn = guards[guard.type];

    if (!condFn) {
      throw new Error("Guard '" + guard.type + "' is not implemented on machine '" + this.machine.id + "'.");
    }

    return condFn(context, _event.data, guardMeta);
  };

  StateNode.prototype.getActions = function (transition, currentContext, _event, prevState) {
    var e_4, _a, e_5, _b;

    var prevConfig = getConfiguration([], prevState ? this.getStateNodes(prevState.value) : [this]);
    var resolvedConfig = transition.configuration.length ? getConfiguration(prevConfig, transition.configuration) : prevConfig;

    try {
      for (var resolvedConfig_1 = __values(resolvedConfig), resolvedConfig_1_1 = resolvedConfig_1.next(); !resolvedConfig_1_1.done; resolvedConfig_1_1 = resolvedConfig_1.next()) {
        var sn = resolvedConfig_1_1.value;

        if (!has(prevConfig, sn)) {
          transition.entrySet.push(sn);
        }
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (resolvedConfig_1_1 && !resolvedConfig_1_1.done && (_a = resolvedConfig_1.return)) _a.call(resolvedConfig_1);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    try {
      for (var prevConfig_1 = __values(prevConfig), prevConfig_1_1 = prevConfig_1.next(); !prevConfig_1_1.done; prevConfig_1_1 = prevConfig_1.next()) {
        var sn = prevConfig_1_1.value;

        if (!has(resolvedConfig, sn) || has(transition.exitSet, sn.parent)) {
          transition.exitSet.push(sn);
        }
      }
    } catch (e_5_1) {
      e_5 = {
        error: e_5_1
      };
    } finally {
      try {
        if (prevConfig_1_1 && !prevConfig_1_1.done && (_b = prevConfig_1.return)) _b.call(prevConfig_1);
      } finally {
        if (e_5) throw e_5.error;
      }
    }

    if (!transition.source) {
      transition.exitSet = []; // Ensure that root StateNode (machine) is entered

      transition.entrySet.push(this);
    }

    var doneEvents = flatten$1(transition.entrySet.map(function (sn) {
      var events = [];

      if (sn.type !== 'final') {
        return events;
      }

      var parent = sn.parent;
      events.push(done(sn.id, sn.data), // TODO: deprecate - final states should not emit done events for their own state.
      done(parent.id, sn.data ? mapContext(sn.data, currentContext, _event) : undefined));

      if (parent.parent) {
        var grandparent = parent.parent;

        if (grandparent.type === 'parallel') {
          if (getChildren(grandparent).every(function (parentNode) {
            return isInFinalState(transition.configuration, parentNode);
          })) {
            events.push(done(grandparent.id, grandparent.data));
          }
        }
      }

      return events;
    }));
    transition.exitSet.sort(function (a, b) {
      return b.order - a.order;
    });
    transition.entrySet.sort(function (a, b) {
      return a.order - b.order;
    });
    var entryStates = new Set(transition.entrySet);
    var exitStates = new Set(transition.exitSet);

    var _c = __read([flatten$1(Array.from(entryStates).map(function (stateNode) {
      return __spread(stateNode.activities.map(function (activity) {
        return start(activity);
      }), stateNode.onEntry);
    })).concat(doneEvents.map(raise)), flatten$1(Array.from(exitStates).map(function (stateNode) {
      return __spread(stateNode.onExit, stateNode.activities.map(function (activity) {
        return stop(activity);
      }));
    }))], 2),
        entryActions = _c[0],
        exitActions = _c[1];

    var actions = toActionObjects(exitActions.concat(transition.actions).concat(entryActions), this.machine.options.actions);
    return actions;
  };
  /**
   * Determines the next state given the current `state` and sent `event`.
   *
   * @param state The current State instance or state value
   * @param event The event that was sent at the current state
   * @param context The current context (extended state) of the current state
   */


  StateNode.prototype.transition = function (state, event, context) {
    if (state === void 0) {
      state = this.initialState;
    }

    var _event = toSCXMLEvent(event);

    var currentState;

    if (state instanceof State) {
      currentState = context === undefined ? state : this.resolveState(State.from(state, context));
    } else {
      var resolvedStateValue = isString$4(state) ? this.resolve(pathToStateValue(this.getResolvedPath(state))) : this.resolve(state);
      var resolvedContext = context ? context : this.machine.context;
      currentState = this.resolveState(State.from(resolvedStateValue, resolvedContext));
    }

    if (!IS_PRODUCTION && _event.name === WILDCARD) {
      throw new Error("An event cannot have the wildcard type ('" + WILDCARD + "')");
    }

    if (this.strict) {
      if (!this.events.includes(_event.name) && !isBuiltInEvent(_event.name)) {
        throw new Error("Machine '" + this.id + "' does not accept event '" + _event.name + "'");
      }
    }

    var stateTransition = this._transition(currentState.value, currentState, _event) || {
      transitions: [],
      configuration: [],
      entrySet: [],
      exitSet: [],
      source: currentState,
      actions: []
    };
    var prevConfig = getConfiguration([], this.getStateNodes(currentState.value));
    var resolvedConfig = stateTransition.configuration.length ? getConfiguration(prevConfig, stateTransition.configuration) : prevConfig;
    stateTransition.configuration = __spread(resolvedConfig);
    return this.resolveTransition(stateTransition, currentState, _event);
  };

  StateNode.prototype.resolveRaisedTransition = function (state, _event, originalEvent) {
    var _a;

    var currentActions = state.actions;
    state = this.transition(state, _event); // Save original event to state

    state._event = originalEvent;
    state.event = originalEvent.data;

    (_a = state.actions).unshift.apply(_a, __spread(currentActions));

    return state;
  };

  StateNode.prototype.resolveTransition = function (stateTransition, currentState, _event, context) {
    var e_6, _a;

    var _this = this;

    if (_event === void 0) {
      _event = initEvent;
    }

    if (context === void 0) {
      context = this.machine.context;
    }

    var configuration = stateTransition.configuration; // Transition will "apply" if:
    // - this is the initial state (there is no current state)
    // - OR there are transitions

    var willTransition = !currentState || stateTransition.transitions.length > 0;
    var resolvedStateValue = willTransition ? getValue(this.machine, configuration) : undefined;
    var historyValue = currentState ? currentState.historyValue ? currentState.historyValue : stateTransition.source ? this.machine.historyValue(currentState.value) : undefined : undefined;
    var currentContext = currentState ? currentState.context : context;
    var actions = this.getActions(stateTransition, currentContext, _event, currentState);
    var activities = currentState ? __assign({}, currentState.activities) : {};

    try {
      for (var actions_1 = __values(actions), actions_1_1 = actions_1.next(); !actions_1_1.done; actions_1_1 = actions_1.next()) {
        var action = actions_1_1.value;

        if (action.type === start$1) {
          activities[action.activity.type] = action;
        } else if (action.type === stop$1) {
          activities[action.activity.type] = false;
        }
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (actions_1_1 && !actions_1_1.done && (_a = actions_1.return)) _a.call(actions_1);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    var _b = __read(partition$1(actions, function (action) {
      return action.type === assign;
    }), 2),
        assignActions = _b[0],
        otherActions = _b[1];

    var updatedContext = assignActions.length ? updateContext(currentContext, _event, assignActions, currentState) : currentContext;
    var resolvedActions = flatten$1(otherActions.map(function (actionObject) {
      switch (actionObject.type) {
        case raise$1:
          return resolveRaise(actionObject);

        case send$1:
          var sendAction = resolveSend(actionObject, updatedContext, _event, _this.machine.options.delays); // TODO: fix ActionTypes.Init

          if (!IS_PRODUCTION) {
            // warn after resolving as we can create better contextual message here
            warn(!isString$4(actionObject.delay) || typeof sendAction.delay === 'number', // tslint:disable-next-line:max-line-length
            "No delay reference for delay expression '" + actionObject.delay + "' was found on machine '" + _this.machine.id + "'");
          }

          return sendAction;

        case log:
          return resolveLog(actionObject, updatedContext, _event);

        case pure:
          return actionObject.get(updatedContext, _event.data) || [];

        default:
          return toActionObject(actionObject, _this.options.actions);
      }
    }));

    var _c = __read(partition$1(resolvedActions, function (action) {
      return action.type === raise$1 || action.type === send$1 && action.to === SpecialTargets.Internal;
    }), 2),
        raisedEvents = _c[0],
        nonRaisedActions = _c[1];

    var invokeActions = resolvedActions.filter(function (action) {
      return action.type === start$1 && action.activity.type === invoke;
    });
    var children = invokeActions.reduce(function (acc, action) {
      acc[action.activity.id] = createInvocableActor(action.activity);
      return acc;
    }, currentState ? __assign({}, currentState.children) : {});
    var resolvedConfiguration = resolvedStateValue ? stateTransition.configuration : currentState ? currentState.configuration : [];
    var meta = resolvedConfiguration.reduce(function (acc, stateNode) {
      if (stateNode.meta !== undefined) {
        acc[stateNode.id] = stateNode.meta;
      }

      return acc;
    }, {});
    var isDone = isInFinalState(resolvedConfiguration, this);
    var nextState = new State({
      value: resolvedStateValue || currentState.value,
      context: updatedContext,
      _event: _event,
      // Persist _sessionid between states
      _sessionid: currentState ? currentState._sessionid : null,
      historyValue: resolvedStateValue ? historyValue ? updateHistoryValue(historyValue, resolvedStateValue) : undefined : currentState ? currentState.historyValue : undefined,
      history: !resolvedStateValue || stateTransition.source ? currentState : undefined,
      actions: resolvedStateValue ? nonRaisedActions : [],
      activities: resolvedStateValue ? activities : currentState ? currentState.activities : {},
      meta: resolvedStateValue ? meta : currentState ? currentState.meta : undefined,
      events: [],
      configuration: resolvedConfiguration,
      transitions: stateTransition.transitions,
      children: children,
      done: isDone
    });
    nextState.changed = _event.name === update || !!assignActions.length; // Dispose of penultimate histories to prevent memory leaks

    var history = nextState.history;

    if (history) {
      delete history.history;
    }

    if (!resolvedStateValue) {
      return nextState;
    }

    var maybeNextState = nextState;

    if (!isDone) {
      var isTransient = this._transient || configuration.some(function (stateNode) {
        return stateNode._transient;
      });

      if (isTransient) {
        maybeNextState = this.resolveRaisedTransition(maybeNextState, {
          type: nullEvent
        }, _event);
      }

      while (raisedEvents.length) {
        var raisedEvent = raisedEvents.shift();
        maybeNextState = this.resolveRaisedTransition(maybeNextState, raisedEvent._event, _event);
      }
    } // Detect if state changed


    var changed = maybeNextState.changed || (history ? !!maybeNextState.actions.length || !!assignActions.length || typeof history.value !== typeof maybeNextState.value || !stateValuesEqual(maybeNextState.value, history.value) : undefined);
    maybeNextState.changed = changed; // Preserve original history after raised events

    maybeNextState.historyValue = nextState.historyValue;
    maybeNextState.history = history;
    return maybeNextState;
  };
  /**
   * Returns the child state node from its relative `stateKey`, or throws.
   */


  StateNode.prototype.getStateNode = function (stateKey) {
    if (isStateId(stateKey)) {
      return this.machine.getStateNodeById(stateKey);
    }

    if (!this.states) {
      throw new Error("Unable to retrieve child state '" + stateKey + "' from '" + this.id + "'; no child states exist.");
    }

    var result = this.states[stateKey];

    if (!result) {
      throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
    }

    return result;
  };
  /**
   * Returns the state node with the given `stateId`, or throws.
   *
   * @param stateId The state ID. The prefix "#" is removed.
   */


  StateNode.prototype.getStateNodeById = function (stateId) {
    var resolvedStateId = isStateId(stateId) ? stateId.slice(STATE_IDENTIFIER.length) : stateId;

    if (resolvedStateId === this.id) {
      return this;
    }

    var stateNode = this.machine.idMap[resolvedStateId];

    if (!stateNode) {
      throw new Error("Child state node '#" + resolvedStateId + "' does not exist on machine '" + this.id + "'");
    }

    return stateNode;
  };
  /**
   * Returns the relative state node from the given `statePath`, or throws.
   *
   * @param statePath The string or string array relative path to the state node.
   */


  StateNode.prototype.getStateNodeByPath = function (statePath) {
    if (typeof statePath === 'string' && isStateId(statePath)) {
      try {
        return this.getStateNodeById(statePath.slice(1));
      } catch (e) {// try individual paths
        // throw e;
      }
    }

    var arrayStatePath = toStatePath(statePath, this.delimiter).slice();
    var currentStateNode = this;

    while (arrayStatePath.length) {
      var key = arrayStatePath.shift();

      if (!key.length) {
        break;
      }

      currentStateNode = currentStateNode.getStateNode(key);
    }

    return currentStateNode;
  };
  /**
   * Resolves a partial state value with its full representation in this machine.
   *
   * @param stateValue The partial state value to resolve.
   */


  StateNode.prototype.resolve = function (stateValue) {
    var _a;

    var _this = this;

    if (!stateValue) {
      return this.initialStateValue || EMPTY_OBJECT; // TODO: type-specific properties
    }

    switch (this.type) {
      case 'parallel':
        return mapValues(this.initialStateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(stateValue[subStateKey] || subStateValue) : EMPTY_OBJECT;
        });

      case 'compound':
        if (isString$4(stateValue)) {
          var subStateNode = this.getStateNode(stateValue);

          if (subStateNode.type === 'parallel' || subStateNode.type === 'compound') {
            return _a = {}, _a[stateValue] = subStateNode.initialStateValue, _a;
          }

          return stateValue;
        }

        if (!keys(stateValue).length) {
          return this.initialStateValue || {};
        }

        return mapValues(stateValue, function (subStateValue, subStateKey) {
          return subStateValue ? _this.getStateNode(subStateKey).resolve(subStateValue) : EMPTY_OBJECT;
        });

      default:
        return stateValue || EMPTY_OBJECT;
    }
  };

  StateNode.prototype.getResolvedPath = function (stateIdentifier) {
    if (isStateId(stateIdentifier)) {
      var stateNode = this.machine.idMap[stateIdentifier.slice(STATE_IDENTIFIER.length)];

      if (!stateNode) {
        throw new Error("Unable to find state node '" + stateIdentifier + "'");
      }

      return stateNode.path;
    }

    return toStatePath(stateIdentifier, this.delimiter);
  };

  Object.defineProperty(StateNode.prototype, "initialStateValue", {
    get: function () {
      var _a;

      if (this.__cache.initialStateValue) {
        return this.__cache.initialStateValue;
      }

      var initialStateValue;

      if (this.type === 'parallel') {
        initialStateValue = mapFilterValues(this.states, function (state) {
          return state.initialStateValue || EMPTY_OBJECT;
        }, function (stateNode) {
          return !(stateNode.type === 'history');
        });
      } else if (this.initial !== undefined) {
        if (!this.states[this.initial]) {
          throw new Error("Initial state '" + this.initial + "' not found on '" + this.key + "'");
        }

        initialStateValue = isLeafNode(this.states[this.initial]) ? this.initial : (_a = {}, _a[this.initial] = this.states[this.initial].initialStateValue, _a);
      }

      this.__cache.initialStateValue = initialStateValue;
      return this.__cache.initialStateValue;
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.getInitialState = function (stateValue, context) {
    var configuration = this.getStateNodes(stateValue);
    return this.resolveTransition({
      configuration: configuration,
      entrySet: configuration,
      exitSet: [],
      transitions: [],
      source: undefined,
      actions: []
    }, undefined, undefined, context);
  };

  Object.defineProperty(StateNode.prototype, "initialState", {
    /**
     * The initial State instance, which includes all actions to be executed from
     * entering the initial state.
     */
    get: function () {
      this._init();

      var initialStateValue = this.initialStateValue;

      if (!initialStateValue) {
        throw new Error("Cannot retrieve initial state from simple state '" + this.id + "'.");
      }

      return this.getInitialState(initialStateValue);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "target", {
    /**
     * The target state value of the history state node, if it exists. This represents the
     * default state value to transition to if no history value exists yet.
     */
    get: function () {
      var target;

      if (this.type === 'history') {
        var historyConfig = this.config;

        if (isString$4(historyConfig.target)) {
          target = isStateId(historyConfig.target) ? pathToStateValue(this.machine.getStateNodeById(historyConfig.target).path.slice(this.path.length - 1)) : historyConfig.target;
        } else {
          target = historyConfig.target;
        }
      }

      return target;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Returns the leaf nodes from a state path relative to this state node.
   *
   * @param relativeStateId The relative state path to retrieve the state nodes
   * @param history The previous state to retrieve history
   * @param resolve Whether state nodes should resolve to initial child state nodes
   */

  StateNode.prototype.getRelativeStateNodes = function (relativeStateId, historyValue, resolve) {
    if (resolve === void 0) {
      resolve = true;
    }

    return resolve ? relativeStateId.type === 'history' ? relativeStateId.resolveHistory(historyValue) : relativeStateId.initialStateNodes : [relativeStateId];
  };

  Object.defineProperty(StateNode.prototype, "initialStateNodes", {
    get: function () {
      var _this = this;

      if (isLeafNode(this)) {
        return [this];
      } // Case when state node is compound but no initial state is defined


      if (this.type === 'compound' && !this.initial) {
        if (!IS_PRODUCTION) {
          warn(false, "Compound state node '" + this.id + "' has no initial state.");
        }

        return [this];
      }

      var initialStateNodePaths = toStatePaths(this.initialStateValue);
      return flatten$1(initialStateNodePaths.map(function (initialPath) {
        return _this.getFromRelativePath(initialPath);
      }));
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Retrieves state nodes from a relative path to this state node.
   *
   * @param relativePath The relative path from this state node
   * @param historyValue
   */

  StateNode.prototype.getFromRelativePath = function (relativePath) {
    if (!relativePath.length) {
      return [this];
    }

    var _a = __read(relativePath),
        stateKey = _a[0],
        childStatePath = _a.slice(1);

    if (!this.states) {
      throw new Error("Cannot retrieve subPath '" + stateKey + "' from node with no states");
    }

    var childStateNode = this.getStateNode(stateKey);

    if (childStateNode.type === 'history') {
      return childStateNode.resolveHistory();
    }

    if (!this.states[stateKey]) {
      throw new Error("Child state '" + stateKey + "' does not exist on '" + this.id + "'");
    }

    return this.states[stateKey].getFromRelativePath(childStatePath);
  };

  StateNode.prototype.historyValue = function (relativeStateValue) {
    if (!keys(this.states).length) {
      return undefined;
    }

    return {
      current: relativeStateValue || this.initialStateValue,
      states: mapFilterValues(this.states, function (stateNode, key) {
        if (!relativeStateValue) {
          return stateNode.historyValue();
        }

        var subStateValue = isString$4(relativeStateValue) ? undefined : relativeStateValue[key];
        return stateNode.historyValue(subStateValue || stateNode.initialStateValue);
      }, function (stateNode) {
        return !stateNode.history;
      })
    };
  };
  /**
   * Resolves to the historical value(s) of the parent state node,
   * represented by state nodes.
   *
   * @param historyValue
   */


  StateNode.prototype.resolveHistory = function (historyValue) {
    var _this = this;

    if (this.type !== 'history') {
      return [this];
    }

    var parent = this.parent;

    if (!historyValue) {
      var historyTarget = this.target;
      return historyTarget ? flatten$1(toStatePaths(historyTarget).map(function (relativeChildPath) {
        return parent.getFromRelativePath(relativeChildPath);
      })) : parent.initialStateNodes;
    }

    var subHistoryValue = nestedPath(parent.path, 'states')(historyValue).current;

    if (isString$4(subHistoryValue)) {
      return [parent.getStateNode(subHistoryValue)];
    }

    return flatten$1(toStatePaths(subHistoryValue).map(function (subStatePath) {
      return _this.history === 'deep' ? parent.getFromRelativePath(subStatePath) : [parent.states[subStatePath[0]]];
    }));
  };

  Object.defineProperty(StateNode.prototype, "stateIds", {
    /**
     * All the state node IDs of this state node and its descendant state nodes.
     */
    get: function () {
      var _this = this;

      var childStateIds = flatten$1(keys(this.states).map(function (stateKey) {
        return _this.states[stateKey].stateIds;
      }));
      return [this.id].concat(childStateIds);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "events", {
    /**
     * All the event types accepted by this state node and its descendants.
     */
    get: function () {
      var e_7, _a, e_8, _b;

      if (this.__cache.events) {
        return this.__cache.events;
      }

      var states = this.states;
      var events = new Set(this.ownEvents);

      if (states) {
        try {
          for (var _c = __values(keys(states)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var stateId = _d.value;
            var state = states[stateId];

            if (state.states) {
              try {
                for (var _e = (e_8 = void 0, __values(state.events)), _f = _e.next(); !_f.done; _f = _e.next()) {
                  var event_1 = _f.value;
                  events.add("" + event_1);
                }
              } catch (e_8_1) {
                e_8 = {
                  error: e_8_1
                };
              } finally {
                try {
                  if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                } finally {
                  if (e_8) throw e_8.error;
                }
              }
            }
          }
        } catch (e_7_1) {
          e_7 = {
            error: e_7_1
          };
        } finally {
          try {
            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
          } finally {
            if (e_7) throw e_7.error;
          }
        }
      }

      return this.__cache.events = Array.from(events);
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(StateNode.prototype, "ownEvents", {
    /**
     * All the events that have transitions directly from this state node.
     *
     * Excludes any inert events.
     */
    get: function () {
      var events = new Set(this.transitions.filter(function (transition) {
        return !(!transition.target && !transition.actions.length && transition.internal);
      }).map(function (transition) {
        return transition.eventType;
      }));
      return Array.from(events);
    },
    enumerable: true,
    configurable: true
  });

  StateNode.prototype.resolveTarget = function (_target) {
    var _this = this;

    if (_target === undefined) {
      // an undefined target signals that the state node should not transition from that state when receiving that event
      return undefined;
    }

    return _target.map(function (target) {
      if (!isString$4(target)) {
        return target;
      }

      var isInternalTarget = target[0] === _this.delimiter; // If internal target is defined on machine,
      // do not include machine key on target

      if (isInternalTarget && !_this.parent) {
        return _this.getStateNodeByPath(target.slice(1));
      }

      var resolvedTarget = isInternalTarget ? _this.key + target : target;

      if (_this.parent) {
        try {
          var targetStateNode = _this.parent.getStateNodeByPath(resolvedTarget);

          return targetStateNode;
        } catch (err) {
          throw new Error("Invalid transition definition for state node '" + _this.id + "':\n" + err.message);
        }
      } else {
        return _this.getStateNodeByPath(resolvedTarget);
      }
    });
  };

  StateNode.prototype.formatTransition = function (transitionConfig) {
    var _this = this;

    var normalizedTarget = normalizeTarget(transitionConfig.target);
    var internal = 'internal' in transitionConfig ? transitionConfig.internal : normalizedTarget ? normalizedTarget.some(function (_target) {
      return isString$4(_target) && _target[0] === _this.delimiter;
    }) : true;
    var guards = this.machine.options.guards;
    var target = this.resolveTarget(normalizedTarget);

    var transition = __assign(__assign({}, transitionConfig), {
      actions: toActionObjects(toArray$1(transitionConfig.actions)),
      cond: toGuard(transitionConfig.cond, guards),
      target: target,
      source: this,
      internal: internal,
      eventType: transitionConfig.event
    });

    Object.defineProperty(transition, 'toJSON', {
      value: function () {
        return __assign(__assign({}, transition), {
          target: transition.target ? transition.target.map(function (t) {
            return "#" + t.id;
          }) : undefined,
          source: "#{this.id}"
        });
      }
    });
    return transition;
  };

  StateNode.prototype.formatTransitions = function () {
    var e_9, _a;

    var _this = this;

    var onConfig;

    if (!this.config.on) {
      onConfig = [];
    } else if (Array.isArray(this.config.on)) {
      onConfig = this.config.on;
    } else {
      var _b = this.config.on,
          _c = WILDCARD,
          _d = _b[_c],
          wildcardConfigs = _d === void 0 ? [] : _d,
          strictOnConfigs_1 = __rest(_b, [typeof _c === "symbol" ? _c : _c + ""]);

      onConfig = flatten$1(keys(strictOnConfigs_1).map(function (key) {
        var arrayified = toTransitionConfigArray(key, strictOnConfigs_1[key]);

        if (!IS_PRODUCTION) {
          validateArrayifiedTransitions(_this, key, arrayified);
        }

        return arrayified;
      }).concat(toTransitionConfigArray(WILDCARD, wildcardConfigs)));
    }

    var doneConfig = this.config.onDone ? toTransitionConfigArray(String(done(this.id)), this.config.onDone) : [];
    var invokeConfig = flatten$1(this.invoke.map(function (invokeDef) {
      var settleTransitions = [];

      if (invokeDef.onDone) {
        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(doneInvoke(invokeDef.id)), invokeDef.onDone)));
      }

      if (invokeDef.onError) {
        settleTransitions.push.apply(settleTransitions, __spread(toTransitionConfigArray(String(error(invokeDef.id)), invokeDef.onError)));
      }

      return settleTransitions;
    }));
    var delayedTransitions = this.after;
    var formattedTransitions = flatten$1(__spread(doneConfig, invokeConfig, onConfig).map(function (transitionConfig) {
      return toArray$1(transitionConfig).map(function (transition) {
        return _this.formatTransition(transition);
      });
    }));

    try {
      for (var delayedTransitions_1 = __values(delayedTransitions), delayedTransitions_1_1 = delayedTransitions_1.next(); !delayedTransitions_1_1.done; delayedTransitions_1_1 = delayedTransitions_1.next()) {
        var delayedTransition = delayedTransitions_1_1.value;
        formattedTransitions.push(delayedTransition);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (delayedTransitions_1_1 && !delayedTransitions_1_1.done && (_a = delayedTransitions_1.return)) _a.call(delayedTransitions_1);
      } finally {
        if (e_9) throw e_9.error;
      }
    }

    return formattedTransitions;
  };

  return StateNode;
}();function createMachine(config, options) {
  var resolvedInitialContext = typeof config.context === 'function' ? config.context() : config.context;
  return new StateNode(config, options, resolvedInitialContext);
}var defaultOptions = {
  deferEvents: false
};

var Scheduler$1 =
/*#__PURE__*/

/** @class */
function () {
  function Scheduler(options) {
    this.processingEvent = false;
    this.queue = [];
    this.initialized = false;
    this.options = __assign(__assign({}, defaultOptions), options);
  }

  Scheduler.prototype.initialize = function (callback) {
    this.initialized = true;

    if (callback) {
      if (!this.options.deferEvents) {
        this.schedule(callback);
        return;
      }

      this.process(callback);
    }

    this.flushEvents();
  };

  Scheduler.prototype.schedule = function (task) {
    if (!this.initialized || this.processingEvent) {
      this.queue.push(task);
      return;
    }

    if (this.queue.length !== 0) {
      throw new Error('Event queue should be empty when it is not processing events');
    }

    this.process(task);
    this.flushEvents();
  };

  Scheduler.prototype.clear = function () {
    this.queue = [];
  };

  Scheduler.prototype.flushEvents = function () {
    var nextCallback = this.queue.shift();

    while (nextCallback) {
      this.process(nextCallback);
      nextCallback = this.queue.shift();
    }
  };

  Scheduler.prototype.process = function (callback) {
    this.processingEvent = true;

    try {
      callback();
    } catch (e) {
      // there is no use to keep the future events
      // as the situation is not anymore the same
      this.clear();
      throw e;
    } finally {
      this.processingEvent = false;
    }
  };

  return Scheduler;
}();var children =
/*#__PURE__*/
new Map();
var sessionIdIndex = 0;
var registry = {
  bookId: function () {
    return "x:" + sessionIdIndex++;
  },
  register: function (id, actor) {
    children.set(id, actor);
    return id;
  },
  get: function (id) {
    return children.get(id);
  },
  free: function (id) {
    children.delete(id);
  }
};var DEFAULT_SPAWN_OPTIONS = {
  sync: false,
  autoForward: false
};
/**
 * Maintains a stack of the current service in scope.
 * This is used to provide the correct service to spawn().
 *
 * @private
 */

var withServiceScope =
/*#__PURE__*/
function () {
  var serviceStack = [];
  return function (service, fn) {
    service && serviceStack.push(service);
    var result = fn(service || serviceStack[serviceStack.length - 1]);
    service && serviceStack.pop();
    return result;
  };
}();

var InterpreterStatus;

(function (InterpreterStatus) {
  InterpreterStatus[InterpreterStatus["NotStarted"] = 0] = "NotStarted";
  InterpreterStatus[InterpreterStatus["Running"] = 1] = "Running";
  InterpreterStatus[InterpreterStatus["Stopped"] = 2] = "Stopped";
})(InterpreterStatus || (InterpreterStatus = {}));

var Interpreter =
/*#__PURE__*/

/** @class */
function () {
  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   *
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  function Interpreter(machine, options) {
    var _this = this;

    if (options === void 0) {
      options = Interpreter.defaultOptions;
    }

    this.machine = machine;
    this.scheduler = new Scheduler$1();
    this.delayedEventsMap = {};
    this.listeners = new Set();
    this.contextListeners = new Set();
    this.stopListeners = new Set();
    this.doneListeners = new Set();
    this.eventListeners = new Set();
    this.sendListeners = new Set();
    /**
     * Whether the service is started.
     */

    this.initialized = false;
    this._status = InterpreterStatus.NotStarted;
    this.children = new Map();
    this.forwardTo = new Set();
    /**
     * Alias for Interpreter.prototype.start
     */

    this.init = this.start;
    /**
     * Sends an event to the running interpreter to trigger a transition.
     *
     * An array of events (batched) can be sent as well, which will send all
     * batched events to the running interpreter. The listeners will be
     * notified only **once** when all events are processed.
     *
     * @param event The event(s) to send
     */

    this.send = function (event, payload) {
      if (isArray$4(event)) {
        _this.batch(event);

        return _this.state;
      }

      var _event = toSCXMLEvent(toEventObject(event, payload));

      if (_this._status === InterpreterStatus.Stopped) {

        return _this.state;
      }

      if (_this._status === InterpreterStatus.NotStarted && _this.options.deferEvents) ; else if (_this._status !== InterpreterStatus.Running) {
        throw new Error("Event \"" + _event.name + "\" was sent to uninitialized service \"" + _this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.\nEvent: " + JSON.stringify(_event.data));
      }

      _this.scheduler.schedule(function () {
        // Forward copy of event to child actors
        _this.forward(_event);

        var nextState = _this.nextState(_event);

        _this.update(nextState, _event);
      });

      return _this._state; // TODO: deprecate (should return void)
      // tslint:disable-next-line:semicolon
    };

    this.sendTo = function (event, to) {
      var isParent = _this.parent && (to === SpecialTargets.Parent || _this.parent.id === to);
      var target = isParent ? _this.parent : isActor(to) ? to : _this.children.get(to) || registry.get(to);

      if (!target) {
        if (!isParent) {
          throw new Error("Unable to send event to child '" + to + "' from service '" + _this.id + "'.");
        } // tslint:disable-next-line:no-console

        return;
      }

      if ('machine' in target) {
        // Send SCXML events to machines
        target.send(__assign(__assign({}, event), {
          name: event.name === error$1 ? "" + error(_this.id) : event.name,
          origin: _this.sessionId
        }));
      } else {
        // Send normal events to other targets
        target.send(event.data);
      }
    };

    var resolvedOptions = __assign(__assign({}, Interpreter.defaultOptions), options);

    var clock = resolvedOptions.clock,
        logger = resolvedOptions.logger,
        parent = resolvedOptions.parent,
        id = resolvedOptions.id;
    var resolvedId = id !== undefined ? id : machine.id;
    this.id = resolvedId;
    this.logger = logger;
    this.clock = clock;
    this.parent = parent;
    this.options = resolvedOptions;
    this.scheduler = new Scheduler$1({
      deferEvents: this.options.deferEvents
    });
    this.sessionId = registry.bookId();
  }

  Object.defineProperty(Interpreter.prototype, "initialState", {
    get: function () {
      var _this = this;

      if (this._initialState) {
        return this._initialState;
      }

      return withServiceScope(this, function () {
        _this._initialState = _this.machine.initialState;
        return _this._initialState;
      });
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Interpreter.prototype, "state", {
    get: function () {

      return this._state;
    },
    enumerable: true,
    configurable: true
  });
  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   *
   * @param state The state whose actions will be executed
   * @param actionsConfig The action implementations to use
   */

  Interpreter.prototype.execute = function (state, actionsConfig) {
    var e_1, _a;

    try {
      for (var _b = __values(state.actions), _c = _b.next(); !_c.done; _c = _b.next()) {
        var action = _c.value;
        this.exec(action, state, actionsConfig);
      }
    } catch (e_1_1) {
      e_1 = {
        error: e_1_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  };

  Interpreter.prototype.update = function (state, _event) {
    var e_2, _a, e_3, _b, e_4, _c, e_5, _d;

    var _this = this; // Attach session ID to state


    state._sessionid = this.sessionId; // Update state

    this._state = state; // Execute actions

    if (this.options.execute) {
      this.execute(this.state);
    } // Dev tools


    if (this.devTools) {
      this.devTools.send(_event.data, state);
    } // Execute listeners


    if (state.event) {
      try {
        for (var _e = __values(this.eventListeners), _f = _e.next(); !_f.done; _f = _e.next()) {
          var listener = _f.value;
          listener(state.event);
        }
      } catch (e_2_1) {
        e_2 = {
          error: e_2_1
        };
      } finally {
        try {
          if (_f && !_f.done && (_a = _e.return)) _a.call(_e);
        } finally {
          if (e_2) throw e_2.error;
        }
      }
    }

    try {
      for (var _g = __values(this.listeners), _h = _g.next(); !_h.done; _h = _g.next()) {
        var listener = _h.value;
        listener(state, state.event);
      }
    } catch (e_3_1) {
      e_3 = {
        error: e_3_1
      };
    } finally {
      try {
        if (_h && !_h.done && (_b = _g.return)) _b.call(_g);
      } finally {
        if (e_3) throw e_3.error;
      }
    }

    try {
      for (var _j = __values(this.contextListeners), _k = _j.next(); !_k.done; _k = _j.next()) {
        var contextListener = _k.value;
        contextListener(this.state.context, this.state.history ? this.state.history.context : undefined);
      }
    } catch (e_4_1) {
      e_4 = {
        error: e_4_1
      };
    } finally {
      try {
        if (_k && !_k.done && (_c = _j.return)) _c.call(_j);
      } finally {
        if (e_4) throw e_4.error;
      }
    }

    var isDone = isInFinalState(state.configuration || [], this.machine);

    if (this.state.configuration && isDone) {
      // get final child state node
      var finalChildStateNode = state.configuration.find(function (sn) {
        return sn.type === 'final' && sn.parent === _this.machine;
      });
      var doneData = finalChildStateNode && finalChildStateNode.data ? mapContext(finalChildStateNode.data, state.context, _event) : undefined;

      try {
        for (var _l = __values(this.doneListeners), _m = _l.next(); !_m.done; _m = _l.next()) {
          var listener = _m.value;
          listener(doneInvoke(this.id, doneData));
        }
      } catch (e_5_1) {
        e_5 = {
          error: e_5_1
        };
      } finally {
        try {
          if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
        } finally {
          if (e_5) throw e_5.error;
        }
      }

      this.stop();
    }
  };
  /*
   * Adds a listener that is notified whenever a state transition happens. The listener is called with
   * the next state and the event object that caused the state transition.
   *
   * @param listener The state listener
   */


  Interpreter.prototype.onTransition = function (listener) {
    this.listeners.add(listener); // Send current state to listener

    if (this._status === InterpreterStatus.Running) {
      listener(this.state, this.state.event);
    }

    return this;
  };

  Interpreter.prototype.subscribe = function (nextListenerOrObserver, // @ts-ignore
  errorListener, completeListener) {
    var _this = this;

    if (!nextListenerOrObserver) {
      return {
        unsubscribe: function () {
          return void 0;
        }
      };
    }

    var listener;
    var resolvedCompleteListener = completeListener;

    if (typeof nextListenerOrObserver === 'function') {
      listener = nextListenerOrObserver;
    } else {
      listener = nextListenerOrObserver.next.bind(nextListenerOrObserver);
      resolvedCompleteListener = nextListenerOrObserver.complete.bind(nextListenerOrObserver);
    }

    this.listeners.add(listener); // Send current state to listener

    if (this._status === InterpreterStatus.Running) {
      listener(this.state);
    }

    if (resolvedCompleteListener) {
      this.onDone(resolvedCompleteListener);
    }

    return {
      unsubscribe: function () {
        listener && _this.listeners.delete(listener);
        resolvedCompleteListener && _this.doneListeners.delete(resolvedCompleteListener);
      }
    };
  };
  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */


  Interpreter.prototype.onEvent = function (listener) {
    this.eventListeners.add(listener);
    return this;
  };
  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */


  Interpreter.prototype.onSend = function (listener) {
    this.sendListeners.add(listener);
    return this;
  };
  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */


  Interpreter.prototype.onChange = function (listener) {
    this.contextListeners.add(listener);
    return this;
  };
  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */


  Interpreter.prototype.onStop = function (listener) {
    this.stopListeners.add(listener);
    return this;
  };
  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */


  Interpreter.prototype.onDone = function (listener) {
    this.doneListeners.add(listener);
    return this;
  };
  /**
   * Removes a listener.
   * @param listener The listener to remove
   */


  Interpreter.prototype.off = function (listener) {
    this.listeners.delete(listener);
    this.eventListeners.delete(listener);
    this.sendListeners.delete(listener);
    this.stopListeners.delete(listener);
    this.doneListeners.delete(listener);
    this.contextListeners.delete(listener);
    return this;
  };
  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */


  Interpreter.prototype.start = function (initialState) {
    var _this = this;

    if (this._status === InterpreterStatus.Running) {
      // Do not restart the service if it is already started
      return this;
    }

    registry.register(this.sessionId, this);
    this.initialized = true;
    this._status = InterpreterStatus.Running;
    var resolvedState = initialState === undefined ? this.initialState : withServiceScope(this, function () {
      return isState(initialState) ? _this.machine.resolveState(initialState) : _this.machine.resolveState(State.from(initialState, _this.machine.context));
    });

    if (this.options.devTools) {
      this.attachDev();
    }

    this.scheduler.initialize(function () {
      _this.update(resolvedState, initEvent);
    });
    return this;
  };
  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */


  Interpreter.prototype.stop = function () {
    var e_6, _a, e_7, _b, e_8, _c, e_9, _d, e_10, _e;

    try {
      for (var _f = __values(this.listeners), _g = _f.next(); !_g.done; _g = _f.next()) {
        var listener = _g.value;
        this.listeners.delete(listener);
      }
    } catch (e_6_1) {
      e_6 = {
        error: e_6_1
      };
    } finally {
      try {
        if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
      } finally {
        if (e_6) throw e_6.error;
      }
    }

    try {
      for (var _h = __values(this.stopListeners), _j = _h.next(); !_j.done; _j = _h.next()) {
        var listener = _j.value; // call listener, then remove

        listener();
        this.stopListeners.delete(listener);
      }
    } catch (e_7_1) {
      e_7 = {
        error: e_7_1
      };
    } finally {
      try {
        if (_j && !_j.done && (_b = _h.return)) _b.call(_h);
      } finally {
        if (e_7) throw e_7.error;
      }
    }

    try {
      for (var _k = __values(this.contextListeners), _l = _k.next(); !_l.done; _l = _k.next()) {
        var listener = _l.value;
        this.contextListeners.delete(listener);
      }
    } catch (e_8_1) {
      e_8 = {
        error: e_8_1
      };
    } finally {
      try {
        if (_l && !_l.done && (_c = _k.return)) _c.call(_k);
      } finally {
        if (e_8) throw e_8.error;
      }
    }

    try {
      for (var _m = __values(this.doneListeners), _o = _m.next(); !_o.done; _o = _m.next()) {
        var listener = _o.value;
        this.doneListeners.delete(listener);
      }
    } catch (e_9_1) {
      e_9 = {
        error: e_9_1
      };
    } finally {
      try {
        if (_o && !_o.done && (_d = _m.return)) _d.call(_m);
      } finally {
        if (e_9) throw e_9.error;
      }
    } // Stop all children


    this.children.forEach(function (child) {
      if (isFunction$4(child.stop)) {
        child.stop();
      }
    });

    try {
      // Cancel all delayed events
      for (var _p = __values(keys(this.delayedEventsMap)), _q = _p.next(); !_q.done; _q = _p.next()) {
        var key = _q.value;
        this.clock.clearTimeout(this.delayedEventsMap[key]);
      }
    } catch (e_10_1) {
      e_10 = {
        error: e_10_1
      };
    } finally {
      try {
        if (_q && !_q.done && (_e = _p.return)) _e.call(_p);
      } finally {
        if (e_10) throw e_10.error;
      }
    }

    this.scheduler.clear();
    this.initialized = false;
    this._status = InterpreterStatus.Stopped;
    registry.free(this.sessionId);
    return this;
  };

  Interpreter.prototype.batch = function (events) {
    var _this = this;

    if (this._status === InterpreterStatus.NotStarted && this.options.deferEvents) ; else if (this._status !== InterpreterStatus.Running) {
      throw new Error( // tslint:disable-next-line:max-line-length
      events.length + " event(s) were sent to uninitialized service \"" + this.machine.id + "\". Make sure .start() is called for this service, or set { deferEvents: true } in the service options.");
    }

    this.scheduler.schedule(function () {
      var e_11, _a;

      var nextState = _this.state;
      var batchChanged = false;
      var batchedActions = [];

      var _loop_1 = function (event_1) {
        var _event = toSCXMLEvent(event_1);

        _this.forward(_event);

        nextState = withServiceScope(_this, function () {
          return _this.machine.transition(nextState, _event);
        });
        batchedActions.push.apply(batchedActions, __spread(nextState.actions.map(function (a) {
          return bindActionToState(a, nextState);
        })));
        batchChanged = batchChanged || !!nextState.changed;
      };

      try {
        for (var events_1 = __values(events), events_1_1 = events_1.next(); !events_1_1.done; events_1_1 = events_1.next()) {
          var event_1 = events_1_1.value;

          _loop_1(event_1);
        }
      } catch (e_11_1) {
        e_11 = {
          error: e_11_1
        };
      } finally {
        try {
          if (events_1_1 && !events_1_1.done && (_a = events_1.return)) _a.call(events_1);
        } finally {
          if (e_11) throw e_11.error;
        }
      }

      nextState.changed = batchChanged;
      nextState.actions = batchedActions;

      _this.update(nextState, toSCXMLEvent(events[events.length - 1]));
    });
  };
  /**
   * Returns a send function bound to this interpreter instance.
   *
   * @param event The event to be sent by the sender.
   */


  Interpreter.prototype.sender = function (event) {
    return this.send.bind(this, event);
  };
  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   *
   * @param event The event to determine the next state
   */


  Interpreter.prototype.nextState = function (event) {
    var _this = this;

    var _event = toSCXMLEvent(event);

    if (_event.name.indexOf(errorPlatform) === 0 && !this.state.nextEvents.some(function (nextEvent) {
      return nextEvent.indexOf(errorPlatform) === 0;
    })) {
      throw _event.data.data;
    }

    var nextState = withServiceScope(this, function () {
      return _this.machine.transition(_this.state, _event);
    });
    return nextState;
  };

  Interpreter.prototype.forward = function (event) {
    var e_12, _a;

    try {
      for (var _b = __values(this.forwardTo), _c = _b.next(); !_c.done; _c = _b.next()) {
        var id = _c.value;
        var child = this.children.get(id);

        if (!child) {
          throw new Error("Unable to forward event '" + event + "' from interpreter '" + this.id + "' to nonexistant child '" + id + "'.");
        }

        child.send(event);
      }
    } catch (e_12_1) {
      e_12 = {
        error: e_12_1
      };
    } finally {
      try {
        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_12) throw e_12.error;
      }
    }
  };

  Interpreter.prototype.defer = function (sendAction) {
    var _this = this;

    this.delayedEventsMap[sendAction.id] = this.clock.setTimeout(function () {
      if (sendAction.to) {
        _this.sendTo(sendAction._event, sendAction.to);
      } else {
        _this.send(sendAction._event);
      }
    }, sendAction.delay);
  };

  Interpreter.prototype.cancel = function (sendId) {
    this.clock.clearTimeout(this.delayedEventsMap[sendId]);
    delete this.delayedEventsMap[sendId];
  };

  Interpreter.prototype.exec = function (action, state, actionFunctionMap) {
    var context = state.context,
        _event = state._event;
    var actionOrExec = getActionFunction(action.type, actionFunctionMap) || action.exec;
    var exec = isFunction$4(actionOrExec) ? actionOrExec : actionOrExec ? actionOrExec.exec : action.exec;

    if (exec) {
      try {
        return exec(context, _event.data, {
          action: action,
          state: this.state,
          _event: _event
        });
      } catch (err) {
        if (this.parent) {
          this.parent.send({
            type: 'xstate.error',
            data: err
          });
        }

        throw err;
      }
    }

    switch (action.type) {
      case send$1:
        var sendAction = action;

        if (typeof sendAction.delay === 'number') {
          this.defer(sendAction);
          return;
        } else {
          if (sendAction.to) {
            this.sendTo(sendAction._event, sendAction.to);
          } else {
            this.send(sendAction._event);
          }
        }

        break;

      case cancel$1:
        this.cancel(action.sendId);
        break;

      case start$1:
        {
          var activity = action.activity; // If the activity will be stopped right after it's started
          // (such as in transient states)
          // don't bother starting the activity.

          if (!this.state.activities[activity.type]) {
            break;
          } // Invoked services


          if (activity.type === ActionTypes$1.Invoke) {
            var serviceCreator = this.machine.options.services ? this.machine.options.services[activity.src] : undefined;
            var id = activity.id,
                data = activity.data;

            var autoForward = 'autoForward' in activity ? activity.autoForward : !!activity.forward;

            if (!serviceCreator) {

              return;
            }

            var source = isFunction$4(serviceCreator) ? serviceCreator(context, _event.data) : serviceCreator;

            if (isPromiseLike(source)) {
              this.state.children[id] = this.spawnPromise(Promise.resolve(source), id);
            } else if (isFunction$4(source)) {
              this.state.children[id] = this.spawnCallback(source, id);
            } else if (isObservable$1(source)) {
              this.state.children[id] = this.spawnObservable(source, id);
            } else if (isMachine(source)) {
              // TODO: try/catch here
              this.state.children[id] = this.spawnMachine(data ? source.withContext(mapContext(data, context, _event)) : source, {
                id: id,
                autoForward: autoForward
              });
            }
          } else {
            this.spawnActivity(activity);
          }

          break;
        }

      case stop$1:
        {
          this.stopChild(action.activity.id);
          break;
        }

      case log:
        var label = action.label,
            value = action.value;

        if (label) {
          this.logger(label, value);
        } else {
          this.logger(value);
        }

        break;
    }

    return undefined;
  };

  Interpreter.prototype.stopChild = function (childId) {
    var child = this.children.get(childId);

    if (!child) {
      return;
    }

    this.children.delete(childId);
    this.forwardTo.delete(childId);
    delete this.state.children[childId];

    if (isFunction$4(child.stop)) {
      child.stop();
    }
  };

  Interpreter.prototype.spawn = function (entity, name, options) {
    if (isPromiseLike(entity)) {
      return this.spawnPromise(Promise.resolve(entity), name);
    } else if (isFunction$4(entity)) {
      return this.spawnCallback(entity, name);
    } else if (isActor(entity)) {
      return this.spawnActor(entity);
    } else if (isObservable$1(entity)) {
      return this.spawnObservable(entity, name);
    } else if (isMachine(entity)) {
      return this.spawnMachine(entity, __assign(__assign({}, options), {
        id: name
      }));
    } else {
      throw new Error("Unable to spawn entity \"" + name + "\" of type \"" + typeof entity + "\".");
    }
  };

  Interpreter.prototype.spawnMachine = function (machine, options) {
    var _this = this;

    if (options === void 0) {
      options = {};
    }

    var childService = new Interpreter(machine, __assign(__assign({}, this.options), {
      parent: this,
      id: options.id || machine.id
    }));

    var resolvedOptions = __assign(__assign({}, DEFAULT_SPAWN_OPTIONS), options);

    if (resolvedOptions.sync) {
      childService.onTransition(function (state) {
        _this.send(update, {
          state: state,
          id: childService.id
        });
      });
    }

    childService.onDone(function (doneEvent) {
      _this.send(toSCXMLEvent(doneEvent, {
        origin: childService.id
      }));
    }).start();
    var actor = childService;
    this.children.set(childService.id, actor);

    if (resolvedOptions.autoForward) {
      this.forwardTo.add(childService.id);
    }

    return actor;
  };

  Interpreter.prototype.spawnPromise = function (promise, id) {
    var _this = this;

    var canceled = false;
    promise.then(function (response) {
      if (!canceled) {
        _this.send(toSCXMLEvent(doneInvoke(id, response), {
          origin: id
        }));
      }
    }, function (errorData) {
      if (!canceled) {
        var errorEvent = error(id, errorData);

        try {
          // Send "error.platform.id" to this (parent).
          _this.send(toSCXMLEvent(errorEvent, {
            origin: id
          }));
        } catch (error) {

          if (_this.devTools) {
            _this.devTools.send(errorEvent, _this.state);
          }

          if (_this.machine.strict) {
            // it would be better to always stop the state machine if unhandled
            // exception/promise rejection happens but because we don't want to
            // break existing code so enforce it on strict mode only especially so
            // because documentation says that onError is optional
            _this.stop();
          }
        }
      }
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        var unsubscribed = false;
        promise.then(function (response) {
          if (unsubscribed) {
            return;
          }

          next && next(response);

          if (unsubscribed) {
            return;
          }

          complete && complete();
        }, function (err) {
          if (unsubscribed) {
            return;
          }

          handleError(err);
        });
        return {
          unsubscribe: function () {
            return unsubscribed = true;
          }
        };
      },
      stop: function () {
        canceled = true;
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnCallback = function (callback, id) {
    var _this = this;

    var canceled = false;
    var receivers = new Set();
    var listeners = new Set();

    var receive = function (e) {
      listeners.forEach(function (listener) {
        return listener(e);
      });

      if (canceled) {
        return;
      }

      _this.send(e);
    };

    var callbackStop;

    try {
      callbackStop = callback(receive, function (newListener) {
        receivers.add(newListener);
      });
    } catch (err) {
      this.send(error(id, err));
    }

    if (isPromiseLike(callbackStop)) {
      // it turned out to be an async function, can't reliably check this before calling `callback`
      // because transpiled async functions are not recognizable
      return this.spawnPromise(callbackStop, id);
    }

    var actor = {
      id: id,
      send: function (event) {
        return receivers.forEach(function (receiver) {
          return receiver(event);
        });
      },
      subscribe: function (next) {
        listeners.add(next);
        return {
          unsubscribe: function () {
            listeners.delete(next);
          }
        };
      },
      stop: function () {
        canceled = true;

        if (isFunction$4(callbackStop)) {
          callbackStop();
        }
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnObservable = function (source, id) {
    var _this = this;

    var subscription = source.subscribe(function (value) {
      _this.send(toSCXMLEvent(value, {
        origin: id
      }));
    }, function (err) {
      _this.send(toSCXMLEvent(error(id, err), {
        origin: id
      }));
    }, function () {
      _this.send(toSCXMLEvent(doneInvoke(id), {
        origin: id
      }));
    });
    var actor = {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function (next, handleError, complete) {
        return source.subscribe(next, handleError, complete);
      },
      stop: function () {
        return subscription.unsubscribe();
      },
      toJSON: function () {
        return {
          id: id
        };
      }
    };
    this.children.set(id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActor = function (actor) {
    this.children.set(actor.id, actor);
    return actor;
  };

  Interpreter.prototype.spawnActivity = function (activity) {
    var implementation = this.machine.options && this.machine.options.activities ? this.machine.options.activities[activity.type] : undefined;

    if (!implementation) {


      return;
    } // Start implementation


    var dispose = implementation(this.state.context, activity);
    this.spawnEffect(activity.id, dispose);
  };

  Interpreter.prototype.spawnEffect = function (id, dispose) {
    this.children.set(id, {
      id: id,
      send: function () {
        return void 0;
      },
      subscribe: function () {
        return {
          unsubscribe: function () {
            return void 0;
          }
        };
      },
      stop: dispose || undefined,
      toJSON: function () {
        return {
          id: id
        };
      }
    });
  };

  Interpreter.prototype.attachDev = function () {
    if (this.options.devTools && typeof window !== 'undefined') {
      if (window.__REDUX_DEVTOOLS_EXTENSION__) {
        var devToolsOptions = typeof this.options.devTools === 'object' ? this.options.devTools : undefined;
        this.devTools = window.__REDUX_DEVTOOLS_EXTENSION__.connect(__assign(__assign({
          name: this.id,
          autoPause: true,
          stateSanitizer: function (state) {
            return {
              value: state.value,
              context: state.context,
              actions: state.actions
            };
          }
        }, devToolsOptions), {
          features: __assign({
            jump: false,
            skip: false
          }, devToolsOptions ? devToolsOptions.features : undefined)
        }), this.machine);
        this.devTools.init(this.state);
      } // add XState-specific dev tooling hook
    }
  };

  Interpreter.prototype.toJSON = function () {
    return {
      id: this.id
    };
  };

  Interpreter.prototype[symbolObservable] = function () {
    return this;
  };
  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */


  Interpreter.defaultOptions =
  /*#__PURE__*/
  function (global) {
    return {
      execute: true,
      deferEvents: true,
      clock: {
        setTimeout: function (fn, ms) {
          return global.setTimeout.call(null, fn, ms);
        },
        clearTimeout: function (id) {
          return global.clearTimeout.call(null, id);
        }
      },
      logger: global.console.log.bind(console),
      devTools: false
    };
  }(typeof window === 'undefined' ? __webpack_require__.g : window);

  Interpreter.interpret = interpret;
  return Interpreter;
}();
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 *
 * @param machine The machine to interpret
 * @param options Interpreter options
 */


function interpret(machine, options) {
  var interpreter = new Interpreter(machine, options);
  return interpreter;
}// threejs.org/license
const REVISION = '126';
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
const CullFaceNone = 0;
const CullFaceBack = 1;
const CullFaceFront = 2;
const CullFaceFrontBack = 3;
const BasicShadowMap = 0;
const PCFShadowMap = 1;
const PCFSoftShadowMap = 2;
const VSMShadowMap = 3;
const FrontSide = 0;
const BackSide = 1;
const DoubleSide = 2;
const FlatShading = 1;
const SmoothShading = 2;
const NoBlending = 0;
const NormalBlending = 1;
const AdditiveBlending = 2;
const SubtractiveBlending = 3;
const MultiplyBlending = 4;
const CustomBlending = 5;
const AddEquation = 100;
const SubtractEquation = 101;
const ReverseSubtractEquation = 102;
const MinEquation = 103;
const MaxEquation = 104;
const ZeroFactor = 200;
const OneFactor = 201;
const SrcColorFactor = 202;
const OneMinusSrcColorFactor = 203;
const SrcAlphaFactor = 204;
const OneMinusSrcAlphaFactor = 205;
const DstAlphaFactor = 206;
const OneMinusDstAlphaFactor = 207;
const DstColorFactor = 208;
const OneMinusDstColorFactor = 209;
const SrcAlphaSaturateFactor = 210;
const NeverDepth = 0;
const AlwaysDepth = 1;
const LessDepth = 2;
const LessEqualDepth = 3;
const EqualDepth = 4;
const GreaterEqualDepth = 5;
const GreaterDepth = 6;
const NotEqualDepth = 7;
const MultiplyOperation = 0;
const MixOperation = 1;
const AddOperation = 2;
const NoToneMapping = 0;
const LinearToneMapping = 1;
const ReinhardToneMapping = 2;
const CineonToneMapping = 3;
const ACESFilmicToneMapping = 4;
const CustomToneMapping = 5;

const UVMapping = 300;
const CubeReflectionMapping = 301;
const CubeRefractionMapping = 302;
const EquirectangularReflectionMapping = 303;
const EquirectangularRefractionMapping = 304;
const CubeUVReflectionMapping = 306;
const CubeUVRefractionMapping = 307;
const RepeatWrapping$1 = 1000;
const ClampToEdgeWrapping = 1001;
const MirroredRepeatWrapping = 1002;
const NearestFilter = 1003;
const NearestMipmapNearestFilter = 1004;
const NearestMipMapNearestFilter = 1004;
const NearestMipmapLinearFilter = 1005;
const NearestMipMapLinearFilter = 1005;
const LinearFilter = 1006;
const LinearMipmapNearestFilter = 1007;
const LinearMipMapNearestFilter = 1007;
const LinearMipmapLinearFilter = 1008;
const LinearMipMapLinearFilter = 1008;
const UnsignedByteType = 1009;
const ByteType = 1010;
const ShortType = 1011;
const UnsignedShortType = 1012;
const IntType = 1013;
const UnsignedIntType = 1014;
const FloatType$1 = 1015;
const HalfFloatType = 1016;
const UnsignedShort4444Type = 1017;
const UnsignedShort5551Type = 1018;
const UnsignedShort565Type = 1019;
const UnsignedInt248Type = 1020;
const AlphaFormat = 1021;
const RGBFormat = 1022;
const RGBAFormat = 1023;
const LuminanceFormat = 1024;
const LuminanceAlphaFormat = 1025;
const RGBEFormat = RGBAFormat;
const DepthFormat = 1026;
const DepthStencilFormat = 1027;
const RedFormat = 1028;
const RedIntegerFormat = 1029;
const RGFormat = 1030;
const RGIntegerFormat = 1031;
const RGBIntegerFormat = 1032;
const RGBAIntegerFormat = 1033;

const RGB_S3TC_DXT1_Format = 33776;
const RGBA_S3TC_DXT1_Format = 33777;
const RGBA_S3TC_DXT3_Format = 33778;
const RGBA_S3TC_DXT5_Format = 33779;
const RGB_PVRTC_4BPPV1_Format = 35840;
const RGB_PVRTC_2BPPV1_Format = 35841;
const RGBA_PVRTC_4BPPV1_Format = 35842;
const RGBA_PVRTC_2BPPV1_Format = 35843;
const RGB_ETC1_Format = 36196;
const RGB_ETC2_Format = 37492;
const RGBA_ETC2_EAC_Format = 37496;
const RGBA_ASTC_4x4_Format = 37808;
const RGBA_ASTC_5x4_Format = 37809;
const RGBA_ASTC_5x5_Format = 37810;
const RGBA_ASTC_6x5_Format = 37811;
const RGBA_ASTC_6x6_Format = 37812;
const RGBA_ASTC_8x5_Format = 37813;
const RGBA_ASTC_8x6_Format = 37814;
const RGBA_ASTC_8x8_Format = 37815;
const RGBA_ASTC_10x5_Format = 37816;
const RGBA_ASTC_10x6_Format = 37817;
const RGBA_ASTC_10x8_Format = 37818;
const RGBA_ASTC_10x10_Format = 37819;
const RGBA_ASTC_12x10_Format = 37820;
const RGBA_ASTC_12x12_Format = 37821;
const RGBA_BPTC_Format = 36492;
const SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
const SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
const SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
const SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
const SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
const SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
const SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
const SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
const SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
const SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
const SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
const SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
const SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
const SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
const LoopOnce = 2200;
const LoopRepeat = 2201;
const LoopPingPong = 2202;
const InterpolateDiscrete = 2300;
const InterpolateLinear = 2301;
const InterpolateSmooth = 2302;
const ZeroCurvatureEnding = 2400;
const ZeroSlopeEnding = 2401;
const WrapAroundEnding = 2402;
const NormalAnimationBlendMode = 2500;
const AdditiveAnimationBlendMode = 2501;
const TrianglesDrawMode = 0;
const TriangleStripDrawMode = 1;
const TriangleFanDrawMode = 2;
const LinearEncoding = 3000;
const sRGBEncoding = 3001;
const GammaEncoding = 3007;
const RGBEEncoding = 3002;
const LogLuvEncoding = 3003;
const RGBM7Encoding = 3004;
const RGBM16Encoding = 3005;
const RGBDEncoding = 3006;
const BasicDepthPacking = 3200;
const RGBADepthPacking = 3201;
const TangentSpaceNormalMap = 0;
const ObjectSpaceNormalMap = 1;

const ZeroStencilOp = 0;
const KeepStencilOp = 7680;
const ReplaceStencilOp = 7681;
const IncrementStencilOp = 7682;
const DecrementStencilOp = 7683;
const IncrementWrapStencilOp = 34055;
const DecrementWrapStencilOp = 34056;
const InvertStencilOp = 5386;

const NeverStencilFunc = 512;
const LessStencilFunc = 513;
const EqualStencilFunc = 514;
const LessEqualStencilFunc = 515;
const GreaterStencilFunc = 516;
const NotEqualStencilFunc = 517;
const GreaterEqualStencilFunc = 518;
const AlwaysStencilFunc = 519;

const StaticDrawUsage = 35044;
const DynamicDrawUsage = 35048;
const StreamDrawUsage = 35040;
const StaticReadUsage = 35045;
const DynamicReadUsage = 35049;
const StreamReadUsage = 35041;
const StaticCopyUsage = 35046;
const DynamicCopyUsage = 35050;
const StreamCopyUsage = 35042;

const GLSL1 = '100';
const GLSL3 = '300 es';

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		const listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		const listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			const index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		const listeners = this._listeners;
		const listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			// Make a copy, in case listeners are removed while iterating.
			const array = listenerArray.slice( 0 );

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

const _lut = [];

for ( let i = 0; i < 256; i ++ ) {

	_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

}

let _seed = 1234567;

const MathUtils = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

		const d0 = Math.random() * 0xffffffff | 0;
		const d1 = Math.random() * 0xffffffff | 0;
		const d2 = Math.random() * 0xffffffff | 0;
		const d3 = Math.random() * 0xffffffff | 0;
		const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

		// .toUpperCase() here flattens concatenated strings to save heap memory space.
		return uuid.toUpperCase();

	},

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/

	damp: function ( x, y, lambda, dt ) {

		return MathUtils.lerp( x, y, 1 - Math.exp( - lambda * dt ) );

	},

	// https://www.desmos.com/calculator/vcsjnyz7x4

	pingpong: function ( x, length = 1 ) {

		return length - Math.abs( MathUtils.euclideanModulo( x, length * 2 ) - length );

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	// Deterministic pseudo-random float in the interval [ 0, 1 ]

	seededRandom: function ( s ) {

		if ( s !== undefined ) _seed = s % 2147483647;

		// Park-Miller algorithm

		_seed = _seed * 16807 % 2147483647;

		return ( _seed - 1 ) / 2147483646;

	},

	degToRad: function ( degrees ) {

		return degrees * MathUtils.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * MathUtils.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	ceilPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

	},

	floorPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

	},

	setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

		// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

		// rotations are applied to the axes in the order specified by 'order'
		// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
		// angles are in radians

		const cos = Math.cos;
		const sin = Math.sin;

		const c2 = cos( b / 2 );
		const s2 = sin( b / 2 );

		const c13 = cos( ( a + c ) / 2 );
		const s13 = sin( ( a + c ) / 2 );

		const c1_3 = cos( ( a - c ) / 2 );
		const s1_3 = sin( ( a - c ) / 2 );

		const c3_1 = cos( ( c - a ) / 2 );
		const s3_1 = sin( ( c - a ) / 2 );

		switch ( order ) {

			case 'XYX':
				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );
				break;

			case 'YZY':
				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );
				break;

			case 'ZXZ':
				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );
				break;

			case 'XZX':
				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );
				break;

			case 'YXY':
				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );
				break;

			case 'ZYZ':
				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );
				break;

			default:
				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order );

		}

	}

};

class Vector2 {

	constructor( x = 0, y = 0 ) {

		this.x = x;
		this.y = y;

	}

	get width() {

		return this.x;

	}

	set width( value ) {

		this.x = value;

	}

	get height() {

		return this.y;

	}

	set height( value ) {

		this.y = value;

	}

	set( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;

		return this;

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y;

	}

	cross( v ) {

		return this.x * v.y - this.y * v.x;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	angle() {

		// computes the angle in radians with respect to the positive x-axis

		const angle = Math.atan2( - this.y, - this.x ) + Math.PI;

		return angle;

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	}

	rotateAround( center, angle ) {

		const c = Math.cos( angle ), s = Math.sin( angle );

		const x = this.x - center.x;
		const y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();

		return this;

	}

}

Vector2.prototype.isVector2 = true;

class Matrix3 {

	constructor() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
		te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
		te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrix3Column( this, 0 );
		yAxis.setFromMatrix3Column( this, 1 );
		zAxis.setFromMatrix3Column( this, 2 );

		return this;

	}

	setFromMatrix4( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[ 8 ],
			me[ 1 ], me[ 5 ], me[ 9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	}

	multiply( m ) {

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
		const a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
		const a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

		const b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
		const b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
		const b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
		te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
		te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
		te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
		te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
		te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
		te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	}

	invert() {

		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ],
			n12 = te[ 3 ], n22 = te[ 4 ], n32 = te[ 5 ],
			n13 = te[ 6 ], n23 = te[ 7 ], n33 = te[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	}

	transpose() {

		let tmp;
		const m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	}

	getNormalMatrix( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).invert().transpose();

	}

	transposeIntoArray( r ) {

		const m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	}

	setUvTransform( tx, ty, sx, sy, rotation, cx, cy ) {

		const c = Math.cos( rotation );
		const s = Math.sin( rotation );

		this.set(
			sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
			- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
			0, 0, 1
		);

		return this;

	}

	scale( sx, sy ) {

		const te = this.elements;

		te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
		te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

		return this;

	}

	rotate( theta ) {

		const c = Math.cos( theta );
		const s = Math.sin( theta );

		const te = this.elements;

		const a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
		const a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

		te[ 0 ] = c * a11 + s * a21;
		te[ 3 ] = c * a12 + s * a22;
		te[ 6 ] = c * a13 + s * a23;

		te[ 1 ] = - s * a11 + c * a21;
		te[ 4 ] = - s * a12 + c * a22;
		te[ 7 ] = - s * a13 + c * a23;

		return this;

	}

	translate( tx, ty ) {

		const te = this.elements;

		te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
		te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 9; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ] = te[ 8 ];

		return array;

	}

	clone() {

		return new this.constructor().fromArray( this.elements );

	}

}

Matrix3.prototype.isMatrix3 = true;

let _canvas;

const ImageUtils = {

	getDataURL: function ( image ) {

		if ( /^data:/i.test( image.src ) ) {

			return image.src;

		}

		if ( typeof HTMLCanvasElement == 'undefined' ) {

			return image.src;

		}

		let canvas;

		if ( image instanceof HTMLCanvasElement ) {

			canvas = image;

		} else {

			if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

			_canvas.width = image.width;
			_canvas.height = image.height;

			const context = _canvas.getContext( '2d' );

			if ( image instanceof ImageData ) {

				context.putImageData( image, 0, 0 );

			} else {

				context.drawImage( image, 0, 0, image.width, image.height );

			}

			canvas = _canvas;

		}

		if ( canvas.width > 2048 || canvas.height > 2048 ) {

			return canvas.toDataURL( 'image/jpeg', 0.6 );

		} else {

			return canvas.toDataURL( 'image/png' );

		}

	}

};

let textureId = 0;

class Texture extends EventDispatcher {

	constructor( image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = 1, encoding = LinearEncoding ) {

		super();

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';

		this.image = image;
		this.mipmaps = [];

		this.mapping = mapping;

		this.wrapS = wrapS;
		this.wrapT = wrapT;

		this.magFilter = magFilter;
		this.minFilter = minFilter;

		this.anisotropy = anisotropy;

		this.format = format;
		this.internalFormat = null;
		this.type = type;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding;

		this.version = 0;
		this.onUpdate = null;

	}

	updateMatrix() {

		this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.name = source.name;

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.internalFormat = source.internalFormat;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );
		this.center.copy( source.center );
		this.rotation = source.rotation;

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrix.copy( source.matrix );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	}

	toJSON( meta ) {

		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		const output = {

			metadata: {
				version: 4.5,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			center: [ this.center.x, this.center.y ],
			rotation: this.rotation,

			wrap: [ this.wrapS, this.wrapT ],

			format: this.format,
			type: this.type,
			encoding: this.encoding,

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY,

			premultiplyAlpha: this.premultiplyAlpha,
			unpackAlignment: this.unpackAlignment

		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			const image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = MathUtils.generateUUID(); // UGH

			}

			if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

				let url;

				if ( Array.isArray( image ) ) {

					// process array of images e.g. CubeTexture

					url = [];

					for ( let i = 0, l = image.length; i < l; i ++ ) {

						// check cube texture with data textures

						if ( image[ i ].isDataTexture ) {

							url.push( serializeImage( image[ i ].image ) );

						} else {

							url.push( serializeImage( image[ i ] ) );

						}

					}

				} else {

					// process single image

					url = serializeImage( image );

				}

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: url
				};

			}

			output.image = image.uuid;

		}

		if ( ! isRootObject ) {

			meta.textures[ this.uuid ] = output;

		}

		return output;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

	transformUv( uv ) {

		if ( this.mapping !== UVMapping ) return uv;

		uv.applyMatrix3( this.matrix );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping$1:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}

					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping$1:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}

					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

		return uv;

	}

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	}

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype.isTexture = true;

function serializeImage( image ) {

	if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
		( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
		( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

		// default images

		return ImageUtils.getDataURL( image );

	} else {

		if ( image.data ) {

			// images of DataTexture

			return {
				data: Array.prototype.slice.call( image.data ),
				width: image.width,
				height: image.height,
				type: image.data.constructor.name
			};

		} else {

			console.warn( 'THREE.Texture: Unable to serialize Texture.' );
			return {};

		}

	}

}

class Vector4 {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

	}

	get width() {

		return this.z;

	}

	set width( value ) {

		this.z = value;

	}

	get height() {

		return this.w;

	}

	set height( value ) {

		this.w = value;

	}

	set( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setW( w ) {

		this.w = w;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z, this.w );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	}

	multiply( v ) {

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;
		this.w *= v.w;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;
		this.w *= scalar;

		return this;

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z, w = this.w;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	setAxisAngleFromQuaternion( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		const s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			this.x = 1;
			this.y = 0;
			this.z = 0;

		} else {

			this.x = q.x / s;
			this.y = q.y / s;
			this.z = q.z / s;

		}

		return this;

	}

	setAxisAngleFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		let angle, x, y, z; // variables for result
		const epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			const xx = ( m11 + 1 ) / 2;
			const yy = ( m22 + 1 ) / 2;
			const zz = ( m33 + 1 ) / 2;
			const xy = ( m12 + m21 ) / 4;
			const xz = ( m13 + m31 ) / 4;
			const yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		let s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			( m13 - m31 ) * ( m13 - m31 ) +
			( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
		this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	}

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;
		this.w = v1.w + ( v2.w - v1.w ) * alpha;

		return this;

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();
		this.w = Math.random();

		return this;

	}

}

Vector4.prototype.isVector4 = true;

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
class WebGLRenderTarget extends EventDispatcher {

	constructor( width, height, options ) {

		super();

		this.width = width;
		this.height = height;
		this.depth = 1;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.image = {};
		this.texture.image.width = width;
		this.texture.image.height = height;
		this.texture.image.depth = 1;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : false;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	setTexture( texture ) {

		texture.image = {
			width: this.width,
			height: this.height,
			depth: this.depth
		};

		this.texture = texture;

	}

	setSize( width, height, depth = 1 ) {

		if ( this.width !== width || this.height !== height || this.depth !== depth ) {

			this.width = width;
			this.height = height;
			this.depth = depth;

			this.texture.image.width = width;
			this.texture.image.height = height;
			this.texture.image.depth = depth;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( source ) {

		this.width = source.width;
		this.height = source.height;
		this.depth = source.depth;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	}

	dispose() {

		this.dispatchEvent( { type: 'dispose' } );

	}

}

WebGLRenderTarget.prototype.isWebGLRenderTarget = true;

class WebGLMultisampleRenderTarget extends WebGLRenderTarget {

	constructor( width, height, options ) {

		super( width, height, options );

		this.samples = 4;

	}

	copy( source ) {

		super.copy.call( this, source );

		this.samples = source.samples;

		return this;

	}

}

WebGLMultisampleRenderTarget.prototype.isWebGLMultisampleRenderTarget = true;

class Quaternion {

	constructor( x = 0, y = 0, z = 0, w = 1 ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

	}

	static slerp( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	}

	static slerpFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		let x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( t === 0 ) {

			dst[ dstOffset + 0 ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
			return;

		}

		if ( t === 1 ) {

			dst[ dstOffset + 0 ] = x1;
			dst[ dstOffset + 1 ] = y1;
			dst[ dstOffset + 2 ] = z1;
			dst[ dstOffset + 3 ] = w1;
			return;

		}

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			let s = 1 - t;
			const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				const sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			const tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				const f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

	static multiplyQuaternionsFlat( dst, dstOffset, src0, srcOffset0, src1, srcOffset1 ) {

		const x0 = src0[ srcOffset0 ];
		const y0 = src0[ srcOffset0 + 1 ];
		const z0 = src0[ srcOffset0 + 2 ];
		const w0 = src0[ srcOffset0 + 3 ];

		const x1 = src1[ srcOffset1 ];
		const y1 = src1[ srcOffset1 + 1 ];
		const z1 = src1[ srcOffset1 + 2 ];
		const w1 = src1[ srcOffset1 + 3 ];

		dst[ dstOffset ] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
		dst[ dstOffset + 1 ] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
		dst[ dstOffset + 2 ] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
		dst[ dstOffset + 3 ] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;

		return dst;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get w() {

		return this._w;

	}

	set w( value ) {

		this._w = value;
		this._onChangeCallback();

	}

	set( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._w );

	}

	copy( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this._onChangeCallback();

		return this;

	}

	setFromEuler( euler, update ) {

		if ( ! ( euler && euler.isEuler ) ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		const x = euler._x, y = euler._y, z = euler._z, order = euler._order;

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		const cos = Math.cos;
		const sin = Math.sin;

		const c1 = cos( x / 2 );
		const c2 = cos( y / 2 );
		const c3 = cos( z / 2 );

		const s1 = sin( x / 2 );
		const s2 = sin( y / 2 );
		const s3 = sin( z / 2 );

		switch ( order ) {

			case 'XYZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'YXZ':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'ZXY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'ZYX':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			case 'YZX':
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
				break;

			case 'XZY':
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
				break;

			default:
				console.warn( 'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order );

		}

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromAxisAngle( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		const halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33;

		if ( trace > 0 ) {

			const s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			const s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			const s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this._onChangeCallback();

		return this;

	}

	setFromUnitVectors( vFrom, vTo ) {

		// assumes direction vectors vFrom and vTo are normalized

		const EPS = 0.000001;

		let r = vFrom.dot( vTo ) + 1;

		if ( r < EPS ) {

			r = 0;

			if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

				this._x = - vFrom.y;
				this._y = vFrom.x;
				this._z = 0;
				this._w = r;

			} else {

				this._x = 0;
				this._y = - vFrom.z;
				this._z = vFrom.y;
				this._w = r;

			}

		} else {

			// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

			this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
			this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
			this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
			this._w = r;

		}

		return this.normalize();

	}

	angleTo( q ) {

		return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

	}

	rotateTowards( q, step ) {

		const angle = this.angleTo( q );

		if ( angle === 0 ) return this;

		const t = Math.min( 1, step / angle );

		this.slerp( q, t );

		return this;

	}

	identity() {

		return this.set( 0, 0, 0, 1 );

	}

	invert() {

		// quaternion is assumed to have unit length

		return this.conjugate();

	}

	conjugate() {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this._onChangeCallback();

		return this;

	}

	dot( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	}

	lengthSq() {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	}

	length() {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	}

	normalize() {

		let l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this._onChangeCallback();

		return this;

	}

	multiply( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	}

	premultiply( q ) {

		return this.multiplyQuaternions( q, this );

	}

	multiplyQuaternions( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this._onChangeCallback();

		return this;

	}

	slerp( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		const x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		const sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

		if ( sqrSinHalfTheta <= Number.EPSILON ) {

			const s = 1 - t;
			this._w = s * w + t * this._w;
			this._x = s * x + t * this._x;
			this._y = s * y + t * this._y;
			this._z = s * z + t * this._z;

			this.normalize();
			this._onChangeCallback();

			return this;

		}

		const sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
		const halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		const ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
			ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this._onChangeCallback();

		return this;

	}

	equals( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	}

	fromArray( array, offset = 0 ) {

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this._x = attribute.getX( index );
		this._y = attribute.getY( index );
		this._z = attribute.getZ( index );
		this._w = attribute.getW( index );

		return this;

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Quaternion.prototype.isQuaternion = true;

class Vector3$1 {

	constructor( x = 0, y = 0, z = 0 ) {

		this.x = x;
		this.y = y;
		this.z = z;

	}

	set( x, y, z ) {

		if ( z === undefined ) z = this.z; // sprite.scale.set(x,y)

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	}

	setScalar( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	}

	setX( x ) {

		this.x = x;

		return this;

	}

	setY( y ) {

		this.y = y;

		return this;

	}

	setZ( z ) {

		this.z = z;

		return this;

	}

	setComponent( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	}

	getComponent( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	}

	clone() {

		return new this.constructor( this.x, this.y, this.z );

	}

	copy( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	}

	add( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	}

	addScalar( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	}

	addVectors( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	}

	addScaledVector( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	}

	sub( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	}

	subScalar( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	}

	subVectors( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	}

	multiply( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	}

	multiplyScalar( scalar ) {

		this.x *= scalar;
		this.y *= scalar;
		this.z *= scalar;

		return this;

	}

	multiplyVectors( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	}

	applyEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

	}

	applyAxisAngle( axis, angle ) {

		return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

	}

	applyMatrix3( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	}

	applyNormalMatrix( m ) {

		return this.applyMatrix3( m ).normalize();

	}

	applyMatrix4( m ) {

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		const w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

		return this;

	}

	applyQuaternion( q ) {

		const x = this.x, y = this.y, z = this.z;
		const qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		const ix = qw * x + qy * z - qz * y;
		const iy = qw * y + qz * x - qx * z;
		const iz = qw * z + qx * y - qy * x;
		const iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	}

	project( camera ) {

		return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

	}

	unproject( camera ) {

		return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

	}

	transformDirection( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		const x = this.x, y = this.y, z = this.z;
		const e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	}

	divide( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	}

	divideScalar( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	}

	min( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	}

	max( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	}

	clamp( min, max ) {

		// assumes min < max, componentwise

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	}

	clampScalar( minVal, maxVal ) {

		this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
		this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
		this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

		return this;

	}

	clampLength( min, max ) {

		const length = this.length();

		return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

	}

	floor() {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	}

	ceil() {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	}

	round() {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	}

	roundToZero() {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	}

	negate() {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	}

	dot( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	}

	// TODO lengthSquared?

	lengthSq() {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	}

	length() {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	}

	manhattanLength() {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	}

	normalize() {

		return this.divideScalar( this.length() || 1 );

	}

	setLength( length ) {

		return this.normalize().multiplyScalar( length );

	}

	lerp( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	}

	lerpVectors( v1, v2, alpha ) {

		this.x = v1.x + ( v2.x - v1.x ) * alpha;
		this.y = v1.y + ( v2.y - v1.y ) * alpha;
		this.z = v1.z + ( v2.z - v1.z ) * alpha;

		return this;

	}

	cross( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		return this.crossVectors( this, v );

	}

	crossVectors( a, b ) {

		const ax = a.x, ay = a.y, az = a.z;
		const bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	}

	projectOnVector( v ) {

		const denominator = v.lengthSq();

		if ( denominator === 0 ) return this.set( 0, 0, 0 );

		const scalar = v.dot( this ) / denominator;

		return this.copy( v ).multiplyScalar( scalar );

	}

	projectOnPlane( planeNormal ) {

		_vector.copy( this ).projectOnVector( planeNormal );

		return this.sub( _vector );

	}

	reflect( normal ) {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

	}

	angleTo( v ) {

		const denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

		if ( denominator === 0 ) return Math.PI / 2;

		const theta = this.dot( v ) / denominator;

		// clamp, to handle numerical problems

		return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

	}

	distanceTo( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	}

	distanceToSquared( v ) {

		const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	}

	manhattanDistanceTo( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	}

	setFromSpherical( s ) {

		return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

	}

	setFromSphericalCoords( radius, phi, theta ) {

		const sinPhiRadius = Math.sin( phi ) * radius;

		this.x = sinPhiRadius * Math.sin( theta );
		this.y = Math.cos( phi ) * radius;
		this.z = sinPhiRadius * Math.cos( theta );

		return this;

	}

	setFromCylindrical( c ) {

		return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

	}

	setFromCylindricalCoords( radius, theta, y ) {

		this.x = radius * Math.sin( theta );
		this.y = y;
		this.z = radius * Math.cos( theta );

		return this;

	}

	setFromMatrixPosition( m ) {

		const e = m.elements;

		this.x = e[ 12 ];
		this.y = e[ 13 ];
		this.z = e[ 14 ];

		return this;

	}

	setFromMatrixScale( m ) {

		const sx = this.setFromMatrixColumn( m, 0 ).length();
		const sy = this.setFromMatrixColumn( m, 1 ).length();
		const sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	}

	setFromMatrixColumn( m, index ) {

		return this.fromArray( m.elements, index * 4 );

	}

	setFromMatrix3Column( m, index ) {

		return this.fromArray( m.elements, index * 3 );

	}

	equals( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	}

	fromArray( array, offset = 0 ) {

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	}

	fromBufferAttribute( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

	random() {

		this.x = Math.random();
		this.y = Math.random();
		this.z = Math.random();

		return this;

	}

}

Vector3$1.prototype.isVector3 = true;

const _vector = /*@__PURE__*/ new Vector3$1();
const _quaternion = /*@__PURE__*/ new Quaternion();

class Box3 {

	constructor( min = new Vector3$1( + Infinity, + Infinity, + Infinity ), max = new Vector3$1( - Infinity, - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromArray( array ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = array.length; i < l; i += 3 ) {

			const x = array[ i ];
			const y = array[ i + 1 ];
			const z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromBufferAttribute( attribute ) {

		let minX = + Infinity;
		let minY = + Infinity;
		let minZ = + Infinity;

		let maxX = - Infinity;
		let maxY = - Infinity;
		let maxZ = - Infinity;

		for ( let i = 0, l = attribute.count; i < l; i ++ ) {

			const x = attribute.getX( i );
			const y = attribute.getY( i );
			const z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	setFromObject( object ) {

		this.makeEmpty();

		return this.expandByObject( object );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getCenter() target is now required' );
			target = new Vector3$1();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getSize() target is now required' );
			target = new Vector3$1();

		}

		return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	expandByObject( object ) {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		object.updateWorldMatrix( false, false );

		const geometry = object.geometry;

		if ( geometry !== undefined ) {

			if ( geometry.boundingBox === null ) {

				geometry.computeBoundingBox();

			}

			_box.copy( geometry.boundingBox );
			_box.applyMatrix4( object.matrixWorld );

			this.union( _box );

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			this.expandByObject( children[ i ] );

		}

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .getParameter() target is now required' );
			target = new Vector3$1();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	}

	intersectsBox( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	}

	intersectsSphere( sphere ) {

		// Find the point on the AABB closest to the sphere center.
		this.clampPoint( sphere.center, _vector$1 );

		// If that point is inside the sphere, the AABB and sphere intersect.
		return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	intersectsPlane( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		let min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= - plane.constant && max >= - plane.constant );

	}

	intersectsTriangle( triangle ) {

		if ( this.isEmpty() ) {

			return false;

		}

		// compute box center and extents
		this.getCenter( _center$1 );
		_extents.subVectors( this.max, _center$1 );

		// translate triangle to aabb origin
		_v0.subVectors( triangle.a, _center$1 );
		_v1.subVectors( triangle.b, _center$1 );
		_v2.subVectors( triangle.c, _center$1 );

		// compute edge vectors for triangle
		_f0.subVectors( _v1, _v0 );
		_f1.subVectors( _v2, _v1 );
		_f2.subVectors( _v0, _v2 );

		// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
		// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
		// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
		let axes = [
			0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
			_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
			- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
		];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// test 3 face normals from the aabb
		axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
		if ( ! satForAxes( axes, _v0, _v1, _v2, _extents ) ) {

			return false;

		}

		// finally testing the face normal of the triangle
		// use already existing triangle edge vectors here
		_triangleNormal.crossVectors( _f0, _f1 );
		axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

		return satForAxes( axes, _v0, _v1, _v2, _extents );

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box3: .clampPoint() target is now required' );
			target = new Vector3$1();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

		return clampedPoint.sub( point ).length();

	}

	getBoundingSphere( target ) {

		if ( target === undefined ) {

			console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
			//target = new Sphere(); // removed to avoid cyclic dependency

		}

		this.getCenter( target.center );

		target.radius = this.getSize( _vector$1 ).length() * 0.5;

		return target;

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if ( this.isEmpty() ) this.makeEmpty();

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	applyMatrix4( matrix ) {

		// transform of empty box is an empty box.
		if ( this.isEmpty() ) return this;

		// NOTE: I am using a binary pattern to specify all 2^3 combinations below
		_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
		_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
		_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
		_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
		_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
		_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
		_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
		_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

		this.setFromPoints( _points );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box3.prototype.isBox3 = true;

const _points = [
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1(),
	/*@__PURE__*/ new Vector3$1()
];

const _vector$1 = /*@__PURE__*/ new Vector3$1();

const _box = /*@__PURE__*/ new Box3();

// triangle centered vertices

const _v0 = /*@__PURE__*/ new Vector3$1();
const _v1 = /*@__PURE__*/ new Vector3$1();
const _v2 = /*@__PURE__*/ new Vector3$1();

// triangle edge vectors

const _f0 = /*@__PURE__*/ new Vector3$1();
const _f1 = /*@__PURE__*/ new Vector3$1();
const _f2 = /*@__PURE__*/ new Vector3$1();

const _center$1 = /*@__PURE__*/ new Vector3$1();
const _extents = /*@__PURE__*/ new Vector3$1();
const _triangleNormal = /*@__PURE__*/ new Vector3$1();
const _testAxis = /*@__PURE__*/ new Vector3$1();

function satForAxes( axes, v0, v1, v2, extents ) {

	for ( let i = 0, j = axes.length - 3; i <= j; i += 3 ) {

		_testAxis.fromArray( axes, i );
		// project the aabb onto the seperating axis
		const r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
		// project all 3 vertices of the triangle onto the seperating axis
		const p0 = v0.dot( _testAxis );
		const p1 = v1.dot( _testAxis );
		const p2 = v2.dot( _testAxis );
		// actual test, basically see if either of the most extreme of the triangle points intersects r
		if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

			// points of the projected triangle are outside the projected half-length of the aabb
			// the axis is seperating and we can exit
			return false;

		}

	}

	return true;

}

const _box$1 = /*@__PURE__*/ new Box3();

class Sphere$1 {

	constructor( center = new Vector3$1(), radius = - 1 ) {

		this.center = center;
		this.radius = radius;

	}

	set( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	}

	setFromPoints( points, optionalCenter ) {

		const center = this.center;

		if ( optionalCenter !== undefined ) {

			center.copy( optionalCenter );

		} else {

			_box$1.setFromPoints( points ).getCenter( center );

		}

		let maxRadiusSq = 0;

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

		}

		this.radius = Math.sqrt( maxRadiusSq );

		return this;

	}

	copy( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	}

	isEmpty() {

		return ( this.radius < 0 );

	}

	makeEmpty() {

		this.center.set( 0, 0, 0 );
		this.radius = - 1;

		return this;

	}

	containsPoint( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	}

	distanceToPoint( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	}

	intersectsSphere( sphere ) {

		const radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	}

	intersectsBox( box ) {

		return box.intersectsSphere( this );

	}

	intersectsPlane( plane ) {

		return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

	}

	clampPoint( point, target ) {

		const deltaLengthSq = this.center.distanceToSquared( point );

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
			target = new Vector3$1();

		}

		target.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			target.sub( this.center ).normalize();
			target.multiplyScalar( this.radius ).add( this.center );

		}

		return target;

	}

	getBoundingBox( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
			target = new Box3();

		}

		if ( this.isEmpty() ) {

			// Empty sphere produces empty bounding box
			target.makeEmpty();
			return target;

		}

		target.set( this.center, this.center );
		target.expandByScalar( this.radius );

		return target;

	}

	applyMatrix4( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	}

	translate( offset ) {

		this.center.add( offset );

		return this;

	}

	equals( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$2 = /*@__PURE__*/ new Vector3$1();
const _segCenter = /*@__PURE__*/ new Vector3$1();
const _segDir = /*@__PURE__*/ new Vector3$1();
const _diff = /*@__PURE__*/ new Vector3$1();

const _edge1 = /*@__PURE__*/ new Vector3$1();
const _edge2 = /*@__PURE__*/ new Vector3$1();
const _normal = /*@__PURE__*/ new Vector3$1();

class Ray {

	constructor( origin = new Vector3$1(), direction = new Vector3$1( 0, 0, - 1 ) ) {

		this.origin = origin;
		this.direction = direction;

	}

	set( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	}

	copy( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .at() target is now required' );
			target = new Vector3$1();

		}

		return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	}

	lookAt( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	}

	recast( t ) {

		this.origin.copy( this.at( t, _vector$2 ) );

		return this;

	}

	closestPointToPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
			target = new Vector3$1();

		}

		target.subVectors( point, this.origin );

		const directionDistance = target.dot( this.direction );

		if ( directionDistance < 0 ) {

			return target.copy( this.origin );

		}

		return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	}

	distanceToPoint( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	}

	distanceSqToPoint( point ) {

		const directionDistance = _vector$2.subVectors( point, this.origin ).dot( this.direction );

		// point behind the ray

		if ( directionDistance < 0 ) {

			return this.origin.distanceToSquared( point );

		}

		_vector$2.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

		return _vector$2.distanceToSquared( point );

	}

	distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
		// It returns the min distance between the ray and the segment
		// defined by v0 and v1
		// It can also set two optional targets :
		// - The closest point on the ray
		// - The closest point on the segment

		_segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
		_segDir.copy( v1 ).sub( v0 ).normalize();
		_diff.copy( this.origin ).sub( _segCenter );

		const segExtent = v0.distanceTo( v1 ) * 0.5;
		const a01 = - this.direction.dot( _segDir );
		const b0 = _diff.dot( this.direction );
		const b1 = - _diff.dot( _segDir );
		const c = _diff.lengthSq();
		const det = Math.abs( 1 - a01 * a01 );
		let s0, s1, sqrDist, extDet;

		if ( det > 0 ) {

			// The ray and segment are not parallel.

			s0 = a01 * b1 - b0;
			s1 = a01 * b0 - b1;
			extDet = segExtent * det;

			if ( s0 >= 0 ) {

				if ( s1 >= - extDet ) {

					if ( s1 <= extDet ) {

						// region 0
						// Minimum at interior points of ray and segment.

						const invDet = 1 / det;
						s0 *= invDet;
						s1 *= invDet;
						sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

					} else {

						// region 1

						s1 = segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					// region 5

					s1 = - segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			} else {

				if ( s1 <= - extDet ) {

					// region 4

					s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				} else if ( s1 <= extDet ) {

					// region 3

					s0 = 0;
					s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = s1 * ( s1 + 2 * b1 ) + c;

				} else {

					// region 2

					s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
					s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

				}

			}

		} else {

			// Ray and segment are parallel.

			s1 = ( a01 > 0 ) ? - segExtent : segExtent;
			s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
			sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

		}

		if ( optionalPointOnRay ) {

			optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

		}

		if ( optionalPointOnSegment ) {

			optionalPointOnSegment.copy( _segDir ).multiplyScalar( s1 ).add( _segCenter );

		}

		return sqrDist;

	}

	intersectSphere( sphere, target ) {

		_vector$2.subVectors( sphere.center, this.origin );
		const tca = _vector$2.dot( this.direction );
		const d2 = _vector$2.dot( _vector$2 ) - tca * tca;
		const radius2 = sphere.radius * sphere.radius;

		if ( d2 > radius2 ) return null;

		const thc = Math.sqrt( radius2 - d2 );

		// t0 = first intersect point - entrance on front of sphere
		const t0 = tca - thc;

		// t1 = second intersect point - exit point on back of sphere
		const t1 = tca + thc;

		// test to see if both t0 and t1 are behind the ray - if so, return null
		if ( t0 < 0 && t1 < 0 ) return null;

		// test to see if t0 is behind the ray:
		// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
		// in order to always return an intersect point that is in front of the ray.
		if ( t0 < 0 ) return this.at( t1, target );

		// else t0 is in front of the ray, so return the first collision point scaled by t0
		return this.at( t0, target );

	}

	intersectsSphere( sphere ) {

		return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );

	}

	distanceToPlane( plane ) {

		const denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		const t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t : null;

	}

	intersectPlane( plane, target ) {

		const t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, target );

	}

	intersectsPlane( plane ) {

		// check if the ray lies on the plane first

		const distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		const denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	}

	intersectBox( box, target ) {

		let tmin, tmax, tymin, tymax, tzmin, tzmax;

		const invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		const origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, target );

	}

	intersectsBox( box ) {

		return this.intersectBox( box, _vector$2 ) !== null;

	}

	intersectTriangle( a, b, c, backfaceCulling, target ) {

		// Compute the offset origin, edges, and normal.

		// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

		_edge1.subVectors( b, a );
		_edge2.subVectors( c, a );
		_normal.crossVectors( _edge1, _edge2 );

		// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
		// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
		//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
		//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
		//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
		let DdN = this.direction.dot( _normal );
		let sign;

		if ( DdN > 0 ) {

			if ( backfaceCulling ) return null;
			sign = 1;

		} else if ( DdN < 0 ) {

			sign = - 1;
			DdN = - DdN;

		} else {

			return null;

		}

		_diff.subVectors( this.origin, a );
		const DdQxE2 = sign * this.direction.dot( _edge2.crossVectors( _diff, _edge2 ) );

		// b1 < 0, no intersection
		if ( DdQxE2 < 0 ) {

			return null;

		}

		const DdE1xQ = sign * this.direction.dot( _edge1.cross( _diff ) );

		// b2 < 0, no intersection
		if ( DdE1xQ < 0 ) {

			return null;

		}

		// b1+b2 > 1, no intersection
		if ( DdQxE2 + DdE1xQ > DdN ) {

			return null;

		}

		// Line intersects triangle, check if ray does.
		const QdN = - sign * _diff.dot( _normal );

		// t < 0, no intersection
		if ( QdN < 0 ) {

			return null;

		}

		// Ray intersects triangle.
		return this.at( QdN / DdN, target );

	}

	applyMatrix4( matrix4 ) {

		this.origin.applyMatrix4( matrix4 );
		this.direction.transformDirection( matrix4 );

		return this;

	}

	equals( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

class Matrix4 {

	constructor() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	set( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		const te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	}

	identity() {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	clone() {

		return new Matrix4().fromArray( this.elements );

	}

	copy( m ) {

		const te = this.elements;
		const me = m.elements;

		te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
		te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
		te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
		te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

		return this;

	}

	copyPosition( m ) {

		const te = this.elements, me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	}

	setFromMatrix3( m ) {

		const me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ], 0,
			me[ 1 ], me[ 4 ], me[ 7 ], 0,
			me[ 2 ], me[ 5 ], me[ 8 ], 0,
			0, 0, 0, 1

		);

		return this;

	}

	extractBasis( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	}

	makeBasis( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0, 0, 0, 1
		);

		return this;

	}

	extractRotation( m ) {

		// this method does not support reflection matrices

		const te = this.elements;
		const me = m.elements;

		const scaleX = 1 / _v1$1.setFromMatrixColumn( m, 0 ).length();
		const scaleY = 1 / _v1$1.setFromMatrixColumn( m, 1 ).length();
		const scaleZ = 1 / _v1$1.setFromMatrixColumn( m, 2 ).length();

		te[ 0 ] = me[ 0 ] * scaleX;
		te[ 1 ] = me[ 1 ] * scaleX;
		te[ 2 ] = me[ 2 ] * scaleX;
		te[ 3 ] = 0;

		te[ 4 ] = me[ 4 ] * scaleY;
		te[ 5 ] = me[ 5 ] * scaleY;
		te[ 6 ] = me[ 6 ] * scaleY;
		te[ 7 ] = 0;

		te[ 8 ] = me[ 8 ] * scaleZ;
		te[ 9 ] = me[ 9 ] * scaleZ;
		te[ 10 ] = me[ 10 ] * scaleZ;
		te[ 11 ] = 0;

		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromEuler( euler ) {

		if ( ! ( euler && euler.isEuler ) ) {

			console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		const te = this.elements;

		const x = euler.x, y = euler.y, z = euler.z;
		const a = Math.cos( x ), b = Math.sin( x );
		const c = Math.cos( y ), d = Math.sin( y );
		const e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			const ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			const ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			const ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// bottom row
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// last column
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	}

	makeRotationFromQuaternion( q ) {

		return this.compose( _zero, q, _one );

	}

	lookAt( eye, target, up ) {

		const te = this.elements;

		_z.subVectors( eye, target );

		if ( _z.lengthSq() === 0 ) {

			// eye and target are in the same position

			_z.z = 1;

		}

		_z.normalize();
		_x.crossVectors( up, _z );

		if ( _x.lengthSq() === 0 ) {

			// up and z are parallel

			if ( Math.abs( up.z ) === 1 ) {

				_z.x += 0.0001;

			} else {

				_z.z += 0.0001;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

		}

		_x.normalize();
		_y.crossVectors( _z, _x );

		te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
		te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
		te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

		return this;

	}

	multiply( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	}

	premultiply( m ) {

		return this.multiplyMatrices( m, this );

	}

	multiplyMatrices( a, b ) {

		const ae = a.elements;
		const be = b.elements;
		const te = this.elements;

		const a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		const a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		const a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		const a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		const b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		const b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		const b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		const b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	}

	multiplyScalar( s ) {

		const te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	}

	determinant() {

		const te = this.elements;

		const n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		const n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		const n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		const n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	}

	transpose() {

		const te = this.elements;
		let tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	}

	setPosition( x, y, z ) {

		const te = this.elements;

		if ( x.isVector3 ) {

			te[ 12 ] = x.x;
			te[ 13 ] = x.y;
			te[ 14 ] = x.z;

		} else {

			te[ 12 ] = x;
			te[ 13 ] = y;
			te[ 14 ] = z;

		}

		return this;

	}

	invert() {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		const te = this.elements,

			n11 = te[ 0 ], n21 = te[ 1 ], n31 = te[ 2 ], n41 = te[ 3 ],
			n12 = te[ 4 ], n22 = te[ 5 ], n32 = te[ 6 ], n42 = te[ 7 ],
			n13 = te[ 8 ], n23 = te[ 9 ], n33 = te[ 10 ], n43 = te[ 11 ],
			n14 = te[ 12 ], n24 = te[ 13 ], n34 = te[ 14 ], n44 = te[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) return this.set( 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 );

		const detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	}

	scale( v ) {

		const te = this.elements;
		const x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	}

	getMaxScaleOnAxis() {

		const te = this.elements;

		const scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		const scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		const scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	}

	makeTranslation( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationX( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0, 0, 0,
			0, c, - s, 0,
			0, s, c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationY( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	}

	makeRotationZ( theta ) {

		const c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s, c, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeRotationAxis( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		const c = Math.cos( angle );
		const s = Math.sin( angle );
		const t = 1 - c;
		const x = axis.x, y = axis.y, z = axis.z;
		const tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeScale( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	}

	makeShear( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	}

	compose( position, quaternion, scale ) {

		const te = this.elements;

		const x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
		const x2 = x + x,	y2 = y + y, z2 = z + z;
		const xx = x * x2, xy = x * y2, xz = x * z2;
		const yy = y * y2, yz = y * z2, zz = z * z2;
		const wx = w * x2, wy = w * y2, wz = w * z2;

		const sx = scale.x, sy = scale.y, sz = scale.z;

		te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
		te[ 1 ] = ( xy + wz ) * sx;
		te[ 2 ] = ( xz - wy ) * sx;
		te[ 3 ] = 0;

		te[ 4 ] = ( xy - wz ) * sy;
		te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
		te[ 6 ] = ( yz + wx ) * sy;
		te[ 7 ] = 0;

		te[ 8 ] = ( xz + wy ) * sz;
		te[ 9 ] = ( yz - wx ) * sz;
		te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
		te[ 11 ] = 0;

		te[ 12 ] = position.x;
		te[ 13 ] = position.y;
		te[ 14 ] = position.z;
		te[ 15 ] = 1;

		return this;

	}

	decompose( position, quaternion, scale ) {

		const te = this.elements;

		let sx = _v1$1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
		const sy = _v1$1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
		const sz = _v1$1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

		// if determine is negative, we need to invert one scale
		const det = this.determinant();
		if ( det < 0 ) sx = - sx;

		position.x = te[ 12 ];
		position.y = te[ 13 ];
		position.z = te[ 14 ];

		// scale the rotation part
		_m1.copy( this );

		const invSX = 1 / sx;
		const invSY = 1 / sy;
		const invSZ = 1 / sz;

		_m1.elements[ 0 ] *= invSX;
		_m1.elements[ 1 ] *= invSX;
		_m1.elements[ 2 ] *= invSX;

		_m1.elements[ 4 ] *= invSY;
		_m1.elements[ 5 ] *= invSY;
		_m1.elements[ 6 ] *= invSY;

		_m1.elements[ 8 ] *= invSZ;
		_m1.elements[ 9 ] *= invSZ;
		_m1.elements[ 10 ] *= invSZ;

		quaternion.setFromRotationMatrix( _m1 );

		scale.x = sx;
		scale.y = sy;
		scale.z = sz;

		return this;

	}

	makePerspective( left, right, top, bottom, near, far ) {

		if ( far === undefined ) {

			console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

		}

		const te = this.elements;
		const x = 2 * near / ( right - left );
		const y = 2 * near / ( top - bottom );

		const a = ( right + left ) / ( right - left );
		const b = ( top + bottom ) / ( top - bottom );
		const c = - ( far + near ) / ( far - near );
		const d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	}

	makeOrthographic( left, right, top, bottom, near, far ) {

		const te = this.elements;
		const w = 1.0 / ( right - left );
		const h = 1.0 / ( top - bottom );
		const p = 1.0 / ( far - near );

		const x = ( right + left ) * w;
		const y = ( top + bottom ) * h;
		const z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	}

	equals( matrix ) {

		const te = this.elements;
		const me = matrix.elements;

		for ( let i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	}

	fromArray( array, offset = 0 ) {

		for ( let i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ] = te[ 8 ];
		array[ offset + 9 ] = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

}

Matrix4.prototype.isMatrix4 = true;

const _v1$1 = /*@__PURE__*/ new Vector3$1();
const _m1 = /*@__PURE__*/ new Matrix4();
const _zero = /*@__PURE__*/ new Vector3$1( 0, 0, 0 );
const _one = /*@__PURE__*/ new Vector3$1( 1, 1, 1 );
const _x = /*@__PURE__*/ new Vector3$1();
const _y = /*@__PURE__*/ new Vector3$1();
const _z = /*@__PURE__*/ new Vector3$1();

const _matrix = /*@__PURE__*/ new Matrix4();
const _quaternion$1 = /*@__PURE__*/ new Quaternion();

class Euler {

	constructor( x = 0, y = 0, z = 0, order = Euler.DefaultOrder ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order;

	}

	get x() {

		return this._x;

	}

	set x( value ) {

		this._x = value;
		this._onChangeCallback();

	}

	get y() {

		return this._y;

	}

	set y( value ) {

		this._y = value;
		this._onChangeCallback();

	}

	get z() {

		return this._z;

	}

	set z( value ) {

		this._z = value;
		this._onChangeCallback();

	}

	get order() {

		return this._order;

	}

	set order( value ) {

		this._order = value;
		this._onChangeCallback();

	}

	set( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this._onChangeCallback();

		return this;

	}

	clone() {

		return new this.constructor( this._x, this._y, this._z, this._order );

	}

	copy( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this._onChangeCallback();

		return this;

	}

	setFromRotationMatrix( m, order, update ) {

		const clamp = MathUtils.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		const te = m.elements;
		const m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		const m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		const m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		switch ( order ) {

			case 'XYZ':

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

				break;

			case 'YXZ':

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

				break;

			case 'ZXY':

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

				break;

			case 'ZYX':

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

				break;

			case 'YZX':

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

				break;

			case 'XZY':

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

				break;

			default:

				console.warn( 'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this._onChangeCallback();

		return this;

	}

	setFromQuaternion( q, order, update ) {

		_matrix.makeRotationFromQuaternion( q );

		return this.setFromRotationMatrix( _matrix, order, update );

	}

	setFromVector3( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	}

	reorder( newOrder ) {

		// WARNING: this discards revolution information -bhouston

		_quaternion$1.setFromEuler( this );

		return this.setFromQuaternion( _quaternion$1, newOrder );

	}

	equals( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	}

	fromArray( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this._onChangeCallback();

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	}

	toVector3( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3$1( this._x, this._y, this._z );

		}

	}

	_onChange( callback ) {

		this._onChangeCallback = callback;

		return this;

	}

	_onChangeCallback() {}

}

Euler.prototype.isEuler = true;

Euler.DefaultOrder = 'XYZ';
Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

class Layers {

	constructor() {

		this.mask = 1 | 0;

	}

	set( channel ) {

		this.mask = 1 << channel | 0;

	}

	enable( channel ) {

		this.mask |= 1 << channel | 0;

	}

	enableAll() {

		this.mask = 0xffffffff | 0;

	}

	toggle( channel ) {

		this.mask ^= 1 << channel | 0;

	}

	disable( channel ) {

		this.mask &= ~ ( 1 << channel | 0 );

	}

	disableAll() {

		this.mask = 0;

	}

	test( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

}

let _object3DId = 0;

const _v1$2 = new Vector3$1();
const _q1 = new Quaternion();
const _m1$1 = new Matrix4();
const _target = new Vector3$1();

const _position = new Vector3$1();
const _scale = new Vector3$1();
const _quaternion$2 = new Quaternion();

const _xAxis = new Vector3$1( 1, 0, 0 );
const _yAxis = new Vector3$1( 0, 1, 0 );
const _zAxis = new Vector3$1( 0, 0, 1 );

const _addedEvent = { type: 'added' };
const _removedEvent = { type: 'removed' };

function Object3D() {

	Object.defineProperty( this, 'id', { value: _object3DId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	const position = new Vector3$1();
	const rotation = new Euler();
	const quaternion = new Quaternion();
	const scale = new Vector3$1( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation._onChange( onRotationChange );
	quaternion._onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			configurable: true,
			enumerable: true,
			value: position
		},
		rotation: {
			configurable: true,
			enumerable: true,
			value: rotation
		},
		quaternion: {
			configurable: true,
			enumerable: true,
			value: quaternion
		},
		scale: {
			configurable: true,
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.animations = [];

	this.userData = {};

}

Object3D.DefaultUp = new Vector3$1( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Object3D,

	isObject3D: true,

	onBeforeRender: function () {},
	onAfterRender: function () {},

	applyMatrix4: function ( matrix ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		this.matrix.premultiply( matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	applyQuaternion: function ( q ) {

		this.quaternion.premultiply( q );

		return this;

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function ( axis, angle ) {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.multiply( _q1 );

		return this;

	},

	rotateOnWorldAxis: function ( axis, angle ) {

		// rotate object on axis in world space
		// axis is assumed to be normalized
		// method assumes no rotated parent

		_q1.setFromAxisAngle( axis, angle );

		this.quaternion.premultiply( _q1 );

		return this;

	},

	rotateX: function ( angle ) {

		return this.rotateOnAxis( _xAxis, angle );

	},

	rotateY: function ( angle ) {

		return this.rotateOnAxis( _yAxis, angle );

	},

	rotateZ: function ( angle ) {

		return this.rotateOnAxis( _zAxis, angle );

	},

	translateOnAxis: function ( axis, distance ) {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		_v1$2.copy( axis ).applyQuaternion( this.quaternion );

		this.position.add( _v1$2.multiplyScalar( distance ) );

		return this;

	},

	translateX: function ( distance ) {

		return this.translateOnAxis( _xAxis, distance );

	},

	translateY: function ( distance ) {

		return this.translateOnAxis( _yAxis, distance );

	},

	translateZ: function ( distance ) {

		return this.translateOnAxis( _zAxis, distance );

	},

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function ( vector ) {

		return vector.applyMatrix4( _m1$1.copy( this.matrixWorld ).invert() );

	},

	lookAt: function ( x, y, z ) {

		// This method does not support objects having non-uniformly-scaled parent(s)

		if ( x.isVector3 ) {

			_target.copy( x );

		} else {

			_target.set( x, y, z );

		}

		const parent = this.parent;

		this.updateWorldMatrix( true, false );

		_position.setFromMatrixPosition( this.matrixWorld );

		if ( this.isCamera || this.isLight ) {

			_m1$1.lookAt( _position, _target, this.up );

		} else {

			_m1$1.lookAt( _target, _position, this.up );

		}

		this.quaternion.setFromRotationMatrix( _m1$1 );

		if ( parent ) {

			_m1$1.extractRotation( parent.matrixWorld );
			_q1.setFromRotationMatrix( _m1$1 );
			this.quaternion.premultiply( _q1.invert() );

		}

	},

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( 'THREE.Object3D.add: object can\'t be added as a child of itself.', object );
			return this;

		}

		if ( object && object.isObject3D ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			this.children.push( object );

			object.dispatchEvent( _addedEvent );

		} else {

			console.error( 'THREE.Object3D.add: object not an instance of THREE.Object3D.', object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( let i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

			return this;

		}

		const index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;
			this.children.splice( index, 1 );

			object.dispatchEvent( _removedEvent );

		}

		return this;

	},

	clear: function () {

		for ( let i = 0; i < this.children.length; i ++ ) {

			const object = this.children[ i ];

			object.parent = null;

			object.dispatchEvent( _removedEvent );

		}

		this.children.length = 0;

		return this;


	},

	attach: function ( object ) {

		// adds object as a child of this, while maintaining the object's world transform

		this.updateWorldMatrix( true, false );

		_m1$1.copy( this.matrixWorld ).invert();

		if ( object.parent !== null ) {

			object.parent.updateWorldMatrix( true, false );

			_m1$1.multiply( object.parent.matrixWorld );

		}

		object.applyMatrix4( _m1$1 );

		this.add( object );

		object.updateWorldMatrix( false, true );

		return this;

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( let i = 0, l = this.children.length; i < l; i ++ ) {

			const child = this.children[ i ];
			const object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
			target = new Vector3$1();

		}

		this.updateWorldMatrix( true, false );

		return target.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
			target = new Quaternion();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, target, _scale );

		return target;

	},

	getWorldScale: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
			target = new Vector3$1();

		}

		this.updateWorldMatrix( true, false );

		this.matrixWorld.decompose( _position, _quaternion$2, target );

		return target;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
			target = new Vector3$1();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

	},

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		const parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate || force ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		const children = this.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		const parent = this.parent;

		if ( updateParents === true && parent !== null ) {

			parent.updateWorldMatrix( true, false );

		}

		if ( this.matrixAutoUpdate ) this.updateMatrix();

		if ( this.parent === null ) {

			this.matrixWorld.copy( this.matrix );

		} else {

			this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

		}

		// update children

		if ( updateChildren === true ) {

			const children = this.children;

			for ( let i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateWorldMatrix( false, true );

			}

		}

	},

	toJSON: function ( meta ) {

		// meta is a string when called from JSON.stringify
		const isRootObject = ( meta === undefined || typeof meta === 'string' );

		const output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {},
				shapes: {},
				skeletons: {},
				animations: {}
			};

			output.metadata = {
				version: 4.5,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		const object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;
		if ( this.frustumCulled === false ) object.frustumCulled = false;
		if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

		object.layers = this.layers.mask;
		object.matrix = this.matrix.toArray();

		if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

		// object specific properties

		if ( this.isInstancedMesh ) {

			object.type = 'InstancedMesh';
			object.count = this.count;
			object.instanceMatrix = this.instanceMatrix.toJSON();

		}

		//

		function serialize( library, element ) {

			if ( library[ element.uuid ] === undefined ) {

				library[ element.uuid ] = element.toJSON( meta );

			}

			return element.uuid;

		}

		if ( this.isMesh || this.isLine || this.isPoints ) {

			object.geometry = serialize( meta.geometries, this.geometry );

			const parameters = this.geometry.parameters;

			if ( parameters !== undefined && parameters.shapes !== undefined ) {

				const shapes = parameters.shapes;

				if ( Array.isArray( shapes ) ) {

					for ( let i = 0, l = shapes.length; i < l; i ++ ) {

						const shape = shapes[ i ];

						serialize( meta.shapes, shape );

					}

				} else {

					serialize( meta.shapes, shapes );

				}

			}

		}

		if ( this.isSkinnedMesh ) {

			object.bindMode = this.bindMode;
			object.bindMatrix = this.bindMatrix.toArray();

			if ( this.skeleton !== undefined ) {

				serialize( meta.skeletons, this.skeleton );

				object.skeleton = this.skeleton.uuid;

			}

		}

		if ( this.material !== undefined ) {

			if ( Array.isArray( this.material ) ) {

				const uuids = [];

				for ( let i = 0, l = this.material.length; i < l; i ++ ) {

					uuids.push( serialize( meta.materials, this.material[ i ] ) );

				}

				object.material = uuids;

			} else {

				object.material = serialize( meta.materials, this.material );

			}

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( let i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		//

		if ( this.animations.length > 0 ) {

			object.animations = [];

			for ( let i = 0; i < this.animations.length; i ++ ) {

				const animation = this.animations[ i ];

				object.animations.push( serialize( meta.animations, animation ) );

			}

		}

		if ( isRootObject ) {

			const geometries = extractFromCache( meta.geometries );
			const materials = extractFromCache( meta.materials );
			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );
			const shapes = extractFromCache( meta.shapes );
			const skeletons = extractFromCache( meta.skeletons );
			const animations = extractFromCache( meta.animations );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;
			if ( shapes.length > 0 ) output.shapes = shapes;
			if ( skeletons.length > 0 ) output.skeletons = skeletons;
			if ( animations.length > 0 ) output.animations = animations;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			const values = [];
			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive = true ) {

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.rotation.order = source.rotation.order;
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( let i = 0; i < source.children.length; i ++ ) {

				const child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

const _vector1 = /*@__PURE__*/ new Vector3$1();
const _vector2 = /*@__PURE__*/ new Vector3$1();
const _normalMatrix = /*@__PURE__*/ new Matrix3();

class Plane$1 {

	constructor( normal = new Vector3$1( 1, 0, 0 ), constant = 0 ) {

		// normal is assumed to be normalized

		this.normal = normal;
		this.constant = constant;

	}

	set( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	}

	setComponents( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	}

	setFromNormalAndCoplanarPoint( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );

		return this;

	}

	setFromCoplanarPoints( a, b, c ) {

		const normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

		// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

		this.setFromNormalAndCoplanarPoint( normal, a );

		return this;

	}

	copy( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	}

	normalize() {

		// Note: will lead to a divide by zero if the plane is invalid.

		const inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	}

	negate() {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	}

	distanceToPoint( point ) {

		return this.normal.dot( point ) + this.constant;

	}

	distanceToSphere( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	}

	projectPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .projectPoint() target is now required' );
			target = new Vector3$1();

		}

		return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

	}

	intersectLine( line, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .intersectLine() target is now required' );
			target = new Vector3$1();

		}

		const direction = line.delta( _vector1 );

		const denominator = this.normal.dot( direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( this.distanceToPoint( line.start ) === 0 ) {

				return target.copy( line.start );

			}

			// Unsure if this is the correct method to handle this case.
			return undefined;

		}

		const t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

		if ( t < 0 || t > 1 ) {

			return undefined;

		}

		return target.copy( direction ).multiplyScalar( t ).add( line.start );

	}

	intersectsLine( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		const startSign = this.distanceToPoint( line.start );
		const endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	}

	intersectsBox( box ) {

		return box.intersectsPlane( this );

	}

	intersectsSphere( sphere ) {

		return sphere.intersectsPlane( this );

	}

	coplanarPoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
			target = new Vector3$1();

		}

		return target.copy( this.normal ).multiplyScalar( - this.constant );

	}

	applyMatrix4( matrix, optionalNormalMatrix ) {

		const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

		const referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

		const normal = this.normal.applyMatrix3( normalMatrix ).normalize();

		this.constant = - referencePoint.dot( normal );

		return this;

	}

	translate( offset ) {

		this.constant -= offset.dot( this.normal );

		return this;

	}

	equals( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

Plane$1.prototype.isPlane = true;

const _v0$1 = /*@__PURE__*/ new Vector3$1();
const _v1$3 = /*@__PURE__*/ new Vector3$1();
const _v2$1 = /*@__PURE__*/ new Vector3$1();
const _v3 = /*@__PURE__*/ new Vector3$1();

const _vab = /*@__PURE__*/ new Vector3$1();
const _vac = /*@__PURE__*/ new Vector3$1();
const _vbc = /*@__PURE__*/ new Vector3$1();
const _vap = /*@__PURE__*/ new Vector3$1();
const _vbp = /*@__PURE__*/ new Vector3$1();
const _vcp = /*@__PURE__*/ new Vector3$1();

class Triangle {

	constructor( a = new Vector3$1(), b = new Vector3$1(), c = new Vector3$1() ) {

		this.a = a;
		this.b = b;
		this.c = c;

	}

	static getNormal( a, b, c, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getNormal() target is now required' );
			target = new Vector3$1();

		}

		target.subVectors( c, b );
		_v0$1.subVectors( a, b );
		target.cross( _v0$1 );

		const targetLengthSq = target.lengthSq();
		if ( targetLengthSq > 0 ) {

			return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

		}

		return target.set( 0, 0, 0 );

	}

	// static/instance method to calculate barycentric coordinates
	// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
	static getBarycoord( point, a, b, c, target ) {

		_v0$1.subVectors( c, a );
		_v1$3.subVectors( b, a );
		_v2$1.subVectors( point, a );

		const dot00 = _v0$1.dot( _v0$1 );
		const dot01 = _v0$1.dot( _v1$3 );
		const dot02 = _v0$1.dot( _v2$1 );
		const dot11 = _v1$3.dot( _v1$3 );
		const dot12 = _v1$3.dot( _v2$1 );

		const denom = ( dot00 * dot11 - dot01 * dot01 );

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
			target = new Vector3$1();

		}

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return target.set( - 2, - 1, - 1 );

		}

		const invDenom = 1 / denom;
		const u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		const v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return target.set( 1 - u - v, v, u );

	}

	static containsPoint( point, a, b, c ) {

		this.getBarycoord( point, a, b, c, _v3 );

		return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

	}

	static getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {

		this.getBarycoord( point, p1, p2, p3, _v3 );

		target.set( 0, 0 );
		target.addScaledVector( uv1, _v3.x );
		target.addScaledVector( uv2, _v3.y );
		target.addScaledVector( uv3, _v3.z );

		return target;

	}

	static isFrontFacing( a, b, c, direction ) {

		_v0$1.subVectors( c, b );
		_v1$3.subVectors( a, b );

		// strictly front facing
		return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

	}

	set( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	}

	setFromPointsAndIndices( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	}

	getArea() {

		_v0$1.subVectors( this.c, this.b );
		_v1$3.subVectors( this.a, this.b );

		return _v0$1.cross( _v1$3 ).length() * 0.5;

	}

	getMidpoint( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
			target = new Vector3$1();

		}

		return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	}

	getNormal( target ) {

		return Triangle.getNormal( this.a, this.b, this.c, target );

	}

	getPlane( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .getPlane() target is now required' );
			target = new Plane$1();

		}

		return target.setFromCoplanarPoints( this.a, this.b, this.c );

	}

	getBarycoord( point, target ) {

		return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

	}

	getUV( point, uv1, uv2, uv3, target ) {

		return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

	}

	containsPoint( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	}

	isFrontFacing( direction ) {

		return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

	}

	intersectsBox( box ) {

		return box.intersectsTriangle( this );

	}

	closestPointToPoint( p, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
			target = new Vector3$1();

		}

		const a = this.a, b = this.b, c = this.c;
		let v, w;

		// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
		// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
		// under the accompanying license; see chapter 5.1.5 for detailed explanation.
		// basically, we're distinguishing which of the voronoi regions of the triangle
		// the point lies in with the minimum amount of redundant computation.

		_vab.subVectors( b, a );
		_vac.subVectors( c, a );
		_vap.subVectors( p, a );
		const d1 = _vab.dot( _vap );
		const d2 = _vac.dot( _vap );
		if ( d1 <= 0 && d2 <= 0 ) {

			// vertex region of A; barycentric coords (1, 0, 0)
			return target.copy( a );

		}

		_vbp.subVectors( p, b );
		const d3 = _vab.dot( _vbp );
		const d4 = _vac.dot( _vbp );
		if ( d3 >= 0 && d4 <= d3 ) {

			// vertex region of B; barycentric coords (0, 1, 0)
			return target.copy( b );

		}

		const vc = d1 * d4 - d3 * d2;
		if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

			v = d1 / ( d1 - d3 );
			// edge region of AB; barycentric coords (1-v, v, 0)
			return target.copy( a ).addScaledVector( _vab, v );

		}

		_vcp.subVectors( p, c );
		const d5 = _vab.dot( _vcp );
		const d6 = _vac.dot( _vcp );
		if ( d6 >= 0 && d5 <= d6 ) {

			// vertex region of C; barycentric coords (0, 0, 1)
			return target.copy( c );

		}

		const vb = d5 * d2 - d1 * d6;
		if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

			w = d2 / ( d2 - d6 );
			// edge region of AC; barycentric coords (1-w, 0, w)
			return target.copy( a ).addScaledVector( _vac, w );

		}

		const va = d3 * d6 - d5 * d4;
		if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

			_vbc.subVectors( c, b );
			w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
			// edge region of BC; barycentric coords (0, 1-w, w)
			return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

		}

		// face region
		const denom = 1 / ( va + vb + vc );
		// u = va * denom
		v = vb * denom;
		w = vc * denom;

		return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

	}

	equals( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

}

let materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.vertexColors = false;

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.stencilWriteMask = 0xff;
	this.stencilFunc = AlwaysStencilFunc;
	this.stencilRef = 0;
	this.stencilFuncMask = 0xff;
	this.stencilFail = KeepStencilOp;
	this.stencilZFail = KeepStencilOp;
	this.stencilZPass = KeepStencilOp;
	this.stencilWrite = false;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.shadowSide = null;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.dithering = false;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.visible = true;

	this.toneMapped = true;

	this.userData = {};

	this.version = 0;

}

Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: Material,

	isMaterial: true,

	onBeforeCompile: function ( /* shaderobject, renderer */ ) {},

	customProgramCacheKey: function () {

		return this.onBeforeCompile.toString();

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( const key in values ) {

			const newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( 'THREE.Material: \'' + key + '\' parameter is undefined.' );
				continue;

			}

			// for backward compatability if shading is set in the constructor
			if ( key === 'shading' ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( newValue === FlatShading ) ? true : false;
				continue;

			}

			const currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( 'THREE.' + this.type + ': \'' + key + '\' is not a property of this material.' );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

				currentValue.copy( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		const isRoot = ( meta === undefined || typeof meta === 'string' );

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		const data = {
			metadata: {
				version: 4.5,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
		if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

		if ( this.clearcoatMap && this.clearcoatMap.isTexture ) {

			data.clearcoatMap = this.clearcoatMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture ) {

			data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON( meta ).uuid;

		}

		if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

			data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
			data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

		}

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;

		if ( this.lightMap && this.lightMap.isTexture ) {

			data.lightMap = this.lightMap.toJSON( meta ).uuid;
			data.lightMapIntensity = this.lightMapIntensity;

		}

		if ( this.aoMap && this.aoMap.isTexture ) {

			data.aoMap = this.aoMap.toJSON( meta ).uuid;
			data.aoMapIntensity = this.aoMapIntensity;

		}

		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}

		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalMapType = this.normalMapType;
			data.normalScale = this.normalScale.toArray();

		}

		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}

		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap
			data.refractionRatio = this.refractionRatio;

			if ( this.combine !== undefined ) data.combine = this.combine;
			if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors ) data.vertexColors = true;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		data.stencilWrite = this.stencilWrite;
		data.stencilWriteMask = this.stencilWriteMask;
		data.stencilFunc = this.stencilFunc;
		data.stencilRef = this.stencilRef;
		data.stencilFuncMask = this.stencilFuncMask;
		data.stencilFail = this.stencilFail;
		data.stencilZFail = this.stencilZFail;
		data.stencilZPass = this.stencilZPass;

		// rotation (SpriteMaterial)
		if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

		if ( this.polygonOffset === true ) data.polygonOffset = true;
		if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
		if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

		if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
		if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
		if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
		if ( this.scale !== undefined ) data.scale = this.scale;

		if ( this.dithering === true ) data.dithering = true;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		if ( this.morphTargets === true ) data.morphTargets = true;
		if ( this.morphNormals === true ) data.morphNormals = true;
		if ( this.skinning === true ) data.skinning = true;

		if ( this.flatShading === true ) data.flatShading = this.flatShading;

		if ( this.visible === false ) data.visible = false;

		if ( this.toneMapped === false ) data.toneMapped = false;

		if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			const values = [];

			for ( const key in cache ) {

				const data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			const textures = extractFromCache( meta.textures );
			const images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;

		this.blending = source.blending;
		this.side = source.side;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.stencilWriteMask = source.stencilWriteMask;
		this.stencilFunc = source.stencilFunc;
		this.stencilRef = source.stencilRef;
		this.stencilFuncMask = source.stencilFuncMask;
		this.stencilFail = source.stencilFail;
		this.stencilZFail = source.stencilZFail;
		this.stencilZPass = source.stencilZPass;
		this.stencilWrite = source.stencilWrite;

		const srcPlanes = source.clippingPlanes;
		let dstPlanes = null;

		if ( srcPlanes !== null ) {

			const n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( let i = 0; i !== n; ++ i ) {

				dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

		}

		this.clippingPlanes = dstPlanes;
		this.clipIntersection = source.clipIntersection;
		this.clipShadows = source.clipShadows;

		this.shadowSide = source.shadowSide;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.dithering = source.dithering;

		this.alphaTest = source.alphaTest;
		this.premultipliedAlpha = source.premultipliedAlpha;

		this.visible = source.visible;

		this.toneMapped = source.toneMapped;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

Object.defineProperty( Material.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

const _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
	'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
	'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
	'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
	'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
	'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
	'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
	'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
	'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
	'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
	'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
	'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
	'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
	'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
	'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
	'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
	'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
	'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
	'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
	'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
	'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
	'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
	'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
	'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

const _hslA = { h: 0, s: 0, l: 0 };
const _hslB = { h: 0, s: 0, l: 0 };

function hue2rgb( p, q, t ) {

	if ( t < 0 ) t += 1;
	if ( t > 1 ) t -= 1;
	if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
	if ( t < 1 / 2 ) return q;
	if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
	return p;

}

function SRGBToLinear( c ) {

	return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

}

function LinearToSRGB( c ) {

	return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

}

class Color$1 {

	constructor( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	set( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	}

	setScalar( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	}

	setHex( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	}

	setRGB( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	}

	setHSL( h, s, l ) {

		// h,s,l ranges are in 0.0 - 1.0
		h = MathUtils.euclideanModulo( h, 1 );
		s = MathUtils.clamp( s, 0, 1 );
		l = MathUtils.clamp( l, 0, 1 );

		if ( s === 0 ) {

			this.r = this.g = this.b = l;

		} else {

			const p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
			const q = ( 2 * l ) - p;

			this.r = hue2rgb( q, p, h + 1 / 3 );
			this.g = hue2rgb( q, p, h );
			this.b = hue2rgb( q, p, h - 1 / 3 );

		}

		return this;

	}

	setStyle( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		let m;

		if ( m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			let color;
			const name = m[ 1 ];
			const components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 4 ] );

						return this;

					}

					if ( color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 4 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						const h = parseFloat( color[ 1 ] ) / 360;
						const s = parseInt( color[ 2 ], 10 ) / 100;
						const l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 4 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f\d]+)$/.exec( style ) ) {

			// hex color

			const hex = m[ 1 ];
			const size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			return this.setColorName( style );

		}

		return this;

	}

	setColorName( style ) {

		// color keywords
		const hex = _colorKeywords[ style ];

		if ( hex !== undefined ) {

			// red
			this.setHex( hex );

		} else {

			// unknown color
			console.warn( 'THREE.Color: Unknown color ' + style );

		}

		return this;

	}

	clone() {

		return new this.constructor( this.r, this.g, this.b );

	}

	copy( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	}

	copyGammaToLinear( color, gammaFactor = 2.0 ) {

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	}

	copyLinearToGamma( color, gammaFactor = 2.0 ) {

		const safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	}

	convertGammaToLinear( gammaFactor ) {

		this.copyGammaToLinear( this, gammaFactor );

		return this;

	}

	convertLinearToGamma( gammaFactor ) {

		this.copyLinearToGamma( this, gammaFactor );

		return this;

	}

	copySRGBToLinear( color ) {

		this.r = SRGBToLinear( color.r );
		this.g = SRGBToLinear( color.g );
		this.b = SRGBToLinear( color.b );

		return this;

	}

	copyLinearToSRGB( color ) {

		this.r = LinearToSRGB( color.r );
		this.g = LinearToSRGB( color.g );
		this.b = LinearToSRGB( color.b );

		return this;

	}

	convertSRGBToLinear() {

		this.copySRGBToLinear( this );

		return this;

	}

	convertLinearToSRGB() {

		this.copyLinearToSRGB( this );

		return this;

	}

	getHex() {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	}

	getHexString() {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	}

	getHSL( target ) {

		// h,s,l ranges are in 0.0 - 1.0

		if ( target === undefined ) {

			console.warn( 'THREE.Color: .getHSL() target is now required' );
			target = { h: 0, s: 0, l: 0 };

		}

		const r = this.r, g = this.g, b = this.b;

		const max = Math.max( r, g, b );
		const min = Math.min( r, g, b );

		let hue, saturation;
		const lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			const delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		target.h = hue;
		target.s = saturation;
		target.l = lightness;

		return target;

	}

	getStyle() {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	}

	offsetHSL( h, s, l ) {

		this.getHSL( _hslA );

		_hslA.h += h; _hslA.s += s; _hslA.l += l;

		this.setHSL( _hslA.h, _hslA.s, _hslA.l );

		return this;

	}

	add( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	}

	addColors( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	}

	addScalar( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	}

	sub( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	}

	multiply( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	}

	multiplyScalar( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	}

	lerp( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	}

	lerpColors( color1, color2, alpha ) {

		this.r = color1.r + ( color2.r - color1.r ) * alpha;
		this.g = color1.g + ( color2.g - color1.g ) * alpha;
		this.b = color1.b + ( color2.b - color1.b ) * alpha;

		return this;

	}

	lerpHSL( color, alpha ) {

		this.getHSL( _hslA );
		color.getHSL( _hslB );

		const h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
		const s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
		const l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

		this.setHSL( h, s, l );

		return this;

	}

	equals( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	}

	fromArray( array, offset = 0 ) {

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	}

	toArray( array = [], offset = 0 ) {

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	}

	fromBufferAttribute( attribute, index ) {

		this.r = attribute.getX( index );
		this.g = attribute.getY( index );
		this.b = attribute.getZ( index );

		if ( attribute.normalized === true ) {

			// assuming Uint8Array

			this.r /= 255;
			this.g /= 255;
			this.b /= 255;

		}

		return this;

	}

	toJSON() {

		return this.getHex();

	}

}

Color$1.NAMES = _colorKeywords;

Color$1.prototype.isColor = true;
Color$1.prototype.r = 1;
Color$1.prototype.g = 1;
Color$1.prototype.b = 1;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

class MeshBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshBasicMaterial';

		this.color = new Color$1( 0xffffff ); // emissive

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		return this;

	}

}

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

const _vector$3 = new Vector3$1();
const _vector2$1 = new Vector2();

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.name = '';

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

}

Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( BufferAttribute.prototype, {

	isBufferAttribute: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.name = source.name;
		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( let i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = colors.length; i < l; i ++ ) {

			let color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color$1();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3$1();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		const array = this.array;
		let offset = 0;

		for ( let i = 0, l = vectors.length; i < l; i ++ ) {

			let vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	applyMatrix3: function ( m ) {

		if ( this.itemSize === 2 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector2$1.fromBufferAttribute( this, i );
				_vector2$1.applyMatrix3( m );

				this.setXY( i, _vector2$1.x, _vector2$1.y );

			}

		} else if ( this.itemSize === 3 ) {

			for ( let i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.fromBufferAttribute( this, i );
				_vector$3.applyMatrix3( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyMatrix4( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	applyNormalMatrix: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.applyNormalMatrix( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	transformDirection: function ( m ) {

		for ( let i = 0, l = this.count; i < l; i ++ ) {

			_vector$3.x = this.getX( i );
			_vector$3.y = this.getY( i );
			_vector$3.z = this.getZ( i );

			_vector$3.transformDirection( m );

			this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor( this.array, this.itemSize ).copy( this );

	},

	toJSON: function () {

		return {
			itemSize: this.itemSize,
			type: this.array.constructor.name,
			array: Array.prototype.slice.call( this.array ),
			normalized: this.normalized
		};

	}

} );

//

function Int8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;

function Float16BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

}

Float16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float16BufferAttribute.prototype.constructor = Float16BufferAttribute;
Float16BufferAttribute.prototype.isFloat16BufferAttribute = true;

function Float32BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize, normalized ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

function arrayMax( array ) {

	if ( array.length === 0 ) return - Infinity;

	let max = array[ 0 ];

	for ( let i = 1, l = array.length; i < l; ++ i ) {

		if ( array[ i ] > max ) max = array[ i ];

	}

	return max;

}

const TYPED_ARRAYS = {
	Int8Array: Int8Array,
	Uint8Array: Uint8Array,
	Uint8ClampedArray: Uint8ClampedArray,
	Int16Array: Int16Array,
	Uint16Array: Uint16Array,
	Int32Array: Int32Array,
	Uint32Array: Uint32Array,
	Float32Array: Float32Array,
	Float64Array: Float64Array
};

function getTypedArray( type, buffer ) {

	return new TYPED_ARRAYS[ type ]( buffer );

}

let _id = 0;

const _m1$2 = new Matrix4();
const _obj = new Object3D();
const _offset = new Vector3$1();
const _box$2 = new Box3();
const _boxMorphTargets = new Box3();
const _vector$4 = new Vector3$1();

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: _id ++ } );

	this.uuid = MathUtils.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};
	this.morphTargetsRelative = false;

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

	this.userData = {};

}

BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

	constructor: BufferGeometry,

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		if ( Array.isArray( index ) ) {

			this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

		} else {

			this.index = index;

		}

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	setAttribute: function ( name, attribute ) {

		this.attributes[ name ] = attribute;

		return this;

	},

	deleteAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	hasAttribute: function ( name ) {

		return this.attributes[ name ] !== undefined;

	},

	addGroup: function ( start, count, materialIndex = 0 ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix4: function ( matrix ) {

		const position = this.attributes.position;

		if ( position !== undefined ) {

			position.applyMatrix4( matrix );

			position.needsUpdate = true;

		}

		const normal = this.attributes.normal;

		if ( normal !== undefined ) {

			const normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normal.applyNormalMatrix( normalMatrix );

			normal.needsUpdate = true;

		}

		const tangent = this.attributes.tangent;

		if ( tangent !== undefined ) {

			tangent.transformDirection( matrix );

			tangent.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function ( angle ) {

		// rotate geometry around world x-axis

		_m1$2.makeRotationX( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateY: function ( angle ) {

		// rotate geometry around world y-axis

		_m1$2.makeRotationY( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	rotateZ: function ( angle ) {

		// rotate geometry around world z-axis

		_m1$2.makeRotationZ( angle );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	translate: function ( x, y, z ) {

		// translate geometry

		_m1$2.makeTranslation( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	scale: function ( x, y, z ) {

		// scale geometry

		_m1$2.makeScale( x, y, z );

		this.applyMatrix4( _m1$2 );

		return this;

	},

	lookAt: function ( vector ) {

		_obj.lookAt( vector );

		_obj.updateMatrix();

		this.applyMatrix4( _obj.matrix );

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		this.boundingBox.getCenter( _offset ).negate();

		this.translate( _offset.x, _offset.y, _offset.z );

		return this;

	},

	setFromPoints: function ( points ) {

		const position = [];

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			const point = points[ i ];
			position.push( point.x, point.y, point.z || 0 );

		}

		this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingBox.set(
				new Vector3$1( - Infinity, - Infinity, - Infinity ),
				new Vector3$1( + Infinity, + Infinity, + Infinity )
			);

			return;

		}

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_box$2.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( this.boundingBox.min, _box$2.min );
						this.boundingBox.expandByPoint( _vector$4 );

						_vector$4.addVectors( this.boundingBox.max, _box$2.max );
						this.boundingBox.expandByPoint( _vector$4 );

					} else {

						this.boundingBox.expandByPoint( _box$2.min );
						this.boundingBox.expandByPoint( _box$2.max );

					}

				}

			}

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere$1();

		}

		const position = this.attributes.position;
		const morphAttributesPosition = this.morphAttributes.position;

		if ( position && position.isGLBufferAttribute ) {

			console.error( 'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".', this );

			this.boundingSphere.set( new Vector3$1(), Infinity );

			return;

		}

		if ( position ) {

			// first, find the center of the bounding sphere

			const center = this.boundingSphere.center;

			_box$2.setFromBufferAttribute( position );

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					_boxMorphTargets.setFromBufferAttribute( morphAttribute );

					if ( this.morphTargetsRelative ) {

						_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
						_box$2.expandByPoint( _vector$4 );

						_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
						_box$2.expandByPoint( _vector$4 );

					} else {

						_box$2.expandByPoint( _boxMorphTargets.min );
						_box$2.expandByPoint( _boxMorphTargets.max );

					}

				}

			}

			_box$2.getCenter( center );

			// second, try to find a boundingSphere with a radius smaller than the
			// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

			let maxRadiusSq = 0;

			for ( let i = 0, il = position.count; i < il; i ++ ) {

				_vector$4.fromBufferAttribute( position, i );

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

			}

			// process morph attributes if present

			if ( morphAttributesPosition ) {

				for ( let i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

					const morphAttribute = morphAttributesPosition[ i ];
					const morphTargetsRelative = this.morphTargetsRelative;

					for ( let j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

						_vector$4.fromBufferAttribute( morphAttribute, j );

						if ( morphTargetsRelative ) {

							_offset.fromBufferAttribute( position, j );
							_vector$4.add( _offset );

						}

						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

					}

				}

			}

			this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

			if ( isNaN( this.boundingSphere.radius ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

			}

		}

	},

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeTangents: function () {

		const index = this.index;
		const attributes = this.attributes;

		// based on http://www.terathon.com/code/tangent.html
		// (per vertex tangents)

		if ( index === null ||
			 attributes.position === undefined ||
			 attributes.normal === undefined ||
			 attributes.uv === undefined ) {

			console.error( 'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)' );
			return;

		}

		const indices = index.array;
		const positions = attributes.position.array;
		const normals = attributes.normal.array;
		const uvs = attributes.uv.array;

		const nVertices = positions.length / 3;

		if ( attributes.tangent === undefined ) {

			this.setAttribute( 'tangent', new BufferAttribute( new Float32Array( 4 * nVertices ), 4 ) );

		}

		const tangents = attributes.tangent.array;

		const tan1 = [], tan2 = [];

		for ( let i = 0; i < nVertices; i ++ ) {

			tan1[ i ] = new Vector3$1();
			tan2[ i ] = new Vector3$1();

		}

		const vA = new Vector3$1(),
			vB = new Vector3$1(),
			vC = new Vector3$1(),

			uvA = new Vector2(),
			uvB = new Vector2(),
			uvC = new Vector2(),

			sdir = new Vector3$1(),
			tdir = new Vector3$1();

		function handleTriangle( a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			uvA.fromArray( uvs, a * 2 );
			uvB.fromArray( uvs, b * 2 );
			uvC.fromArray( uvs, c * 2 );

			vB.sub( vA );
			vC.sub( vA );

			uvB.sub( uvA );
			uvC.sub( uvA );

			const r = 1.0 / ( uvB.x * uvC.y - uvC.x * uvB.y );

			// silently ignore degenerate uv triangles having coincident or colinear vertices

			if ( ! isFinite( r ) ) return;

			sdir.copy( vB ).multiplyScalar( uvC.y ).addScaledVector( vC, - uvB.y ).multiplyScalar( r );
			tdir.copy( vC ).multiplyScalar( uvB.x ).addScaledVector( vB, - uvC.x ).multiplyScalar( r );

			tan1[ a ].add( sdir );
			tan1[ b ].add( sdir );
			tan1[ c ].add( sdir );

			tan2[ a ].add( tdir );
			tan2[ b ].add( tdir );
			tan2[ c ].add( tdir );

		}

		let groups = this.groups;

		if ( groups.length === 0 ) {

			groups = [ {
				start: 0,
				count: indices.length
			} ];

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleTriangle(
					indices[ j + 0 ],
					indices[ j + 1 ],
					indices[ j + 2 ]
				);

			}

		}

		const tmp = new Vector3$1(), tmp2 = new Vector3$1();
		const n = new Vector3$1(), n2 = new Vector3$1();

		function handleVertex( v ) {

			n.fromArray( normals, v * 3 );
			n2.copy( n );

			const t = tan1[ v ];

			// Gram-Schmidt orthogonalize

			tmp.copy( t );
			tmp.sub( n.multiplyScalar( n.dot( t ) ) ).normalize();

			// Calculate handedness

			tmp2.crossVectors( n2, t );
			const test = tmp2.dot( tan2[ v ] );
			const w = ( test < 0.0 ) ? - 1.0 : 1.0;

			tangents[ v * 4 ] = tmp.x;
			tangents[ v * 4 + 1 ] = tmp.y;
			tangents[ v * 4 + 2 ] = tmp.z;
			tangents[ v * 4 + 3 ] = w;

		}

		for ( let i = 0, il = groups.length; i < il; ++ i ) {

			const group = groups[ i ];

			const start = group.start;
			const count = group.count;

			for ( let j = start, jl = start + count; j < jl; j += 3 ) {

				handleVertex( indices[ j + 0 ] );
				handleVertex( indices[ j + 1 ] );
				handleVertex( indices[ j + 2 ] );

			}

		}

	},

	computeVertexNormals: function () {

		const index = this.index;
		const positionAttribute = this.getAttribute( 'position' );

		if ( positionAttribute !== undefined ) {

			let normalAttribute = this.getAttribute( 'normal' );

			if ( normalAttribute === undefined ) {

				normalAttribute = new BufferAttribute( new Float32Array( positionAttribute.count * 3 ), 3 );
				this.setAttribute( 'normal', normalAttribute );

			} else {

				// reset existing normals to zero

				for ( let i = 0, il = normalAttribute.count; i < il; i ++ ) {

					normalAttribute.setXYZ( i, 0, 0, 0 );

				}

			}

			const pA = new Vector3$1(), pB = new Vector3$1(), pC = new Vector3$1();
			const nA = new Vector3$1(), nB = new Vector3$1(), nC = new Vector3$1();
			const cb = new Vector3$1(), ab = new Vector3$1();

			// indexed elements

			if ( index ) {

				for ( let i = 0, il = index.count; i < il; i += 3 ) {

					const vA = index.getX( i + 0 );
					const vB = index.getX( i + 1 );
					const vC = index.getX( i + 2 );

					pA.fromBufferAttribute( positionAttribute, vA );
					pB.fromBufferAttribute( positionAttribute, vB );
					pC.fromBufferAttribute( positionAttribute, vC );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					nA.fromBufferAttribute( normalAttribute, vA );
					nB.fromBufferAttribute( normalAttribute, vB );
					nC.fromBufferAttribute( normalAttribute, vC );

					nA.add( cb );
					nB.add( cb );
					nC.add( cb );

					normalAttribute.setXYZ( vA, nA.x, nA.y, nA.z );
					normalAttribute.setXYZ( vB, nB.x, nB.y, nB.z );
					normalAttribute.setXYZ( vC, nC.x, nC.y, nC.z );

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( let i = 0, il = positionAttribute.count; i < il; i += 3 ) {

					pA.fromBufferAttribute( positionAttribute, i + 0 );
					pB.fromBufferAttribute( positionAttribute, i + 1 );
					pC.fromBufferAttribute( positionAttribute, i + 2 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normalAttribute.setXYZ( i + 0, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 1, cb.x, cb.y, cb.z );
					normalAttribute.setXYZ( i + 2, cb.x, cb.y, cb.z );

				}

			}

			this.normalizeNormals();

			normalAttribute.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ! ( geometry && geometry.isBufferGeometry ) ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) {

			offset = 0;

			console.warn(
				'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
				+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
			);

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			const attribute1 = attributes[ key ];
			const attributeArray1 = attribute1.array;

			const attribute2 = geometry.attributes[ key ];
			const attributeArray2 = attribute2.array;

			const attributeOffset = attribute2.itemSize * offset;
			const length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

			for ( let i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		const normals = this.attributes.normal;

		for ( let i = 0, il = normals.count; i < il; i ++ ) {

			_vector$4.fromBufferAttribute( normals, i );

			_vector$4.normalize();

			normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

		}

	},

	toNonIndexed: function () {

		function convertBufferAttribute( attribute, indices ) {

			const array = attribute.array;
			const itemSize = attribute.itemSize;
			const normalized = attribute.normalized;

			const array2 = new array.constructor( indices.length * itemSize );

			let index = 0, index2 = 0;

			for ( let i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( let j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			return new BufferAttribute( array2, itemSize, normalized );

		}

		//

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.' );
			return this;

		}

		const geometry2 = new BufferGeometry();

		const indices = this.index.array;
		const attributes = this.attributes;

		// attributes

		for ( const name in attributes ) {

			const attribute = attributes[ name ];

			const newAttribute = convertBufferAttribute( attribute, indices );

			geometry2.setAttribute( name, newAttribute );

		}

		// morph attributes

		const morphAttributes = this.morphAttributes;

		for ( const name in morphAttributes ) {

			const morphArray = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, il = morphAttribute.length; i < il; i ++ ) {

				const attribute = morphAttribute[ i ];

				const newAttribute = convertBufferAttribute( attribute, indices );

				morphArray.push( newAttribute );

			}

			geometry2.morphAttributes[ name ] = morphArray;

		}

		geometry2.morphTargetsRelative = this.morphTargetsRelative;

		// groups

		const groups = this.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			geometry2.addGroup( group.start, group.count, group.materialIndex );

		}

		return geometry2;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;
		if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

		if ( this.parameters !== undefined ) {

			const parameters = this.parameters;

			for ( const key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		const index = this.index;

		if ( index !== null ) {

			data.data.index = {
				type: index.array.constructor.name,
				array: Array.prototype.slice.call( index.array )
			};

		}

		const attributes = this.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const attributeData = attribute.toJSON( data.data );

			if ( attribute.name !== '' ) attributeData.name = attribute.name;

			data.data.attributes[ key ] = attributeData;

		}

		const morphAttributes = {};
		let hasMorphAttributes = false;

		for ( const key in this.morphAttributes ) {

			const attributeArray = this.morphAttributes[ key ];

			const array = [];

			for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

				const attribute = attributeArray[ i ];

				const attributeData = attribute.toJSON( data.data );

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				array.push( attributeData );

			}

			if ( array.length > 0 ) {

				morphAttributes[ key ] = array;

				hasMorphAttributes = true;

			}

		}

		if ( hasMorphAttributes ) {

			data.data.morphAttributes = morphAttributes;
			data.data.morphTargetsRelative = this.morphTargetsRelative;

		}

		const groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		const boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		 // Handle primitives

		 const parameters = this.parameters;

		 if ( parameters !== undefined ) {

		 const values = [];

		 for ( const key in parameters ) {

		 values.push( parameters[ key ] );

		 }

		 const geometry = Object.create( this.constructor.prototype );
		 this.constructor.apply( geometry, values );
		 return geometry;

		 }

		 return new this.constructor().copy( this );
		 */

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		// reset

		this.index = null;
		this.attributes = {};
		this.morphAttributes = {};
		this.groups = [];
		this.boundingBox = null;
		this.boundingSphere = null;

		// used for storing cloned, shared data

		const data = {};

		// name

		this.name = source.name;

		// index

		const index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone( data ) );

		}

		// attributes

		const attributes = source.attributes;

		for ( const name in attributes ) {

			const attribute = attributes[ name ];
			this.setAttribute( name, attribute.clone( data ) );

		}

		// morph attributes

		const morphAttributes = source.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = [];
			const morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

			for ( let i = 0, l = morphAttribute.length; i < l; i ++ ) {

				array.push( morphAttribute[ i ].clone( data ) );

			}

			this.morphAttributes[ name ] = array;

		}

		this.morphTargetsRelative = source.morphTargetsRelative;

		// groups

		const groups = source.groups;

		for ( let i = 0, l = groups.length; i < l; i ++ ) {

			const group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		// bounding box

		const boundingBox = source.boundingBox;

		if ( boundingBox !== null ) {

			this.boundingBox = boundingBox.clone();

		}

		// bounding sphere

		const boundingSphere = source.boundingSphere;

		if ( boundingSphere !== null ) {

			this.boundingSphere = boundingSphere.clone();

		}

		// draw range

		this.drawRange.start = source.drawRange.start;
		this.drawRange.count = source.drawRange.count;

		// user data

		this.userData = source.userData;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

const _inverseMatrix = new Matrix4();
const _ray = new Ray();
const _sphere = new Sphere$1();

const _vA$1 = new Vector3$1();
const _vB$1 = new Vector3$1();
const _vC$1 = new Vector3$1();

const _tempA = new Vector3$1();
const _tempB = new Vector3$1();
const _tempC = new Vector3$1();

const _morphA = new Vector3$1();
const _morphB = new Vector3$1();
const _morphC = new Vector3$1();

const _uvA = new Vector2();
const _uvB = new Vector2();
const _uvC = new Vector2();

const _intersectionPoint = new Vector3$1();
const _intersectionPointWorld = new Vector3$1();

function Mesh( geometry = new BufferGeometry(), material = new MeshBasicMaterial() ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		if ( source.morphTargetInfluences !== undefined ) {

			this.morphTargetInfluences = source.morphTargetInfluences.slice();

		}

		if ( source.morphTargetDictionary !== undefined ) {

			this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

		}

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const material = this.material;
		const matrixWorld = this.matrixWorld;

		if ( material === undefined ) return;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere );
		_sphere.applyMatrix4( matrixWorld );

		if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

		//

		_inverseMatrix.copy( matrixWorld ).invert();
		_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

		// Check boundingBox before continuing

		if ( geometry.boundingBox !== null ) {

			if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

		}

		let intersection;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const position = geometry.attributes.position;
			const morphPosition = geometry.morphAttributes.position;
			const morphTargetsRelative = geometry.morphTargetsRelative;
			const uv = geometry.attributes.uv;
			const uv2 = geometry.attributes.uv2;
			const groups = geometry.groups;
			const drawRange = geometry.drawRange;

			if ( index !== null ) {

				// indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = index.getX( j );
							const b = index.getX( j + 1 );
							const c = index.getX( j + 2 );

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = index.getX( i );
						const b = index.getX( i + 1 );
						const c = index.getX( i + 2 );

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( position !== undefined ) {

				// non-indexed buffer geometry

				if ( Array.isArray( material ) ) {

					for ( let i = 0, il = groups.length; i < il; i ++ ) {

						const group = groups[ i ];
						const groupMaterial = material[ group.materialIndex ];

						const start = Math.max( group.start, drawRange.start );
						const end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

						for ( let j = start, jl = end; j < jl; j += 3 ) {

							const a = j;
							const b = j + 1;
							const c = j + 2;

							intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
								intersection.face.materialIndex = group.materialIndex;
								intersects.push( intersection );

							}

						}

					}

				} else {

					const start = Math.max( 0, drawRange.start );
					const end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

					for ( let i = start, il = end; i < il; i += 3 ) {

						const a = i;
						const b = i + 1;
						const c = i + 2;

						intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
							intersects.push( intersection );

						}

					}

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	}

} );

function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

	let intersect;

	if ( material.side === BackSide ) {

		intersect = ray.intersectTriangle( pC, pB, pA, true, point );

	} else {

		intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

	}

	if ( intersect === null ) return null;

	_intersectionPointWorld.copy( point );
	_intersectionPointWorld.applyMatrix4( object.matrixWorld );

	const distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

	if ( distance < raycaster.near || distance > raycaster.far ) return null;

	return {
		distance: distance,
		point: _intersectionPointWorld.clone(),
		object: object
	};

}

function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

	_vA$1.fromBufferAttribute( position, a );
	_vB$1.fromBufferAttribute( position, b );
	_vC$1.fromBufferAttribute( position, c );

	const morphInfluences = object.morphTargetInfluences;

	if ( material.morphTargets && morphPosition && morphInfluences ) {

		_morphA.set( 0, 0, 0 );
		_morphB.set( 0, 0, 0 );
		_morphC.set( 0, 0, 0 );

		for ( let i = 0, il = morphPosition.length; i < il; i ++ ) {

			const influence = morphInfluences[ i ];
			const morphAttribute = morphPosition[ i ];

			if ( influence === 0 ) continue;

			_tempA.fromBufferAttribute( morphAttribute, a );
			_tempB.fromBufferAttribute( morphAttribute, b );
			_tempC.fromBufferAttribute( morphAttribute, c );

			if ( morphTargetsRelative ) {

				_morphA.addScaledVector( _tempA, influence );
				_morphB.addScaledVector( _tempB, influence );
				_morphC.addScaledVector( _tempC, influence );

			} else {

				_morphA.addScaledVector( _tempA.sub( _vA$1 ), influence );
				_morphB.addScaledVector( _tempB.sub( _vB$1 ), influence );
				_morphC.addScaledVector( _tempC.sub( _vC$1 ), influence );

			}

		}

		_vA$1.add( _morphA );
		_vB$1.add( _morphB );
		_vC$1.add( _morphC );

	}

	if ( object.isSkinnedMesh && material.skinning ) {

		object.boneTransform( a, _vA$1 );
		object.boneTransform( b, _vB$1 );
		object.boneTransform( c, _vC$1 );

	}

	const intersection = checkIntersection( object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint );

	if ( intersection ) {

		if ( uv ) {

			_uvA.fromBufferAttribute( uv, a );
			_uvB.fromBufferAttribute( uv, b );
			_uvC.fromBufferAttribute( uv, c );

			intersection.uv = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA, _uvB, _uvC, new Vector2() );

		}

		if ( uv2 ) {

			_uvA.fromBufferAttribute( uv2, a );
			_uvB.fromBufferAttribute( uv2, b );
			_uvC.fromBufferAttribute( uv2, c );

			intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA$1, _vB$1, _vC$1, _uvA, _uvB, _uvC, new Vector2() );

		}

		const face = {
			a: a,
			b: a,
			c: c,
			normal: new Vector3$1(),
			materialIndex: 0
		};

		Triangle.getNormal( _vA$1, _vB$1, _vC$1, face.normal );

		intersection.face = face;

	}

	return intersection;

}

class BoxGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1 ) {

		super();

		this.type = 'BoxGeometry';

		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};

		const scope = this;

		// segments

		widthSegments = Math.floor( widthSegments );
		heightSegments = Math.floor( heightSegments );
		depthSegments = Math.floor( depthSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let numberOfVertices = 0;
		let groupStart = 0;

		// build each side of the box geometry

		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

			const segmentWidth = width / gridX;
			const segmentHeight = height / gridY;

			const widthHalf = width / 2;
			const heightHalf = height / 2;
			const depthHalf = depth / 2;

			const gridX1 = gridX + 1;
			const gridY1 = gridY + 1;

			let vertexCounter = 0;
			let groupCount = 0;

			const vector = new Vector3$1();

			// generate vertices, normals and uvs

			for ( let iy = 0; iy < gridY1; iy ++ ) {

				const y = iy * segmentHeight - heightHalf;

				for ( let ix = 0; ix < gridX1; ix ++ ) {

					const x = ix * segmentWidth - widthHalf;

					// set values to correct vector component

					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;

					// now apply vector to vertex buffer

					vertices.push( vector.x, vector.y, vector.z );

					// set values to correct vector component

					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;

					// now apply vector to normal buffer

					normals.push( vector.x, vector.y, vector.z );

					// uvs

					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );

					// counters

					vertexCounter += 1;

				}

			}

			// indices

			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment

			for ( let iy = 0; iy < gridY; iy ++ ) {

				for ( let ix = 0; ix < gridX; ix ++ ) {

					const a = numberOfVertices + ix + gridX1 * iy;
					const b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					const c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					const d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// increase counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, materialIndex );

			// calculate new start value for groups

			groupStart += groupCount;

			// update total number of vertices

			numberOfVertices += vertexCounter;

		}

	}

}

/**
 * Uniform Utilities
 */

function cloneUniforms( src ) {

	const dst = {};

	for ( const u in src ) {

		dst[ u ] = {};

		for ( const p in src[ u ] ) {

			const property = src[ u ][ p ];

			if ( property && ( property.isColor ||
				property.isMatrix3 || property.isMatrix4 ||
				property.isVector2 || property.isVector3 || property.isVector4 ||
				property.isTexture || property.isQuaternion ) ) {

				dst[ u ][ p ] = property.clone();

			} else if ( Array.isArray( property ) ) {

				dst[ u ][ p ] = property.slice();

			} else {

				dst[ u ][ p ] = property;

			}

		}

	}

	return dst;

}

function mergeUniforms( uniforms ) {

	const merged = {};

	for ( let u = 0; u < uniforms.length; u ++ ) {

		const tmp = cloneUniforms( uniforms[ u ] );

		for ( const p in tmp ) {

			merged[ p ] = tmp[ p ];

		}

	}

	return merged;

}

// Legacy

const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";

var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";

/**
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = default_vertex;
	this.fragmentShader = default_fragment;

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;
	this.uniformsNeedUpdate = false;

	this.glslVersion = null;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = cloneUniforms( source.uniforms );

	this.defines = Object.assign( {}, source.defines );

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = Object.assign( {}, source.extensions );

	this.glslVersion = source.glslVersion;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	const data = Material.prototype.toJSON.call( this, meta );

	data.glslVersion = this.glslVersion;
	data.uniforms = {};

	for ( const name in this.uniforms ) {

		const uniform = this.uniforms[ name ];
		const value = uniform.value;

		if ( value && value.isTexture ) {

			data.uniforms[ name ] = {
				type: 't',
				value: value.toJSON( meta ).uuid
			};

		} else if ( value && value.isColor ) {

			data.uniforms[ name ] = {
				type: 'c',
				value: value.getHex()
			};

		} else if ( value && value.isVector2 ) {

			data.uniforms[ name ] = {
				type: 'v2',
				value: value.toArray()
			};

		} else if ( value && value.isVector3 ) {

			data.uniforms[ name ] = {
				type: 'v3',
				value: value.toArray()
			};

		} else if ( value && value.isVector4 ) {

			data.uniforms[ name ] = {
				type: 'v4',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix3 ) {

			data.uniforms[ name ] = {
				type: 'm3',
				value: value.toArray()
			};

		} else if ( value && value.isMatrix4 ) {

			data.uniforms[ name ] = {
				type: 'm4',
				value: value.toArray()
			};

		} else {

			data.uniforms[ name ] = {
				value: value
			};

			// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

		}

	}

	if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	const extensions = {};

	for ( const key in this.extensions ) {

		if ( this.extensions[ key ] === true ) extensions[ key ] = true;

	}

	if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

	return data;

};

function Camera$1() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();

	this.projectionMatrix = new Matrix4();
	this.projectionMatrixInverse = new Matrix4();

}

Camera$1.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Camera$1,

	isCamera: true,

	copy: function ( source, recursive ) {

		Object3D.prototype.copy.call( this, source, recursive );

		this.matrixWorldInverse.copy( source.matrixWorldInverse );

		this.projectionMatrix.copy( source.projectionMatrix );
		this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

		return this;

	},

	getWorldDirection: function ( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
			target = new Vector3$1();

		}

		this.updateWorldMatrix( true, false );

		const e = this.matrixWorld.elements;

		return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

	},

	updateMatrixWorld: function ( force ) {

		Object3D.prototype.updateMatrixWorld.call( this, force );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	updateWorldMatrix: function ( updateParents, updateChildren ) {

		Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

		this.matrixWorldInverse.copy( this.matrixWorld ).invert();

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

} );

function PerspectiveCamera( fov = 50, aspect = 1, near = 0.1, far = 2000 ) {

	Camera$1.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov;
	this.zoom = 1;

	this.near = near;
	this.far = far;
	this.focus = 10;

	this.aspect = aspect;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera$1.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source, recursive ) {

		Camera$1.prototype.copy.call( this, source, recursive );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		/** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
		const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		const vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return MathUtils.RAD2DEG * 2 * Math.atan(
			Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   const w = 1920;
	 *   const h = 1080;
	 *   const fullWidth = w * 3;
	 *   const fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	},

	clearViewOffset: function () {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		const near = this.near;
		let top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom;
		let height = 2 * top;
		let width = this.aspect * height;
		let left = - 0.5 * width;
		const view = this.view;

		if ( this.view !== null && this.view.enabled ) {

			const fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		const skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	},

	toJSON: function ( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

const fov = 90, aspect = 1;

class CubeCamera extends Object3D {

	constructor( near, far, renderTarget ) {

		super();

		this.type = 'CubeCamera';

		if ( renderTarget.isWebGLCubeRenderTarget !== true ) {

			console.error( 'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.' );
			return;

		}

		this.renderTarget = renderTarget;

		const cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.layers = this.layers;
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3$1( 1, 0, 0 ) );
		this.add( cameraPX );

		const cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.layers = this.layers;
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3$1( - 1, 0, 0 ) );
		this.add( cameraNX );

		const cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.layers = this.layers;
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3$1( 0, 1, 0 ) );
		this.add( cameraPY );

		const cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.layers = this.layers;
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3$1( 0, - 1, 0 ) );
		this.add( cameraNY );

		const cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.layers = this.layers;
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3$1( 0, 0, 1 ) );
		this.add( cameraPZ );

		const cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.layers = this.layers;
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3$1( 0, 0, - 1 ) );
		this.add( cameraNZ );

	}

	update( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		const renderTarget = this.renderTarget;

		const [ cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ ] = this.children;

		const currentXrEnabled = renderer.xr.enabled;
		const currentRenderTarget = renderer.getRenderTarget();

		renderer.xr.enabled = false;

		const generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderer.setRenderTarget( renderTarget, 0 );
		renderer.render( scene, cameraPX );

		renderer.setRenderTarget( renderTarget, 1 );
		renderer.render( scene, cameraNX );

		renderer.setRenderTarget( renderTarget, 2 );
		renderer.render( scene, cameraPY );

		renderer.setRenderTarget( renderTarget, 3 );
		renderer.render( scene, cameraNY );

		renderer.setRenderTarget( renderTarget, 4 );
		renderer.render( scene, cameraPZ );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderer.setRenderTarget( renderTarget, 5 );
		renderer.render( scene, cameraNZ );

		renderer.setRenderTarget( currentRenderTarget );

		renderer.xr.enabled = currentXrEnabled;

	}

}

class CubeTexture extends Texture {

	constructor( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
		format = format !== undefined ? format : RGBFormat;

		super( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		// Why CubeTexture._needsFlipEnvMap is necessary:
		//
		// By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
		// in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
		// in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

		// three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
		// and the flag _needsFlipEnvMap controls this conversion. The flip is not required (and thus _needsFlipEnvMap is set to false)
		// when using WebGLCubeRenderTarget.texture as a cube texture.

		this._needsFlipEnvMap = true;

		this.flipY = false;

	}

	get images() {

		return this.image;

	}

	set images( value ) {

		this.image = value;

	}

}

CubeTexture.prototype.isCubeTexture = true;

class WebGLCubeRenderTarget extends WebGLRenderTarget {

	constructor( size, options, dummy ) {

		if ( Number.isInteger( options ) ) {

			console.warn( 'THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )' );

			options = dummy;

		}

		super( size, size, options );

		options = options || {};

		this.texture = new CubeTexture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.texture._needsFlipEnvMap = false;

	}

	fromEquirectangularTexture( renderer, texture ) {

		this.texture.type = texture.type;
		this.texture.format = RGBAFormat; // see #18859
		this.texture.encoding = texture.encoding;

		this.texture.generateMipmaps = texture.generateMipmaps;
		this.texture.minFilter = texture.minFilter;
		this.texture.magFilter = texture.magFilter;

		const shader = {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,

			fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
		};

		const geometry = new BoxGeometry( 5, 5, 5 );

		const material = new ShaderMaterial( {

			name: 'CubemapFromEquirect',

			uniforms: cloneUniforms( shader.uniforms ),
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader,
			side: BackSide,
			blending: NoBlending

		} );

		material.uniforms.tEquirect.value = texture;

		const mesh = new Mesh( geometry, material );

		const currentMinFilter = texture.minFilter;

		// Avoid blurred poles
		if ( texture.minFilter === LinearMipmapLinearFilter ) texture.minFilter = LinearFilter;

		const camera = new CubeCamera( 1, 10, this );
		camera.update( renderer, mesh );

		texture.minFilter = currentMinFilter;

		mesh.geometry.dispose();
		mesh.material.dispose();

		return this;

	}

	clear( renderer, color, depth, stencil ) {

		const currentRenderTarget = renderer.getRenderTarget();

		for ( let i = 0; i < 6; i ++ ) {

			renderer.setRenderTarget( this, i );

			renderer.clear( color, depth, stencil );

		}

		renderer.setRenderTarget( currentRenderTarget );

	}

}

WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget = true;

class DataTexture extends Texture {

	constructor( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data || null, width: width || 1, height: height || 1 };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

}

DataTexture.prototype.isDataTexture = true;

const _sphere$1 = /*@__PURE__*/ new Sphere$1();
const _vector$5 = /*@__PURE__*/ new Vector3$1();

class Frustum$1 {

	constructor( p0 = new Plane$1(), p1 = new Plane$1(), p2 = new Plane$1(), p3 = new Plane$1(), p4 = new Plane$1(), p5 = new Plane$1() ) {

		this.planes = [ p0, p1, p2, p3, p4, p5 ];

	}

	set( p0, p1, p2, p3, p4, p5 ) {

		const planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	}

	copy( frustum ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	}

	setFromProjectionMatrix( m ) {

		const planes = this.planes;
		const me = m.elements;
		const me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		const me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		const me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		const me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	}

	intersectsObject( object ) {

		const geometry = object.geometry;

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	}

	intersectsSprite( sprite ) {

		_sphere$1.center.set( 0, 0, 0 );
		_sphere$1.radius = 0.7071067811865476;
		_sphere$1.applyMatrix4( sprite.matrixWorld );

		return this.intersectsSphere( _sphere$1 );

	}

	intersectsSphere( sphere ) {

		const planes = this.planes;
		const center = sphere.center;
		const negRadius = - sphere.radius;

		for ( let i = 0; i < 6; i ++ ) {

			const distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	}

	intersectsBox( box ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			const plane = planes[ i ];

			// corner at max distance

			_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
			_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
			_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

			if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	containsPoint( point ) {

		const planes = this.planes;

		for ( let i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function WebGLAnimation() {

	let context = null;
	let isAnimating = false;
	let animationLoop = null;
	let requestId = null;

	function onAnimationFrame( time, frame ) {

		animationLoop( time, frame );

		requestId = context.requestAnimationFrame( onAnimationFrame );

	}

	return {

		start: function () {

			if ( isAnimating === true ) return;
			if ( animationLoop === null ) return;

			requestId = context.requestAnimationFrame( onAnimationFrame );

			isAnimating = true;

		},

		stop: function () {

			context.cancelAnimationFrame( requestId );

			isAnimating = false;

		},

		setAnimationLoop: function ( callback ) {

			animationLoop = callback;

		},

		setContext: function ( value ) {

			context = value;

		}

	};

}

function WebGLAttributes( gl, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	const buffers = new WeakMap();

	function createBuffer( attribute, bufferType ) {

		const array = attribute.array;
		const usage = attribute.usage;

		const buffer = gl.createBuffer();

		gl.bindBuffer( bufferType, buffer );
		gl.bufferData( bufferType, array, usage );

		attribute.onUploadCallback();

		let type = 5126;

		if ( array instanceof Float32Array ) {

			type = 5126;

		} else if ( array instanceof Float64Array ) {

			console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

		} else if ( array instanceof Uint16Array ) {

			if ( attribute.isFloat16BufferAttribute ) {

				if ( isWebGL2 ) {

					type = 5131;

				} else {

					console.warn( 'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.' );

				}

			} else {

				type = 5123;

			}

		} else if ( array instanceof Int16Array ) {

			type = 5122;

		} else if ( array instanceof Uint32Array ) {

			type = 5125;

		} else if ( array instanceof Int32Array ) {

			type = 5124;

		} else if ( array instanceof Int8Array ) {

			type = 5120;

		} else if ( array instanceof Uint8Array ) {

			type = 5121;

		}

		return {
			buffer: buffer,
			type: type,
			bytesPerElement: array.BYTES_PER_ELEMENT,
			version: attribute.version
		};

	}

	function updateBuffer( buffer, attribute, bufferType ) {

		const array = attribute.array;
		const updateRange = attribute.updateRange;

		gl.bindBuffer( bufferType, buffer );

		if ( updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, array );

		} else {

			if ( isWebGL2 ) {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array, updateRange.offset, updateRange.count );

			} else {

				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

			}

			updateRange.count = - 1; // reset range

		}

	}

	//

	function get( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		return buffers.get( attribute );

	}

	function remove( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data ) {

			gl.deleteBuffer( data.buffer );

			buffers.delete( attribute );

		}

	}

	function update( attribute, bufferType ) {

		if ( attribute.isGLBufferAttribute ) {

			const cached = buffers.get( attribute );

			if ( ! cached || cached.version < attribute.version ) {

				buffers.set( attribute, {
					buffer: attribute.buffer,
					type: attribute.type,
					bytesPerElement: attribute.elementSize,
					version: attribute.version
				} );

			}

			return;

		}

		if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

		const data = buffers.get( attribute );

		if ( data === undefined ) {

			buffers.set( attribute, createBuffer( attribute, bufferType ) );

		} else if ( data.version < attribute.version ) {

			updateBuffer( data.buffer, attribute, bufferType );

			data.version = attribute.version;

		}

	}

	return {

		get: get,
		remove: remove,
		update: update

	};

}

class PlaneGeometry extends BufferGeometry {

	constructor( width = 1, height = 1, widthSegments = 1, heightSegments = 1 ) {

		super();
		this.type = 'PlaneGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		const width_half = width / 2;
		const height_half = height / 2;

		const gridX = Math.floor( widthSegments );
		const gridY = Math.floor( heightSegments );

		const gridX1 = gridX + 1;
		const gridY1 = gridY + 1;

		const segment_width = width / gridX;
		const segment_height = height / gridY;

		//

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		for ( let iy = 0; iy < gridY1; iy ++ ) {

			const y = iy * segment_height - height_half;

			for ( let ix = 0; ix < gridX1; ix ++ ) {

				const x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		for ( let iy = 0; iy < gridY; iy ++ ) {

			for ( let ix = 0; ix < gridX; ix ++ ) {

				const a = ix + gridX1 * iy;
				const b = ix + gridX1 * ( iy + 1 );
				const c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				const d = ( ix + 1 ) + gridX1 * iy;

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "vec3 transformed = vec3( position );";

var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif";

var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + viewDir );\n\tfloat dotNL = saturate( dot( normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie(float roughness, float NoH) {\n\tfloat invAlpha = 1.0 / roughness;\n\tfloat cos2h = NoH * NoH;\n\tfloat sin2h = max(1.0 - cos2h, 0.0078125);\treturn (2.0 + invAlpha) * pow(sin2h, invAlpha * 0.5) / (2.0 * PI);\n}\nfloat V_Neubelt(float NoV, float NoL) {\n\treturn saturate(1.0 / (4.0 * (NoL + NoV - NoL * NoV)));\n}\nvec3 BRDF_Specular_Sheen( const in float roughness, const in vec3 L, const in GeometricContext geometry, vec3 specularColor ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 H = normalize( V + L );\n\tfloat dotNH = saturate( dot( N, H ) );\n\treturn specularColor * D_Charlie( roughness, dotNH ) * V_Neubelt( dot(N, V), dot(N, L) );\n}\n#endif";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_pars_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#if defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor.xyz *= color.xyz;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif";

var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat max3( vec3 v ) { return max( max( v.x, v.y ), v.z ); }\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\tfloat texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\t\tvec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );\n\t\tvec2 f = fract( uv );\n\t\tuv += 0.5 - f;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tif ( mipInt < cubeUV_maxMipLevel ) {\n\t\t\tuv.y += 2.0 * cubeUV_maxTileSize;\n\t\t}\n\t\tuv.y += filterInt * 2.0 * cubeUV_minTileSize;\n\t\tuv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\t\tuv *= texelSize;\n\t\tvec3 tl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x += texelSize;\n\t\tvec3 tr = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.y += texelSize;\n\t\tvec3 br = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tuv.x -= texelSize;\n\t\tvec3 bl = envMapTexelToLinear( texture2D( envMap, uv ) ).rgb;\n\t\tvec3 tm = mix( tl, tr, f.x );\n\t\tvec3 bm = mix( bl, br, f.x );\n\t\treturn mix( tm, bm, f.y );\n\t}\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= r1 ) {\n\t\t\tmip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\t\t} else if ( roughness >= r4 ) {\n\t\t\tmip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\t\t} else if ( roughness >= r5 ) {\n\t\t\tmip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\t\t} else if ( roughness >= r6 ) {\n\t\t\tmip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif";

var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";

var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = clamp( floor( D ) / 255.0, 0.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value ) {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\tenvColor = envMapTexelToLinear( envColor );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";

var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif";

var envmap_pars_fragment = "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";

var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = - mvPosition.z;\n#endif";

var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn texture2D( gradientMap, coord ).rgb;\n\t#else\n\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t#endif\n}";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\treflectedLight.indirectDiffuse += PI * lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n#endif";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry );\n#ifdef DOUBLE_SIDED\n\tvIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n\tvIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry );\n#endif\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n#endif";

var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";

var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP )\n\t#ifdef ENVMAP_MODE_REFRACTION\n\t\tuniform float refractionRatio;\n\t#endif\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float roughness, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat sigma = PI * roughness * roughness / ( 1.0 + roughness );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + log2( sigma );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -viewDir, normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( roughness, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";

var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";

var lights_toon_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.specularRoughness = max( roughnessFactor, 0.0525 );material.specularRoughness += geometryRoughness;\nmaterial.specularRoughness = min( material.specularRoughness, 1.0 );\n#ifdef REFLECTIVITY\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#endif\n#ifdef CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheen;\n#endif";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat specularRoughness;\n\tvec3 specularColor;\n#ifdef CLEARCOAT\n\tfloat clearcoat;\n\tfloat clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tvec3 sheenColor;\n#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearcoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNL = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = ccDotNL * directLight.color;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tccIrradiance *= PI;\n\t\t#endif\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t\treflectedLight.directSpecular += ccIrradiance * material.clearcoat * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_Sheen(\n\t\t\tmaterial.specularRoughness,\n\t\t\tdirectLight.direction,\n\t\t\tgeometry,\n\t\t\tmaterial.sheenColor\n\t\t);\n\t#else\n\t\treflectedLight.directSpecular += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry.viewDir, geometry.normal, material.specularColor, material.specularRoughness);\n\t#endif\n\treflectedLight.directDiffuse += ( 1.0 - clearcoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef CLEARCOAT\n\t\tfloat ccDotNV = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular += clearcoatRadiance * material.clearcoat * BRDF_Specular_GGX_Environment( geometry.viewDir, geometry.clearcoatNormal, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearcoatRoughness );\n\t\tfloat ccDotNL = ccDotNV;\n\t\tfloat clearcoatDHR = material.clearcoat * clearcoatDHRApprox( material.clearcoatRoughness, ccDotNL );\n\t#else\n\t\tfloat clearcoatDHR = 0.0;\n\t#endif\n\tfloat clearcoatInv = 1.0 - clearcoatDHR;\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\treflectedLight.indirectSpecular += clearcoatInv * radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";

var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif";

var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance = lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.normal, material.specularRoughness, maxMipLevel );\n\t#ifdef CLEARCOAT\n\t\tclearcoatRadiance += getLightProbeIndirectRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness, maxMipLevel );\n\t#endif\n#endif";

var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif";

var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";

var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";

var map_particle_pars_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n#endif";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifndef USE_MORPHNORMALS\n\t\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\t\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";

var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * faceDirection;\n\t\t\tbitangent = bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal = normal;";

var normal_fragment_maps = "#ifdef OBJECTSPACE_NORMALMAP\n\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal = normalize( vTBN * mapN );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif";

var clearcoat_normal_fragment_begin = "#ifdef CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif";

var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal = normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif";

var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ));\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w);\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";

var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";

var dithering_fragment = "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";

var dithering_pars_fragment = "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n\t\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform highp sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";

var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";

var transmissionmap_fragment = "#ifdef USE_TRANSMISSIONMAP\n\ttotalTransmission *= texture2D( transmissionMap, vUv ).r;\n#endif";

var transmissionmap_pars_fragment = "#ifdef USE_TRANSMISSIONMAP\n\tuniform sampler2D transmissionMap;\n#endif";

var uv_pars_fragment = "#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif";

var uv_vertex = "#ifdef USE_UV\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif";

var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";

var cube_frag = "#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\tvec3 vReflect = vWorldDirection;\n\t#include <envmap_fragment>\n\tgl_FragColor = envColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}";

var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";

var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";

var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";

var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\n\t\tvec4 lightMapTexel= texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse += lightMapTexelToLinear( lightMapTexel ).rgb * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";

var meshtoon_frag = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshtoon_vert = "#define TOON\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var meshphysical_frag = "#define STANDARD\n#ifdef PHYSICAL\n\t#define REFLECTIVITY\n\t#define CLEARCOAT\n\t#define TRANSMISSION\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef TRANSMISSION\n\tuniform float transmission;\n#endif\n#ifdef REFLECTIVITY\n\tuniform float reflectivity;\n#endif\n#ifdef CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheen;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <transmissionmap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#ifdef TRANSMISSION\n\t\tfloat totalTransmission = transmission;\n\t#endif\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <transmissionmap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#ifdef TRANSMISSION\n\t\tdiffuseColor.a *= mix( saturate( 1. - totalTransmission + linearToRelativeLuminance( reflectedLight.directSpecular + reflectedLight.indirectSpecular ) ), 1.0, metalness );\n\t#endif\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";

var meshphysical_vert = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";

var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var shadow_vert = "#include <common>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";

var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";

var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";

const ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_common_pars_fragment: envmap_common_pars_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_physical_pars_fragment: envmap_physical_pars_fragment,
	envmap_vertex: envmap_vertex,
	fog_vertex: fog_vertex,
	fog_pars_vertex: fog_pars_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars_begin: lights_pars_begin,
	lights_toon_fragment: lights_toon_fragment,
	lights_toon_pars_fragment: lights_toon_pars_fragment,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_fragment_begin: lights_fragment_begin,
	lights_fragment_maps: lights_fragment_maps,
	lights_fragment_end: lights_fragment_end,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_fragment_begin: normal_fragment_begin,
	normal_fragment_maps: normal_fragment_maps,
	normalmap_pars_fragment: normalmap_pars_fragment,
	clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
	clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
	clearcoat_pars_fragment: clearcoat_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	dithering_fragment: dithering_fragment,
	dithering_pars_fragment: dithering_pars_fragment,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	transmissionmap_fragment: transmissionmap_fragment,
	transmissionmap_pars_fragment: transmissionmap_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	background_frag: background_frag,
	background_vert: background_vert,
	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshmatcap_frag: meshmatcap_frag,
	meshmatcap_vert: meshmatcap_vert,
	meshtoon_frag: meshtoon_frag,
	meshtoon_vert: meshtoon_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert,
	sprite_frag: sprite_frag,
	sprite_vert: sprite_vert
};

/**
 * Uniforms library for shared webgl shaders
 */

const UniformsLib = {

	common: {

		diffuse: { value: new Color$1( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		uvTransform: { value: new Matrix3() },
		uv2Transform: { value: new Matrix3() },

		alphaMap: { value: null },

	},

	specularmap: {

		specularMap: { value: null },

	},

	envmap: {

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 },
		maxMipLevel: { value: 0 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color$1( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		lightProbe: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {}
		} },

		directionalLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {}
		} },

		spotLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {}
		} },

		pointLightShadows: { value: [], properties: {
			shadowBias: {},
			shadowNormalBias: {},
			shadowRadius: {},
			shadowMapSize: {},
			shadowCameraNear: {},
			shadowCameraFar: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

		// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
		rectAreaLights: { value: [], properties: {
			color: {},
			position: {},
			width: {},
			height: {}
		} },

		ltc_1: { value: null },
		ltc_2: { value: null }

	},

	points: {

		diffuse: { value: new Color$1( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	},

	sprite: {

		diffuse: { value: new Color$1( 0xeeeeee ) },
		opacity: { value: 1.0 },
		center: { value: new Vector2( 0.5, 0.5 ) },
		rotation: { value: 0.0 },
		map: { value: null },
		alphaMap: { value: null },
		uvTransform: { value: new Matrix3() }

	}

};

const ShaderLib = {

	basic: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.specularmap,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) },
				specular: { value: new Color$1( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.envmap,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) },
				roughness: { value: 1.0 },
				metalness: { value: 0.0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	toon: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color$1( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshtoon_vert,
		fragmentShader: ShaderChunk.meshtoon_frag

	},

	matcap: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.fog,
			{
				matcap: { value: null }
			}
		] ),

		vertexShader: ShaderChunk.meshmatcap_vert,
		fragmentShader: ShaderChunk.meshmatcap_frag

	},

	points: {

		uniforms: mergeUniforms( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	sprite: {

		uniforms: mergeUniforms( [
			UniformsLib.sprite,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.sprite_vert,
		fragmentShader: ShaderChunk.sprite_frag

	},

	background: {

		uniforms: {
			uvTransform: { value: new Matrix3() },
			t2D: { value: null },
		},

		vertexShader: ShaderChunk.background_vert,
		fragmentShader: ShaderChunk.background_frag

	},
	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: mergeUniforms( [
			UniformsLib.envmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	equirect: {

		uniforms: {
			tEquirect: { value: null },
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: mergeUniforms( [
			UniformsLib.common,
			UniformsLib.displacementmap,
			{
				referencePosition: { value: new Vector3$1() },
				nearDistance: { value: 1 },
				farDistance: { value: 1000 }
			}
		] ),

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	},

	shadow: {

		uniforms: mergeUniforms( [
			UniformsLib.lights,
			UniformsLib.fog,
			{
				color: { value: new Color$1( 0x00000 ) },
				opacity: { value: 1.0 }
			},
		] ),

		vertexShader: ShaderChunk.shadow_vert,
		fragmentShader: ShaderChunk.shadow_frag

	}

};

ShaderLib.physical = {

	uniforms: mergeUniforms( [
		ShaderLib.standard.uniforms,
		{
			clearcoat: { value: 0 },
			clearcoatMap: { value: null },
			clearcoatRoughness: { value: 0 },
			clearcoatRoughnessMap: { value: null },
			clearcoatNormalScale: { value: new Vector2( 1, 1 ) },
			clearcoatNormalMap: { value: null },
			sheen: { value: new Color$1( 0x000000 ) },
			transmission: { value: 0 },
			transmissionMap: { value: null },
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

function WebGLBackground( renderer, cubemaps, state, objects, premultipliedAlpha ) {

	const clearColor = new Color$1( 0x000000 );
	let clearAlpha = 0;

	let planeMesh;
	let boxMesh;

	let currentBackground = null;
	let currentBackgroundVersion = 0;
	let currentTonemapping = null;

	function render( renderList, scene, camera, forceClear ) {

		let background = scene.isScene === true ? scene.background : null;

		if ( background && background.isTexture ) {

			background = cubemaps.get( background );

		}

		// Ignore background in AR
		// TODO: Reconsider this.

		const xr = renderer.xr;
		const session = xr.getSession && xr.getSession();

		if ( session && session.environmentBlendMode === 'additive' ) {

			background = null;

		}

		if ( background === null ) {

			setClear( clearColor, clearAlpha );

		} else if ( background && background.isColor ) {

			setClear( background, 1 );
			forceClear = true;

		}

		if ( renderer.autoClear || forceClear ) {

			renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

		}

		if ( background && ( background.isCubeTexture || background.isWebGLCubeRenderTarget || background.mapping === CubeUVReflectionMapping ) ) {

			if ( boxMesh === undefined ) {

				boxMesh = new Mesh(
					new BoxGeometry( 1, 1, 1 ),
					new ShaderMaterial( {
						name: 'BackgroundCubeMaterial',
						uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
						vertexShader: ShaderLib.cube.vertexShader,
						fragmentShader: ShaderLib.cube.fragmentShader,
						side: BackSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				boxMesh.geometry.deleteAttribute( 'normal' );
				boxMesh.geometry.deleteAttribute( 'uv' );

				boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

					this.matrixWorld.copyPosition( camera.matrixWorld );

				};

				// enable code injection for non-built-in material
				Object.defineProperty( boxMesh.material, 'envMap', {

					get: function () {

						return this.uniforms.envMap.value;

					}

				} );

				objects.update( boxMesh );

			}

			if ( background.isWebGLCubeRenderTarget ) {

				// TODO Deprecate

				background = background.texture;

			}

			boxMesh.material.uniforms.envMap.value = background;
			boxMesh.material.uniforms.flipEnvMap.value = ( background.isCubeTexture && background._needsFlipEnvMap ) ? - 1 : 1;

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				boxMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}

			// push to the pre-sorted opaque render list
			renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

		} else if ( background && background.isTexture ) {

			if ( planeMesh === undefined ) {

				planeMesh = new Mesh(
					new PlaneGeometry( 2, 2 ),
					new ShaderMaterial( {
						name: 'BackgroundMaterial',
						uniforms: cloneUniforms( ShaderLib.background.uniforms ),
						vertexShader: ShaderLib.background.vertexShader,
						fragmentShader: ShaderLib.background.fragmentShader,
						side: FrontSide,
						depthTest: false,
						depthWrite: false,
						fog: false
					} )
				);

				planeMesh.geometry.deleteAttribute( 'normal' );

				// enable code injection for non-built-in material
				Object.defineProperty( planeMesh.material, 'map', {

					get: function () {

						return this.uniforms.t2D.value;

					}

				} );

				objects.update( planeMesh );

			}

			planeMesh.material.uniforms.t2D.value = background;

			if ( background.matrixAutoUpdate === true ) {

				background.updateMatrix();

			}

			planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

			if ( currentBackground !== background ||
				currentBackgroundVersion !== background.version ||
				currentTonemapping !== renderer.toneMapping ) {

				planeMesh.material.needsUpdate = true;

				currentBackground = background;
				currentBackgroundVersion = background.version;
				currentTonemapping = renderer.toneMapping;

			}


			// push to the pre-sorted opaque render list
			renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

		}

	}

	function setClear( color, alpha ) {

		state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

	}

	return {

		getClearColor: function () {

			return clearColor;

		},
		setClearColor: function ( color, alpha = 1 ) {

			clearColor.set( color );
			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		getClearAlpha: function () {

			return clearAlpha;

		},
		setClearAlpha: function ( alpha ) {

			clearAlpha = alpha;
			setClear( clearColor, clearAlpha );

		},
		render: render

	};

}

function WebGLBindingStates( gl, extensions, attributes, capabilities ) {

	const maxVertexAttributes = gl.getParameter( 34921 );

	const extension = capabilities.isWebGL2 ? null : extensions.get( 'OES_vertex_array_object' );
	const vaoAvailable = capabilities.isWebGL2 || extension !== null;

	const bindingStates = {};

	const defaultState = createBindingState( null );
	let currentState = defaultState;

	function setup( object, material, program, geometry, index ) {

		let updateBuffers = false;

		if ( vaoAvailable ) {

			const state = getBindingState( geometry, program, material );

			if ( currentState !== state ) {

				currentState = state;
				bindVertexArrayObject( currentState.object );

			}

			updateBuffers = needsUpdate( geometry, index );

			if ( updateBuffers ) saveCache( geometry, index );

		} else {

			const wireframe = ( material.wireframe === true );

			if ( currentState.geometry !== geometry.id ||
				currentState.program !== program.id ||
				currentState.wireframe !== wireframe ) {

				currentState.geometry = geometry.id;
				currentState.program = program.id;
				currentState.wireframe = wireframe;

				updateBuffers = true;

			}

		}

		if ( object.isInstancedMesh === true ) {

			updateBuffers = true;

		}

		if ( index !== null ) {

			attributes.update( index, 34963 );

		}

		if ( updateBuffers ) {

			setupVertexAttributes( object, material, program, geometry );

			if ( index !== null ) {

				gl.bindBuffer( 34963, attributes.get( index ).buffer );

			}

		}

	}

	function createVertexArrayObject() {

		if ( capabilities.isWebGL2 ) return gl.createVertexArray();

		return extension.createVertexArrayOES();

	}

	function bindVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.bindVertexArray( vao );

		return extension.bindVertexArrayOES( vao );

	}

	function deleteVertexArrayObject( vao ) {

		if ( capabilities.isWebGL2 ) return gl.deleteVertexArray( vao );

		return extension.deleteVertexArrayOES( vao );

	}

	function getBindingState( geometry, program, material ) {

		const wireframe = ( material.wireframe === true );

		let programMap = bindingStates[ geometry.id ];

		if ( programMap === undefined ) {

			programMap = {};
			bindingStates[ geometry.id ] = programMap;

		}

		let stateMap = programMap[ program.id ];

		if ( stateMap === undefined ) {

			stateMap = {};
			programMap[ program.id ] = stateMap;

		}

		let state = stateMap[ wireframe ];

		if ( state === undefined ) {

			state = createBindingState( createVertexArrayObject() );
			stateMap[ wireframe ] = state;

		}

		return state;

	}

	function createBindingState( vao ) {

		const newAttributes = [];
		const enabledAttributes = [];
		const attributeDivisors = [];

		for ( let i = 0; i < maxVertexAttributes; i ++ ) {

			newAttributes[ i ] = 0;
			enabledAttributes[ i ] = 0;
			attributeDivisors[ i ] = 0;

		}

		return {

			// for backward compatibility on non-VAO support browser
			geometry: null,
			program: null,
			wireframe: false,

			newAttributes: newAttributes,
			enabledAttributes: enabledAttributes,
			attributeDivisors: attributeDivisors,
			object: vao,
			attributes: {},
			index: null

		};

	}

	function needsUpdate( geometry, index ) {

		const cachedAttributes = currentState.attributes;
		const geometryAttributes = geometry.attributes;

		let attributesNum = 0;

		for ( const key in geometryAttributes ) {

			const cachedAttribute = cachedAttributes[ key ];
			const geometryAttribute = geometryAttributes[ key ];

			if ( cachedAttribute === undefined ) return true;

			if ( cachedAttribute.attribute !== geometryAttribute ) return true;

			if ( cachedAttribute.data !== geometryAttribute.data ) return true;

			attributesNum ++;

		}

		if ( currentState.attributesNum !== attributesNum ) return true;

		if ( currentState.index !== index ) return true;

		return false;

	}

	function saveCache( geometry, index ) {

		const cache = {};
		const attributes = geometry.attributes;
		let attributesNum = 0;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];

			const data = {};
			data.attribute = attribute;

			if ( attribute.data ) {

				data.data = attribute.data;

			}

			cache[ key ] = data;

			attributesNum ++;

		}

		currentState.attributes = cache;
		currentState.attributesNum = attributesNum;

		currentState.index = index;

	}

	function initAttributes() {

		const newAttributes = currentState.newAttributes;

		for ( let i = 0, il = newAttributes.length; i < il; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		enableAttributeAndDivisor( attribute, 0 );

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;
		const attributeDivisors = currentState.attributeDivisors;

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			const extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

			extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		const newAttributes = currentState.newAttributes;
		const enabledAttributes = currentState.enabledAttributes;

		for ( let i = 0, il = enabledAttributes.length; i < il; i ++ ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function vertexAttribPointer( index, size, type, normalized, stride, offset ) {

		if ( capabilities.isWebGL2 === true && ( type === 5124 || type === 5125 ) ) {

			gl.vertexAttribIPointer( index, size, type, stride, offset );

		} else {

			gl.vertexAttribPointer( index, size, type, normalized, stride, offset );

		}

	}

	function setupVertexAttributes( object, material, program, geometry ) {

		if ( capabilities.isWebGL2 === false && ( object.isInstancedMesh || geometry.isInstancedBufferGeometry ) ) {

			if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

		}

		initAttributes();

		const geometryAttributes = geometry.attributes;

		const programAttributes = program.getAttributes();

		const materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( const name in programAttributes ) {

			const programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				const geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					const normalized = geometryAttribute.normalized;
					const size = geometryAttribute.itemSize;

					const attribute = attributes.get( geometryAttribute );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;
					const bytesPerElement = attribute.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						const data = geometryAttribute.data;
						const stride = data.stride;
						const offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = data.meshPerAttribute * data.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

							if ( geometry._maxInstanceCount === undefined ) {

								geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							enableAttribute( programAttribute );

						}

						gl.bindBuffer( 34962, buffer );
						vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

					}

				} else if ( name === 'instanceMatrix' ) {

					const attribute = attributes.get( object.instanceMatrix );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute + 0, 1 );
					enableAttributeAndDivisor( programAttribute + 1, 1 );
					enableAttributeAndDivisor( programAttribute + 2, 1 );
					enableAttributeAndDivisor( programAttribute + 3, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
					gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
					gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
					gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

				} else if ( name === 'instanceColor' ) {

					const attribute = attributes.get( object.instanceColor );

					// TODO Attribute may not be available on context restore

					if ( attribute === undefined ) continue;

					const buffer = attribute.buffer;
					const type = attribute.type;

					enableAttributeAndDivisor( programAttribute, 1 );

					gl.bindBuffer( 34962, buffer );

					gl.vertexAttribPointer( programAttribute, 3, type, false, 12, 0 );

				} else if ( materialDefaultAttributeValues !== undefined ) {

					const value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		disableUnusedAttributes();

	}

	function dispose() {

		reset();

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			for ( const programId in programMap ) {

				const stateMap = programMap[ programId ];

				for ( const wireframe in stateMap ) {

					deleteVertexArrayObject( stateMap[ wireframe ].object );

					delete stateMap[ wireframe ];

				}

				delete programMap[ programId ];

			}

			delete bindingStates[ geometryId ];

		}

	}

	function releaseStatesOfGeometry( geometry ) {

		if ( bindingStates[ geometry.id ] === undefined ) return;

		const programMap = bindingStates[ geometry.id ];

		for ( const programId in programMap ) {

			const stateMap = programMap[ programId ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ programId ];

		}

		delete bindingStates[ geometry.id ];

	}

	function releaseStatesOfProgram( program ) {

		for ( const geometryId in bindingStates ) {

			const programMap = bindingStates[ geometryId ];

			if ( programMap[ program.id ] === undefined ) continue;

			const stateMap = programMap[ program.id ];

			for ( const wireframe in stateMap ) {

				deleteVertexArrayObject( stateMap[ wireframe ].object );

				delete stateMap[ wireframe ];

			}

			delete programMap[ program.id ];

		}

	}

	function reset() {

		resetDefaultState();

		if ( currentState === defaultState ) return;

		currentState = defaultState;
		bindVertexArrayObject( currentState.object );

	}

	// for backward-compatilibity

	function resetDefaultState() {

		defaultState.geometry = null;
		defaultState.program = null;
		defaultState.wireframe = false;

	}

	return {

		setup: setup,
		reset: reset,
		resetDefaultState: resetDefaultState,
		dispose: dispose,
		releaseStatesOfGeometry: releaseStatesOfGeometry,
		releaseStatesOfProgram: releaseStatesOfProgram,

		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		disableUnusedAttributes: disableUnusedAttributes

	};

}

function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawArraysInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawArraysInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, start, count, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLCapabilities( gl, extensions, parameters ) {

	let maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
				gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	/* eslint-disable no-undef */
	const isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
		( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
	/* eslint-enable no-undef */

	let precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	const maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

	const maxTextures = gl.getParameter( 34930 );
	const maxVertexTextures = gl.getParameter( 35660 );
	const maxTextureSize = gl.getParameter( 3379 );
	const maxCubemapSize = gl.getParameter( 34076 );

	const maxAttributes = gl.getParameter( 34921 );
	const maxVertexUniforms = gl.getParameter( 36347 );
	const maxVaryings = gl.getParameter( 36348 );
	const maxFragmentUniforms = gl.getParameter( 36349 );

	const vertexTextures = maxVertexTextures > 0;
	const floatFragmentTextures = isWebGL2 || extensions.has( 'OES_texture_float' );
	const floatVertexTextures = vertexTextures && floatFragmentTextures;

	const maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

	return {

		isWebGL2: isWebGL2,

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures,

		maxSamples: maxSamples

	};

}

function WebGLClipping( properties ) {

	const scope = this;

	let globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false;

	const plane = new Plane$1(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function ( planes, enableLocalClipping, camera ) {

		const enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function () {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function () {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function ( material, camera, useCache ) {

		const planes = material.clippingPlanes,
			clipIntersection = material.clipIntersection,
			clipShadows = material.clipShadows;

		const materialProperties = properties.get( material );

		if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

			// there's no local clipping

			if ( renderingShadows ) {

				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();

			}

		} else {

			const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4;

			let dstArray = materialProperties.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, useCache );

			for ( let i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			materialProperties.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		const nPlanes = planes !== null ? planes.length : 0;
		let dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				const flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( let i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		scope.numIntersection = 0;

		return dstArray;

	}

}

function WebGLCubeMaps( renderer ) {

	let cubemaps = new WeakMap();

	function mapTextureMapping( texture, mapping ) {

		if ( mapping === EquirectangularReflectionMapping ) {

			texture.mapping = CubeReflectionMapping;

		} else if ( mapping === EquirectangularRefractionMapping ) {

			texture.mapping = CubeRefractionMapping;

		}

		return texture;

	}

	function get( texture ) {

		if ( texture && texture.isTexture ) {

			const mapping = texture.mapping;

			if ( mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping ) {

				if ( cubemaps.has( texture ) ) {

					const cubemap = cubemaps.get( texture ).texture;
					return mapTextureMapping( cubemap, texture.mapping );

				} else {

					const image = texture.image;

					if ( image && image.height > 0 ) {

						const currentRenderTarget = renderer.getRenderTarget();

						const renderTarget = new WebGLCubeRenderTarget( image.height / 2 );
						renderTarget.fromEquirectangularTexture( renderer, texture );
						cubemaps.set( texture, renderTarget );

						renderer.setRenderTarget( currentRenderTarget );

						texture.addEventListener( 'dispose', onTextureDispose );

						return mapTextureMapping( renderTarget.texture, texture.mapping );

					} else {

						// image not yet ready. try the conversion next frame

						return null;

					}

				}

			}

		}

		return texture;

	}

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		const cubemap = cubemaps.get( texture );

		if ( cubemap !== undefined ) {

			cubemaps.delete( texture );
			cubemap.dispose();

		}

	}

	function dispose() {

		cubemaps = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function WebGLExtensions( gl ) {

	const extensions = {};

	function getExtension( name ) {

		if ( extensions[ name ] !== undefined ) {

			return extensions[ name ];

		}

		let extension;

		switch ( name ) {

			case 'WEBGL_depth_texture':
				extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
				break;

			case 'EXT_texture_filter_anisotropic':
				extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
				break;

			case 'WEBGL_compressed_texture_s3tc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
				break;

			case 'WEBGL_compressed_texture_pvrtc':
				extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
				break;

			default:
				extension = gl.getExtension( name );

		}

		extensions[ name ] = extension;

		return extension;

	}

	return {

		has: function ( name ) {

			return getExtension( name ) !== null;

		},

		init: function ( capabilities ) {

			if ( capabilities.isWebGL2 ) {

				getExtension( 'EXT_color_buffer_float' );

			} else {

				getExtension( 'WEBGL_depth_texture' );
				getExtension( 'OES_texture_float' );
				getExtension( 'OES_texture_half_float' );
				getExtension( 'OES_texture_half_float_linear' );
				getExtension( 'OES_standard_derivatives' );
				getExtension( 'OES_element_index_uint' );
				getExtension( 'OES_vertex_array_object' );
				getExtension( 'ANGLE_instanced_arrays' );

			}

			getExtension( 'OES_texture_float_linear' );
			getExtension( 'EXT_color_buffer_half_float' );

		},

		get: function ( name ) {

			const extension = getExtension( name );

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			return extension;

		}

	};

}

function WebGLGeometries( gl, attributes, info, bindingStates ) {

	const geometries = {};
	const wireframeAttributes = new WeakMap();

	function onGeometryDispose( event ) {

		const geometry = event.target;

		if ( geometry.index !== null ) {

			attributes.remove( geometry.index );

		}

		for ( const name in geometry.attributes ) {

			attributes.remove( geometry.attributes[ name ] );

		}

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		const attribute = wireframeAttributes.get( geometry );

		if ( attribute ) {

			attributes.remove( attribute );
			wireframeAttributes.delete( geometry );

		}

		bindingStates.releaseStatesOfGeometry( geometry );

		if ( geometry.isInstancedBufferGeometry === true ) {

			delete geometry._maxInstanceCount;

		}

		//

		info.memory.geometries --;

	}

	function get( object, geometry ) {

		if ( geometries[ geometry.id ] === true ) return geometry;

		geometry.addEventListener( 'dispose', onGeometryDispose );

		geometries[ geometry.id ] = true;

		info.memory.geometries ++;

		return geometry;

	}

	function update( geometry ) {

		const geometryAttributes = geometry.attributes;

		// Updating index buffer in VAO now. See WebGLBindingStates.

		for ( const name in geometryAttributes ) {

			attributes.update( geometryAttributes[ name ], 34962 );

		}

		// morph targets

		const morphAttributes = geometry.morphAttributes;

		for ( const name in morphAttributes ) {

			const array = morphAttributes[ name ];

			for ( let i = 0, l = array.length; i < l; i ++ ) {

				attributes.update( array[ i ], 34962 );

			}

		}

	}

	function updateWireframeAttribute( geometry ) {

		const indices = [];

		const geometryIndex = geometry.index;
		const geometryPosition = geometry.attributes.position;
		let version = 0;

		if ( geometryIndex !== null ) {

			const array = geometryIndex.array;
			version = geometryIndex.version;

			for ( let i = 0, l = array.length; i < l; i += 3 ) {

				const a = array[ i + 0 ];
				const b = array[ i + 1 ];
				const c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			const array = geometryPosition.array;
			version = geometryPosition.version;

			for ( let i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				const a = i + 0;
				const b = i + 1;
				const c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		const attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
		attribute.version = version;

		// Updating index buffer in VAO now. See WebGLBindingStates

		//

		const previousAttribute = wireframeAttributes.get( geometry );

		if ( previousAttribute ) attributes.remove( previousAttribute );

		//

		wireframeAttributes.set( geometry, attribute );

	}

	function getWireframeAttribute( geometry ) {

		const currentAttribute = wireframeAttributes.get( geometry );

		if ( currentAttribute ) {

			const geometryIndex = geometry.index;

			if ( geometryIndex !== null ) {

				// if the attribute is obsolete, create a new one

				if ( currentAttribute.version < geometryIndex.version ) {

					updateWireframeAttribute( geometry );

				}

			}

		} else {

			updateWireframeAttribute( geometry );

		}

		return wireframeAttributes.get( geometry );

	}

	return {

		get: get,
		update: update,

		getWireframeAttribute: getWireframeAttribute

	};

}

function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	let mode;

	function setMode( value ) {

		mode = value;

	}

	let type, bytesPerElement;

	function setIndex( value ) {

		type = value.type;
		bytesPerElement = value.bytesPerElement;

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * bytesPerElement );

		info.update( count, mode, 1 );

	}

	function renderInstances( start, count, primcount ) {

		if ( primcount === 0 ) return;

		let extension, methodName;

		if ( isWebGL2 ) {

			extension = gl;
			methodName = 'drawElementsInstanced';

		} else {

			extension = extensions.get( 'ANGLE_instanced_arrays' );
			methodName = 'drawElementsInstancedANGLE';

			if ( extension === null ) {

				console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

		info.update( count, mode, primcount );

	}

	//

	this.setMode = setMode;
	this.setIndex = setIndex;
	this.render = render;
	this.renderInstances = renderInstances;

}

function WebGLInfo( gl ) {

	const memory = {
		geometries: 0,
		textures: 0
	};

	const render = {
		frame: 0,
		calls: 0,
		triangles: 0,
		points: 0,
		lines: 0
	};

	function update( count, mode, instanceCount ) {

		render.calls ++;

		switch ( mode ) {

			case 4:
				render.triangles += instanceCount * ( count / 3 );
				break;

			case 1:
				render.lines += instanceCount * ( count / 2 );
				break;

			case 3:
				render.lines += instanceCount * ( count - 1 );
				break;

			case 2:
				render.lines += instanceCount * count;
				break;

			case 0:
				render.points += instanceCount * count;
				break;

			default:
				console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
				break;

		}

	}

	function reset() {

		render.frame ++;
		render.calls = 0;
		render.triangles = 0;
		render.points = 0;
		render.lines = 0;

	}

	return {
		memory: memory,
		render: render,
		programs: null,
		autoReset: true,
		reset: reset,
		update: update
	};

}

function numericalSort( a, b ) {

	return a[ 0 ] - b[ 0 ];

}

function absNumericalSort( a, b ) {

	return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

}

function WebGLMorphtargets( gl ) {

	const influencesList = {};
	const morphInfluences = new Float32Array( 8 );

	const workInfluences = [];

	for ( let i = 0; i < 8; i ++ ) {

		workInfluences[ i ] = [ i, 0 ];

	}

	function update( object, geometry, material, program ) {

		const objectInfluences = object.morphTargetInfluences;

		// When object doesn't have morph target influences defined, we treat it as a 0-length array
		// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

		const length = objectInfluences === undefined ? 0 : objectInfluences.length;

		let influences = influencesList[ geometry.id ];

		if ( influences === undefined ) {

			// initialise list

			influences = [];

			for ( let i = 0; i < length; i ++ ) {

				influences[ i ] = [ i, 0 ];

			}

			influencesList[ geometry.id ] = influences;

		}

		// Collect influences

		for ( let i = 0; i < length; i ++ ) {

			const influence = influences[ i ];

			influence[ 0 ] = i;
			influence[ 1 ] = objectInfluences[ i ];

		}

		influences.sort( absNumericalSort );

		for ( let i = 0; i < 8; i ++ ) {

			if ( i < length && influences[ i ][ 1 ] ) {

				workInfluences[ i ][ 0 ] = influences[ i ][ 0 ];
				workInfluences[ i ][ 1 ] = influences[ i ][ 1 ];

			} else {

				workInfluences[ i ][ 0 ] = Number.MAX_SAFE_INTEGER;
				workInfluences[ i ][ 1 ] = 0;

			}

		}

		workInfluences.sort( numericalSort );

		const morphTargets = material.morphTargets && geometry.morphAttributes.position;
		const morphNormals = material.morphNormals && geometry.morphAttributes.normal;

		let morphInfluencesSum = 0;

		for ( let i = 0; i < 8; i ++ ) {

			const influence = workInfluences[ i ];
			const index = influence[ 0 ];
			const value = influence[ 1 ];

			if ( index !== Number.MAX_SAFE_INTEGER && value ) {

				if ( morphTargets && geometry.getAttribute( 'morphTarget' + i ) !== morphTargets[ index ] ) {

					geometry.setAttribute( 'morphTarget' + i, morphTargets[ index ] );

				}

				if ( morphNormals && geometry.getAttribute( 'morphNormal' + i ) !== morphNormals[ index ] ) {

					geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

				}

				morphInfluences[ i ] = value;
				morphInfluencesSum += value;

			} else {

				if ( morphTargets && geometry.hasAttribute( 'morphTarget' + i ) === true ) {

					geometry.deleteAttribute( 'morphTarget' + i );

				}

				if ( morphNormals && geometry.hasAttribute( 'morphNormal' + i ) === true ) {

					geometry.deleteAttribute( 'morphNormal' + i );

				}

				morphInfluences[ i ] = 0;

			}

		}

		// GLSL shader uses formula baseinfluence * base + sum(target * influence)
		// This allows us to switch between absolute morphs and relative morphs without changing shader code
		// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
		const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

		program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
		program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

	}

	return {

		update: update

	};

}

function WebGLObjects( gl, geometries, attributes, info ) {

	let updateMap = new WeakMap();

	function update( object ) {

		const frame = info.render.frame;

		const geometry = object.geometry;
		const buffergeometry = geometries.get( object, geometry );

		// Update once per frame

		if ( updateMap.get( buffergeometry ) !== frame ) {

			geometries.update( buffergeometry );

			updateMap.set( buffergeometry, frame );

		}

		if ( object.isInstancedMesh ) {

			if ( object.hasEventListener( 'dispose', onInstancedMeshDispose ) === false ) {

				object.addEventListener( 'dispose', onInstancedMeshDispose );

			}

			attributes.update( object.instanceMatrix, 34962 );

			if ( object.instanceColor !== null ) {

				attributes.update( object.instanceColor, 34962 );

			}

		}

		return buffergeometry;

	}

	function dispose() {

		updateMap = new WeakMap();

	}

	function onInstancedMeshDispose( event ) {

		const instancedMesh = event.target;

		instancedMesh.removeEventListener( 'dispose', onInstancedMeshDispose );

		attributes.remove( instancedMesh.instanceMatrix );

		if ( instancedMesh.instanceColor !== null ) attributes.remove( instancedMesh.instanceColor );

	}

	return {

		update: update,
		dispose: dispose

	};

}

class DataTexture2DArray extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture2DArray.prototype.isDataTexture2DArray = true;

class DataTexture3D extends Texture {

	constructor( data = null, width = 1, height = 1, depth = 1 ) {

		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	const texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839

		super( null );

		this.image = { data, width, height, depth };

		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;

		this.wrapR = ClampToEdgeWrapping;

		this.generateMipmaps = false;
		this.flipY = false;

		this.needsUpdate = true;

	}

}

DataTexture3D.prototype.isDataTexture3D = true;

/**
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [textures] )
 *
 * 		uploads a uniform value(s)
 *  	the 'textures' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (textures factorizations):
 *
 * .upload( gl, seq, values, textures )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (textures factorizations):
 *
 * .setValue( gl, name, value, textures )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

const emptyTexture = new Texture();
const emptyTexture2dArray = new DataTexture2DArray();
const emptyTexture3d = new DataTexture3D();
const emptyCubeTexture = new CubeTexture();

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

const arrayCacheF32 = [];
const arrayCacheI32 = [];

// Float32Array caches used for uploading Matrix uniforms

const mat4array = new Float32Array( 16 );
const mat3array = new Float32Array( 9 );
const mat2array = new Float32Array( 4 );

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	const firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	const n = nBlocks * blockSize;
	let r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( let i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

function arraysEqual( a, b ) {

	if ( a.length !== b.length ) return false;

	for ( let i = 0, l = a.length; i < l; i ++ ) {

		if ( a[ i ] !== b[ i ] ) return false;

	}

	return true;

}

function copyArray( a, b ) {

	for ( let i = 0, l = b.length; i < l; i ++ ) {

		a[ i ] = b[ i ];

	}

}

// Texture unit allocation

function allocTexUnits( textures, n ) {

	let r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( let i = 0; i !== n; ++ i ) {

		r[ i ] = textures.allocateTextureUnit();

	}

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValueV1f( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1f( this.addr, v );

	cache[ 0 ] = v;

}

// Single float vector (from flat array or THREE.VectorN)

function setValueV2f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

			gl.uniform2f( this.addr, v.x, v.y );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV3f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

			gl.uniform3f( this.addr, v.x, v.y, v.z );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;

		}

	} else if ( v.r !== undefined ) {

		if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

			gl.uniform3f( this.addr, v.r, v.g, v.b );

			cache[ 0 ] = v.r;
			cache[ 1 ] = v.g;
			cache[ 2 ] = v.b;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3fv( this.addr, v );

		copyArray( cache, v );

	}

}

function setValueV4f( gl, v ) {

	const cache = this.cache;

	if ( v.x !== undefined ) {

		if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

			gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

			cache[ 0 ] = v.x;
			cache[ 1 ] = v.y;
			cache[ 2 ] = v.z;
			cache[ 3 ] = v.w;

		}

	} else {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4fv( this.addr, v );

		copyArray( cache, v );

	}

}

// Single matrix (from flat array or MatrixN)

function setValueM2( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix2fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat2array.set( elements );

		gl.uniformMatrix2fv( this.addr, false, mat2array );

		copyArray( cache, elements );

	}

}

function setValueM3( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix3fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat3array.set( elements );

		gl.uniformMatrix3fv( this.addr, false, mat3array );

		copyArray( cache, elements );

	}

}

function setValueM4( gl, v ) {

	const cache = this.cache;
	const elements = v.elements;

	if ( elements === undefined ) {

		if ( arraysEqual( cache, v ) ) return;

		gl.uniformMatrix4fv( this.addr, false, v );

		copyArray( cache, v );

	} else {

		if ( arraysEqual( cache, elements ) ) return;

		mat4array.set( elements );

		gl.uniformMatrix4fv( this.addr, false, mat4array );

		copyArray( cache, elements );

	}

}

// Single texture (2D / Cube)

function setValueT1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTexture2D( v || emptyTexture, unit );

}

function setValueT2DArray1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture2DArray( v || emptyTexture2dArray, unit );

}

function setValueT3D1( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.setTexture3D( v || emptyTexture3d, unit );

}

function setValueT6( gl, v, textures ) {

	const cache = this.cache;
	const unit = textures.allocateTextureUnit();

	if ( cache[ 0 ] !== unit ) {

		gl.uniform1i( this.addr, unit );
		cache[ 0 ] = unit;

	}

	textures.safeSetTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValueV1i( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1i( this.addr, v );

	cache[ 0 ] = v;

}

function setValueV2i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform2iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV3i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform3iv( this.addr, v );

	copyArray( cache, v );

}

function setValueV4i( gl, v ) {

	const cache = this.cache;

	if ( arraysEqual( cache, v ) ) return;

	gl.uniform4iv( this.addr, v );

	copyArray( cache, v );

}

// uint

function setValueV1ui( gl, v ) {

	const cache = this.cache;

	if ( cache[ 0 ] === v ) return;

	gl.uniform1ui( this.addr, v );

	cache[ 0 ] = v;

}

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1f; // FLOAT
		case 0x8b50: return setValueV2f; // _VEC2
		case 0x8b51: return setValueV3f; // _VEC3
		case 0x8b52: return setValueV4f; // _VEC4

		case 0x8b5a: return setValueM2; // _MAT2
		case 0x8b5b: return setValueM3; // _MAT3
		case 0x8b5c: return setValueM4; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

		case 0x1405: return setValueV1ui; // UINT

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1;

		case 0x8b5f: // SAMPLER_3D
		case 0x8dcb: // INT_SAMPLER_3D
		case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
			return setValueT3D1;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6;

		case 0x8dc1: // SAMPLER_2D_ARRAY
		case 0x8dcf: // INT_SAMPLER_2D_ARRAY
		case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
		case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
			return setValueT2DArray1;

	}

}

// Array of scalars
function setValueV1fArray( gl, v ) {

	gl.uniform1fv( this.addr, v );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)
function setValueV1iArray( gl, v ) {

	gl.uniform1iv( this.addr, v );

}

function setValueV2iArray( gl, v ) {

	gl.uniform2iv( this.addr, v );

}

function setValueV3iArray( gl, v ) {

	gl.uniform3iv( this.addr, v );

}

function setValueV4iArray( gl, v ) {

	gl.uniform4iv( this.addr, v );

}


// Array of vectors (flat or from THREE classes)

function setValueV2fArray( gl, v ) {

	const data = flatten( v, this.size, 2 );

	gl.uniform2fv( this.addr, data );

}

function setValueV3fArray( gl, v ) {

	const data = flatten( v, this.size, 3 );

	gl.uniform3fv( this.addr, data );

}

function setValueV4fArray( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniform4fv( this.addr, data );

}

// Array of matrices (flat or from THREE clases)

function setValueM2Array( gl, v ) {

	const data = flatten( v, this.size, 4 );

	gl.uniformMatrix2fv( this.addr, false, data );

}

function setValueM3Array( gl, v ) {

	const data = flatten( v, this.size, 9 );

	gl.uniformMatrix3fv( this.addr, false, data );

}

function setValueM4Array( gl, v ) {

	const data = flatten( v, this.size, 16 );

	gl.uniformMatrix4fv( this.addr, false, data );

}

// Array of textures (2D / Cube)

function setValueT1Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6Array( gl, v, textures ) {

	const n = v.length;

	const units = allocTexUnits( textures, n );

	gl.uniform1iv( this.addr, units );

	for ( let i = 0; i !== n; ++ i ) {

		textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValueV1fArray; // FLOAT
		case 0x8b50: return setValueV2fArray; // _VEC2
		case 0x8b51: return setValueV3fArray; // _VEC3
		case 0x8b52: return setValueV4fArray; // _VEC4

		case 0x8b5a: return setValueM2Array; // _MAT2
		case 0x8b5b: return setValueM3Array; // _MAT3
		case 0x8b5c: return setValueM4Array; // _MAT4

		case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
		case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
		case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

		case 0x8b5e: // SAMPLER_2D
		case 0x8d66: // SAMPLER_EXTERNAL_OES
		case 0x8dca: // INT_SAMPLER_2D
		case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
		case 0x8b62: // SAMPLER_2D_SHADOW
			return setValueT1Array;

		case 0x8b60: // SAMPLER_CUBE
		case 0x8dcc: // INT_SAMPLER_CUBE
		case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
		case 0x8dc5: // SAMPLER_CUBE_SHADOW
			return setValueT6Array;

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.cache = [];
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

PureArrayUniform.prototype.updateCache = function ( data ) {

	const cache = this.cache;

	if ( data instanceof Float32Array && cache.length !== data.length ) {

		this.cache = new Float32Array( data.length );

	}

	copyArray( cache, data );

};

function StructuredUniform( id ) {

	this.id = id;

	this.seq = [];
	this.map = {};

}

StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

	const seq = this.seq;

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		u.setValue( gl, value[ u.id ], textures );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

const RePathPart = /(\w+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	const path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	while ( true ) {

		const match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex;

		let id = match[ 1 ];
		const idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
				new SingleUniform( id, activeInfo, addr ) :
				new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {

			// step into inner node / create it in case it doesn't exist

			const map = container.map;
			let next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program ) {

	this.seq = [];
	this.map = {};

	const n = gl.getProgramParameter( program, 35718 );

	for ( let i = 0; i < n; ++ i ) {

		const info = gl.getActiveUniform( program, i ),
			addr = gl.getUniformLocation( program, info.name );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

	const u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, textures );

};

WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

	const v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function ( gl, seq, values, textures ) {

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {

			// note: always updating when .needsUpdate is undefined
			u.setValue( gl, v.value, textures );

		}

	}

};

WebGLUniforms.seqWithValue = function ( seq, values ) {

	const r = [];

	for ( let i = 0, n = seq.length; i !== n; ++ i ) {

		const u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

function WebGLShader( gl, type, string ) {

	const shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	return shader;

}

let programIdCount = 0;

function addLineNumbers( string ) {

	const lines = string.split( '\n' );

	for ( let i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear', '( value )' ];
		case sRGBEncoding:
			return [ 'sRGB', '( value )' ];
		case RGBEEncoding:
			return [ 'RGBE', '( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM', '( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM', '( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD', '( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
		case LogLuvEncoding:
			return [ 'LogLuv', '( value )' ];
		default:
			console.warn( 'THREE.WebGLProgram: Unsupported encoding:', encoding );
			return [ 'Linear', '( value )' ];

	}

}

function getShaderErrors( gl, shader, type ) {

	const status = gl.getShaderParameter( shader, 35713 );
	const log = gl.getShaderInfoLog( shader ).trim();

	if ( status && log === '' ) return '';

	// --enable-privileged-webgl-extension
	// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	const source = gl.getShaderSource( shader );

	return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

}

function getTexelDecodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';

}

function getTexelEncodingFunction( functionName, encoding ) {

	const components = getEncodingComponents( encoding );
	return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';

}

function getToneMappingFunction( functionName, toneMapping ) {

	let toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = 'Linear';
			break;

		case ReinhardToneMapping:
			toneMappingName = 'Reinhard';
			break;

		case CineonToneMapping:
			toneMappingName = 'OptimizedCineon';
			break;

		case ACESFilmicToneMapping:
			toneMappingName = 'ACESFilmic';
			break;

		case CustomToneMapping:
			toneMappingName = 'Custom';
			break;

		default:
			console.warn( 'THREE.WebGLProgram: Unsupported toneMapping:', toneMapping );
			toneMappingName = 'Linear';

	}

	return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';

}

function generateExtensions( parameters ) {

	const chunks = [
		( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
		( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	const chunks = [];

	for ( const name in defines ) {

		const value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program ) {

	const attributes = {};

	const n = gl.getProgramParameter( program, 35721 );

	for ( let i = 0; i < n; i ++ ) {

		const info = gl.getActiveAttrib( program, i );
		const name = info.name;

		// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
		.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
		.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
		.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

}

function replaceClippingPlaneNums( string, parameters ) {

	return string
		.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
		.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

}

// Resolve Includes

const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

function resolveIncludes( string ) {

	return string.replace( includePattern, includeReplacer );

}

function includeReplacer( match, include ) {

	const string = ShaderChunk[ include ];

	if ( string === undefined ) {

		throw new Error( 'Can not resolve #include <' + include + '>' );

	}

	return resolveIncludes( string );

}

// Unroll Loops

const deprecatedUnrollLoopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
const unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function unrollLoops( string ) {

	return string
		.replace( unrollLoopPattern, loopReplacer )
		.replace( deprecatedUnrollLoopPattern, deprecatedLoopReplacer );

}

function deprecatedLoopReplacer( match, start, end, snippet ) {

	console.warn( 'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.' );
	return loopReplacer( match, start, end, snippet );

}

function loopReplacer( match, start, end, snippet ) {

	let string = '';

	for ( let i = parseInt( start ); i < parseInt( end ); i ++ ) {

		string += snippet
			.replace( /\[\s*i\s*\]/g, '[ ' + i + ' ]' )
			.replace( /UNROLLED_LOOP_INDEX/g, i );

	}

	return string;

}

//

function generatePrecision( parameters ) {

	let precisionstring = 'precision ' + parameters.precision + ' float;\nprecision ' + parameters.precision + ' int;';

	if ( parameters.precision === 'highp' ) {

		precisionstring += '\n#define HIGH_PRECISION';

	} else if ( parameters.precision === 'mediump' ) {

		precisionstring += '\n#define MEDIUM_PRECISION';

	} else if ( parameters.precision === 'lowp' ) {

		precisionstring += '\n#define LOW_PRECISION';

	}

	return precisionstring;

}

function generateShadowMapTypeDefine( parameters ) {

	let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	} else if ( parameters.shadowMapType === VSMShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM';

	}

	return shadowMapTypeDefine;

}

function generateEnvMapTypeDefine( parameters ) {

	let envMapTypeDefine = 'ENVMAP_TYPE_CUBE';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

		}

	}

	return envMapTypeDefine;

}

function generateEnvMapModeDefine( parameters ) {

	let envMapModeDefine = 'ENVMAP_MODE_REFLECTION';

	if ( parameters.envMap ) {

		switch ( parameters.envMapMode ) {

			case CubeRefractionMapping:
			case CubeUVRefractionMapping:

				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

	}

	return envMapModeDefine;

}

function generateEnvMapBlendingDefine( parameters ) {

	let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE';

	if ( parameters.envMap ) {

		switch ( parameters.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	return envMapBlendingDefine;

}

function WebGLProgram( renderer, cacheKey, parameters, bindingStates ) {

	const gl = renderer.getContext();

	const defines = parameters.defines;

	let vertexShader = parameters.vertexShader;
	let fragmentShader = parameters.fragmentShader;

	const shadowMapTypeDefine = generateShadowMapTypeDefine( parameters );
	const envMapTypeDefine = generateEnvMapTypeDefine( parameters );
	const envMapModeDefine = generateEnvMapModeDefine( parameters );
	const envMapBlendingDefine = generateEnvMapBlendingDefine( parameters );


	const gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	const customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

	const customDefines = generateDefines( defines );

	const program = gl.createProgram();

	let prefixVertex, prefixFragment;
	let versionString = parameters.glslVersion ? '#version ' + parameters.glslVersion + '\n' : '';

	if ( parameters.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixVertex.length > 0 ) {

			prefixVertex += '\n';

		}

		prefixFragment = [

			customExtensions,
			customDefines

		].filter( filterEmptyLine ).join( '\n' );

		if ( prefixFragment.length > 0 ) {

			prefixFragment += '\n';

		}

	} else {

		prefixVertex = [

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.instancing ? '#define USE_INSTANCING' : '',
			parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,
			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',

			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			'#ifdef USE_INSTANCING',

			'	attribute mat4 instanceMatrix;',

			'#endif',

			'#ifdef USE_INSTANCING_COLOR',

			'	attribute vec3 instanceColor;',

			'#endif',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_TANGENT',

			'	attribute vec4 tangent;',

			'#endif',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			generatePrecision( parameters ),

			'#define SHADER_NAME ' + parameters.shaderName,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp2 ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.matcap ? '#define USE_MATCAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
			( parameters.normalMap && parameters.tangentSpaceNormalMap ) ? '#define TANGENTSPACE_NORMALMAP' : '',
			parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
			parameters.clearcoatRoughnessMap ? '#define USE_CLEARCOAT_ROUGHNESSMAP' : '',
			parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',

			parameters.sheen ? '#define USE_SHEEN' : '',
			parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',

			parameters.vertexTangents ? '#define USE_TANGENT' : '',
			parameters.vertexColors || parameters.instancingColor ? '#define USE_COLOR' : '',
			parameters.vertexUvs ? '#define USE_UV' : '',
			parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',

			parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			( parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			( ( parameters.extensionShaderTextureLOD || parameters.envMap ) && parameters.rendererExtensionShaderTextureLod ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',
			'uniform bool isOrthographic;',

			( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',

			parameters.dithering ? '#define DITHERING' : '',

			ShaderChunk[ 'encodings_pars_fragment' ], // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.map ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.matcap ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
			parameters.envMap ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMap ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.lightMap ? getTexelDecodingFunction( 'lightMapTexelToLinear', parameters.lightMapEncoding ) : '',
			getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ),

			parameters.depthPacking ? '#define DEPTH_PACKING ' + parameters.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = resolveIncludes( vertexShader );
	vertexShader = replaceLightNums( vertexShader, parameters );
	vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

	fragmentShader = resolveIncludes( fragmentShader );
	fragmentShader = replaceLightNums( fragmentShader, parameters );
	fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

	vertexShader = unrollLoops( vertexShader );
	fragmentShader = unrollLoops( fragmentShader );

	if ( parameters.isWebGL2 && parameters.isRawShaderMaterial !== true ) {

		// GLSL 3.0 conversion for built-in materials and ShaderMaterial

		versionString = '#version 300 es\n';

		prefixVertex = [
			'#define attribute in',
			'#define varying out',
			'#define texture2D texture'
		].join( '\n' ) + '\n' + prefixVertex;

		prefixFragment = [
			'#define varying in',
			( parameters.glslVersion === GLSL3 ) ? '' : 'out highp vec4 pc_fragColor;',
			( parameters.glslVersion === GLSL3 ) ? '' : '#define gl_FragColor pc_fragColor',
			'#define gl_FragDepthEXT gl_FragDepth',
			'#define texture2D texture',
			'#define textureCube texture',
			'#define texture2DProj textureProj',
			'#define texture2DLodEXT textureLod',
			'#define texture2DProjLodEXT textureProjLod',
			'#define textureCubeLodEXT textureLod',
			'#define texture2DGradEXT textureGrad',
			'#define texture2DProjGradEXT textureProjGrad',
			'#define textureCubeGradEXT textureGrad'
		].join( '\n' ) + '\n' + prefixFragment;

	}

	const vertexGlsl = versionString + prefixVertex + vertexShader;
	const fragmentGlsl = versionString + prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	const glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
	const glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( parameters.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	// check for link errors
	if ( renderer.debug.checkShaderErrors ) {

		const programLog = gl.getProgramInfoLog( program ).trim();
		const vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		const fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

		let runnable = true;
		let haveDiagnostics = true;

		if ( gl.getProgramParameter( program, 35714 ) === false ) {

			runnable = false;

			const vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
			const fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

		} else if ( programLog !== '' ) {

			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

		} else if ( vertexLog === '' || fragmentLog === '' ) {

			haveDiagnostics = false;

		}

		if ( haveDiagnostics ) {

			this.diagnostics = {

				runnable: runnable,

				programLog: programLog,

				vertexShader: {

					log: vertexLog,
					prefix: prefixVertex

				},

				fragmentShader: {

					log: fragmentLog,
					prefix: prefixFragment

				}

			};

		}

	}

	// Clean up

	// Crashes in iOS9 and iOS10. #18402
	// gl.detachShader( program, glVertexShader );
	// gl.detachShader( program, glFragmentShader );

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	let cachedUniforms;

	this.getUniforms = function () {

		if ( cachedUniforms === undefined ) {

			cachedUniforms = new WebGLUniforms( gl, program );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	let cachedAttributes;

	this.getAttributes = function () {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function () {

		bindingStates.releaseStatesOfProgram( this );

		gl.deleteProgram( program );
		this.program = undefined;

	};

	//

	this.name = parameters.shaderName;
	this.id = programIdCount ++;
	this.cacheKey = cacheKey;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

function WebGLPrograms( renderer, cubemaps, extensions, capabilities, bindingStates, clipping ) {

	const programs = [];

	const isWebGL2 = capabilities.isWebGL2;
	const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
	const floatVertexTextures = capabilities.floatVertexTextures;
	const maxVertexUniforms = capabilities.maxVertexUniforms;
	const vertexTextures = capabilities.vertexTextures;

	let precision = capabilities.precision;

	const shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshDistanceMaterial: 'distanceRGBA',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'toon',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		MeshMatcapMaterial: 'matcap',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points',
		ShadowMaterial: 'shadow',
		SpriteMaterial: 'sprite'
	};

	const parameterNames = [
		'precision', 'isWebGL2', 'supportsVertexTextures', 'outputEncoding', 'instancing', 'instancingColor',
		'map', 'mapEncoding', 'matcap', 'matcapEncoding', 'envMap', 'envMapMode', 'envMapEncoding', 'envMapCubeUV',
		'lightMap', 'lightMapEncoding', 'aoMap', 'emissiveMap', 'emissiveMapEncoding', 'bumpMap', 'normalMap', 'objectSpaceNormalMap', 'tangentSpaceNormalMap', 'clearcoatMap', 'clearcoatRoughnessMap', 'clearcoatNormalMap', 'displacementMap', 'specularMap',
		'roughnessMap', 'metalnessMap', 'gradientMap',
		'alphaMap', 'combine', 'vertexColors', 'vertexTangents', 'vertexUvs', 'uvsVertexOnly', 'fog', 'useFog', 'fogExp2',
		'flatShading', 'sizeAttenuation', 'logarithmicDepthBuffer', 'skinning',
		'maxBones', 'useVertexTexture', 'morphTargets', 'morphNormals',
		'maxMorphTargets', 'maxMorphNormals', 'premultipliedAlpha',
		'numDirLights', 'numPointLights', 'numSpotLights', 'numHemiLights', 'numRectAreaLights',
		'numDirLightShadows', 'numPointLightShadows', 'numSpotLightShadows',
		'shadowMapEnabled', 'shadowMapType', 'toneMapping', 'physicallyCorrectLights',
		'alphaTest', 'doubleSided', 'flipSided', 'numClippingPlanes', 'numClipIntersection', 'depthPacking', 'dithering',
		'sheen', 'transmissionMap'
	];

	function getMaxBones( object ) {

		const skeleton = object.skeleton;
		const bones = skeleton.bones;

		if ( floatVertexTextures ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			const nVertexUniforms = maxVertexUniforms;
			const nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			const maxBones = Math.min( nVertexMatrices, bones.length );

			if ( maxBones < bones.length ) {

				console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
				return 0;

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map ) {

		let encoding;

		if ( map && map.isTexture ) {

			encoding = map.encoding;

		} else if ( map && map.isWebGLRenderTarget ) {

			console.warn( 'THREE.WebGLPrograms.getTextureEncodingFromMap: don\'t use render targets as textures. Use their .texture property instead.' );
			encoding = map.texture.encoding;

		} else {

			encoding = LinearEncoding;

		}

		return encoding;

	}

	function getParameters( material, lights, shadows, scene, object ) {

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;

		const envMap = cubemaps.get( material.envMap || environment );

		const shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		const maxBones = object.isSkinnedMesh ? getMaxBones( object ) : 0;

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		let vertexShader, fragmentShader;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];

			vertexShader = shader.vertexShader;
			fragmentShader = shader.fragmentShader;

		} else {

			vertexShader = material.vertexShader;
			fragmentShader = material.fragmentShader;

		}

		const currentRenderTarget = renderer.getRenderTarget();

		const parameters = {

			isWebGL2: isWebGL2,

			shaderID: shaderID,
			shaderName: material.type,

			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			defines: material.defines,

			isRawShaderMaterial: material.isRawShaderMaterial === true,
			glslVersion: material.glslVersion,

			precision: precision,

			instancing: object.isInstancedMesh === true,
			instancingColor: object.isInstancedMesh === true && object.instanceColor !== null,

			supportsVertexTextures: vertexTextures,
			outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map ),
			matcap: !! material.matcap,
			matcapEncoding: getTextureEncodingFromMap( material.matcap ),
			envMap: !! envMap,
			envMapMode: envMap && envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( envMap ),
			envMapCubeUV: ( !! envMap ) && ( ( envMap.mapping === CubeUVReflectionMapping ) || ( envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
			tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
			clearcoatMap: !! material.clearcoatMap,
			clearcoatRoughnessMap: !! material.clearcoatRoughnessMap,
			clearcoatNormalMap: !! material.clearcoatNormalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			sheen: !! material.sheen,

			transmissionMap: !! material.transmissionMap,

			combine: material.combine,

			vertexTangents: ( material.normalMap && material.vertexTangents ),
			vertexColors: material.vertexColors,
			vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatMap || !! material.clearcoatRoughnessMap || !! material.clearcoatNormalMap || !! material.displacementMap || !! material.transmissionMap,
			uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.transmissionMap ) && !! material.displacementMap,

			fog: !! fog,
			useFog: material.fog,
			fogExp2: ( fog && fog.isFogExp2 ),

			flatShading: !! material.flatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			skinning: material.skinning && maxBones > 0,
			maxBones: maxBones,
			useVertexTexture: floatVertexTextures,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numDirLightShadows: lights.directionalShadowMap.length,
			numPointLightShadows: lights.pointShadowMap.length,
			numSpotLightShadows: lights.spotShadowMap.length,

			numClippingPlanes: clipping.numPlanes,
			numClipIntersection: clipping.numIntersection,

			dithering: material.dithering,

			shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

			index0AttributeName: material.index0AttributeName,

			extensionDerivatives: material.extensions && material.extensions.derivatives,
			extensionFragDepth: material.extensions && material.extensions.fragDepth,
			extensionDrawBuffers: material.extensions && material.extensions.drawBuffers,
			extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

			rendererExtensionFragDepth: isWebGL2 || extensions.has( 'EXT_frag_depth' ),
			rendererExtensionDrawBuffers: isWebGL2 || extensions.has( 'WEBGL_draw_buffers' ),
			rendererExtensionShaderTextureLod: isWebGL2 || extensions.has( 'EXT_shader_texture_lod' ),

			customProgramCacheKey: material.customProgramCacheKey()

		};

		return parameters;

	}

	function getProgramCacheKey( parameters ) {

		const array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( parameters.fragmentShader );
			array.push( parameters.vertexShader );

		}

		if ( parameters.defines !== undefined ) {

			for ( const name in parameters.defines ) {

				array.push( name );
				array.push( parameters.defines[ name ] );

			}

		}

		if ( parameters.isRawShaderMaterial === false ) {

			for ( let i = 0; i < parameterNames.length; i ++ ) {

				array.push( parameters[ parameterNames[ i ] ] );

			}

			array.push( renderer.outputEncoding );
			array.push( renderer.gammaFactor );

		}

		array.push( parameters.customProgramCacheKey );

		return array.join();

	}

	function getUniforms( material ) {

		const shaderID = shaderIDs[ material.type ];
		let uniforms;

		if ( shaderID ) {

			const shader = ShaderLib[ shaderID ];
			uniforms = UniformsUtils.clone( shader.uniforms );

		} else {

			uniforms = material.uniforms;

		}

		return uniforms;

	}

	function acquireProgram( parameters, cacheKey ) {

		let program;

		// Check if code has been already compiled
		for ( let p = 0, pl = programs.length; p < pl; p ++ ) {

			const preexistingProgram = programs[ p ];

			if ( preexistingProgram.cacheKey === cacheKey ) {

				program = preexistingProgram;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, cacheKey, parameters, bindingStates );
			programs.push( program );

		}

		return program;

	}

	function releaseProgram( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			const i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	}

	return {
		getParameters: getParameters,
		getProgramCacheKey: getProgramCacheKey,
		getUniforms: getUniforms,
		acquireProgram: acquireProgram,
		releaseProgram: releaseProgram,
		// Exposed for resource monitoring & error feedback via renderer.info:
		programs: programs
	};

}

function WebGLProperties() {

	let properties = new WeakMap();

	function get( object ) {

		let map = properties.get( object );

		if ( map === undefined ) {

			map = {};
			properties.set( object, map );

		}

		return map;

	}

	function remove( object ) {

		properties.delete( object );

	}

	function update( object, key, value ) {

		properties.get( object )[ key ] = value;

	}

	function dispose() {

		properties = new WeakMap();

	}

	return {
		get: get,
		remove: remove,
		update: update,
		dispose: dispose
	};

}

function painterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.program !== b.program ) {

		return a.program.id - b.program.id;

	} else if ( a.material.id !== b.material.id ) {

		return a.material.id - b.material.id;

	} else if ( a.z !== b.z ) {

		return a.z - b.z;

	} else {

		return a.id - b.id;

	}

}

function reversePainterSortStable( a, b ) {

	if ( a.groupOrder !== b.groupOrder ) {

		return a.groupOrder - b.groupOrder;

	} else if ( a.renderOrder !== b.renderOrder ) {

		return a.renderOrder - b.renderOrder;

	} else if ( a.z !== b.z ) {

		return b.z - a.z;

	} else {

		return a.id - b.id;

	}

}


function WebGLRenderList( properties ) {

	const renderItems = [];
	let renderItemsIndex = 0;

	const opaque = [];
	const transparent = [];

	const defaultProgram = { id: - 1 };

	function init() {

		renderItemsIndex = 0;

		opaque.length = 0;
		transparent.length = 0;

	}

	function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

		let renderItem = renderItems[ renderItemsIndex ];
		const materialProperties = properties.get( material );

		if ( renderItem === undefined ) {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				program: materialProperties.program || defaultProgram,
				groupOrder: groupOrder,
				renderOrder: object.renderOrder,
				z: z,
				group: group
			};

			renderItems[ renderItemsIndex ] = renderItem;

		} else {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.program = materialProperties.program || defaultProgram;
			renderItem.groupOrder = groupOrder;
			renderItem.renderOrder = object.renderOrder;
			renderItem.z = z;
			renderItem.group = group;

		}

		renderItemsIndex ++;

		return renderItem;

	}

	function push( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).push( renderItem );

	}

	function unshift( object, geometry, material, groupOrder, z, group ) {

		const renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

		( material.transparent === true ? transparent : opaque ).unshift( renderItem );

	}

	function sort( customOpaqueSort, customTransparentSort ) {

		if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
		if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

	}

	function finish() {

		// Clear references from inactive renderItems in the list

		for ( let i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

			const renderItem = renderItems[ i ];

			if ( renderItem.id === null ) break;

			renderItem.id = null;
			renderItem.object = null;
			renderItem.geometry = null;
			renderItem.material = null;
			renderItem.program = null;
			renderItem.group = null;

		}

	}

	return {

		opaque: opaque,
		transparent: transparent,

		init: init,
		push: push,
		unshift: unshift,
		finish: finish,

		sort: sort
	};

}

function WebGLRenderLists( properties ) {

	let lists = new WeakMap();

	function get( scene, renderCallDepth ) {

		let list;

		if ( lists.has( scene ) === false ) {

			list = new WebGLRenderList( properties );
			lists.set( scene, [ list ] );

		} else {

			if ( renderCallDepth >= lists.get( scene ).length ) {

				list = new WebGLRenderList( properties );
				lists.get( scene ).push( list );

			} else {

				list = lists.get( scene )[ renderCallDepth ];

			}

		}

		return list;

	}

	function dispose() {

		lists = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

function UniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3$1(),
						color: new Color$1()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3$1(),
						direction: new Vector3$1(),
						color: new Color$1(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3$1(),
						color: new Color$1(),
						distance: 0,
						decay: 0
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3$1(),
						skyColor: new Color$1(),
						groundColor: new Color$1()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color$1(),
						position: new Vector3$1(),
						halfWidth: new Vector3$1(),
						halfHeight: new Vector3$1()
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

function ShadowUniformsCache() {

	const lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			let uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						shadowBias: 0,
						shadowNormalBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2(),
						shadowCameraNear: 1,
						shadowCameraFar: 1000
					};
					break;

				// TODO (abelnation): set RectAreaLight shadow uniforms

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}



let nextVersion = 0;

function shadowCastingLightsFirst( lightA, lightB ) {

	return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

}

function WebGLLights( extensions, capabilities ) {

	const cache = new UniformsCache();

	const shadowCache = ShadowUniformsCache();

	const state = {

		version: 0,

		hash: {
			directionalLength: - 1,
			pointLength: - 1,
			spotLength: - 1,
			rectAreaLength: - 1,
			hemiLength: - 1,

			numDirectionalShadows: - 1,
			numPointShadows: - 1,
			numSpotShadows: - 1
		},

		ambient: [ 0, 0, 0 ],
		probe: [],
		directional: [],
		directionalShadow: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadow: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		rectAreaLTC1: null,
		rectAreaLTC2: null,
		point: [],
		pointShadow: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: []

	};

	for ( let i = 0; i < 9; i ++ ) state.probe.push( new Vector3$1() );

	const vector3 = new Vector3$1();
	const matrix4 = new Matrix4();
	const matrix42 = new Matrix4();

	function setup( lights ) {

		let r = 0, g = 0, b = 0;

		for ( let i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		let numDirectionalShadows = 0;
		let numPointShadows = 0;
		let numSpotShadows = 0;

		lights.sort( shadowCastingLightsFirst );

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			const color = light.color;
			const intensity = light.intensity;
			const distance = light.distance;

			const shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isLightProbe ) {

				for ( let j = 0; j < 9; j ++ ) {

					state.probe[ j ].addScaledVector( light.sh.coefficients[ j ], intensity );

				}

			} else if ( light.isDirectionalLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.directionalShadow[ directionalLength ] = shadowUniforms;
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;

					numDirectionalShadows ++;

				}

				state.directional[ directionalLength ] = uniforms;

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = cache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;

					state.spotShadow[ spotLength ] = shadowUniforms;
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;

					numSpotShadows ++;

				}

				state.spot[ spotLength ] = uniforms;

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = cache.get( light );

				// (a) intensity is the total visible light emitted
				//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );

				// (b) intensity is the brightness of the light
				uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				state.rectArea[ rectAreaLength ] = uniforms;

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = cache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = light.decay;

				if ( light.castShadow ) {

					const shadow = light.shadow;

					const shadowUniforms = shadowCache.get( light );

					shadowUniforms.shadowBias = shadow.bias;
					shadowUniforms.shadowNormalBias = shadow.normalBias;
					shadowUniforms.shadowRadius = shadow.radius;
					shadowUniforms.shadowMapSize = shadow.mapSize;
					shadowUniforms.shadowCameraNear = shadow.camera.near;
					shadowUniforms.shadowCameraFar = shadow.camera.far;

					state.pointShadow[ pointLength ] = shadowUniforms;
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;

					numPointShadows ++;

				}

				state.point[ pointLength ] = uniforms;

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = cache.get( light );

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				state.hemi[ hemiLength ] = uniforms;

				hemiLength ++;

			}

		}

		if ( rectAreaLength > 0 ) {

			if ( capabilities.isWebGL2 ) {

				// WebGL 2

				state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
				state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

			} else {

				// WebGL 1

				if ( extensions.has( 'OES_texture_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
					state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;

				} else if ( extensions.has( 'OES_texture_half_float_linear' ) === true ) {

					state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
					state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;

				} else {

					console.error( 'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.' );

				}

			}

		}

		state.ambient[ 0 ] = r;
		state.ambient[ 1 ] = g;
		state.ambient[ 2 ] = b;

		const hash = state.hash;

		if ( hash.directionalLength !== directionalLength ||
			hash.pointLength !== pointLength ||
			hash.spotLength !== spotLength ||
			hash.rectAreaLength !== rectAreaLength ||
			hash.hemiLength !== hemiLength ||
			hash.numDirectionalShadows !== numDirectionalShadows ||
			hash.numPointShadows !== numPointShadows ||
			hash.numSpotShadows !== numSpotShadows ) {

			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;

			state.directionalShadow.length = numDirectionalShadows;
			state.directionalShadowMap.length = numDirectionalShadows;
			state.pointShadow.length = numPointShadows;
			state.pointShadowMap.length = numPointShadows;
			state.spotShadow.length = numSpotShadows;
			state.spotShadowMap.length = numSpotShadows;
			state.directionalShadowMatrix.length = numDirectionalShadows;
			state.pointShadowMatrix.length = numPointShadows;
			state.spotShadowMatrix.length = numSpotShadows;

			hash.directionalLength = directionalLength;
			hash.pointLength = pointLength;
			hash.spotLength = spotLength;
			hash.rectAreaLength = rectAreaLength;
			hash.hemiLength = hemiLength;

			hash.numDirectionalShadows = numDirectionalShadows;
			hash.numPointShadows = numPointShadows;
			hash.numSpotShadows = numSpotShadows;

			state.version = nextVersion ++;

		}

	}

	function setupView( lights, camera ) {

		let directionalLength = 0;
		let pointLength = 0;
		let spotLength = 0;
		let rectAreaLength = 0;
		let hemiLength = 0;

		const viewMatrix = camera.matrixWorldInverse;

		for ( let i = 0, l = lights.length; i < l; i ++ ) {

			const light = lights[ i ];

			if ( light.isDirectionalLight ) {

				const uniforms = state.directional[ directionalLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				directionalLength ++;

			} else if ( light.isSpotLight ) {

				const uniforms = state.spot[ spotLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				spotLength ++;

			} else if ( light.isRectAreaLight ) {

				const uniforms = state.rectArea[ rectAreaLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				matrix42.identity();
				matrix4.copy( light.matrixWorld );
				matrix4.premultiply( viewMatrix );
				matrix42.extractRotation( matrix4 );

				uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
				uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( matrix42 );
				uniforms.halfHeight.applyMatrix4( matrix42 );

				rectAreaLength ++;

			} else if ( light.isPointLight ) {

				const uniforms = state.point[ pointLength ];

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				pointLength ++;

			} else if ( light.isHemisphereLight ) {

				const uniforms = state.hemi[ hemiLength ];

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				hemiLength ++;

			}

		}

	}

	return {
		setup: setup,
		setupView: setupView,
		state: state
	};

}

function WebGLRenderState( extensions, capabilities ) {

	const lights = new WebGLLights( extensions, capabilities );

	const lightsArray = [];
	const shadowsArray = [];

	function init() {

		lightsArray.length = 0;
		shadowsArray.length = 0;

	}

	function pushLight( light ) {

		lightsArray.push( light );

	}

	function pushShadow( shadowLight ) {

		shadowsArray.push( shadowLight );

	}

	function setupLights() {

		lights.setup( lightsArray );

	}

	function setupLightsView( camera ) {

		lights.setupView( lightsArray, camera );

	}

	const state = {
		lightsArray: lightsArray,
		shadowsArray: shadowsArray,

		lights: lights
	};

	return {
		init: init,
		state: state,
		setupLights: setupLights,
		setupLightsView: setupLightsView,

		pushLight: pushLight,
		pushShadow: pushShadow
	};

}

function WebGLRenderStates( extensions, capabilities ) {

	let renderStates = new WeakMap();

	function get( scene, renderCallDepth = 0 ) {

		let renderState;

		if ( renderStates.has( scene ) === false ) {

			renderState = new WebGLRenderState( extensions, capabilities );
			renderStates.set( scene, [ renderState ] );

		} else {

			if ( renderCallDepth >= renderStates.get( scene ).length ) {

				renderState = new WebGLRenderState( extensions, capabilities );
				renderStates.get( scene ).push( renderState );

			} else {

				renderState = renderStates.get( scene )[ renderCallDepth ];

			}

		}

		return renderState;

	}

	function dispose() {

		renderStates = new WeakMap();

	}

	return {
		get: get,
		dispose: dispose
	};

}

/**
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

class MeshDepthMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	}

}

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

/**
 * parameters = {
 *
 *  referencePosition: <float>,
 *  nearDistance: <float>,
 *  farDistance: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>
 *
 * }
 */

class MeshDistanceMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshDistanceMaterial';

		this.referencePosition = new Vector3$1();
		this.nearDistance = 1;
		this.farDistance = 1000;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.fog = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		return this;

	}

}

MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;

var vsm_frag = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\tfor ( float i = -1.0; i < 1.0 ; i += SAMPLE_RATE) {\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( i, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, i ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean * HALF_SAMPLE_RATE;\n\tsquared_mean = squared_mean * HALF_SAMPLE_RATE;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}";

var vsm_vert = "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}";

function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {

	let _frustum = new Frustum$1();

	const _shadowMapSize = new Vector2(),
		_viewportSize = new Vector2(),

		_viewport = new Vector4(),

		_depthMaterials = [],
		_distanceMaterials = [],

		_materialCache = {};

	const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };

	const shadowMaterialVertical = new ShaderMaterial( {

		defines: {
			SAMPLE_RATE: 2.0 / 8.0,
			HALF_SAMPLE_RATE: 1.0 / 8.0
		},

		uniforms: {
			shadow_pass: { value: null },
			resolution: { value: new Vector2() },
			radius: { value: 4.0 }
		},

		vertexShader: vsm_vert,

		fragmentShader: vsm_frag

	} );

	const shadowMaterialHorizontal = shadowMaterialVertical.clone();
	shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;

	const fullScreenTri = new BufferGeometry();
	fullScreenTri.setAttribute(
		'position',
		new BufferAttribute(
			new Float32Array( [ - 1, - 1, 0.5, 3, - 1, 0.5, - 1, 3, 0.5 ] ),
			3
		)
	);

	const fullScreenMesh = new Mesh( fullScreenTri, shadowMaterialVertical );

	const scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.render = function ( lights, scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( lights.length === 0 ) return;

		const currentRenderTarget = _renderer.getRenderTarget();
		const activeCubeFace = _renderer.getActiveCubeFace();
		const activeMipmapLevel = _renderer.getActiveMipmapLevel();

		const _state = _renderer.state;

		// Set GL state for depth map.
		_state.setBlending( NoBlending );
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.buffers.depth.setTest( true );
		_state.setScissorTest( false );

		// render depth map

		for ( let i = 0, il = lights.length; i < il; i ++ ) {

			const light = lights[ i ];
			const shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			if ( shadow.autoUpdate === false && shadow.needsUpdate === false ) continue;

			_shadowMapSize.copy( shadow.mapSize );

			const shadowFrameExtents = shadow.getFrameExtents();

			_shadowMapSize.multiply( shadowFrameExtents );

			_viewportSize.copy( shadow.mapSize );

			if ( _shadowMapSize.x > maxTextureSize || _shadowMapSize.y > maxTextureSize ) {

				if ( _shadowMapSize.x > maxTextureSize ) {

					_viewportSize.x = Math.floor( maxTextureSize / shadowFrameExtents.x );
					_shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
					shadow.mapSize.x = _viewportSize.x;

				}

				if ( _shadowMapSize.y > maxTextureSize ) {

					_viewportSize.y = Math.floor( maxTextureSize / shadowFrameExtents.y );
					_shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
					shadow.mapSize.y = _viewportSize.y;

				}

			}

			if ( shadow.map === null && ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				const pars = { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.mapPass = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadow.camera.updateProjectionMatrix();

			}

			if ( shadow.map === null ) {

				const pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
				shadow.map.texture.name = light.name + '.shadowMap';

				shadow.camera.updateProjectionMatrix();

			}

			_renderer.setRenderTarget( shadow.map );
			_renderer.clear();

			const viewportCount = shadow.getViewportCount();

			for ( let vp = 0; vp < viewportCount; vp ++ ) {

				const viewport = shadow.getViewport( vp );

				_viewport.set(
					_viewportSize.x * viewport.x,
					_viewportSize.y * viewport.y,
					_viewportSize.x * viewport.z,
					_viewportSize.y * viewport.w
				);

				_state.viewport( _viewport );

				shadow.updateMatrices( light, vp );

				_frustum = shadow.getFrustum();

				renderObject( scene, camera, shadow.camera, light, this.type );

			}

			// do blur pass for VSM

			if ( ! shadow.isPointLightShadow && this.type === VSMShadowMap ) {

				VSMPass( shadow, camera );

			}

			shadow.needsUpdate = false;

		}

		scope.needsUpdate = false;

		_renderer.setRenderTarget( currentRenderTarget, activeCubeFace, activeMipmapLevel );

	};

	function VSMPass( shadow, camera ) {

		const geometry = _objects.update( fullScreenMesh );

		// vertical pass

		shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture;
		shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialVertical.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.mapPass );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null );

		// horizontal pass

		shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
		shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
		shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
		_renderer.setRenderTarget( shadow.map );
		_renderer.clear();
		_renderer.renderBufferDirect( camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null );

	}

	function getDepthMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _depthMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDepthMaterial( {

				depthPacking: RGBADepthPacking,

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_depthMaterials[ index ] = material;

		}

		return material;

	}

	function getDistanceMaterialVariant( useMorphing, useSkinning, useInstancing ) {

		const index = useMorphing << 0 | useSkinning << 1 | useInstancing << 2;

		let material = _distanceMaterials[ index ];

		if ( material === undefined ) {

			material = new MeshDistanceMaterial( {

				morphTargets: useMorphing,
				skinning: useSkinning

			} );

			_distanceMaterials[ index ] = material;

		}

		return material;

	}

	function getDepthMaterial( object, geometry, material, light, shadowCameraNear, shadowCameraFar, type ) {

		let result = null;

		let getMaterialVariant = getDepthMaterialVariant;
		let customMaterial = object.customDepthMaterial;

		if ( light.isPointLight === true ) {

			getMaterialVariant = getDistanceMaterialVariant;
			customMaterial = object.customDistanceMaterial;

		}

		if ( customMaterial === undefined ) {

			let useMorphing = false;

			if ( material.morphTargets === true ) {

				useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

			}

			let useSkinning = false;

			if ( object.isSkinnedMesh === true ) {

				if ( material.skinning === true ) {

					useSkinning = true;

				} else {

					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );

				}

			}

			const useInstancing = object.isInstancedMesh === true;

			result = getMaterialVariant( useMorphing, useSkinning, useInstancing );

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
				material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			const keyA = result.uuid, keyB = material.uuid;

			let materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			let cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		if ( type === VSMShadowMap ) {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : material.side;

		} else {

			result.side = ( material.shadowSide !== null ) ? material.shadowSide : shadowSide[ material.side ];

		}

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;
		result.clipIntersection = material.clipIntersection;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( light.isPointLight === true && result.isMeshDistanceMaterial === true ) {

			result.referencePosition.setFromMatrixPosition( light.matrixWorld );
			result.nearDistance = shadowCameraNear;
			result.farDistance = shadowCameraFar;

		}

		return result;

	}

	function renderObject( object, camera, shadowCamera, light, type ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( ( object.castShadow || ( object.receiveShadow && type === VSMShadowMap ) ) && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {

				object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );

				const geometry = _objects.update( object );
				const material = object.material;

				if ( Array.isArray( material ) ) {

					const groups = geometry.groups;

					for ( let k = 0, kl = groups.length; k < kl; k ++ ) {

						const group = groups[ k ];
						const groupMaterial = material[ group.materialIndex ];

						if ( groupMaterial && groupMaterial.visible ) {

							const depthMaterial = getDepthMaterial( object, geometry, groupMaterial, light, shadowCamera.near, shadowCamera.far, type );

							_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

						}

					}

				} else if ( material.visible ) {

					const depthMaterial = getDepthMaterial( object, geometry, material, light, shadowCamera.near, shadowCamera.far, type );

					_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			renderObject( children[ i ], camera, shadowCamera, light, type );

		}

	}

}

function WebGLState( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function ColorBuffer() {

		let locked = false;

		const color = new Vector4();
		let currentColorMask = null;
		const currentColorClear = new Vector4( 0, 0, 0, 0 );

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

			}

		};

	}

	function DepthBuffer() {

		let locked = false;

		let currentDepthMask = null;
		let currentDepthFunc = null;
		let currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( 2929 );

				} else {

					disable( 2929 );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( 512 );
								break;

							case AlwaysDepth:

								gl.depthFunc( 519 );
								break;

							case LessDepth:

								gl.depthFunc( 513 );
								break;

							case LessEqualDepth:

								gl.depthFunc( 515 );
								break;

							case EqualDepth:

								gl.depthFunc( 514 );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( 518 );
								break;

							case GreaterDepth:

								gl.depthFunc( 516 );
								break;

							case NotEqualDepth:

								gl.depthFunc( 517 );
								break;

							default:

								gl.depthFunc( 515 );

						}

					} else {

						gl.depthFunc( 515 );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		let locked = false;

		let currentStencilMask = null;
		let currentStencilFunc = null;
		let currentStencilRef = null;
		let currentStencilFuncMask = null;
		let currentStencilFail = null;
		let currentStencilZFail = null;
		let currentStencilZPass = null;
		let currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( ! locked ) {

					if ( stencilTest ) {

						enable( 2960 );

					} else {

						disable( 2960 );

					}

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef !== stencilRef ||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail !== stencilFail ||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	const colorBuffer = new ColorBuffer();
	const depthBuffer = new DepthBuffer();
	const stencilBuffer = new StencilBuffer();

	let enabledCapabilities = {};

	let currentProgram = null;

	let currentBlendingEnabled = false;
	let currentBlending = null;
	let currentBlendEquation = null;
	let currentBlendSrc = null;
	let currentBlendDst = null;
	let currentBlendEquationAlpha = null;
	let currentBlendSrcAlpha = null;
	let currentBlendDstAlpha = null;
	let currentPremultipledAlpha = false;

	let currentFlipSided = null;
	let currentCullFace = null;

	let currentLineWidth = null;

	let currentPolygonOffsetFactor = null;
	let currentPolygonOffsetUnits = null;

	const maxTextures = gl.getParameter( 35661 );

	let lineWidthAvailable = false;
	let version = 0;
	const glVersion = gl.getParameter( 7938 );

	if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

		version = parseFloat( /^WebGL (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 1.0 );

	} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

		version = parseFloat( /^OpenGL ES (\d)/.exec( glVersion )[ 1 ] );
		lineWidthAvailable = ( version >= 2.0 );

	}

	let currentTextureSlot = null;
	let currentBoundTextures = {};

	const currentScissor = new Vector4();
	const currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		const data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		const texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, 10241, 9728 );
		gl.texParameteri( type, 10240, 9728 );

		for ( let i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

		}

		return texture;

	}

	const emptyTextures = {};
	emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
	emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

	// init

	colorBuffer.setClear( 0, 0, 0, 1 );
	depthBuffer.setClear( 1 );
	stencilBuffer.setClear( 0 );

	enable( 2929 );
	depthBuffer.setFunc( LessEqualDepth );

	setFlipSided( false );
	setCullFace( CullFaceBack );
	enable( 2884 );

	setBlending( NoBlending );

	//

	function enable( id ) {

		if ( enabledCapabilities[ id ] !== true ) {

			gl.enable( id );
			enabledCapabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( enabledCapabilities[ id ] !== false ) {

			gl.disable( id );
			enabledCapabilities[ id ] = false;

		}

	}

	function useProgram( program ) {

		if ( currentProgram !== program ) {

			gl.useProgram( program );

			currentProgram = program;

			return true;

		}

		return false;

	}

	const equationToGL = {
		[ AddEquation ]: 32774,
		[ SubtractEquation ]: 32778,
		[ ReverseSubtractEquation ]: 32779
	};

	if ( isWebGL2 ) {

		equationToGL[ MinEquation ] = 32775;
		equationToGL[ MaxEquation ] = 32776;

	} else {

		const extension = extensions.get( 'EXT_blend_minmax' );

		if ( extension !== null ) {

			equationToGL[ MinEquation ] = extension.MIN_EXT;
			equationToGL[ MaxEquation ] = extension.MAX_EXT;

		}

	}

	const factorToGL = {
		[ ZeroFactor ]: 0,
		[ OneFactor ]: 1,
		[ SrcColorFactor ]: 768,
		[ SrcAlphaFactor ]: 770,
		[ SrcAlphaSaturateFactor ]: 776,
		[ DstColorFactor ]: 774,
		[ DstAlphaFactor ]: 772,
		[ OneMinusSrcColorFactor ]: 769,
		[ OneMinusSrcAlphaFactor ]: 771,
		[ OneMinusDstColorFactor ]: 775,
		[ OneMinusDstAlphaFactor ]: 773
	};

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending === NoBlending ) {

			if ( currentBlendingEnabled === true ) {

				disable( 3042 );
				currentBlendingEnabled = false;

			}

			return;

		}

		if ( currentBlendingEnabled === false ) {

			enable( 3042 );
			currentBlendingEnabled = true;

		}

		if ( blending !== CustomBlending ) {

			if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

				if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

					gl.blendEquation( 32774 );

					currentBlendEquation = AddEquation;
					currentBlendEquationAlpha = AddEquation;

				}

				if ( premultipliedAlpha ) {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 1, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 1, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFuncSeparate( 0, 0, 769, 771 );
							break;

						case MultiplyBlending:
							gl.blendFuncSeparate( 0, 768, 0, 770 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				} else {

					switch ( blending ) {

						case NormalBlending:
							gl.blendFuncSeparate( 770, 771, 1, 771 );
							break;

						case AdditiveBlending:
							gl.blendFunc( 770, 1 );
							break;

						case SubtractiveBlending:
							gl.blendFunc( 0, 769 );
							break;

						case MultiplyBlending:
							gl.blendFunc( 0, 768 );
							break;

						default:
							console.error( 'THREE.WebGLState: Invalid blending: ', blending );
							break;

					}

				}

				currentBlendSrc = null;
				currentBlendDst = null;
				currentBlendSrcAlpha = null;
				currentBlendDstAlpha = null;

				currentBlending = blending;
				currentPremultipledAlpha = premultipliedAlpha;

			}

			return;

		}

		// custom blending

		blendEquationAlpha = blendEquationAlpha || blendEquation;
		blendSrcAlpha = blendSrcAlpha || blendSrc;
		blendDstAlpha = blendDstAlpha || blendDst;

		if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

			gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

			currentBlendEquation = blendEquation;
			currentBlendEquationAlpha = blendEquationAlpha;

		}

		if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

			gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

			currentBlendSrc = blendSrc;
			currentBlendDst = blendDst;
			currentBlendSrcAlpha = blendSrcAlpha;
			currentBlendDstAlpha = blendDstAlpha;

		}

		currentBlending = blending;
		currentPremultipledAlpha = null;

	}

	function setMaterial( material, frontFaceCW ) {

		material.side === DoubleSide
			? disable( 2884 )
			: enable( 2884 );

		let flipSided = ( material.side === BackSide );
		if ( frontFaceCW ) flipSided = ! flipSided;

		setFlipSided( flipSided );

		( material.blending === NormalBlending && material.transparent === false )
			? setBlending( NoBlending )
			: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

		depthBuffer.setFunc( material.depthFunc );
		depthBuffer.setTest( material.depthTest );
		depthBuffer.setMask( material.depthWrite );
		colorBuffer.setMask( material.colorWrite );

		const stencilWrite = material.stencilWrite;
		stencilBuffer.setTest( stencilWrite );
		if ( stencilWrite ) {

			stencilBuffer.setMask( material.stencilWriteMask );
			stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
			stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

		}

		setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( 2304 );

			} else {

				gl.frontFace( 2305 );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( 2884 );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( 1029 );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( 1028 );

				} else {

					gl.cullFace( 1032 );

				}

			}

		} else {

			disable( 2884 );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( 32823 );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( 32823 );

		}

	}

	function setScissorTest( scissorTest ) {

		if ( scissorTest ) {

			enable( 3089 );

		} else {

			disable( 3089 );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		let boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function unbindTexture() {

		const boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

			gl.bindTexture( boundTexture.type, null );

			boundTexture.type = undefined;
			boundTexture.texture = undefined;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	function texImage3D() {

		try {

			gl.texImage3D.apply( gl, arguments );

		} catch ( error ) {

			console.error( 'THREE.WebGLState:', error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		// reset state

		gl.disable( 3042 );
		gl.disable( 2884 );
		gl.disable( 2929 );
		gl.disable( 32823 );
		gl.disable( 3089 );
		gl.disable( 2960 );

		gl.blendEquation( 32774 );
		gl.blendFunc( 1, 0 );
		gl.blendFuncSeparate( 1, 0, 1, 0 );

		gl.colorMask( true, true, true, true );
		gl.clearColor( 0, 0, 0, 0 );

		gl.depthMask( true );
		gl.depthFunc( 513 );
		gl.clearDepth( 1 );

		gl.stencilMask( 0xffffffff );
		gl.stencilFunc( 519, 0, 0xffffffff );
		gl.stencilOp( 7680, 7680, 7680 );
		gl.clearStencil( 0 );

		gl.cullFace( 1029 );
		gl.frontFace( 2305 );

		gl.polygonOffset( 0, 0 );

		gl.activeTexture( 33984 );

		gl.useProgram( null );

		gl.lineWidth( 1 );

		gl.scissor( 0, 0, gl.canvas.width, gl.canvas.height );
		gl.viewport( 0, 0, gl.canvas.width, gl.canvas.height );

		// reset internals

		enabledCapabilities = {};

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentProgram = null;

		currentBlendingEnabled = false;
		currentBlending = null;
		currentBlendEquation = null;
		currentBlendSrc = null;
		currentBlendDst = null;
		currentBlendEquationAlpha = null;
		currentBlendSrcAlpha = null;
		currentBlendDstAlpha = null;
		currentPremultipledAlpha = false;

		currentFlipSided = null;
		currentCullFace = null;

		currentLineWidth = null;

		currentPolygonOffsetFactor = null;
		currentPolygonOffsetUnits = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		enable: enable,
		disable: disable,

		useProgram: useProgram,

		setBlending: setBlending,
		setMaterial: setMaterial,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		unbindTexture: unbindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,
		texImage3D: texImage3D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

	const isWebGL2 = capabilities.isWebGL2;
	const maxTextures = capabilities.maxTextures;
	const maxCubemapSize = capabilities.maxCubemapSize;
	const maxTextureSize = capabilities.maxTextureSize;
	const maxSamples = capabilities.maxSamples;

	const _videoTextures = new WeakMap();
	let _canvas;

	// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
	// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
	// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

	let useOffscreenCanvas = false;

	try {

		useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
			&& ( new OffscreenCanvas( 1, 1 ).getContext( '2d' ) ) !== null;

	} catch ( err ) {

		// Ignore any errors

	}

	function createCanvas( width, height ) {

		// Use OffscreenCanvas when available. Specially needed in web workers

		return useOffscreenCanvas ?
			new OffscreenCanvas( width, height ) :
			document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

	}

	function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

		let scale = 1;

		// handle case if texture exceeds max size

		if ( image.width > maxSize || image.height > maxSize ) {

			scale = maxSize / Math.max( image.width, image.height );

		}

		// only perform resize if necessary

		if ( scale < 1 || needsPowerOfTwo === true ) {

			// only perform resize for certain image types

			if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
				( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
				( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

				const floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

				const width = floor( scale * image.width );
				const height = floor( scale * image.height );

				if ( _canvas === undefined ) _canvas = createCanvas( width, height );

				// cube textures can't reuse the same canvas

				const canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

				canvas.width = width;
				canvas.height = height;

				const context = canvas.getContext( '2d' );
				context.drawImage( image, 0, 0, width, height );

				console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

				return canvas;

			} else {

				if ( 'data' in image ) {

					console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

				}

				return image;

			}

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

	}

	function textureNeedsPowerOfTwo( texture ) {

		if ( isWebGL2 ) return false;

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	function textureNeedsGenerateMipmaps( texture, supportsMips ) {

		return texture.generateMipmaps && supportsMips &&
			texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

	}

	function generateMipmap( target, texture, width, height ) {

		_gl.generateMipmap( target );

		const textureProperties = properties.get( texture );

		textureProperties.__maxMipLevel = Math.log2( Math.max( width, height ) );

	}

	function getInternalFormat( internalFormatName, glFormat, glType ) {

		if ( isWebGL2 === false ) return glFormat;

		if ( internalFormatName !== null ) {

			if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

			console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

		}

		let internalFormat = glFormat;

		if ( glFormat === 6403 ) {

			if ( glType === 5126 ) internalFormat = 33326;
			if ( glType === 5131 ) internalFormat = 33325;
			if ( glType === 5121 ) internalFormat = 33321;

		}

		if ( glFormat === 6407 ) {

			if ( glType === 5126 ) internalFormat = 34837;
			if ( glType === 5131 ) internalFormat = 34843;
			if ( glType === 5121 ) internalFormat = 32849;

		}

		if ( glFormat === 6408 ) {

			if ( glType === 5126 ) internalFormat = 34836;
			if ( glType === 5131 ) internalFormat = 34842;
			if ( glType === 5121 ) internalFormat = 32856;

		}

		if ( internalFormat === 33325 || internalFormat === 33326 ||
			internalFormat === 34842 || internalFormat === 34836 ) {

			extensions.get( 'EXT_color_buffer_float' );

		}

		return internalFormat;

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

			return 9728;

		}

		return 9729;

	}

	//

	function onTextureDispose( event ) {

		const texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		if ( texture.isVideoTexture ) {

			_videoTextures.delete( texture );

		}

		info.memory.textures --;

	}

	function onRenderTargetDispose( event ) {

		const renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		info.memory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		const textureProperties = properties.get( texture );

		if ( textureProperties.__webglInit === undefined ) return;

		_gl.deleteTexture( textureProperties.__webglTexture );

		properties.remove( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLCubeRenderTarget ) {

			for ( let i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
			if ( renderTargetProperties.__webglMultisampledFramebuffer ) _gl.deleteFramebuffer( renderTargetProperties.__webglMultisampledFramebuffer );
			if ( renderTargetProperties.__webglColorRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglColorRenderbuffer );
			if ( renderTargetProperties.__webglDepthRenderbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthRenderbuffer );

		}

		properties.remove( texture );
		properties.remove( renderTarget );

	}

	//

	let textureUnits = 0;

	function resetTextureUnits() {

		textureUnits = 0;

	}

	function allocateTextureUnit() {

		const textureUnit = textureUnits;

		if ( textureUnit >= maxTextures ) {

			console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

		}

		textureUnits += 1;

		return textureUnit;

	}

	//

	function setTexture2D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.isVideoTexture ) updateVideoTexture( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			const image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 3553, textureProperties.__webglTexture );

	}

	function setTexture2DArray( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 35866, textureProperties.__webglTexture );

	}

	function setTexture3D( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 32879, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		const textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			uploadCubeTexture( textureProperties, texture, slot );
			return;

		}

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

	}

	const wrappingToGL = {
		[ RepeatWrapping$1 ]: 10497,
		[ ClampToEdgeWrapping ]: 33071,
		[ MirroredRepeatWrapping ]: 33648
	};

	const filterToGL = {
		[ NearestFilter ]: 9728,
		[ NearestMipmapNearestFilter ]: 9984,
		[ NearestMipmapLinearFilter ]: 9986,

		[ LinearFilter ]: 9729,
		[ LinearMipmapNearestFilter ]: 9985,
		[ LinearMipmapLinearFilter ]: 9987
	};

	function setTextureParameters( textureType, texture, supportsMips ) {

		if ( supportsMips ) {

			_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
			_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

			}

			_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
			_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

		} else {

			_gl.texParameteri( textureType, 10242, 33071 );
			_gl.texParameteri( textureType, 10243, 33071 );

			if ( textureType === 32879 || textureType === 35866 ) {

				_gl.texParameteri( textureType, 32882, 33071 );

			}

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

			}

			_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

			}

		}

		if ( extensions.has( 'EXT_texture_filter_anisotropic' ) === true ) {

			const extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( texture.type === FloatType$1 && extensions.has( 'OES_texture_float_linear' ) === false ) return; // verify extension for WebGL 1 and WebGL 2
			if ( isWebGL2 === false && ( texture.type === HalfFloatType && extensions.has( 'OES_texture_half_float_linear' ) === false ) ) return; // verify extension for WebGL 1 only

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function initTexture( textureProperties, texture ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		let textureType = 3553;

		if ( texture.isDataTexture2DArray ) textureType = 35866;
		if ( texture.isDataTexture3D ) textureType = 32879;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( textureType, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
		const image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

		const supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format );

		let glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( textureType, texture, supportsMips );

		let mipmap;
		const mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			glInternalFormat = 6402;

			if ( isWebGL2 ) {

				if ( texture.type === FloatType$1 ) {

					glInternalFormat = 36012;

				} else if ( texture.type === UnsignedIntType ) {

					glInternalFormat = 33190;

				} else if ( texture.type === UnsignedInt248Type ) {

					glInternalFormat = 35056;

				} else {

					glInternalFormat = 33189; // WebGL2 requires sized internalformat for glTexImage2D

				}

			} else {

				if ( texture.type === FloatType$1 ) {

					console.error( 'WebGLRenderer: Floating point depth texture requires WebGL2.' );

				}

			}

			// validation checks for WebGL 1

			if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = utils.convert( texture.type );

				}

			}

			if ( texture.format === DepthStencilFormat && glInternalFormat === 6402 ) {

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				glInternalFormat = 34041;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

					console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = utils.convert( texture.type );

				}

			}

			//

			state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			}

		} else if ( texture.isCompressedTexture ) {

			for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( glFormat !== null ) {

						state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

					}

				} else {

					state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else if ( texture.isDataTexture2DArray ) {

			state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else if ( texture.isDataTexture3D ) {

			state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
			textureProperties.__maxMipLevel = 0;

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && supportsMips ) {

				for ( let i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;
				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else {

				state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
				textureProperties.__maxMipLevel = 0;

			}

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			generateMipmap( textureType, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	function uploadCubeTexture( textureProperties, texture, slot ) {

		if ( texture.image.length !== 6 ) return;

		initTexture( textureProperties, texture );

		state.activeTexture( 33984 + slot );
		state.bindTexture( 34067, textureProperties.__webglTexture );

		_gl.pixelStorei( 37440, texture.flipY );
		_gl.pixelStorei( 37441, texture.premultiplyAlpha );
		_gl.pixelStorei( 3317, texture.unpackAlignment );
		_gl.pixelStorei( 37443, 0 );

		const isCompressed = ( texture && ( texture.isCompressedTexture || texture.image[ 0 ].isCompressedTexture ) );
		const isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

		const cubeImage = [];

		for ( let i = 0; i < 6; i ++ ) {

			if ( ! isCompressed && ! isDataTexture ) {

				cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, maxCubemapSize );

			} else {

				cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

			}

		}

		const image = cubeImage[ 0 ],
			supportsMips = isPowerOfTwo( image ) || isWebGL2,
			glFormat = utils.convert( texture.format ),
			glType = utils.convert( texture.type ),
			glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		setTextureParameters( 34067, texture, supportsMips );

		let mipmaps;

		if ( isCompressed ) {

			for ( let i = 0; i < 6; i ++ ) {

				mipmaps = cubeImage[ i ].mipmaps;

				for ( let j = 0; j < mipmaps.length; j ++ ) {

					const mipmap = mipmaps[ j ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );

						}

					} else {

						state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length - 1;

		} else {

			mipmaps = texture.mipmaps;

			for ( let i = 0; i < 6; i ++ ) {

				if ( isDataTexture ) {

					state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];
						const mipmapImage = mipmap.image[ i ].image;

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data );

					}

				} else {

					state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );

					for ( let j = 0; j < mipmaps.length; j ++ ) {

						const mipmap = mipmaps[ j ];

						state.texImage2D( 34069 + i, j + 1, glInternalFormat, glFormat, glType, mipmap.image[ i ] );

					}

				}

			}

			textureProperties.__maxMipLevel = mipmaps.length;

		}

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			// We assume images for cube map have the same size.
			generateMipmap( 34067, texture, image.width, image.height );

		}

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		const texture = renderTarget.texture;

		const glFormat = utils.convert( texture.format );
		const glType = utils.convert( texture.type );
		const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

		if ( textureTarget === 32879 || textureTarget === 35866 ) {

			state.texImage3D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, renderTarget.depth, 0, glFormat, glType, null );

		} else {

			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );

		}

		_gl.bindFramebuffer( 36160, framebuffer );
		_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( 36160, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

		_gl.bindRenderbuffer( 36161, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			let glInternalFormat = 33189;

			if ( isMultisample ) {

				const depthTexture = renderTarget.depthTexture;

				if ( depthTexture && depthTexture.isDepthTexture ) {

					if ( depthTexture.type === FloatType$1 ) {

						glInternalFormat = 36012;

					} else if ( depthTexture.type === UnsignedIntType ) {

						glInternalFormat = 33190;

					}

				}

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

			_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

			}


			_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

		} else {

			const texture = renderTarget.texture;

			const glFormat = utils.convert( texture.format );
			const glType = utils.convert( texture.type );
			const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			if ( isMultisample ) {

				const samples = getRenderTargetSamples( renderTarget );

				_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

			} else {

				_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

			}

		}

		_gl.bindRenderbuffer( 36161, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		const isCube = ( renderTarget && renderTarget.isWebGLCubeRenderTarget );
		if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

		_gl.bindFramebuffer( 36160, framebuffer );

		if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

		}

		// upload an empty depth texture with framebuffer size
		if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {

			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;

		}

		setTexture2D( renderTarget.depthTexture, 0 );

		const webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

		} else {

			throw new Error( 'Unknown depthTexture format' );

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		const renderTargetProperties = properties.get( renderTarget );

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( let i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget, false );

				}

			} else {

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget, false );

			}

		}

		_gl.bindFramebuffer( 36160, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		const texture = renderTarget.texture;

		const renderTargetProperties = properties.get( renderTarget );
		const textureProperties = properties.get( texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		info.memory.textures ++;

		const isCube = ( renderTarget.isWebGLCubeRenderTarget === true );
		const isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
		const isRenderTarget3D = texture.isDataTexture3D || texture.isDataTexture2DArray;
		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		// Handles WebGL2 RGBFormat fallback - #18858

		if ( isWebGL2 && texture.format === RGBFormat && ( texture.type === FloatType$1 || texture.type === HalfFloatType ) ) {

			texture.format = RGBAFormat;

			console.warn( 'THREE.WebGLRenderer: Rendering to textures with RGB format is not supported. Using RGBA format instead.' );

		}

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( let i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

			if ( isMultisample ) {

				if ( isWebGL2 ) {

					renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
					renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

					_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

					const glFormat = utils.convert( texture.format );
					const glType = utils.convert( texture.type );
					const glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );
					const samples = getRenderTargetSamples( renderTarget );
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
					_gl.bindRenderbuffer( 36161, null );

					if ( renderTarget.depthBuffer ) {

						renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

					}

					_gl.bindFramebuffer( 36160, null );


				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( 34067, textureProperties.__webglTexture );
			setTextureParameters( 34067, texture, supportsMips );

			for ( let i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 34067, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 34067, null );

		} else {

			let glTextureType = 3553;

			if ( isRenderTarget3D ) {

				// Render targets containing layers, i.e: Texture 3D and 2d arrays

				if ( isWebGL2 ) {

					const isTexture3D = texture.isDataTexture3D;
					glTextureType = isTexture3D ? 32879 : 35866;

				} else {

					console.warn( 'THREE.DataTexture3D and THREE.DataTexture2DArray only supported with WebGL2.' );

				}

			}

			state.bindTexture( glTextureType, textureProperties.__webglTexture );
			setTextureParameters( glTextureType, texture, supportsMips );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, glTextureType );

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( 3553, texture, renderTarget.width, renderTarget.height );

			}

			state.bindTexture( 3553, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		const texture = renderTarget.texture;

		const supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

		if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

			const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553;
			const webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			generateMipmap( target, texture, renderTarget.width, renderTarget.height );
			state.bindTexture( target, null );

		}

	}

	function updateMultisampleRenderTarget( renderTarget ) {

		if ( renderTarget.isWebGLMultisampleRenderTarget ) {

			if ( isWebGL2 ) {

				const renderTargetProperties = properties.get( renderTarget );

				_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
				_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

				const width = renderTarget.width;
				const height = renderTarget.height;
				let mask = 16384;

				if ( renderTarget.depthBuffer ) mask |= 256;
				if ( renderTarget.stencilBuffer ) mask |= 1024;

				_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer ); // see #18905

			} else {

				console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

			}

		}

	}

	function getRenderTargetSamples( renderTarget ) {

		return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
			Math.min( maxSamples, renderTarget.samples ) : 0;

	}

	function updateVideoTexture( texture ) {

		const frame = info.render.frame;

		// Check the last frame we updated the VideoTexture

		if ( _videoTextures.get( texture ) !== frame ) {

			_videoTextures.set( texture, frame );
			texture.update();

		}

	}

	// backwards compatibility

	let warnedTexture2D = false;
	let warnedTextureCube = false;

	function safeSetTexture2D( texture, slot ) {

		if ( texture && texture.isWebGLRenderTarget ) {

			if ( warnedTexture2D === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTexture2D: don\'t use render targets as textures. Use their .texture property instead.' );
				warnedTexture2D = true;

			}

			texture = texture.texture;

		}

		setTexture2D( texture, slot );

	}

	function safeSetTextureCube( texture, slot ) {

		if ( texture && texture.isWebGLCubeRenderTarget ) {

			if ( warnedTextureCube === false ) {

				console.warn( 'THREE.WebGLTextures.safeSetTextureCube: don\'t use cube render targets as textures. Use their .texture property instead.' );
				warnedTextureCube = true;

			}

			texture = texture.texture;

		}


		setTextureCube( texture, slot );

	}

	//

	this.allocateTextureUnit = allocateTextureUnit;
	this.resetTextureUnits = resetTextureUnits;

	this.setTexture2D = setTexture2D;
	this.setTexture2DArray = setTexture2DArray;
	this.setTexture3D = setTexture3D;
	this.setTextureCube = setTextureCube;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

	this.safeSetTexture2D = safeSetTexture2D;
	this.safeSetTextureCube = safeSetTextureCube;

}

function WebGLUtils( gl, extensions, capabilities ) {

	const isWebGL2 = capabilities.isWebGL2;

	function convert( p ) {

		let extension;

		if ( p === UnsignedByteType ) return 5121;
		if ( p === UnsignedShort4444Type ) return 32819;
		if ( p === UnsignedShort5551Type ) return 32820;
		if ( p === UnsignedShort565Type ) return 33635;

		if ( p === ByteType ) return 5120;
		if ( p === ShortType ) return 5122;
		if ( p === UnsignedShortType ) return 5123;
		if ( p === IntType ) return 5124;
		if ( p === UnsignedIntType ) return 5125;
		if ( p === FloatType$1 ) return 5126;

		if ( p === HalfFloatType ) {

			if ( isWebGL2 ) return 5131;

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) {

				return extension.HALF_FLOAT_OES;

			} else {

				return null;

			}

		}

		if ( p === AlphaFormat ) return 6406;
		if ( p === RGBFormat ) return 6407;
		if ( p === RGBAFormat ) return 6408;
		if ( p === LuminanceFormat ) return 6409;
		if ( p === LuminanceAlphaFormat ) return 6410;
		if ( p === DepthFormat ) return 6402;
		if ( p === DepthStencilFormat ) return 34041;
		if ( p === RedFormat ) return 6403;

		// WebGL2 formats.

		if ( p === RedIntegerFormat ) return 36244;
		if ( p === RGFormat ) return 33319;
		if ( p === RGIntegerFormat ) return 33320;
		if ( p === RGBIntegerFormat ) return 36248;
		if ( p === RGBAIntegerFormat ) return 36249;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			} else {

				return null;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) {

				return extension.COMPRESSED_RGB_ETC1_WEBGL;

			} else {

				return null;

			}

		}

		if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc' );

			if ( extension !== null ) {

				if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
				if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

			}

		}

		if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
			p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
			p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
			p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
			p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
			p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
			p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
			p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
			p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
			p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_astc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === RGBA_BPTC_Format ) {

			extension = extensions.get( 'EXT_texture_compression_bptc' );

			if ( extension !== null ) {

				// TODO Complete?

				return p;

			} else {

				return null;

			}

		}

		if ( p === UnsignedInt248Type ) {

			if ( isWebGL2 ) return 34042;

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) {

				return extension.UNSIGNED_INT_24_8_WEBGL;

			} else {

				return null;

			}

		}

	}

	return { convert: convert };

}

function ArrayCamera( array = [] ) {

	PerspectiveCamera.call( this );

	this.cameras = array;

}

ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {

	constructor: ArrayCamera,

	isArrayCamera: true

} );

class Group extends Object3D {

	constructor() {

		super();

		this.type = 'Group';

	}

}

Group.prototype.isGroup = true;

function WebXRController() {

	this._targetRay = null;
	this._grip = null;
	this._hand = null;

}

Object.assign( WebXRController.prototype, {

	constructor: WebXRController,

	getHandSpace: function () {

		if ( this._hand === null ) {

			this._hand = new Group();
			this._hand.matrixAutoUpdate = false;
			this._hand.visible = false;

			this._hand.joints = {};
			this._hand.inputState = { pinching: false };

		}

		return this._hand;

	},

	getTargetRaySpace: function () {

		if ( this._targetRay === null ) {

			this._targetRay = new Group();
			this._targetRay.matrixAutoUpdate = false;
			this._targetRay.visible = false;

		}

		return this._targetRay;

	},

	getGripSpace: function () {

		if ( this._grip === null ) {

			this._grip = new Group();
			this._grip.matrixAutoUpdate = false;
			this._grip.visible = false;

		}

		return this._grip;

	},

	dispatchEvent: function ( event ) {

		if ( this._targetRay !== null ) {

			this._targetRay.dispatchEvent( event );

		}

		if ( this._grip !== null ) {

			this._grip.dispatchEvent( event );

		}

		if ( this._hand !== null ) {

			this._hand.dispatchEvent( event );

		}

		return this;

	},

	disconnect: function ( inputSource ) {

		this.dispatchEvent( { type: 'disconnected', data: inputSource } );

		if ( this._targetRay !== null ) {

			this._targetRay.visible = false;

		}

		if ( this._grip !== null ) {

			this._grip.visible = false;

		}

		if ( this._hand !== null ) {

			this._hand.visible = false;

		}

		return this;

	},

	update: function ( inputSource, frame, referenceSpace ) {

		let inputPose = null;
		let gripPose = null;
		let handPose = null;

		const targetRay = this._targetRay;
		const grip = this._grip;
		const hand = this._hand;

		if ( inputSource && frame.session.visibilityState !== 'visible-blurred' ) {

			if ( hand && inputSource.hand ) {

				handPose = true;

				for ( const inputjoint of inputSource.hand.values() ) {

					// Update the joints groups with the XRJoint poses
					const jointPose = frame.getJointPose( inputjoint, referenceSpace );

					if ( hand.joints[ inputjoint.jointName ] === undefined ) {

						// The transform of this joint will be updated with the joint pose on each frame
						const joint = new Group();
						joint.matrixAutoUpdate = false;
						joint.visible = false;
						hand.joints[ inputjoint.jointName ] = joint;
						// ??
						hand.add( joint );

					}

					const joint = hand.joints[ inputjoint.jointName ];

					if ( jointPose !== null ) {

						joint.matrix.fromArray( jointPose.transform.matrix );
						joint.matrix.decompose( joint.position, joint.rotation, joint.scale );
						joint.jointRadius = jointPose.radius;

					}

					joint.visible = jointPose !== null;

				}

				// Custom events

				// Check pinchz
				const indexTip = hand.joints[ 'index-finger-tip' ];
				const thumbTip = hand.joints[ 'thumb-tip' ];
				const distance = indexTip.position.distanceTo( thumbTip.position );

				const distanceToPinch = 0.02;
				const threshold = 0.005;

				if ( hand.inputState.pinching && distance > distanceToPinch + threshold ) {

					hand.inputState.pinching = false;
					this.dispatchEvent( {
						type: 'pinchend',
						handedness: inputSource.handedness,
						target: this
					} );

				} else if ( ! hand.inputState.pinching && distance <= distanceToPinch - threshold ) {

					hand.inputState.pinching = true;
					this.dispatchEvent( {
						type: 'pinchstart',
						handedness: inputSource.handedness,
						target: this
					} );

				}

			} else {

				if ( targetRay !== null ) {

					inputPose = frame.getPose( inputSource.targetRaySpace, referenceSpace );

					if ( inputPose !== null ) {

						targetRay.matrix.fromArray( inputPose.transform.matrix );
						targetRay.matrix.decompose( targetRay.position, targetRay.rotation, targetRay.scale );

					}

				}

				if ( grip !== null && inputSource.gripSpace ) {

					gripPose = frame.getPose( inputSource.gripSpace, referenceSpace );

					if ( gripPose !== null ) {

						grip.matrix.fromArray( gripPose.transform.matrix );
						grip.matrix.decompose( grip.position, grip.rotation, grip.scale );

					}

				}

			}

		}

		if ( targetRay !== null ) {

			targetRay.visible = ( inputPose !== null );

		}

		if ( grip !== null ) {

			grip.visible = ( gripPose !== null );

		}

		if ( hand !== null ) {

			hand.visible = ( handPose !== null );

		}

		return this;

	}

} );

function WebXRManager( renderer, gl ) {

	const scope = this;

	let session = null;

	let framebufferScaleFactor = 1.0;

	let referenceSpace = null;
	let referenceSpaceType = 'local-floor';

	let pose = null;

	const controllers = [];
	const inputSourcesMap = new Map();

	//

	const cameraL = new PerspectiveCamera();
	cameraL.layers.enable( 1 );
	cameraL.viewport = new Vector4();

	const cameraR = new PerspectiveCamera();
	cameraR.layers.enable( 2 );
	cameraR.viewport = new Vector4();

	const cameras = [ cameraL, cameraR ];

	const cameraVR = new ArrayCamera();
	cameraVR.layers.enable( 1 );
	cameraVR.layers.enable( 2 );

	let _currentDepthNear = null;
	let _currentDepthFar = null;

	//

	this.enabled = false;

	this.isPresenting = false;

	this.getController = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getTargetRaySpace();

	};

	this.getControllerGrip = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getGripSpace();

	};

	this.getHand = function ( index ) {

		let controller = controllers[ index ];

		if ( controller === undefined ) {

			controller = new WebXRController();
			controllers[ index ] = controller;

		}

		return controller.getHandSpace();

	};

	//

	function onSessionEvent( event ) {

		const controller = inputSourcesMap.get( event.inputSource );

		if ( controller ) {

			controller.dispatchEvent( { type: event.type, data: event.inputSource } );

		}

	}

	function onSessionEnd() {

		inputSourcesMap.forEach( function ( controller, inputSource ) {

			controller.disconnect( inputSource );

		} );

		inputSourcesMap.clear();

		_currentDepthNear = null;
		_currentDepthFar = null;

		//

		renderer.setFramebuffer( null );
		renderer.setRenderTarget( renderer.getRenderTarget() ); // Hack #15830
		animation.stop();

		scope.isPresenting = false;

		scope.dispatchEvent( { type: 'sessionend' } );

	}

	this.setFramebufferScaleFactor = function ( value ) {

		framebufferScaleFactor = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change framebuffer scale while presenting.' );

		}

	};

	this.setReferenceSpaceType = function ( value ) {

		referenceSpaceType = value;

		if ( scope.isPresenting === true ) {

			console.warn( 'THREE.WebXRManager: Cannot change reference space type while presenting.' );

		}

	};

	this.getReferenceSpace = function () {

		return referenceSpace;

	};

	this.getSession = function () {

		return session;

	};

	this.setSession = async function ( value ) {

		session = value;

		if ( session !== null ) {

			session.addEventListener( 'select', onSessionEvent );
			session.addEventListener( 'selectstart', onSessionEvent );
			session.addEventListener( 'selectend', onSessionEvent );
			session.addEventListener( 'squeeze', onSessionEvent );
			session.addEventListener( 'squeezestart', onSessionEvent );
			session.addEventListener( 'squeezeend', onSessionEvent );
			session.addEventListener( 'end', onSessionEnd );
			session.addEventListener( 'inputsourceschange', onInputSourcesChange );

			const attributes = gl.getContextAttributes();

			if ( attributes.xrCompatible !== true ) {

				await gl.makeXRCompatible();

			}

			const layerInit = {
				antialias: attributes.antialias,
				alpha: attributes.alpha,
				depth: attributes.depth,
				stencil: attributes.stencil,
				framebufferScaleFactor: framebufferScaleFactor
			};

			// eslint-disable-next-line no-undef
			const baseLayer = new XRWebGLLayer( session, gl, layerInit );

			session.updateRenderState( { baseLayer: baseLayer } );

			referenceSpace = await session.requestReferenceSpace( referenceSpaceType );

			animation.setContext( session );
			animation.start();

			scope.isPresenting = true;

			scope.dispatchEvent( { type: 'sessionstart' } );

		}

	};

	function onInputSourcesChange( event ) {

		const inputSources = session.inputSources;

		// Assign inputSources to available controllers

		for ( let i = 0; i < controllers.length; i ++ ) {

			inputSourcesMap.set( inputSources[ i ], controllers[ i ] );

		}

		// Notify disconnected

		for ( let i = 0; i < event.removed.length; i ++ ) {

			const inputSource = event.removed[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'disconnected', data: inputSource } );
				inputSourcesMap.delete( inputSource );

			}

		}

		// Notify connected

		for ( let i = 0; i < event.added.length; i ++ ) {

			const inputSource = event.added[ i ];
			const controller = inputSourcesMap.get( inputSource );

			if ( controller ) {

				controller.dispatchEvent( { type: 'connected', data: inputSource } );

			}

		}

	}

	//

	const cameraLPos = new Vector3$1();
	const cameraRPos = new Vector3$1();

	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {

		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );

		const ipd = cameraLPos.distanceTo( cameraRPos );

		const projL = cameraL.projectionMatrix.elements;
		const projR = cameraR.projectionMatrix.elements;

		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		const near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		const far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		const topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		const bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];

		const leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		const rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		const left = near * leftFov;
		const right = near * rightFov;

		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		const zOffset = ipd / ( - leftFov + rightFov );
		const xOffset = zOffset * - leftFov;

		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		const near2 = near + zOffset;
		const far2 = far + zOffset;
		const left2 = left - xOffset;
		const right2 = right + ( ipd - xOffset );
		const top2 = topFov * far / far2 * near2;
		const bottom2 = bottomFov * far / far2 * near2;

		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );

	}

	function updateCamera( camera, parent ) {

		if ( parent === null ) {

			camera.matrixWorld.copy( camera.matrix );

		} else {

			camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );

		}

		camera.matrixWorldInverse.copy( camera.matrixWorld ).invert();

	}

	this.getCamera = function ( camera ) {

		cameraVR.near = cameraR.near = cameraL.near = camera.near;
		cameraVR.far = cameraR.far = cameraL.far = camera.far;

		if ( _currentDepthNear !== cameraVR.near || _currentDepthFar !== cameraVR.far ) {

			// Note that the new renderState won't apply until the next frame. See #18320

			session.updateRenderState( {
				depthNear: cameraVR.near,
				depthFar: cameraVR.far
			} );

			_currentDepthNear = cameraVR.near;
			_currentDepthFar = cameraVR.far;

		}

		const parent = camera.parent;
		const cameras = cameraVR.cameras;

		updateCamera( cameraVR, parent );

		for ( let i = 0; i < cameras.length; i ++ ) {

			updateCamera( cameras[ i ], parent );

		}

		// update camera and its children

		camera.matrixWorld.copy( cameraVR.matrixWorld );
		camera.matrix.copy( cameraVR.matrix );
		camera.matrix.decompose( camera.position, camera.quaternion, camera.scale );

		const children = camera.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( true );

		}

		// update projection matrix for proper view frustum culling

		if ( cameras.length === 2 ) {

			setProjectionFromUnion( cameraVR, cameraL, cameraR );

		} else {

			// assume single camera setup (AR)

			cameraVR.projectionMatrix.copy( cameraL.projectionMatrix );

		}

		return cameraVR;

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time, frame ) {

		pose = frame.getViewerPose( referenceSpace );

		if ( pose !== null ) {

			const views = pose.views;
			const baseLayer = session.renderState.baseLayer;

			renderer.setFramebuffer( baseLayer.framebuffer );

			let cameraVRNeedsUpdate = false;

			// check if it's necessary to rebuild cameraVR's camera list

			if ( views.length !== cameraVR.cameras.length ) {

				cameraVR.cameras.length = 0;
				cameraVRNeedsUpdate = true;

			}

			for ( let i = 0; i < views.length; i ++ ) {

				const view = views[ i ];
				const viewport = baseLayer.getViewport( view );

				const camera = cameras[ i ];
				camera.matrix.fromArray( view.transform.matrix );
				camera.projectionMatrix.fromArray( view.projectionMatrix );
				camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );

				if ( i === 0 ) {

					cameraVR.matrix.copy( camera.matrix );

				}

				if ( cameraVRNeedsUpdate === true ) {

					cameraVR.cameras.push( camera );

				}

			}

		}

		//

		const inputSources = session.inputSources;

		for ( let i = 0; i < controllers.length; i ++ ) {

			const controller = controllers[ i ];
			const inputSource = inputSources[ i ];

			controller.update( inputSource, frame, referenceSpace );

		}

		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time, frame );

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;

	};

	this.dispose = function () {};

}

Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

function WebGLMaterials( properties ) {

	function refreshFogUniforms( uniforms, fog ) {

		uniforms.fogColor.value.copy( fog.color );

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshMaterialUniforms( uniforms, material, pixelRatio, height ) {

		if ( material.isMeshBasicMaterial ) {

			refreshUniformsCommon( uniforms, material );

		} else if ( material.isMeshLambertMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsLambert( uniforms, material );

		} else if ( material.isMeshToonMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsToon( uniforms, material );

		} else if ( material.isMeshPhongMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsPhong( uniforms, material );

		} else if ( material.isMeshStandardMaterial ) {

			refreshUniformsCommon( uniforms, material );

			if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( uniforms, material );

			} else {

				refreshUniformsStandard( uniforms, material );

			}

		} else if ( material.isMeshMatcapMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsMatcap( uniforms, material );

		} else if ( material.isMeshDepthMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDepth( uniforms, material );

		} else if ( material.isMeshDistanceMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsDistance( uniforms, material );

		} else if ( material.isMeshNormalMaterial ) {

			refreshUniformsCommon( uniforms, material );
			refreshUniformsNormal( uniforms, material );

		} else if ( material.isLineBasicMaterial ) {

			refreshUniformsLine( uniforms, material );

			if ( material.isLineDashedMaterial ) {

				refreshUniformsDash( uniforms, material );

			}

		} else if ( material.isPointsMaterial ) {

			refreshUniformsPoints( uniforms, material, pixelRatio, height );

		} else if ( material.isSpriteMaterial ) {

			refreshUniformsSprites( uniforms, material );

		} else if ( material.isShadowMaterial ) {

			uniforms.color.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		} else if ( material.isShaderMaterial ) {

			material.uniformsNeedUpdate = false; // #15581

		}

	}

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		if ( material.color ) {

			uniforms.diffuse.value.copy( material.color );

		}

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		if ( material.specularMap ) {

			uniforms.specularMap.value = material.specularMap;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			uniforms.envMap.value = envMap;

			uniforms.flipEnvMap.value = ( envMap.isCubeTexture && envMap._needsFlipEnvMap ) ? - 1 : 1;

			uniforms.reflectivity.value = material.reflectivity;
			uniforms.refractionRatio.value = material.refractionRatio;

			const maxMipLevel = properties.get( envMap ).__maxMipLevel;

			if ( maxMipLevel !== undefined ) {

				uniforms.maxMipLevel.value = maxMipLevel;

			}

		}

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. displacementMap map
		// 4. normal map
		// 5. bump map
		// 6. roughnessMap map
		// 7. metalnessMap map
		// 8. alphaMap map
		// 9. emissiveMap map
		// 10. clearcoat map
		// 11. clearcoat normal map
		// 12. clearcoat roughnessMap map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		} else if ( material.clearcoatMap ) {

			uvScaleMap = material.clearcoatMap;

		} else if ( material.clearcoatNormalMap ) {

			uvScaleMap = material.clearcoatNormalMap;

		} else if ( material.clearcoatRoughnessMap ) {

			uvScaleMap = material.clearcoatRoughnessMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

		// uv repeat and offset setting priorities for uv2
		// 1. ao map
		// 2. light map

		let uv2ScaleMap;

		if ( material.aoMap ) {

			uv2ScaleMap = material.aoMap;

		} else if ( material.lightMap ) {

			uv2ScaleMap = material.lightMap;

		}

		if ( uv2ScaleMap !== undefined ) {

			// backwards compatibility
			if ( uv2ScaleMap.isWebGLRenderTarget ) {

				uv2ScaleMap = uv2ScaleMap.texture;

			}

			if ( uv2ScaleMap.matrixAutoUpdate === true ) {

				uv2ScaleMap.updateMatrix();

			}

			uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

		}

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material, pixelRatio, height ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * pixelRatio;
		uniforms.scale.value = height * 0.5;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsSprites( uniforms, material ) {

		uniforms.diffuse.value.copy( material.color );
		uniforms.opacity.value = material.opacity;
		uniforms.rotation.value = material.rotation;

		if ( material.map ) {

			uniforms.map.value = material.map;

		}

		if ( material.alphaMap ) {

			uniforms.alphaMap.value = material.alphaMap;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. alpha map

		let uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		}

		if ( uvScaleMap !== undefined ) {

			if ( uvScaleMap.matrixAutoUpdate === true ) {

				uvScaleMap.updateMatrix();

			}

			uniforms.uvTransform.value.copy( uvScaleMap.matrix );

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value.copy( material.specular );
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		const envMap = properties.get( material ).envMap;

		if ( envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		refreshUniformsStandard( uniforms, material );

		uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common

		uniforms.clearcoat.value = material.clearcoat;
		uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
		if ( material.sheen ) uniforms.sheen.value.copy( material.sheen );

		if ( material.clearcoatMap ) {

			uniforms.clearcoatMap.value = material.clearcoatMap;

		}

		if ( material.clearcoatRoughnessMap ) {

			uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;

		}

		if ( material.clearcoatNormalMap ) {

			uniforms.clearcoatNormalScale.value.copy( material.clearcoatNormalScale );
			uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;

			if ( material.side === BackSide ) {

				uniforms.clearcoatNormalScale.value.negate();

			}

		}

		uniforms.transmission.value = material.transmission;

		if ( material.transmissionMap ) {

			uniforms.transmissionMap.value = material.transmissionMap;

		}

	}

	function refreshUniformsMatcap( uniforms, material ) {

		if ( material.matcap ) {

			uniforms.matcap.value = material.matcap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDepth( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsDistance( uniforms, material ) {

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		uniforms.referencePosition.value.copy( material.referencePosition );
		uniforms.nearDistance.value = material.nearDistance;
		uniforms.farDistance.value = material.farDistance;

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;
			if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );
			if ( material.side === BackSide ) uniforms.normalScale.value.negate();

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	return {
		refreshFogUniforms: refreshFogUniforms,
		refreshMaterialUniforms: refreshMaterialUniforms
	};

}

function createCanvasElement() {

	const canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	canvas.style.display = 'block';
	return canvas;

}

function WebGLRenderer( parameters ) {

	parameters = parameters || {};

	const _canvas = parameters.canvas !== undefined ? parameters.canvas : createCanvasElement(),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
		_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
		_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

	let currentRenderList = null;
	let currentRenderState = null;

	// render() can be called from within a callback triggered by another render.
	// We track this so that the nested render call gets its list and state isolated from the parent render call.

	const renderListStack = [];
	const renderStateStack = [];

	// public properties

	this.domElement = _canvas;

	// Debug configuration container
	this.debug = {

		/**
		 * Enables error checking and reporting when shader programs are being compiled
		 * @type {boolean}
		 */
		checkShaderErrors: true
	};

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.outputEncoding = LinearEncoding;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = NoToneMapping;
	this.toneMappingExposure = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	const _this = this;

	let _isContextLost = false;

	// internal state cache

	let _framebuffer = null;

	let _currentActiveCubeFace = 0;
	let _currentActiveMipmapLevel = 0;
	let _currentRenderTarget = null;
	let _currentFramebuffer = null;
	let _currentMaterialId = - 1;

	let _currentCamera = null;

	const _currentViewport = new Vector4();
	const _currentScissor = new Vector4();
	let _currentScissorTest = null;

	//

	let _width = _canvas.width;
	let _height = _canvas.height;

	let _pixelRatio = 1;
	let _opaqueSort = null;
	let _transparentSort = null;

	const _viewport = new Vector4( 0, 0, _width, _height );
	const _scissor = new Vector4( 0, 0, _width, _height );
	let _scissorTest = false;

	// frustum

	const _frustum = new Frustum$1();

	// clipping

	let _clippingEnabled = false;
	let _localClippingEnabled = false;

	// camera matrices cache

	const _projScreenMatrix = new Matrix4();

	const _vector3 = new Vector3$1();

	const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	// initialize

	let _gl = _context;

	function getContext( contextNames, contextAttributes ) {

		for ( let i = 0; i < contextNames.length; i ++ ) {

			const contextName = contextNames[ i ];
			const context = _canvas.getContext( contextName, contextAttributes );
			if ( context !== null ) return context;

		}

		return null;

	}

	try {

		const contextAttributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer,
			powerPreference: _powerPreference,
			failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat
		};

		// event listeners must be registered before WebGL context is created, see #12753

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

		if ( _gl === null ) {

			const contextNames = [ 'webgl2', 'webgl', 'experimental-webgl' ];

			if ( _this.isWebGL1Renderer === true ) {

				contextNames.shift();

			}

			_gl = getContext( contextNames, contextAttributes );

			if ( _gl === null ) {

				if ( getContext( contextNames ) ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error.message );
		throw error;

	}

	let extensions, capabilities, state, info;
	let properties, textures, cubemaps, attributes, geometries, objects;
	let programCache, materials, renderLists, renderStates, clipping;

	let background, morphtargets, bufferRenderer, indexedBufferRenderer;

	let utils, bindingStates;

	function initGLContext() {

		extensions = new WebGLExtensions( _gl );

		capabilities = new WebGLCapabilities( _gl, extensions, parameters );

		extensions.init( capabilities );

		utils = new WebGLUtils( _gl, extensions, capabilities );

		state = new WebGLState( _gl, extensions, capabilities );
		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		info = new WebGLInfo( _gl );
		properties = new WebGLProperties();
		textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
		cubemaps = new WebGLCubeMaps( _this );
		attributes = new WebGLAttributes( _gl, capabilities );
		bindingStates = new WebGLBindingStates( _gl, extensions, attributes, capabilities );
		geometries = new WebGLGeometries( _gl, attributes, info, bindingStates );
		objects = new WebGLObjects( _gl, geometries, attributes, info );
		morphtargets = new WebGLMorphtargets( _gl );
		clipping = new WebGLClipping( properties );
		programCache = new WebGLPrograms( _this, cubemaps, extensions, capabilities, bindingStates, clipping );
		materials = new WebGLMaterials( properties );
		renderLists = new WebGLRenderLists( properties );
		renderStates = new WebGLRenderStates( extensions, capabilities );
		background = new WebGLBackground( _this, cubemaps, state, objects, _premultipliedAlpha );

		bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
		indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

		info.programs = programCache.programs;

		_this.capabilities = capabilities;
		_this.extensions = extensions;
		_this.properties = properties;
		_this.renderLists = renderLists;
		_this.state = state;
		_this.info = info;

	}

	initGLContext();

	// xr

	const xr = new WebXRManager( _this, _gl );

	this.xr = xr;

	// shadow map

	const shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

	this.shadowMap = shadowMap;

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.loseContext();

	};

	this.forceContextRestore = function () {

		const extension = extensions.get( 'WEBGL_lose_context' );
		if ( extension ) extension.restoreContext();

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _width, _height, false );

	};

	this.getSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width, _height );

	};

	this.setSize = function ( width, height, updateStyle ) {

		if ( xr.isPresenting ) {

			console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
			return;

		}

		_width = width;
		_height = height;

		_canvas.width = Math.floor( width * _pixelRatio );
		_canvas.height = Math.floor( height * _pixelRatio );

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.getDrawingBufferSize = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

			target = new Vector2();

		}

		return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

	};

	this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

		_width = width;
		_height = height;

		_pixelRatio = pixelRatio;

		_canvas.width = Math.floor( width * pixelRatio );
		_canvas.height = Math.floor( height * pixelRatio );

		this.setViewport( 0, 0, width, height );

	};

	this.getCurrentViewport = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

			target = new Vector4();

		}

		return target.copy( _currentViewport );

	};

	this.getViewport = function ( target ) {

		return target.copy( _viewport );

	};

	this.setViewport = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_viewport.set( x.x, x.y, x.z, x.w );

		} else {

			_viewport.set( x, y, width, height );

		}

		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissor = function ( target ) {

		return target.copy( _scissor );

	};

	this.setScissor = function ( x, y, width, height ) {

		if ( x.isVector4 ) {

			_scissor.set( x.x, x.y, x.z, x.w );

		} else {

			_scissor.set( x, y, width, height );

		}

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

	};

	this.getScissorTest = function () {

		return _scissorTest;

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	this.setOpaqueSort = function ( method ) {

		_opaqueSort = method;

	};

	this.setTransparentSort = function ( method ) {

		_transparentSort = method;

	};

	// Clearing

	this.getClearColor = function ( target ) {

		if ( target === undefined ) {

			console.warn( 'WebGLRenderer: .getClearColor() now requires a Color as an argument' );

			target = new Color$1();

		}

		return target.copy( background.getClearColor() );

	};

	this.setClearColor = function () {

		background.setClearColor.apply( background, arguments );

	};

	this.getClearAlpha = function () {

		return background.getClearAlpha();

	};

	this.setClearAlpha = function () {

		background.setClearAlpha.apply( background, arguments );

	};

	this.clear = function ( color, depth, stencil ) {

		let bits = 0;

		if ( color === undefined || color ) bits |= 16384;
		if ( depth === undefined || depth ) bits |= 256;
		if ( stencil === undefined || stencil ) bits |= 1024;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	//

	this.dispose = function () {

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
		_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

		renderLists.dispose();
		renderStates.dispose();
		properties.dispose();
		cubemaps.dispose();
		objects.dispose();
		bindingStates.dispose();

		xr.dispose();

		animation.stop();

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		console.log( 'THREE.WebGLRenderer: Context Lost.' );

		_isContextLost = true;

	}

	function onContextRestore( /* event */ ) {

		console.log( 'THREE.WebGLRenderer: Context Restored.' );

		_isContextLost = false;

		initGLContext();

	}

	function onMaterialDispose( event ) {

		const material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.remove( material );

	}


	function releaseMaterialProgramReference( material ) {

		const programInfo = properties.get( material ).program;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	function renderObjectImmediate( object, program ) {

		object.render( function ( object ) {

			_this.renderBufferImmediate( object, program );

		} );

	}

	this.renderBufferImmediate = function ( object, program ) {

		bindingStates.initAttributes();

		const buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		const programAttributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( 34962, buffers.position );
			_gl.bufferData( 34962, object.positionArray, 35048 );

			bindingStates.enableAttribute( programAttributes.position );
			_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( 34962, buffers.normal );
			_gl.bufferData( 34962, object.normalArray, 35048 );

			bindingStates.enableAttribute( programAttributes.normal );
			_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

		}

		if ( object.hasUvs ) {

			_gl.bindBuffer( 34962, buffers.uv );
			_gl.bufferData( 34962, object.uvArray, 35048 );

			bindingStates.enableAttribute( programAttributes.uv );
			_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

		}

		if ( object.hasColors ) {

			_gl.bindBuffer( 34962, buffers.color );
			_gl.bufferData( 34962, object.colorArray, 35048 );

			bindingStates.enableAttribute( programAttributes.color );
			_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

		}

		bindingStates.disableUnusedAttributes();

		_gl.drawArrays( 4, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

		if ( scene === null ) scene = _emptyScene; // renderBufferDirect second parameter used to be fog (could be null)

		const frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

		const program = setProgram( camera, scene, material, object );

		state.setMaterial( material, frontFaceCW );

		//

		let index = geometry.index;
		const position = geometry.attributes.position;

		//

		if ( index === null ) {

			if ( position === undefined || position.count === 0 ) return;

		} else if ( index.count === 0 ) {

			return;

		}

		//

		let rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = geometries.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		if ( material.morphTargets || material.morphNormals ) {

			morphtargets.update( object, geometry, material, program );

		}

		bindingStates.setup( object, material, program, geometry, index );

		let attribute;
		let renderer = bufferRenderer;

		if ( index !== null ) {

			attribute = attributes.get( index );

			renderer = indexedBufferRenderer;
			renderer.setIndex( attribute );

		}

		//

		const dataCount = ( index !== null ) ? index.count : position.count;

		const rangeStart = geometry.drawRange.start * rangeFactor;
		const rangeCount = geometry.drawRange.count * rangeFactor;

		const groupStart = group !== null ? group.start * rangeFactor : 0;
		const groupCount = group !== null ? group.count * rangeFactor : Infinity;

		const drawStart = Math.max( rangeStart, groupStart );
		const drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		const drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( 1 );

			} else {

				renderer.setMode( 4 );

			}

		} else if ( object.isLine ) {

			let lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( 1 );

			} else if ( object.isLineLoop ) {

				renderer.setMode( 2 );

			} else {

				renderer.setMode( 3 );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( 0 );

		} else if ( object.isSprite ) {

			renderer.setMode( 4 );

		}

		if ( object.isInstancedMesh ) {

			renderer.renderInstances( drawStart, drawCount, object.count );

		} else if ( geometry.isInstancedBufferGeometry ) {

			const instanceCount = Math.min( geometry.instanceCount, geometry._maxInstanceCount );

			renderer.renderInstances( drawStart, drawCount, instanceCount );

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	// Compile

	this.compile = function ( scene, camera ) {

		currentRenderState = renderStates.get( scene );
		currentRenderState.init();

		scene.traverseVisible( function ( object ) {

			if ( object.isLight && object.layers.test( camera.layers ) ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			}

		} );

		currentRenderState.setupLights();

		const compiled = new WeakMap();

		scene.traverse( function ( object ) {

			const material = object.material;

			if ( material ) {

				if ( Array.isArray( material ) ) {

					for ( let i = 0; i < material.length; i ++ ) {

						const material2 = material[ i ];

						if ( compiled.has( material2 ) === false ) {

							initMaterial( material2, scene, object );
							compiled.set( material2 );

						}

					}

				} else if ( compiled.has( material ) === false ) {

					initMaterial( material, scene, object );
					compiled.set( material );

				}

			}

		} );

	};

	// Animation Loop

	let onAnimationFrameCallback = null;

	function onAnimationFrame( time ) {

		if ( xr.isPresenting ) return;
		if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

	}

	const animation = new WebGLAnimation();
	animation.setAnimationLoop( onAnimationFrame );

	if ( typeof window !== 'undefined' ) animation.setContext( window );

	this.setAnimationLoop = function ( callback ) {

		onAnimationFrameCallback = callback;
		xr.setAnimationLoop( callback );

		( callback === null ) ? animation.stop() : animation.start();

	};

	// Rendering

	this.render = function ( scene, camera ) {

		let renderTarget, forceClear;

		if ( arguments[ 2 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
			renderTarget = arguments[ 2 ];

		}

		if ( arguments[ 3 ] !== undefined ) {

			console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
			forceClear = arguments[ 3 ];

		}

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		if ( _isContextLost === true ) return;

		// reset caching for this frame

		bindingStates.resetDefaultState();
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		if ( xr.enabled === true && xr.isPresenting === true ) {

			camera = xr.getCamera( camera );

		}

		//
		if ( scene.isScene === true ) scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

		currentRenderState = renderStates.get( scene, renderStateStack.length );
		currentRenderState.init();

		renderStateStack.push( currentRenderState );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromProjectionMatrix( _projScreenMatrix );

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		currentRenderList = renderLists.get( scene, renderListStack.length );
		currentRenderList.init();

		renderListStack.push( currentRenderList );

		projectObject( scene, camera, 0, _this.sortObjects );

		currentRenderList.finish();

		if ( _this.sortObjects === true ) {

			currentRenderList.sort( _opaqueSort, _transparentSort );

		}

		//

		if ( _clippingEnabled === true ) clipping.beginShadows();

		const shadowsArray = currentRenderState.state.shadowsArray;

		shadowMap.render( shadowsArray, scene, camera );

		currentRenderState.setupLights();
		currentRenderState.setupLightsView( camera );

		if ( _clippingEnabled === true ) clipping.endShadows();

		//

		if ( this.info.autoReset === true ) this.info.reset();

		if ( renderTarget !== undefined ) {

			this.setRenderTarget( renderTarget );

		}

		//

		background.render( currentRenderList, scene, camera, forceClear );

		// render scene

		const opaqueObjects = currentRenderList.opaque;
		const transparentObjects = currentRenderList.transparent;

		if ( opaqueObjects.length > 0 ) renderObjects( opaqueObjects, scene, camera );
		if ( transparentObjects.length > 0 ) renderObjects( transparentObjects, scene, camera );

		//

		if ( scene.isScene === true ) scene.onAfterRender( _this, scene, camera );

		//

		if ( _currentRenderTarget !== null ) {

			// Generate mipmap if we're using any kind of mipmap filtering

			textures.updateRenderTargetMipmap( _currentRenderTarget );

			// resolve multisample renderbuffers to a single-sample texture if necessary

			textures.updateMultisampleRenderTarget( _currentRenderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.buffers.depth.setTest( true );
		state.buffers.depth.setMask( true );
		state.buffers.color.setMask( true );

		state.setPolygonOffset( false );

		// _gl.finish();

		renderStateStack.pop();

		if ( renderStateStack.length > 0 ) {

			currentRenderState = renderStateStack[ renderStateStack.length - 1 ];

		} else {

			currentRenderState = null;

		}

		renderListStack.pop();

		if ( renderListStack.length > 0 ) {

			currentRenderList = renderListStack[ renderListStack.length - 1 ];

		} else {

			currentRenderList = null;

		}

	};

	function projectObject( object, camera, groupOrder, sortObjects ) {

		if ( object.visible === false ) return;

		const visible = object.layers.test( camera.layers );

		if ( visible ) {

			if ( object.isGroup ) {

				groupOrder = object.renderOrder;

			} else if ( object.isLOD ) {

				if ( object.autoUpdate === true ) object.update( camera );

			} else if ( object.isLight ) {

				currentRenderState.pushLight( object );

				if ( object.castShadow ) {

					currentRenderState.pushShadow( object );

				}

			} else if ( object.isSprite ) {

				if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			} else if ( object.isImmediateRenderObject ) {

				if ( sortObjects ) {

					_vector3.setFromMatrixPosition( object.matrixWorld )
						.applyMatrix4( _projScreenMatrix );

				}

				currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					// update skeleton only once in a frame

					if ( object.skeleton.frame !== info.render.frame ) {

						object.skeleton.update();
						object.skeleton.frame = info.render.frame;

					}

				}

				if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					const geometry = objects.update( object );
					const material = object.material;

					if ( Array.isArray( material ) ) {

						const groups = geometry.groups;

						for ( let i = 0, l = groups.length; i < l; i ++ ) {

							const group = groups[ i ];
							const groupMaterial = material[ group.materialIndex ];

							if ( groupMaterial && groupMaterial.visible ) {

								currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

							}

						}

					} else if ( material.visible ) {

						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

					}

				}

			}

		}

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, groupOrder, sortObjects );

		}

	}

	function renderObjects( renderList, scene, camera ) {

		const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;

		for ( let i = 0, l = renderList.length; i < l; i ++ ) {

			const renderItem = renderList[ i ];

			const object = renderItem.object;
			const geometry = renderItem.geometry;
			const material = overrideMaterial === null ? renderItem.material : overrideMaterial;
			const group = renderItem.group;

			if ( camera.isArrayCamera ) {

				const cameras = camera.cameras;

				for ( let j = 0, jl = cameras.length; j < jl; j ++ ) {

					const camera2 = cameras[ j ];

					if ( object.layers.test( camera2.layers ) ) {

						state.viewport( _currentViewport.copy( camera2.viewport ) );

						currentRenderState.setupLightsView( camera2 );

						renderObject( object, scene, camera2, geometry, material, group );

					}

				}

			} else {

				renderObject( object, scene, camera, geometry, material, group );

			}

		}

	}

	function renderObject( object, scene, camera, geometry, material, group ) {

		object.onBeforeRender( _this, scene, camera, geometry, material, group );

		object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
		object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

		if ( object.isImmediateRenderObject ) {

			const program = setProgram( camera, scene, material, object );

			state.setMaterial( material );

			bindingStates.reset();

			renderObjectImmediate( object, program );

		} else {

			_this.renderBufferDirect( camera, scene, geometry, material, object, group );

		}

		object.onAfterRender( _this, scene, camera, geometry, material, group );

	}

	function initMaterial( material, scene, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		const materialProperties = properties.get( material );

		const lights = currentRenderState.state.lights;
		const shadowsArray = currentRenderState.state.shadowsArray;

		const lightsStateVersion = lights.state.version;

		const parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, object );
		const programCacheKey = programCache.getProgramCacheKey( parameters );

		let program = materialProperties.program;
		let programChange = true;

		// always update environment and fog - changing these trigger an initMaterial call, but it's possible that the program doesn't change

		materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
		materialProperties.fog = scene.fog;
		materialProperties.envMap = cubemaps.get( material.envMap || materialProperties.environment );

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.cacheKey !== programCacheKey ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

			programChange = false;

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			parameters.uniforms = programCache.getUniforms( material );

			material.onBeforeCompile( parameters, _this );

			program = programCache.acquireProgram( parameters, programCacheKey );

			materialProperties.program = program;
			materialProperties.uniforms = parameters.uniforms;
			materialProperties.outputEncoding = parameters.outputEncoding;

		}

		const uniforms = materialProperties.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = clipping.numPlanes;
			materialProperties.numIntersection = clipping.numIntersection;
			uniforms.clippingPlanes = clipping.uniform;

		}

		// store the light setup it was created for

		materialProperties.needsLights = materialNeedsLights( material );
		materialProperties.lightsStateVersion = lightsStateVersion;

		if ( materialProperties.needsLights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = lights.state.ambient;
			uniforms.lightProbe.value = lights.state.probe;
			uniforms.directionalLights.value = lights.state.directional;
			uniforms.directionalLightShadows.value = lights.state.directionalShadow;
			uniforms.spotLights.value = lights.state.spot;
			uniforms.spotLightShadows.value = lights.state.spotShadow;
			uniforms.rectAreaLights.value = lights.state.rectArea;
			uniforms.ltc_1.value = lights.state.rectAreaLTC1;
			uniforms.ltc_2.value = lights.state.rectAreaLTC2;
			uniforms.pointLights.value = lights.state.point;
			uniforms.pointLightShadows.value = lights.state.pointShadow;
			uniforms.hemisphereLights.value = lights.state.hemi;

			uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
			uniforms.spotShadowMap.value = lights.state.spotShadowMap;
			uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
			uniforms.pointShadowMap.value = lights.state.pointShadowMap;
			uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		const progUniforms = materialProperties.program.getUniforms();
		const uniformsList = WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setProgram( camera, scene, material, object ) {

		if ( scene.isScene !== true ) scene = _emptyScene; // scene could be a Mesh, Line, Points, ...

		textures.resetTextureUnits();

		const fog = scene.fog;
		const environment = material.isMeshStandardMaterial ? scene.environment : null;
		const encoding = ( _currentRenderTarget === null ) ? _this.outputEncoding : _currentRenderTarget.texture.encoding;
		const envMap = cubemaps.get( material.envMap || environment );

		const materialProperties = properties.get( material );
		const lights = currentRenderState.state.lights;

		if ( _clippingEnabled === true ) {

			if ( _localClippingEnabled === true || camera !== _currentCamera ) {

				const useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				clipping.setState( material, camera, useCache );

			}

		}

		if ( material.version === materialProperties.__version ) {

			if ( material.fog && materialProperties.fog !== fog ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.environment !== environment ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== clipping.numPlanes ||
				materialProperties.numIntersection !== clipping.numIntersection ) ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.outputEncoding !== encoding ) {

				initMaterial( material, scene, object );

			} else if ( materialProperties.envMap !== envMap ) {

				initMaterial( material, scene, object );

			}

		} else {

			initMaterial( material, scene, object );
			materialProperties.__version = material.version;

		}

		let refreshProgram = false;
		let refreshMaterial = false;
		let refreshLights = false;

		const program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.uniforms;

		if ( state.useProgram( program.program ) ) {

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || _currentCamera !== camera ) {

			p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}

			if ( _currentCamera !== camera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				const uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ) {

				p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshToonMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.isShadowMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// otherwise textures used for skinning can take over texture units reserved for other material textures

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			const skeleton = object.skeleton;

			if ( skeleton ) {

				const bones = skeleton.bones;

				if ( capabilities.floatVertexTextures ) {

					if ( skeleton.boneTexture === null ) {

						// layout (1 matrix = 4 pixels)
						//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
						//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
						//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
						//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
						//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


						let size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
						size = MathUtils.ceilPowerOfTwo( size );
						size = Math.max( size, 4 );

						const boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
						boneMatrices.set( skeleton.boneMatrices ); // copy current values

						const boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType$1 );

						skeleton.boneMatrices = boneMatrices;
						skeleton.boneTexture = boneTexture;
						skeleton.boneTextureSize = size;

					}

					p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
					p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

			materialProperties.receiveShadow = object.receiveShadow;
			p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

		}

		if ( refreshMaterial ) {

			p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );

			if ( materialProperties.needsLights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				materials.refreshFogUniforms( m_uniforms, fog );

			}

			materials.refreshMaterialUniforms( m_uniforms, material, _pixelRatio, _height );

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

		}

		if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {

			WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
			material.uniformsNeedUpdate = false;

		}

		if ( material.isSpriteMaterial ) {

			p_uniforms.setValue( _gl, 'center', object.center );

		}

		// common matrices

		p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
		p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;
		uniforms.lightProbe.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.directionalLightShadows.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.pointLightShadows.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.spotLightShadows.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	function materialNeedsLights( material ) {

		return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial ||
			material.isMeshStandardMaterial || material.isShadowMaterial ||
			( material.isShaderMaterial && material.lights === true );

	}

	//
	this.setFramebuffer = function ( value ) {

		if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );

		_framebuffer = value;

	};

	this.getActiveCubeFace = function () {

		return _currentActiveCubeFace;

	};

	this.getActiveMipmapLevel = function () {

		return _currentActiveMipmapLevel;

	};

	this.getRenderTarget = function () {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget, activeCubeFace = 0, activeMipmapLevel = 0 ) {

		_currentRenderTarget = renderTarget;
		_currentActiveCubeFace = activeCubeFace;
		_currentActiveMipmapLevel = activeMipmapLevel;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		let framebuffer = _framebuffer;
		let isCube = false;
		let isRenderTarget3D = false;

		if ( renderTarget ) {

			const texture = renderTarget.texture;

			if ( texture.isDataTexture3D || texture.isDataTexture2DArray ) {

				isRenderTarget3D = true;

			}

			const __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( renderTarget.isWebGLCubeRenderTarget ) {

				framebuffer = __webglFramebuffer[ activeCubeFace ];
				isCube = true;

			} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

			} else {

				framebuffer = __webglFramebuffer;

			}

			_currentViewport.copy( renderTarget.viewport );
			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

		} else {

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
			_currentScissorTest = _scissorTest;

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( 36160, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.viewport( _currentViewport );
		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		if ( isCube ) {

			const textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( 36160, 36064, 34069 + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel );

		} else if ( isRenderTarget3D ) {

			const textureProperties = properties.get( renderTarget.texture );
			const layer = activeCubeFace || 0;
			_gl.framebufferTextureLayer( 36160, 36064, textureProperties.__webglTexture, activeMipmapLevel || 0, layer );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

		if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		let framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== undefined ) {

			framebuffer = framebuffer[ activeCubeFaceIndex ];

		}

		if ( framebuffer ) {

			let restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );

				restore = true;

			}

			try {

				const texture = renderTarget.texture;
				const textureFormat = texture.format;
				const textureType = texture.type;

				if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				const halfFloatSupportedByExt = ( textureType === HalfFloatType ) && ( extensions.has( 'EXT_color_buffer_half_float' ) || ( capabilities.isWebGL2 && extensions.has( 'EXT_color_buffer_float' ) ) );

				if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType$1 && ( capabilities.isWebGL2 || extensions.has( 'OES_texture_float' ) || extensions.has( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! halfFloatSupportedByExt ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( 36160, _currentFramebuffer );

				}

			}

		}

	};

	this.copyFramebufferToTexture = function ( position, texture, level = 0 ) {

		const levelScale = Math.pow( 2, - level );
		const width = Math.floor( texture.image.width * levelScale );
		const height = Math.floor( texture.image.height * levelScale );
		const glFormat = utils.convert( texture.format );

		textures.setTexture2D( texture, 0 );

		_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

		state.unbindTexture();

	};

	this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level = 0 ) {

		const width = srcTexture.image.width;
		const height = srcTexture.image.height;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );

		textures.setTexture2D( dstTexture, 0 );

		// As another texture upload may have changed pixelStorei
		// parameters, make sure they are correct for the dstTexture
		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		if ( srcTexture.isDataTexture ) {

			_gl.texSubImage2D( 3553, level, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

		} else {

			if ( srcTexture.isCompressedTexture ) {

				_gl.compressedTexSubImage2D( 3553, level, position.x, position.y, srcTexture.mipmaps[ 0 ].width, srcTexture.mipmaps[ 0 ].height, glFormat, srcTexture.mipmaps[ 0 ].data );

			} else {

				_gl.texSubImage2D( 3553, level, position.x, position.y, glFormat, glType, srcTexture.image );

			}

		}

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( 3553 );

		state.unbindTexture();

	};

	this.copyTextureToTexture3D = function ( sourceBox, position, srcTexture, dstTexture, level = 0 ) {

		if ( _this.isWebGL1Renderer ) {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.' );
			return;

		}

		const { width, height, data } = srcTexture.image;
		const glFormat = utils.convert( dstTexture.format );
		const glType = utils.convert( dstTexture.type );
		let glTarget;

		if ( dstTexture.isDataTexture3D ) {

			textures.setTexture3D( dstTexture, 0 );
			glTarget = 32879;

		} else if ( dstTexture.isDataTexture2DArray ) {

			textures.setTexture2DArray( dstTexture, 0 );
			glTarget = 35866;

		} else {

			console.warn( 'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.' );
			return;

		}

		_gl.pixelStorei( 37440, dstTexture.flipY );
		_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
		_gl.pixelStorei( 3317, dstTexture.unpackAlignment );

		const unpackRowLen = _gl.getParameter( 3314 );
		const unpackImageHeight = _gl.getParameter( 32878 );
		const unpackSkipPixels = _gl.getParameter( 3316 );
		const unpackSkipRows = _gl.getParameter( 3315 );
		const unpackSkipImages = _gl.getParameter( 32877 );

		_gl.pixelStorei( 3314, width );
		_gl.pixelStorei( 32878, height );
		_gl.pixelStorei( 3316, sourceBox.min.x );
		_gl.pixelStorei( 3315, sourceBox.min.y );
		_gl.pixelStorei( 32877, sourceBox.min.z );

		_gl.texSubImage3D(
			glTarget,
			level,
			position.x,
			position.y,
			position.z,
			sourceBox.max.x - sourceBox.min.x + 1,
			sourceBox.max.y - sourceBox.min.y + 1,
			sourceBox.max.z - sourceBox.min.z + 1,
			glFormat,
			glType,
			data
		);

		_gl.pixelStorei( 3314, unpackRowLen );
		_gl.pixelStorei( 32878, unpackImageHeight );
		_gl.pixelStorei( 3316, unpackSkipPixels );
		_gl.pixelStorei( 3315, unpackSkipRows );
		_gl.pixelStorei( 32877, unpackSkipImages );

		// Generate mipmaps only when copying level 0
		if ( level === 0 && dstTexture.generateMipmaps ) _gl.generateMipmap( glTarget );

		state.unbindTexture();

	};

	this.initTexture = function ( texture ) {

		textures.setTexture2D( texture, 0 );

		state.unbindTexture();

	};

	this.resetState = function () {

		state.reset();
		bindingStates.reset();

	};

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

	}

}

class WebGL1Renderer extends WebGLRenderer {}

WebGL1Renderer.prototype.isWebGL1Renderer = true;

class FogExp2 {

	constructor( color, density ) {

		this.name = '';

		this.color = new Color$1( color );
		this.density = ( density !== undefined ) ? density : 0.00025;

	}

	clone() {

		return new FogExp2( this.color, this.density );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};

	}

}

FogExp2.prototype.isFogExp2 = true;

class Fog {

	constructor( color, near, far ) {

		this.name = '';

		this.color = new Color$1( color );

		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;

	}

	clone() {

		return new Fog( this.color, this.near, this.far );

	}

	toJSON( /* meta */ ) {

		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};

	}

}

Fog.prototype.isFog = true;

class Scene$2 extends Object3D {

	constructor() {

		super();

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		if ( source.background !== null ) this.background = source.background.clone();
		if ( source.environment !== null ) this.environment = source.environment.clone();
		if ( source.fog !== null ) this.fog = source.fog.clone();

		if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

		this.autoUpdate = source.autoUpdate;
		this.matrixAutoUpdate = source.matrixAutoUpdate;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
		if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
		if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

		return data;

	}

}

Scene$2.prototype.isScene = true;

function InterleavedBuffer( array, stride ) {

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.usage = StaticDrawUsage;
	this.updateRange = { offset: 0, count: - 1 };

	this.version = 0;

	this.uuid = MathUtils.generateUUID();

}

Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( InterleavedBuffer.prototype, {

	isInterleavedBuffer: true,

	onUploadCallback: function () {},

	setUsage: function ( value ) {

		this.usage = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.usage = source.usage;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( let i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset = 0 ) {

		this.array.set( value, offset );

		return this;

	},

	clone: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = this.array.slice( 0 ).buffer;

		}

		const array = new this.array.constructor( data.arrayBuffers[ this.array.buffer._uuid ] );

		const ib = new InterleavedBuffer( array, this.stride );
		ib.setUsage( this.usage );

		return ib;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	toJSON: function ( data ) {

		if ( data.arrayBuffers === undefined ) {

			data.arrayBuffers = {};

		}

		// generate UUID for array buffer if necessary

		if ( this.array.buffer._uuid === undefined ) {

			this.array.buffer._uuid = MathUtils.generateUUID();

		}

		if ( data.arrayBuffers[ this.array.buffer._uuid ] === undefined ) {

			data.arrayBuffers[ this.array.buffer._uuid ] = Array.prototype.slice.call( new Uint32Array( this.array.buffer ) );

		}

		//

		return {
			uuid: this.uuid,
			buffer: this.array.buffer._uuid,
			type: this.array.constructor.name,
			stride: this.stride
		};

	}

} );

const _vector$6 = new Vector3$1();

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.name = '';

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}

Object.defineProperties( InterleavedBufferAttribute.prototype, {

	count: {

		get: function () {

			return this.data.count;

		}

	},

	array: {

		get: function () {

			return this.data.array;

		}

	},

	needsUpdate: {

		set: function ( value ) {

			this.data.needsUpdate = value;

		}

	}

} );

Object.assign( InterleavedBufferAttribute.prototype, {

	isInterleavedBufferAttribute: true,

	applyMatrix4: function ( m ) {

		for ( let i = 0, l = this.data.count; i < l; i ++ ) {

			_vector$6.x = this.getX( i );
			_vector$6.y = this.getY( i );
			_vector$6.z = this.getZ( i );

			_vector$6.applyMatrix4( m );

			this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

		}

		return this;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	},

	clone: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.clone(): Cloning an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			return new BufferAttribute( new this.array.constructor( array ), this.itemSize, this.normalized );

		} else {

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.clone( data );

			}

			return new InterleavedBufferAttribute( data.interleavedBuffers[ this.data.uuid ], this.itemSize, this.offset, this.normalized );

		}

	},

	toJSON: function ( data ) {

		if ( data === undefined ) {

			console.log( 'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interlaved buffer attribute will deinterleave buffer data.' );

			const array = [];

			for ( let i = 0; i < this.count; i ++ ) {

				const index = i * this.data.stride + this.offset;

				for ( let j = 0; j < this.itemSize; j ++ ) {

					array.push( this.data.array[ index + j ] );

				}

			}

			// deinterleave data and save it as an ordinary buffer attribute for now

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: array,
				normalized: this.normalized
			};

		} else {

			// save as true interlaved attribtue

			if ( data.interleavedBuffers === undefined ) {

				data.interleavedBuffers = {};

			}

			if ( data.interleavedBuffers[ this.data.uuid ] === undefined ) {

				data.interleavedBuffers[ this.data.uuid ] = this.data.toJSON( data );

			}

			return {
				isInterleavedBufferAttribute: true,
				itemSize: this.itemSize,
				data: this.data.uuid,
				offset: this.offset,
				normalized: this.normalized
			};

		}

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *  rotation: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

class SpriteMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'SpriteMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.rotation = 0;

		this.sizeAttenuation = true;

		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.rotation = source.rotation;

		this.sizeAttenuation = source.sizeAttenuation;

		return this;

	}

}

SpriteMaterial.prototype.isSpriteMaterial = true;

let _geometry$1;

const _intersectPoint = /*@__PURE__*/ new Vector3$1();
const _worldScale = /*@__PURE__*/ new Vector3$1();
const _mvPosition = /*@__PURE__*/ new Vector3$1();

const _alignedPosition = /*@__PURE__*/ new Vector2();
const _rotatedPosition = /*@__PURE__*/ new Vector2();
const _viewWorldMatrix = /*@__PURE__*/ new Matrix4();

const _vA$1$1 = /*@__PURE__*/ new Vector3$1();
const _vB$1$1 = /*@__PURE__*/ new Vector3$1();
const _vC$1$1 = /*@__PURE__*/ new Vector3$1();

const _uvA$1 = /*@__PURE__*/ new Vector2();
const _uvB$1 = /*@__PURE__*/ new Vector2();
const _uvC$1 = /*@__PURE__*/ new Vector2();

class Sprite$1 extends Object3D {

	constructor( material ) {

		super();

		this.type = 'Sprite';

		if ( _geometry$1 === undefined ) {

			_geometry$1 = new BufferGeometry();

			const float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );

			const interleavedBuffer = new InterleavedBuffer( float32Array, 5 );

			_geometry$1.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			_geometry$1.setAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			_geometry$1.setAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );

		}

		this.geometry = _geometry$1;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();

		this.center = new Vector2( 0.5, 0.5 );

	}

	raycast( raycaster, intersects ) {

		if ( raycaster.camera === null ) {

			console.error( 'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.' );

		}

		_worldScale.setFromMatrixScale( this.matrixWorld );

		_viewWorldMatrix.copy( raycaster.camera.matrixWorld );
		this.modelViewMatrix.multiplyMatrices( raycaster.camera.matrixWorldInverse, this.matrixWorld );

		_mvPosition.setFromMatrixPosition( this.modelViewMatrix );

		if ( raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false ) {

			_worldScale.multiplyScalar( - _mvPosition.z );

		}

		const rotation = this.material.rotation;
		let sin, cos;

		if ( rotation !== 0 ) {

			cos = Math.cos( rotation );
			sin = Math.sin( rotation );

		}

		const center = this.center;

		transformVertex( _vA$1$1.set( - 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vB$1$1.set( 0.5, - 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
		transformVertex( _vC$1$1.set( 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );

		_uvA$1.set( 0, 0 );
		_uvB$1.set( 1, 0 );
		_uvC$1.set( 1, 1 );

		// check first triangle
		let intersect = raycaster.ray.intersectTriangle( _vA$1$1, _vB$1$1, _vC$1$1, false, _intersectPoint );

		if ( intersect === null ) {

			// check second triangle
			transformVertex( _vB$1$1.set( - 0.5, 0.5, 0 ), _mvPosition, center, _worldScale, sin, cos );
			_uvB$1.set( 0, 1 );

			intersect = raycaster.ray.intersectTriangle( _vA$1$1, _vC$1$1, _vB$1$1, false, _intersectPoint );
			if ( intersect === null ) {

				return;

			}

		}

		const distance = raycaster.ray.origin.distanceTo( _intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			point: _intersectPoint.clone(),
			uv: Triangle.getUV( _intersectPoint, _vA$1$1, _vB$1$1, _vC$1$1, _uvA$1, _uvB$1, _uvC$1, new Vector2() ),
			face: null,
			object: this

		} );

	}

	copy( source ) {

		super.copy( source );

		if ( source.center !== undefined ) this.center.copy( source.center );

		this.material = source.material;

		return this;

	}

}

Sprite$1.prototype.isSprite = true;

function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {

	// compute position in camera space
	_alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );

	// to check if rotation is not zero
	if ( sin !== undefined ) {

		_rotatedPosition.x = ( cos * _alignedPosition.x ) - ( sin * _alignedPosition.y );
		_rotatedPosition.y = ( sin * _alignedPosition.x ) + ( cos * _alignedPosition.y );

	} else {

		_rotatedPosition.copy( _alignedPosition );

	}


	vertexPosition.copy( mvPosition );
	vertexPosition.x += _rotatedPosition.x;
	vertexPosition.y += _rotatedPosition.y;

	// transform to world space
	vertexPosition.applyMatrix4( _viewWorldMatrix );

}

const _v1$4 = /*@__PURE__*/ new Vector3$1();
const _v2$2 = /*@__PURE__*/ new Vector3$1();

class LOD extends Object3D {

	constructor() {

		super();

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			},
			isLOD: {
				value: true,
			}
		} );

		this.autoUpdate = true;

	}

	copy( source ) {

		super.copy( source, false );

		const levels = source.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		this.autoUpdate = source.autoUpdate;

		return this;

	}

	addLevel( object, distance = 0 ) {

		distance = Math.abs( distance );

		const levels = this.levels;

		let l;

		for ( l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

		return this;

	}

	getCurrentLevel() {

		return this._currentLevel;

	}

	getObjectForDistance( distance ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance < levels[ i ].distance ) {

					break;

				}

			}

			return levels[ i - 1 ].object;

		}

		return null;

	}

	raycast( raycaster, intersects ) {

		const levels = this.levels;

		if ( levels.length > 0 ) {

			_v1$4.setFromMatrixPosition( this.matrixWorld );

			const distance = raycaster.ray.origin.distanceTo( _v1$4 );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		}

	}

	update( camera ) {

		const levels = this.levels;

		if ( levels.length > 1 ) {

			_v1$4.setFromMatrixPosition( camera.matrixWorld );
			_v2$2.setFromMatrixPosition( this.matrixWorld );

			const distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

			levels[ 0 ].object.visible = true;

			let i, l;

			for ( i = 1, l = levels.length; i < l; i ++ ) {

				if ( distance >= levels[ i ].distance ) {

					levels[ i - 1 ].object.visible = false;
					levels[ i ].object.visible = true;

				} else {

					break;

				}

			}

			this._currentLevel = i - 1;

			for ( ; i < l; i ++ ) {

				levels[ i ].object.visible = false;

			}

		}

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		if ( this.autoUpdate === false ) data.object.autoUpdate = false;

		data.object.levels = [];

		const levels = this.levels;

		for ( let i = 0, l = levels.length; i < l; i ++ ) {

			const level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

}

const _basePosition = new Vector3$1();

const _skinIndex = new Vector4();
const _skinWeight = new Vector4();

const _vector$7 = new Vector3$1();
const _matrix$1 = new Matrix4();

function SkinnedMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = 'attached';
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

}

SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.bindMode = source.bindMode;
		this.bindMatrix.copy( source.bindMatrix );
		this.bindMatrixInverse.copy( source.bindMatrixInverse );

		this.skeleton = source.skeleton;

		return this;

	},

	bind: function ( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.copy( bindMatrix ).invert();

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		const vector = new Vector4();

		const skinWeight = this.geometry.attributes.skinWeight;

		for ( let i = 0, l = skinWeight.count; i < l; i ++ ) {

			vector.x = skinWeight.getX( i );
			vector.y = skinWeight.getY( i );
			vector.z = skinWeight.getZ( i );
			vector.w = skinWeight.getW( i );

			const scale = 1.0 / vector.manhattanLength();

			if ( scale !== Infinity ) {

				vector.multiplyScalar( scale );

			} else {

				vector.set( 1, 0, 0, 0 ); // do something reasonable

			}

			skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );

		}

	},

	updateMatrixWorld: function ( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, force );

		if ( this.bindMode === 'attached' ) {

			this.bindMatrixInverse.copy( this.matrixWorld ).invert();

		} else if ( this.bindMode === 'detached' ) {

			this.bindMatrixInverse.copy( this.bindMatrix ).invert();

		} else {

			console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );

		}

	},

	boneTransform: function ( index, target ) {

		const skeleton = this.skeleton;
		const geometry = this.geometry;

		_skinIndex.fromBufferAttribute( geometry.attributes.skinIndex, index );
		_skinWeight.fromBufferAttribute( geometry.attributes.skinWeight, index );

		_basePosition.fromBufferAttribute( geometry.attributes.position, index ).applyMatrix4( this.bindMatrix );

		target.set( 0, 0, 0 );

		for ( let i = 0; i < 4; i ++ ) {

			const weight = _skinWeight.getComponent( i );

			if ( weight !== 0 ) {

				const boneIndex = _skinIndex.getComponent( i );

				_matrix$1.multiplyMatrices( skeleton.bones[ boneIndex ].matrixWorld, skeleton.boneInverses[ boneIndex ] );

				target.addScaledVector( _vector$7.copy( _basePosition ).applyMatrix4( _matrix$1 ), weight );

			}

		}

		return target.applyMatrix4( this.bindMatrixInverse );

	}

} );

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

const _offsetMatrix = /*@__PURE__*/ new Matrix4();
const _identityMatrix = /*@__PURE__*/ new Matrix4();

class Skeleton {

	constructor( bones = [], boneInverses = [] ) {

		this.uuid = MathUtils.generateUUID();

		this.bones = bones.slice( 0 );
		this.boneInverses = boneInverses;
		this.boneMatrices = null;

		this.boneTexture = null;
		this.boneTextureSize = 0;

		this.frame = - 1;

		this.init();

	}

	init() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		this.boneMatrices = new Float32Array( bones.length * 16 );

		// calculate inverse bone matrices if necessary

		if ( boneInverses.length === 0 ) {

			this.calculateInverses();

		} else {

			// handle special case

			if ( bones.length !== boneInverses.length ) {

				console.warn( 'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.' );

				this.boneInverses = [];

				for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

					this.boneInverses.push( new Matrix4() );

				}

			}

		}

	}

	calculateInverses() {

		this.boneInverses.length = 0;

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const inverse = new Matrix4();

			if ( this.bones[ i ] ) {

				inverse.copy( this.bones[ i ].matrixWorld ).invert();

			}

			this.boneInverses.push( inverse );

		}

	}

	pose() {

		// recover the bind-time world matrices

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				bone.matrixWorld.copy( this.boneInverses[ i ] ).invert();

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.copy( bone.parent.matrixWorld ).invert();
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	}

	update() {

		const bones = this.bones;
		const boneInverses = this.boneInverses;
		const boneMatrices = this.boneMatrices;
		const boneTexture = this.boneTexture;

		// flatten bone matrices to array

		for ( let i = 0, il = bones.length; i < il; i ++ ) {

			// compute the offset between the current and the original transform

			const matrix = bones[ i ] ? bones[ i ].matrixWorld : _identityMatrix;

			_offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
			_offsetMatrix.toArray( boneMatrices, i * 16 );

		}

		if ( boneTexture !== null ) {

			boneTexture.needsUpdate = true;

		}

	}

	clone() {

		return new Skeleton( this.bones, this.boneInverses );

	}

	getBoneByName( name ) {

		for ( let i = 0, il = this.bones.length; i < il; i ++ ) {

			const bone = this.bones[ i ];

			if ( bone.name === name ) {

				return bone;

			}

		}

		return undefined;

	}

	dispose( ) {

		if ( this.boneTexture !== null ) {

			this.boneTexture.dispose();

			this.boneTexture = null;

		}

	}

	fromJSON( json, bones ) {

		this.uuid = json.uuid;

		for ( let i = 0, l = json.bones.length; i < l; i ++ ) {

			const uuid = json.bones[ i ];
			let bone = bones[ uuid ];

			if ( bone === undefined ) {

				console.warn( 'THREE.Skeleton: No bone found with UUID:', uuid );
				bone = new Bone();

			}

			this.bones.push( bone );
			this.boneInverses.push( new Matrix4().fromArray( json.boneInverses[ i ] ) );

		}

		this.init();

		return this;

	}

	toJSON() {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Skeleton',
				generator: 'Skeleton.toJSON'
			},
			bones: [],
			boneInverses: []
		};

		data.uuid = this.uuid;

		const bones = this.bones;
		const boneInverses = this.boneInverses;

		for ( let i = 0, l = bones.length; i < l; i ++ ) {

			const bone = bones[ i ];
			data.bones.push( bone.uuid );

			const boneInverse = boneInverses[ i ];
			data.boneInverses.push( boneInverse.toArray() );

		}

		return data;

	}

}

const _instanceLocalMatrix = new Matrix4();
const _instanceWorldMatrix = new Matrix4();

const _instanceIntersects = [];

const _mesh = new Mesh();

function InstancedMesh( geometry, material, count ) {

	Mesh.call( this, geometry, material );

	this.instanceMatrix = new BufferAttribute( new Float32Array( count * 16 ), 16 );
	this.instanceColor = null;

	this.count = count;

	this.frustumCulled = false;

}

InstancedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: InstancedMesh,

	isInstancedMesh: true,

	copy: function ( source ) {

		Mesh.prototype.copy.call( this, source );

		this.instanceMatrix.copy( source.instanceMatrix );

		if ( source.instanceColor !== null ) this.instanceColor = source.instanceColor.clone();

		this.count = source.count;

		return this;

	},

	getColorAt: function ( index, color ) {

		color.fromArray( this.instanceColor.array, index * 3 );

	},

	getMatrixAt: function ( index, matrix ) {

		matrix.fromArray( this.instanceMatrix.array, index * 16 );

	},

	raycast: function ( raycaster, intersects ) {

		const matrixWorld = this.matrixWorld;
		const raycastTimes = this.count;

		_mesh.geometry = this.geometry;
		_mesh.material = this.material;

		if ( _mesh.material === undefined ) return;

		for ( let instanceId = 0; instanceId < raycastTimes; instanceId ++ ) {

			// calculate the world matrix for each instance

			this.getMatrixAt( instanceId, _instanceLocalMatrix );

			_instanceWorldMatrix.multiplyMatrices( matrixWorld, _instanceLocalMatrix );

			// the mesh represents this single instance

			_mesh.matrixWorld = _instanceWorldMatrix;

			_mesh.raycast( raycaster, _instanceIntersects );

			// process the result of raycast

			for ( let i = 0, l = _instanceIntersects.length; i < l; i ++ ) {

				const intersect = _instanceIntersects[ i ];
				intersect.instanceId = instanceId;
				intersect.object = this;
				intersects.push( intersect );

			}

			_instanceIntersects.length = 0;

		}

	},

	setColorAt: function ( index, color ) {

		if ( this.instanceColor === null ) {

			this.instanceColor = new BufferAttribute( new Float32Array( this.count * 3 ), 3 );

		}

		color.toArray( this.instanceColor.array, index * 3 );

	},

	setMatrixAt: function ( index, matrix ) {

		matrix.toArray( this.instanceMatrix.array, index * 16 );

	},

	updateMorphTargets: function () {

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

class LineBasicMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'LineBasicMaterial';

		this.color = new Color$1( 0xffffff );

		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';

		this.morphTargets = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

LineBasicMaterial.prototype.isLineBasicMaterial = true;

const _start = new Vector3$1();
const _end = new Vector3$1();
const _inverseMatrix$1 = new Matrix4();
const _ray$1 = new Ray();
const _sphere$2 = new Sphere$1();

function Line$1( geometry = new BufferGeometry(), material = new LineBasicMaterial() ) {

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Line$1.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line$1,

	isLine: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [ 0 ];

				for ( let i = 1, l = positionAttribute.count; i < l; i ++ ) {

					_start.fromBufferAttribute( positionAttribute, i - 1 );
					_end.fromBufferAttribute( positionAttribute, i );

					lineDistances[ i ] = lineDistances[ i - 1 ];
					lineDistances[ i ] += _start.distanceTo( _end );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Line.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$2.copy( geometry.boundingSphere );
		_sphere$2.applyMatrix4( matrixWorld );
		_sphere$2.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$2 ) === false ) return;

		//

		_inverseMatrix$1.copy( matrixWorld ).invert();
		_ray$1.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$1 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		const vStart = new Vector3$1();
		const vEnd = new Vector3$1();
		const interSegment = new Vector3$1();
		const interRay = new Vector3$1();
		const step = this.isLineSegments ? 2 : 1;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const indices = index.array;

				for ( let i = 0, l = indices.length - 1; i < l; i += step ) {

					const a = indices[ i ];
					const b = indices[ i + 1 ];

					vStart.fromBufferAttribute( positionAttribute, a );
					vEnd.fromBufferAttribute( positionAttribute, b );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			} else {

				for ( let i = 0, l = positionAttribute.count - 1; i < l; i += step ) {

					vStart.fromBufferAttribute( positionAttribute, i );
					vEnd.fromBufferAttribute( positionAttribute, i + 1 );

					const distSq = _ray$1.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

					if ( distSq > localThresholdSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					const distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.Line.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Line.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

const _start$1 = new Vector3$1();
const _end$1 = new Vector3$1();

function LineSegments( geometry, material ) {

	Line$1.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line$1.prototype ), {

	constructor: LineSegments,

	isLineSegments: true,

	computeLineDistances: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			// we assume non-indexed geometry

			if ( geometry.index === null ) {

				const positionAttribute = geometry.attributes.position;
				const lineDistances = [];

				for ( let i = 0, l = positionAttribute.count; i < l; i += 2 ) {

					_start$1.fromBufferAttribute( positionAttribute, i );
					_end$1.fromBufferAttribute( positionAttribute, i + 1 );

					lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
					lineDistances[ i + 1 ] = lineDistances[ i ] + _start$1.distanceTo( _end$1 );

				}

				geometry.setAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );

			} else {

				console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );

			}

		} else if ( geometry.isGeometry ) {

			console.error( 'THREE.LineSegments.computeLineDistances() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

		return this;

	}

} );

class LineLoop extends Line$1 {

	constructor( geometry, material ) {

		super( geometry, material );

		this.type = 'LineLoop';

	}

}

LineLoop.prototype.isLineLoop = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 *
 *  morphTargets: <bool>
 * }
 */

class PointsMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'PointsMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;

		this.alphaMap = null;

		this.size = 1;
		this.sizeAttenuation = true;

		this.morphTargets = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;

		this.morphTargets = source.morphTargets;

		return this;

	}

}

PointsMaterial.prototype.isPointsMaterial = true;

const _inverseMatrix$2 = new Matrix4();
const _ray$2 = new Ray();
const _sphere$3 = new Sphere$1();
const _position$1 = new Vector3$1();

function Points( geometry = new BufferGeometry(), material = new PointsMaterial() ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry;
	this.material = material;

	this.updateMorphTargets();

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.material = source.material;
		this.geometry = source.geometry;

		return this;

	},

	raycast: function ( raycaster, intersects ) {

		const geometry = this.geometry;
		const matrixWorld = this.matrixWorld;
		const threshold = raycaster.params.Points.threshold;

		// Checking boundingSphere distance to ray

		if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

		_sphere$3.copy( geometry.boundingSphere );
		_sphere$3.applyMatrix4( matrixWorld );
		_sphere$3.radius += threshold;

		if ( raycaster.ray.intersectsSphere( _sphere$3 ) === false ) return;

		//

		_inverseMatrix$2.copy( matrixWorld ).invert();
		_ray$2.copy( raycaster.ray ).applyMatrix4( _inverseMatrix$2 );

		const localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
		const localThresholdSq = localThreshold * localThreshold;

		if ( geometry.isBufferGeometry ) {

			const index = geometry.index;
			const attributes = geometry.attributes;
			const positionAttribute = attributes.position;

			if ( index !== null ) {

				const indices = index.array;

				for ( let i = 0, il = indices.length; i < il; i ++ ) {

					const a = indices[ i ];

					_position$1.fromBufferAttribute( positionAttribute, a );

					testPoint( _position$1, a, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			} else {

				for ( let i = 0, l = positionAttribute.count; i < l; i ++ ) {

					_position$1.fromBufferAttribute( positionAttribute, i );

					testPoint( _position$1, i, localThresholdSq, matrixWorld, raycaster, intersects, this );

				}

			}

		} else {

			console.error( 'THREE.Points.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

		}

	},

	updateMorphTargets: function () {

		const geometry = this.geometry;

		if ( geometry.isBufferGeometry ) {

			const morphAttributes = geometry.morphAttributes;
			const keys = Object.keys( morphAttributes );

			if ( keys.length > 0 ) {

				const morphAttribute = morphAttributes[ keys[ 0 ] ];

				if ( morphAttribute !== undefined ) {

					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};

					for ( let m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

						const name = morphAttribute[ m ].name || String( m );

						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ name ] = m;

					}

				}

			}

		} else {

			const morphTargets = geometry.morphTargets;

			if ( morphTargets !== undefined && morphTargets.length > 0 ) {

				console.error( 'THREE.Points.updateMorphTargets() does not support THREE.Geometry. Use THREE.BufferGeometry instead.' );

			}

		}

	}

} );

function testPoint( point, index, localThresholdSq, matrixWorld, raycaster, intersects, object ) {

	const rayPointDistanceSq = _ray$2.distanceSqToPoint( point );

	if ( rayPointDistanceSq < localThresholdSq ) {

		const intersectPoint = new Vector3$1();

		_ray$2.closestPointToPoint( point, intersectPoint );
		intersectPoint.applyMatrix4( matrixWorld );

		const distance = raycaster.ray.origin.distanceTo( intersectPoint );

		if ( distance < raycaster.near || distance > raycaster.far ) return;

		intersects.push( {

			distance: distance,
			distanceToRay: Math.sqrt( rayPointDistanceSq ),
			point: intersectPoint,
			index: index,
			face: null,
			object: object

		} );

	}

}

class VideoTexture extends Texture {

	constructor( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.format = format !== undefined ? format : RGBFormat;

		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;

		this.generateMipmaps = false;

		const scope = this;

		function updateVideo() {

			scope.needsUpdate = true;
			video.requestVideoFrameCallback( updateVideo );

		}

		if ( 'requestVideoFrameCallback' in video ) {

			video.requestVideoFrameCallback( updateVideo );

		}

	}

	clone() {

		return new this.constructor( this.image ).copy( this );

	}

	update() {

		const video = this.image;
		const hasVideoFrameCallback = 'requestVideoFrameCallback' in video;

		if ( hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA ) {

			this.needsUpdate = true;

		}

	}

}

VideoTexture.prototype.isVideoTexture = true;

class CompressedTexture extends Texture {

	constructor( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

}

CompressedTexture.prototype.isCompressedTexture = true;

class CanvasTexture extends Texture {

	constructor( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

		super( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.needsUpdate = true;

	}

}

CanvasTexture.prototype.isCanvasTexture = true;

class DepthTexture extends Texture {

	constructor( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		super( null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}


}

DepthTexture.prototype.isDepthTexture = true;

class CircleGeometry extends BufferGeometry {

	constructor( radius = 1, segments = 8, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'CircleGeometry';

		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		segments = Math.max( 3, segments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3$1();
		const uv = new Vector2();

		// center point

		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );

		for ( let s = 0, i = 3; s <= segments; s ++, i += 3 ) {

			const segment = thetaStart + s / segments * thetaLength;

			// vertex

			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );

			vertices.push( vertex.x, vertex.y, vertex.z );

			// normal

			normals.push( 0, 0, 1 );

			// uvs

			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;

			uvs.push( uv.x, uv.y );

		}

		// indices

		for ( let i = 1; i <= segments; i ++ ) {

			indices.push( i, i + 1, 0 );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class CylinderGeometry extends BufferGeometry {

	constructor( radiusTop = 1, radiusBottom = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();
		this.type = 'CylinderGeometry';

		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		const scope = this;

		radialSegments = Math.floor( radialSegments );
		heightSegments = Math.floor( heightSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let index = 0;
		const indexArray = [];
		const halfHeight = height / 2;
		let groupStart = 0;

		// generate geometry

		generateTorso();

		if ( openEnded === false ) {

			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		function generateTorso() {

			const normal = new Vector3$1();
			const vertex = new Vector3$1();

			let groupCount = 0;

			// this will be used to calculate the normal
			const slope = ( radiusBottom - radiusTop ) / height;

			// generate vertices, normals and uvs

			for ( let y = 0; y <= heightSegments; y ++ ) {

				const indexRow = [];

				const v = y / heightSegments;

				// calculate the radius of the current row

				const radius = v * ( radiusBottom - radiusTop ) + radiusTop;

				for ( let x = 0; x <= radialSegments; x ++ ) {

					const u = x / radialSegments;

					const theta = u * thetaLength + thetaStart;

					const sinTheta = Math.sin( theta );
					const cosTheta = Math.cos( theta );

					// vertex

					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );

					// normal

					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );

					// uv

					uvs.push( u, 1 - v );

					// save index of vertex in respective row

					indexRow.push( index ++ );

				}

				// now save vertices of the row in our index array

				indexArray.push( indexRow );

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				for ( let y = 0; y < heightSegments; y ++ ) {

					// we use the index array to access the correct indices

					const a = indexArray[ y ][ x ];
					const b = indexArray[ y + 1 ][ x ];
					const c = indexArray[ y + 1 ][ x + 1 ];
					const d = indexArray[ y ][ x + 1 ];

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

					// update group counter

					groupCount += 6;

				}

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, 0 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

		function generateCap( top ) {

			// save the index of the first center vertex
			const centerIndexStart = index;

			const uv = new Vector2();
			const vertex = new Vector3$1();

			let groupCount = 0;

			const radius = ( top === true ) ? radiusTop : radiusBottom;
			const sign = ( top === true ) ? 1 : - 1;

			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment

			for ( let x = 1; x <= radialSegments; x ++ ) {

				// vertex

				vertices.push( 0, halfHeight * sign, 0 );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uvs.push( 0.5, 0.5 );

				// increase index

				index ++;

			}

			// save the index of the last center vertex
			const centerIndexEnd = index;

			// now we generate the surrounding vertices, normals and uvs

			for ( let x = 0; x <= radialSegments; x ++ ) {

				const u = x / radialSegments;
				const theta = u * thetaLength + thetaStart;

				const cosTheta = Math.cos( theta );
				const sinTheta = Math.sin( theta );

				// vertex

				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, sign, 0 );

				// uv

				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );

				// increase index

				index ++;

			}

			// generate indices

			for ( let x = 0; x < radialSegments; x ++ ) {

				const c = centerIndexStart + x;
				const i = centerIndexEnd + x;

				if ( top === true ) {

					// face top

					indices.push( i, i + 1, c );

				} else {

					// face bottom

					indices.push( i + 1, i, c );

				}

				groupCount += 3;

			}

			// add a group to the geometry. this will ensure multi material support

			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

			// calculate new start value for groups

			groupStart += groupCount;

		}

	}

}

class ConeGeometry extends CylinderGeometry {

	constructor( radius = 1, height = 1, radialSegments = 8, heightSegments = 1, openEnded = false, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super( 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

		this.type = 'ConeGeometry';

		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

	}

}

class PolyhedronGeometry extends BufferGeometry {

	constructor( vertices, indices, radius = 1, detail = 0 ) {

		super();

		this.type = 'PolyhedronGeometry';

		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};

		// default buffer data

		const vertexBuffer = [];
		const uvBuffer = [];

		// the subdivision creates the vertex buffer data

		subdivide( detail );

		// all vertices should lie on a conceptual sphere with a given radius

		applyRadius( radius );

		// finally, create the uv data

		generateUVs();

		// build non-indexed geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );

		if ( detail === 0 ) {

			this.computeVertexNormals(); // flat normals

		} else {

			this.normalizeNormals(); // smooth normals

		}

		// helper functions

		function subdivide( detail ) {

			const a = new Vector3$1();
			const b = new Vector3$1();
			const c = new Vector3$1();

			// iterate over all faces and apply a subdivison with the given detail value

			for ( let i = 0; i < indices.length; i += 3 ) {

				// get the vertices of the face

				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );

				// perform subdivision

				subdivideFace( a, b, c, detail );

			}

		}

		function subdivideFace( a, b, c, detail ) {

			const cols = detail + 1;

			// we use this multidimensional array as a data structure for creating the subdivision

			const v = [];

			// construct all of the vertices for this subdivision

			for ( let i = 0; i <= cols; i ++ ) {

				v[ i ] = [];

				const aj = a.clone().lerp( c, i / cols );
				const bj = b.clone().lerp( c, i / cols );

				const rows = cols - i;

				for ( let j = 0; j <= rows; j ++ ) {

					if ( j === 0 && i === cols ) {

						v[ i ][ j ] = aj;

					} else {

						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

					}

				}

			}

			// construct all of the faces

			for ( let i = 0; i < cols; i ++ ) {

				for ( let j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

					const k = Math.floor( j / 2 );

					if ( j % 2 === 0 ) {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );

					} else {

						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );

					}

				}

			}

		}

		function applyRadius( radius ) {

			const vertex = new Vector3$1();

			// iterate over the entire buffer and apply the radius to each vertex

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				vertex.normalize().multiplyScalar( radius );

				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;

			}

		}

		function generateUVs() {

			const vertex = new Vector3$1();

			for ( let i = 0; i < vertexBuffer.length; i += 3 ) {

				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];

				const u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				const v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );

			}

			correctUVs();

			correctSeam();

		}

		function correctSeam() {

			// handle case when face straddles the seam, see #3269

			for ( let i = 0; i < uvBuffer.length; i += 6 ) {

				// uv data of a single face

				const x0 = uvBuffer[ i + 0 ];
				const x1 = uvBuffer[ i + 2 ];
				const x2 = uvBuffer[ i + 4 ];

				const max = Math.max( x0, x1, x2 );
				const min = Math.min( x0, x1, x2 );

				// 0.9 is somewhat arbitrary

				if ( max > 0.9 && min < 0.1 ) {

					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

				}

			}

		}

		function pushVertex( vertex ) {

			vertexBuffer.push( vertex.x, vertex.y, vertex.z );

		}

		function getVertexByIndex( index, vertex ) {

			const stride = index * 3;

			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];

		}

		function correctUVs() {

			const a = new Vector3$1();
			const b = new Vector3$1();
			const c = new Vector3$1();

			const centroid = new Vector3$1();

			const uvA = new Vector2();
			const uvB = new Vector2();
			const uvC = new Vector2();

			for ( let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

				const azi = azimuth( centroid );

				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );

			}

		}

		function correctUV( uv, stride, vector, azimuth ) {

			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

				uvBuffer[ stride ] = uv.x - 1;

			}

			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

			}

		}

		// Angle around the Y axis, counter-clockwise when looking from above.

		function azimuth( vector ) {

			return Math.atan2( vector.z, - vector.x );

		}


		// Angle above the XZ plane.

		function inclination( vector ) {

			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

		}

	}

}

class DodecahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;
		const r = 1 / t;

		const vertices = [

			// (±1, ±1, ±1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,

			// (0, ±1/φ, ±φ)
			0, - r, - t, 0, - r, t,
			0, r, - t, 0, r, t,

			// (±1/φ, ±φ, 0)
			- r, - t, 0, - r, t, 0,
			r, - t, 0, r, t, 0,

			// (±φ, 0, ±1/φ)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];

		const indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];

		super( vertices, indices, radius, detail );

		this.type = 'DodecahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

const _v0$2 = new Vector3$1();
const _v1$5 = new Vector3$1();
const _normal$1 = new Vector3$1();
const _triangle = new Triangle();

class EdgesGeometry extends BufferGeometry {

	constructor( geometry, thresholdAngle ) {

		super();

		this.type = 'EdgesGeometry';

		this.parameters = {
			thresholdAngle: thresholdAngle
		};

		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.EdgesGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		const precisionPoints = 4;
		const precision = Math.pow( 10, precisionPoints );
		const thresholdDot = Math.cos( MathUtils.DEG2RAD * thresholdAngle );

		const indexAttr = geometry.getIndex();
		const positionAttr = geometry.getAttribute( 'position' );
		const indexCount = indexAttr ? indexAttr.count : positionAttr.count;

		const indexArr = [ 0, 0, 0 ];
		const vertKeys = [ 'a', 'b', 'c' ];
		const hashes = new Array( 3 );

		const edgeData = {};
		const vertices = [];
		for ( let i = 0; i < indexCount; i += 3 ) {

			if ( indexAttr ) {

				indexArr[ 0 ] = indexAttr.getX( i );
				indexArr[ 1 ] = indexAttr.getX( i + 1 );
				indexArr[ 2 ] = indexAttr.getX( i + 2 );

			} else {

				indexArr[ 0 ] = i;
				indexArr[ 1 ] = i + 1;
				indexArr[ 2 ] = i + 2;

			}

			const { a, b, c } = _triangle;
			a.fromBufferAttribute( positionAttr, indexArr[ 0 ] );
			b.fromBufferAttribute( positionAttr, indexArr[ 1 ] );
			c.fromBufferAttribute( positionAttr, indexArr[ 2 ] );
			_triangle.getNormal( _normal$1 );

			// create hashes for the edge from the vertices
			hashes[ 0 ] = `${ Math.round( a.x * precision ) },${ Math.round( a.y * precision ) },${ Math.round( a.z * precision ) }`;
			hashes[ 1 ] = `${ Math.round( b.x * precision ) },${ Math.round( b.y * precision ) },${ Math.round( b.z * precision ) }`;
			hashes[ 2 ] = `${ Math.round( c.x * precision ) },${ Math.round( c.y * precision ) },${ Math.round( c.z * precision ) }`;

			// skip degenerate triangles
			if ( hashes[ 0 ] === hashes[ 1 ] || hashes[ 1 ] === hashes[ 2 ] || hashes[ 2 ] === hashes[ 0 ] ) {

				continue;

			}

			// iterate over every edge
			for ( let j = 0; j < 3; j ++ ) {

				// get the first and next vertex making up the edge
				const jNext = ( j + 1 ) % 3;
				const vecHash0 = hashes[ j ];
				const vecHash1 = hashes[ jNext ];
				const v0 = _triangle[ vertKeys[ j ] ];
				const v1 = _triangle[ vertKeys[ jNext ] ];

				const hash = `${ vecHash0 }_${ vecHash1 }`;
				const reverseHash = `${ vecHash1 }_${ vecHash0 }`;

				if ( reverseHash in edgeData && edgeData[ reverseHash ] ) {

					// if we found a sibling edge add it into the vertex array if
					// it meets the angle threshold and delete the edge from the map.
					if ( _normal$1.dot( edgeData[ reverseHash ].normal ) <= thresholdDot ) {

						vertices.push( v0.x, v0.y, v0.z );
						vertices.push( v1.x, v1.y, v1.z );

					}

					edgeData[ reverseHash ] = null;

				} else if ( ! ( hash in edgeData ) ) {

					// if we've already got an edge here then skip adding a new one
					edgeData[ hash ] = {

						index0: indexArr[ j ],
						index1: indexArr[ jNext ],
						normal: _normal$1.clone(),

					};

				}

			}

		}

		// iterate over all remaining, unmatched edges and add them to the vertex array
		for ( const key in edgeData ) {

			if ( edgeData[ key ] ) {

				const { index0, index1 } = edgeData[ key ];
				_v0$2.fromBufferAttribute( positionAttr, index0 );
				_v1$5.fromBufferAttribute( positionAttr, index1 );

				vertices.push( _v0$2.x, _v0$2.y, _v0$2.z );
				vertices.push( _v1$5.x, _v1$5.y, _v1$5.z );

			}

		}

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

/**
 * Port from https://github.com/mapbox/earcut (v2.2.2)
 */

const Earcut = {

	triangulate: function ( data, holeIndices, dim ) {

		dim = dim || 2;

		const hasHoles = holeIndices && holeIndices.length;
		const outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length;
		let outerNode = linkedList( data, 0, outerLen, dim, true );
		const triangles = [];

		if ( ! outerNode || outerNode.next === outerNode.prev ) return triangles;

		let minX, minY, maxX, maxY, x, y, invSize;

		if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );

		// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
		if ( data.length > 80 * dim ) {

			minX = maxX = data[ 0 ];
			minY = maxY = data[ 1 ];

			for ( let i = dim; i < outerLen; i += dim ) {

				x = data[ i ];
				y = data[ i + 1 ];
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;

			}

			// minX, minY and invSize are later used to transform coords into integers for z-order calculation
			invSize = Math.max( maxX - minX, maxY - minY );
			invSize = invSize !== 0 ? 1 / invSize : 0;

		}

		earcutLinked( outerNode, triangles, dim, minX, minY, invSize );

		return triangles;

	}

};

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList( data, start, end, dim, clockwise ) {

	let i, last;

	if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {

		for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	} else {

		for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );

	}

	if ( last && equals( last, last.next ) ) {

		removeNode( last );
		last = last.next;

	}

	return last;

}

// eliminate colinear or duplicate points
function filterPoints( start, end ) {

	if ( ! start ) return start;
	if ( ! end ) end = start;

	let p = start,
		again;
	do {

		again = false;

		if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {

			removeNode( p );
			p = end = p.prev;
			if ( p === p.next ) break;
			again = true;

		} else {

			p = p.next;

		}

	} while ( again || p !== end );

	return end;

}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {

	if ( ! ear ) return;

	// interlink polygon nodes in z-order
	if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );

	let stop = ear,
		prev, next;

	// iterate through ears, slicing them one by one
	while ( ear.prev !== ear.next ) {

		prev = ear.prev;
		next = ear.next;

		if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {

			// cut off the triangle
			triangles.push( prev.i / dim );
			triangles.push( ear.i / dim );
			triangles.push( next.i / dim );

			removeNode( ear );

			// skipping the next vertex leads to less sliver triangles
			ear = next.next;
			stop = next.next;

			continue;

		}

		ear = next;

		// if we looped through the whole remaining polygon and can't find any more ears
		if ( ear === stop ) {

			// try filtering points and slicing again
			if ( ! pass ) {

				earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );

				// if this didn't work, try curing all small self-intersections locally

			} else if ( pass === 1 ) {

				ear = cureLocalIntersections( filterPoints( ear ), triangles, dim );
				earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );

				// as a last resort, try splitting the remaining polygon into two

			} else if ( pass === 2 ) {

				splitEarcut( ear, triangles, dim, minX, minY, invSize );

			}

			break;

		}

	}

}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar( ear ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// now make sure we don't have other points inside the potential ear
	let p = ear.next.next;

	while ( p !== ear.prev ) {

		if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.next;

	}

	return true;

}

function isEarHashed( ear, minX, minY, invSize ) {

	const a = ear.prev,
		b = ear,
		c = ear.next;

	if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear

	// triangle bbox; min & max are calculated like this for speed
	const minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
		minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
		maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
		maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );

	// z-order range for the current triangle bbox;
	const minZ = zOrder( minTX, minTY, minX, minY, invSize ),
		maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );

	let p = ear.prevZ,
		n = ear.nextZ;

	// look for points inside the triangle in both directions
	while ( p && p.z >= minZ && n && n.z <= maxZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	// look for remaining points in decreasing z-order
	while ( p && p.z >= minZ ) {

		if ( p !== ear.prev && p !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
			area( p.prev, p, p.next ) >= 0 ) return false;
		p = p.prevZ;

	}

	// look for remaining points in increasing z-order
	while ( n && n.z <= maxZ ) {

		if ( n !== ear.prev && n !== ear.next &&
			pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y ) &&
			area( n.prev, n, n.next ) >= 0 ) return false;
		n = n.nextZ;

	}

	return true;

}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections( start, triangles, dim ) {

	let p = start;
	do {

		const a = p.prev,
			b = p.next.next;

		if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {

			triangles.push( a.i / dim );
			triangles.push( p.i / dim );
			triangles.push( b.i / dim );

			// remove two nodes involved
			removeNode( p );
			removeNode( p.next );

			p = start = b;

		}

		p = p.next;

	} while ( p !== start );

	return filterPoints( p );

}

// try splitting polygon into two and triangulate them independently
function splitEarcut( start, triangles, dim, minX, minY, invSize ) {

	// look for a valid diagonal that divides the polygon into two
	let a = start;
	do {

		let b = a.next.next;
		while ( b !== a.prev ) {

			if ( a.i !== b.i && isValidDiagonal( a, b ) ) {

				// split the polygon in two by the diagonal
				let c = splitPolygon( a, b );

				// filter colinear points around the cuts
				a = filterPoints( a, a.next );
				c = filterPoints( c, c.next );

				// run earcut on each half
				earcutLinked( a, triangles, dim, minX, minY, invSize );
				earcutLinked( c, triangles, dim, minX, minY, invSize );
				return;

			}

			b = b.next;

		}

		a = a.next;

	} while ( a !== start );

}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles( data, holeIndices, outerNode, dim ) {

	const queue = [];
	let i, len, start, end, list;

	for ( i = 0, len = holeIndices.length; i < len; i ++ ) {

		start = holeIndices[ i ] * dim;
		end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
		list = linkedList( data, start, end, dim, false );
		if ( list === list.next ) list.steiner = true;
		queue.push( getLeftmost( list ) );

	}

	queue.sort( compareX );

	// process holes from left to right
	for ( i = 0; i < queue.length; i ++ ) {

		eliminateHole( queue[ i ], outerNode );
		outerNode = filterPoints( outerNode, outerNode.next );

	}

	return outerNode;

}

function compareX( a, b ) {

	return a.x - b.x;

}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole( hole, outerNode ) {

	outerNode = findHoleBridge( hole, outerNode );
	if ( outerNode ) {

		const b = splitPolygon( outerNode, hole );

		// filter collinear points around the cuts
		filterPoints( outerNode, outerNode.next );
		filterPoints( b, b.next );

	}

}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge( hole, outerNode ) {

	let p = outerNode;
	const hx = hole.x;
	const hy = hole.y;
	let qx = - Infinity, m;

	// find a segment intersected by a ray from the hole's leftmost point to the left;
	// segment's endpoint with lesser x will be potential connection point
	do {

		if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {

			const x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
			if ( x <= hx && x > qx ) {

				qx = x;
				if ( x === hx ) {

					if ( hy === p.y ) return p;
					if ( hy === p.next.y ) return p.next;

				}

				m = p.x < p.next.x ? p : p.next;

			}

		}

		p = p.next;

	} while ( p !== outerNode );

	if ( ! m ) return null;

	if ( hx === qx ) return m; // hole touches outer segment; pick leftmost endpoint

	// look for points inside the triangle of hole point, segment intersection and endpoint;
	// if there are no points found, we have a valid connection;
	// otherwise choose the point of the minimum angle with the ray as connection point

	const stop = m,
		mx = m.x,
		my = m.y;
	let tanMin = Infinity, tan;

	p = m;

	do {

		if ( hx >= p.x && p.x >= mx && hx !== p.x &&
				pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {

			tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential

			if ( locallyInside( p, hole ) && ( tan < tanMin || ( tan === tanMin && ( p.x > m.x || ( p.x === m.x && sectorContainsSector( m, p ) ) ) ) ) ) {

				m = p;
				tanMin = tan;

			}

		}

		p = p.next;

	} while ( p !== stop );

	return m;

}

// whether sector in vertex m contains sector in vertex p in the same coordinates
function sectorContainsSector( m, p ) {

	return area( m.prev, m, p.prev ) < 0 && area( p.next, m, m.next ) < 0;

}

// interlink polygon nodes in z-order
function indexCurve( start, minX, minY, invSize ) {

	let p = start;
	do {

		if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
		p.prevZ = p.prev;
		p.nextZ = p.next;
		p = p.next;

	} while ( p !== start );

	p.prevZ.nextZ = null;
	p.prevZ = null;

	sortLinked( p );

}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked( list ) {

	let i, p, q, e, tail, numMerges, pSize, qSize,
		inSize = 1;

	do {

		p = list;
		list = null;
		tail = null;
		numMerges = 0;

		while ( p ) {

			numMerges ++;
			q = p;
			pSize = 0;
			for ( i = 0; i < inSize; i ++ ) {

				pSize ++;
				q = q.nextZ;
				if ( ! q ) break;

			}

			qSize = inSize;

			while ( pSize > 0 || ( qSize > 0 && q ) ) {

				if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {

					e = p;
					p = p.nextZ;
					pSize --;

				} else {

					e = q;
					q = q.nextZ;
					qSize --;

				}

				if ( tail ) tail.nextZ = e;
				else list = e;

				e.prevZ = tail;
				tail = e;

			}

			p = q;

		}

		tail.nextZ = null;
		inSize *= 2;

	} while ( numMerges > 1 );

	return list;

}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder( x, y, minX, minY, invSize ) {

	// coords are transformed into non-negative 15-bit integer range
	x = 32767 * ( x - minX ) * invSize;
	y = 32767 * ( y - minY ) * invSize;

	x = ( x | ( x << 8 ) ) & 0x00FF00FF;
	x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
	x = ( x | ( x << 2 ) ) & 0x33333333;
	x = ( x | ( x << 1 ) ) & 0x55555555;

	y = ( y | ( y << 8 ) ) & 0x00FF00FF;
	y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
	y = ( y | ( y << 2 ) ) & 0x33333333;
	y = ( y | ( y << 1 ) ) & 0x55555555;

	return x | ( y << 1 );

}

// find the leftmost node of a polygon ring
function getLeftmost( start ) {

	let p = start,
		leftmost = start;
	do {

		if ( p.x < leftmost.x || ( p.x === leftmost.x && p.y < leftmost.y ) ) leftmost = p;
		p = p.next;

	} while ( p !== start );

	return leftmost;

}

// check if a point lies within a convex triangle
function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {

	return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
			( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
			( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;

}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal( a, b ) {

	return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) && // dones't intersect other edges
		( locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b ) && // locally visible
		( area( a.prev, a, b.prev ) || area( a, b.prev, b ) ) || // does not create opposite-facing sectors
		equals( a, b ) && area( a.prev, a, a.next ) > 0 && area( b.prev, b, b.next ) > 0 ); // special zero-length case

}

// signed area of a triangle
function area( p, q, r ) {

	return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );

}

// check if two points are equal
function equals( p1, p2 ) {

	return p1.x === p2.x && p1.y === p2.y;

}

// check if two segments intersect
function intersects( p1, q1, p2, q2 ) {

	const o1 = sign( area( p1, q1, p2 ) );
	const o2 = sign( area( p1, q1, q2 ) );
	const o3 = sign( area( p2, q2, p1 ) );
	const o4 = sign( area( p2, q2, q1 ) );

	if ( o1 !== o2 && o3 !== o4 ) return true; // general case

	if ( o1 === 0 && onSegment( p1, p2, q1 ) ) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
	if ( o2 === 0 && onSegment( p1, q2, q1 ) ) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
	if ( o3 === 0 && onSegment( p2, p1, q2 ) ) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
	if ( o4 === 0 && onSegment( p2, q1, q2 ) ) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

	return false;

}

// for collinear points p, q, r, check if point q lies on segment pr
function onSegment( p, q, r ) {

	return q.x <= Math.max( p.x, r.x ) && q.x >= Math.min( p.x, r.x ) && q.y <= Math.max( p.y, r.y ) && q.y >= Math.min( p.y, r.y );

}

function sign( num ) {

	return num > 0 ? 1 : num < 0 ? - 1 : 0;

}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon( a, b ) {

	let p = a;
	do {

		if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
				intersects( p, p.next, a, b ) ) return true;
		p = p.next;

	} while ( p !== a );

	return false;

}

// check if a polygon diagonal is locally inside the polygon
function locallyInside( a, b ) {

	return area( a.prev, a, a.next ) < 0 ?
		area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
		area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;

}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside( a, b ) {

	let p = a,
		inside = false;
	const px = ( a.x + b.x ) / 2,
		py = ( a.y + b.y ) / 2;
	do {

		if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
				( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) )
			inside = ! inside;
		p = p.next;

	} while ( p !== a );

	return inside;

}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon( a, b ) {

	const a2 = new Node$1( a.i, a.x, a.y ),
		b2 = new Node$1( b.i, b.x, b.y ),
		an = a.next,
		bp = b.prev;

	a.next = b;
	b.prev = a;

	a2.next = an;
	an.prev = a2;

	b2.next = a2;
	a2.prev = b2;

	bp.next = b2;
	b2.prev = bp;

	return b2;

}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode( i, x, y, last ) {

	const p = new Node$1( i, x, y );

	if ( ! last ) {

		p.prev = p;
		p.next = p;

	} else {

		p.next = last.next;
		p.prev = last;
		last.next.prev = p;
		last.next = p;

	}

	return p;

}

function removeNode( p ) {

	p.next.prev = p.prev;
	p.prev.next = p.next;

	if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
	if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;

}

function Node$1( i, x, y ) {

	// vertex index in coordinates array
	this.i = i;

	// vertex coordinates
	this.x = x;
	this.y = y;

	// previous and next vertex nodes in a polygon ring
	this.prev = null;
	this.next = null;

	// z-order curve value
	this.z = null;

	// previous and next nodes in z-order
	this.prevZ = null;
	this.nextZ = null;

	// indicates whether this is a steiner point
	this.steiner = false;

}

function signedArea( data, start, end, dim ) {

	let sum = 0;
	for ( let i = start, j = end - dim; i < end; i += dim ) {

		sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
		j = i;

	}

	return sum;

}

const ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		const n = contour.length;
		let a = 0.0;

		for ( let p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	triangulateShape: function ( contour, holes ) {

		const vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
		const holeIndices = []; // array of hole indices
		const faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

		removeDupEndPts( contour );
		addContour( vertices, contour );

		//

		let holeIndex = contour.length;

		holes.forEach( removeDupEndPts );

		for ( let i = 0; i < holes.length; i ++ ) {

			holeIndices.push( holeIndex );
			holeIndex += holes[ i ].length;
			addContour( vertices, holes[ i ] );

		}

		//

		const triangles = Earcut.triangulate( vertices, holeIndices );

		//

		for ( let i = 0; i < triangles.length; i += 3 ) {

			faces.push( triangles.slice( i, i + 3 ) );

		}

		return faces;

	}

};

function removeDupEndPts( points ) {

	const l = points.length;

	if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

		points.pop();

	}

}

function addContour( vertices, contour ) {

	for ( let i = 0; i < contour.length; i ++ ) {

		vertices.push( contour[ i ].x );
		vertices.push( contour[ i ].y );

	}

}

/**
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  depth: <float>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
 *  bevelOffset: <float>, // how far from shape outline does bevel start
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *
 *  UVGenerator: <Object> // object that provides UV generator functions
 *
 * }
 */

class ExtrudeGeometry extends BufferGeometry {

	constructor( shapes, options ) {

		super();

		this.type = 'ExtrudeGeometry';

		this.parameters = {
			shapes: shapes,
			options: options
		};

		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

		const scope = this;

		const verticesArray = [];
		const uvArray = [];

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];
			addShape( shape );

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );

		this.computeVertexNormals();

		// functions

		function addShape( shape ) {

			const placeholder = [];

			// options

			const curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			const steps = options.steps !== undefined ? options.steps : 1;
			let depth = options.depth !== undefined ? options.depth : 100;

			let bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			let bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			let bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			let bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
			let bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

			const extrudePath = options.extrudePath;

			const uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

			// deprecated options

			if ( options.amount !== undefined ) {

				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;

			}

			//

			let extrudePts, extrudeByPath = false;
			let splineTube, binormal, normal, position2;

			if ( extrudePath ) {

				extrudePts = extrudePath.getSpacedPoints( steps );

				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion

				// SETUP TNB variables

				// TODO1 - have a .isClosed in spline?

				splineTube = extrudePath.computeFrenetFrames( steps, false );

				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

				binormal = new Vector3$1();
				normal = new Vector3$1();
				position2 = new Vector3$1();

			}

			// Safeguards if bevels are not enabled

			if ( ! bevelEnabled ) {

				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
				bevelOffset = 0;

			}

			// Variables initialization

			const shapePoints = shape.extractPoints( curveSegments );

			let vertices = shapePoints.shape;
			const holes = shapePoints.holes;

			const reverse = ! ShapeUtils.isClockWise( vertices );

			if ( reverse ) {

				vertices = vertices.reverse();

				// Maybe we should also check if holes are in the opposite direction, just to be safe ...

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];

					if ( ShapeUtils.isClockWise( ahole ) ) {

						holes[ h ] = ahole.reverse();

					}

				}

			}


			const faces = ShapeUtils.triangulateShape( vertices, holes );

			/* Vertices */

			const contour = vertices; // vertices has all points but contour has only points of circumference

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				vertices = vertices.concat( ahole );

			}


			function scalePt2( pt, vec, size ) {

				if ( ! vec ) console.error( 'THREE.ExtrudeGeometry: vec does not exist' );

				return vec.clone().multiplyScalar( size ).add( pt );

			}

			const vlen = vertices.length, flen = faces.length;


			// Find directions for point movement


			function getBevelVec( inPt, inPrev, inNext ) {

				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.

				let v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html

				const v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				const v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;

				const v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

				// check for collinear edges
				const collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

				if ( Math.abs( collinear0 ) > Number.EPSILON ) {

					// not collinear

					// length of vectors for normalizing

					const v_prev_len = Math.sqrt( v_prev_lensq );
					const v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

					// shift adjacent points by unit vectors to the left

					const ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					const ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

					const ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					const ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

					// scaling factor for v_prev to intersection point

					const sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );

					// vector from inPt to intersection point

					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					const v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {

						return new Vector2( v_trans_x, v_trans_y );

					} else {

						shrink_by = Math.sqrt( v_trans_lensq / 2 );

					}

				} else {

					// handle special case of collinear edges

					let direction_eq = false; // assumes: opposite

					if ( v_prev_x > Number.EPSILON ) {

						if ( v_next_x > Number.EPSILON ) {

							direction_eq = true;

						}

					} else {

						if ( v_prev_x < - Number.EPSILON ) {

							if ( v_next_x < - Number.EPSILON ) {

								direction_eq = true;

							}

						} else {

							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

								direction_eq = true;

							}

						}

					}

					if ( direction_eq ) {

						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );

					} else {

						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );

					}

				}

				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

			}


			const contourMovements = [];

			for ( let i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

				if ( j === il ) j = 0;
				if ( k === il ) k = 0;

				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)

				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

			}

			const holesMovements = [];
			let oneHoleMovements, verticesMovements = contourMovements.concat();

			for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

				const ahole = holes[ h ];

				oneHoleMovements = [];

				for ( let i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

					if ( j === il ) j = 0;
					if ( k === il ) k = 0;

					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

				}

				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );

			}


			// Loop bevelSegments, 1 for the front, 1 for the back

			for ( let b = 0; b < bevelSegments; b ++ ) {

				//for ( b = bevelSegments; b > 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

					v( vert.x, vert.y, - z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						v( vert.x, vert.y, - z );

					}

				}

			}

			const bs = bevelSize + bevelOffset;

			// Back facing vertices

			for ( let i = 0; i < vlen; i ++ ) {

				const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y, 0 );

				} else {

					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

					v( position2.x, position2.y, position2.z );

				}

			}

			// Add stepped vertices...
			// Including front facing vertices

			for ( let s = 1; s <= steps; s ++ ) {

				for ( let i = 0; i < vlen; i ++ ) {

					const vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

					if ( ! extrudeByPath ) {

						v( vert.x, vert.y, depth / steps * s );

					} else {

						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

						v( position2.x, position2.y, position2.z );

					}

				}

			}


			// Add bevel segments planes

			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( let b = bevelSegments - 1; b >= 0; b -- ) {

				const t = b / bevelSegments;
				const z = bevelThickness * Math.cos( t * Math.PI / 2 );
				const bs = bevelSize * Math.sin( t * Math.PI / 2 ) + bevelOffset;

				// contract shape

				for ( let i = 0, il = contour.length; i < il; i ++ ) {

					const vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );

				}

				// expand holes

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];

					for ( let i = 0, il = ahole.length; i < il; i ++ ) {

						const vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

						if ( ! extrudeByPath ) {

							v( vert.x, vert.y, depth + z );

						} else {

							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

						}

					}

				}

			}

			/* Faces */

			// Top and bottom faces

			buildLidFaces();

			// Sides faces

			buildSideFaces();


			/////  Internal functions

			function buildLidFaces() {

				const start = verticesArray.length / 3;

				if ( bevelEnabled ) {

					let layer = 0; // steps + 1
					let offset = vlen * layer;

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

					}

					layer = steps + bevelSegments * 2;
					offset = vlen * layer;

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

					}

				} else {

					// Bottom faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );

					}

					// Top faces

					for ( let i = 0; i < flen; i ++ ) {

						const face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

					}

				}

				scope.addGroup( start, verticesArray.length / 3 - start, 0 );

			}

			// Create faces for the z-sides of the shape

			function buildSideFaces() {

				const start = verticesArray.length / 3;
				let layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;

				for ( let h = 0, hl = holes.length; h < hl; h ++ ) {

					const ahole = holes[ h ];
					sidewalls( ahole, layeroffset );

					//, true
					layeroffset += ahole.length;

				}


				scope.addGroup( start, verticesArray.length / 3 - start, 1 );


			}

			function sidewalls( contour, layeroffset ) {

				let i = contour.length;

				while ( -- i >= 0 ) {

					const j = i;
					let k = i - 1;
					if ( k < 0 ) k = contour.length - 1;

					//console.log('b', i,j, i-1, k,vertices.length);

					for ( let s = 0, sl = ( steps + bevelSegments * 2 ); s < sl; s ++ ) {

						const slen1 = vlen * s;
						const slen2 = vlen * ( s + 1 );

						const a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;

						f4( a, b, c, d );

					}

				}

			}

			function v( x, y, z ) {

				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );

			}


			function f3( a, b, c ) {

				addVertex( a );
				addVertex( b );
				addVertex( c );

				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );

			}

			function f4( a, b, c, d ) {

				addVertex( a );
				addVertex( b );
				addVertex( d );

				addVertex( b );
				addVertex( c );
				addVertex( d );


				const nextIndex = verticesArray.length / 3;
				const uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );

				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );

				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );

			}

			function addVertex( index ) {

				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );

			}


			function addUV( vector2 ) {

				uvArray.push( vector2.x );
				uvArray.push( vector2.y );

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;
		const options = this.parameters.options;

		return toJSON( shapes, options, data );

	}

}

const WorldUVGenerator = {

	generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];

		return [
			new Vector2( a_x, a_y ),
			new Vector2( b_x, b_y ),
			new Vector2( c_x, c_y )
		];

	},

	generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {

		const a_x = vertices[ indexA * 3 ];
		const a_y = vertices[ indexA * 3 + 1 ];
		const a_z = vertices[ indexA * 3 + 2 ];
		const b_x = vertices[ indexB * 3 ];
		const b_y = vertices[ indexB * 3 + 1 ];
		const b_z = vertices[ indexB * 3 + 2 ];
		const c_x = vertices[ indexC * 3 ];
		const c_y = vertices[ indexC * 3 + 1 ];
		const c_z = vertices[ indexC * 3 + 2 ];
		const d_x = vertices[ indexD * 3 ];
		const d_y = vertices[ indexD * 3 + 1 ];
		const d_z = vertices[ indexD * 3 + 2 ];

		if ( Math.abs( a_y - b_y ) < 0.01 ) {

			return [
				new Vector2( a_x, 1 - a_z ),
				new Vector2( b_x, 1 - b_z ),
				new Vector2( c_x, 1 - c_z ),
				new Vector2( d_x, 1 - d_z )
			];

		} else {

			return [
				new Vector2( a_y, 1 - a_z ),
				new Vector2( b_y, 1 - b_z ),
				new Vector2( c_y, 1 - c_z ),
				new Vector2( d_y, 1 - d_z )
			];

		}

	}

};

function toJSON( shapes, options, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();

	return data;

}

class IcosahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const t = ( 1 + Math.sqrt( 5 ) ) / 2;

		const vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];

		const indices = [
			0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'IcosahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

class LatheGeometry extends BufferGeometry {

	constructor( points, segments = 12, phiStart = 0, phiLength = Math.PI * 2 ) {

		super();

		this.type = 'LatheGeometry';

		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};

		segments = Math.floor( segments );

		// clamp phiLength so it's in range of [ 0, 2PI ]

		phiLength = MathUtils.clamp( phiLength, 0, Math.PI * 2 );

		// buffers

		const indices = [];
		const vertices = [];
		const uvs = [];

		// helper variables

		const inverseSegments = 1.0 / segments;
		const vertex = new Vector3$1();
		const uv = new Vector2();

		// generate vertices and uvs

		for ( let i = 0; i <= segments; i ++ ) {

			const phi = phiStart + i * inverseSegments * phiLength;

			const sin = Math.sin( phi );
			const cos = Math.cos( phi );

			for ( let j = 0; j <= ( points.length - 1 ); j ++ ) {

				// vertex

				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;

				vertices.push( vertex.x, vertex.y, vertex.z );

				// uv

				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );

				uvs.push( uv.x, uv.y );


			}

		}

		// indices

		for ( let i = 0; i < segments; i ++ ) {

			for ( let j = 0; j < ( points.length - 1 ); j ++ ) {

				const base = j + i * points.length;

				const a = base;
				const b = base + points.length;
				const c = base + points.length + 1;
				const d = base + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// generate normals

		this.computeVertexNormals();

		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).

		if ( phiLength === Math.PI * 2 ) {

			const normals = this.attributes.normal.array;
			const n1 = new Vector3$1();
			const n2 = new Vector3$1();
			const n = new Vector3$1();

			// this is the buffer offset for the last line of vertices

			const base = segments * points.length * 3;

			for ( let i = 0, j = 0; i < points.length; i ++, j += 3 ) {

				// select the normal of the vertex in the first line

				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];

				// select the normal of the vertex in the last line

				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];

				// average normals

				n.addVectors( n1, n2 ).normalize();

				// assign the new values to both normals

				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

			}

		}

	}

}

class OctahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];

		const indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];

		super( vertices, indices, radius, detail );

		this.type = 'OctahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

/**
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout https://prideout.net/blog/old/blog/index.html@p=44.html
 */

function ParametricGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// buffers

	const indices = [];
	const vertices = [];
	const normals = [];
	const uvs = [];

	const EPS = 0.00001;

	const normal = new Vector3$1();

	const p0 = new Vector3$1(), p1 = new Vector3$1();
	const pu = new Vector3$1(), pv = new Vector3$1();

	if ( func.length < 3 ) {

		console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );

	}

	// generate vertices, normals and uvs

	const sliceCount = slices + 1;

	for ( let i = 0; i <= stacks; i ++ ) {

		const v = i / stacks;

		for ( let j = 0; j <= slices; j ++ ) {

			const u = j / slices;

			// vertex

			func( u, v, p0 );
			vertices.push( p0.x, p0.y, p0.z );

			// normal

			// approximate tangent vectors via finite differences

			if ( u - EPS >= 0 ) {

				func( u - EPS, v, p1 );
				pu.subVectors( p0, p1 );

			} else {

				func( u + EPS, v, p1 );
				pu.subVectors( p1, p0 );

			}

			if ( v - EPS >= 0 ) {

				func( u, v - EPS, p1 );
				pv.subVectors( p0, p1 );

			} else {

				func( u, v + EPS, p1 );
				pv.subVectors( p1, p0 );

			}

			// cross product of tangent vectors returns surface normal

			normal.crossVectors( pu, pv ).normalize();
			normals.push( normal.x, normal.y, normal.z );

			// uv

			uvs.push( u, v );

		}

	}

	// generate indices

	for ( let i = 0; i < stacks; i ++ ) {

		for ( let j = 0; j < slices; j ++ ) {

			const a = i * sliceCount + j;
			const b = i * sliceCount + j + 1;
			const c = ( i + 1 ) * sliceCount + j + 1;
			const d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( indices );
	this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

}

ParametricGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

class RingGeometry extends BufferGeometry {

	constructor( innerRadius = 0.5, outerRadius = 1, thetaSegments = 8, phiSegments = 1, thetaStart = 0, thetaLength = Math.PI * 2 ) {

		super();

		this.type = 'RingGeometry';

		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		thetaSegments = Math.max( 3, thetaSegments );
		phiSegments = Math.max( 1, phiSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// some helper variables

		let radius = innerRadius;
		const radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		const vertex = new Vector3$1();
		const uv = new Vector2();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= phiSegments; j ++ ) {

			for ( let i = 0; i <= thetaSegments; i ++ ) {

				// values are generate from the inside of the ring to the outside

				const segment = thetaStart + i / thetaSegments * thetaLength;

				// vertex

				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normals.push( 0, 0, 1 );

				// uv

				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;

				uvs.push( uv.x, uv.y );

			}

			// increase the radius for next row of vertices

			radius += radiusStep;

		}

		// indices

		for ( let j = 0; j < phiSegments; j ++ ) {

			const thetaSegmentLevel = j * ( thetaSegments + 1 );

			for ( let i = 0; i < thetaSegments; i ++ ) {

				const segment = i + thetaSegmentLevel;

				const a = segment;
				const b = segment + thetaSegments + 1;
				const c = segment + thetaSegments + 2;
				const d = segment + 1;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class ShapeGeometry extends BufferGeometry {

	constructor( shapes, curveSegments = 12 ) {

		super();
		this.type = 'ShapeGeometry';

		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		let groupStart = 0;
		let groupCount = 0;

		// allow single and array values for "shapes" parameter

		if ( Array.isArray( shapes ) === false ) {

			addShape( shapes );

		} else {

			for ( let i = 0; i < shapes.length; i ++ ) {

				addShape( shapes[ i ] );

				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

				groupStart += groupCount;
				groupCount = 0;

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


		// helper functions

		function addShape( shape ) {

			const indexOffset = vertices.length / 3;
			const points = shape.extractPoints( curveSegments );

			let shapeVertices = points.shape;
			const shapeHoles = points.holes;

			// check direction of vertices

			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

				shapeVertices = shapeVertices.reverse();

			}

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

			const faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

			// join vertices of inner and outer paths to a single array

			for ( let i = 0, l = shapeHoles.length; i < l; i ++ ) {

				const shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );

			}

			// vertices, normals, uvs

			for ( let i = 0, l = shapeVertices.length; i < l; i ++ ) {

				const vertex = shapeVertices[ i ];

				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs

			}

			// incides

			for ( let i = 0, l = faces.length; i < l; i ++ ) {

				const face = faces[ i ];

				const a = face[ 0 ] + indexOffset;
				const b = face[ 1 ] + indexOffset;
				const c = face[ 2 ] + indexOffset;

				indices.push( a, b, c );
				groupCount += 3;

			}

		}

	}

	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		const shapes = this.parameters.shapes;

		return toJSON$1( shapes, data );

	}

}

function toJSON$1( shapes, data ) {

	data.shapes = [];

	if ( Array.isArray( shapes ) ) {

		for ( let i = 0, l = shapes.length; i < l; i ++ ) {

			const shape = shapes[ i ];

			data.shapes.push( shape.uuid );

		}

	} else {

		data.shapes.push( shapes.uuid );

	}

	return data;

}

class SphereGeometry extends BufferGeometry {

	constructor( radius = 1, widthSegments = 8, heightSegments = 6, phiStart = 0, phiLength = Math.PI * 2, thetaStart = 0, thetaLength = Math.PI ) {

		super();
		this.type = 'SphereGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		widthSegments = Math.max( 3, Math.floor( widthSegments ) );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) );

		const thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		let index = 0;
		const grid = [];

		const vertex = new Vector3$1();
		const normal = new Vector3$1();

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// generate vertices, normals and uvs

		for ( let iy = 0; iy <= heightSegments; iy ++ ) {

			const verticesRow = [];

			const v = iy / heightSegments;

			// special case for the poles

			let uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( let ix = 0; ix <= widthSegments; ix ++ ) {

				const u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( let iy = 0; iy < heightSegments; iy ++ ) {

			for ( let ix = 0; ix < widthSegments; ix ++ ) {

				const a = grid[ iy ][ ix + 1 ];
				const b = grid[ iy ][ ix ];
				const c = grid[ iy + 1 ][ ix ];
				const d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class TetrahedronGeometry extends PolyhedronGeometry {

	constructor( radius = 1, detail = 0 ) {

		const vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];

		const indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];

		super( vertices, indices, radius, detail );

		this.type = 'TetrahedronGeometry';

		this.parameters = {
			radius: radius,
			detail: detail
		};

	}

}

/**
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float>, // how far from text outline (including bevelOffset) is bevel
 *  bevelOffset: <float> // how far from text outline does bevel start
 * }
 */

class TextGeometry extends ExtrudeGeometry {

	constructor( text, parameters = {} ) {

		const font = parameters.font;

		if ( ! ( font && font.isFont ) ) {

			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new BufferGeometry();

		}

		const shapes = font.generateShapes( text, parameters.size );

		// translate parameters to ExtrudeGeometry API

		parameters.depth = parameters.height !== undefined ? parameters.height : 50;

		// defaults

		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

		super( shapes, parameters );

		this.type = 'TextGeometry';

	}

}

class TorusGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, radialSegments = 8, tubularSegments = 6, arc = Math.PI * 2 ) {

		super();
		this.type = 'TorusGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};

		radialSegments = Math.floor( radialSegments );
		tubularSegments = Math.floor( tubularSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const center = new Vector3$1();
		const vertex = new Vector3$1();
		const normal = new Vector3$1();

		// generate vertices, normals and uvs

		for ( let j = 0; j <= radialSegments; j ++ ) {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				const u = i / tubularSegments * arc;
				const v = j / radialSegments * Math.PI * 2;

				// vertex

				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= radialSegments; j ++ ) {

			for ( let i = 1; i <= tubularSegments; i ++ ) {

				// indices

				const a = ( tubularSegments + 1 ) * j + i - 1;
				const b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				const c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				const d = ( tubularSegments + 1 ) * j + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

}

class TorusKnotGeometry extends BufferGeometry {

	constructor( radius = 1, tube = 0.4, tubularSegments = 64, radialSegments = 8, p = 2, q = 3 ) {

		super();
		this.type = 'TorusKnotGeometry';

		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};

		tubularSegments = Math.floor( tubularSegments );
		radialSegments = Math.floor( radialSegments );

		// buffers

		const indices = [];
		const vertices = [];
		const normals = [];
		const uvs = [];

		// helper variables

		const vertex = new Vector3$1();
		const normal = new Vector3$1();

		const P1 = new Vector3$1();
		const P2 = new Vector3$1();

		const B = new Vector3$1();
		const T = new Vector3$1();
		const N = new Vector3$1();

		// generate vertices, normals and uvs

		for ( let i = 0; i <= tubularSegments; ++ i ) {

			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

			const u = i / tubularSegments * p * Math.PI * 2;

			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

			// calculate orthonormal basis

			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );

			// normalize B, N. T can be ignored, we don't use it

			B.normalize();
			N.normalize();

			for ( let j = 0; j <= radialSegments; ++ j ) {

				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

				const v = j / radialSegments * Math.PI * 2;
				const cx = - tube * Math.cos( v );
				const cy = tube * Math.sin( v );

				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

				normal.subVectors( vertex, P1 ).normalize();

				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );

			}

		}

		// generate indices

		for ( let j = 1; j <= tubularSegments; j ++ ) {

			for ( let i = 1; i <= radialSegments; i ++ ) {

				// indices

				const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				const b = ( radialSegments + 1 ) * j + ( i - 1 );
				const c = ( radialSegments + 1 ) * j + i;
				const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// this function calculates the current position on the torus curve

		function calculatePositionOnCurve( u, p, q, radius, position ) {

			const cu = Math.cos( u );
			const su = Math.sin( u );
			const quOverP = q / p * u;
			const cs = Math.cos( quOverP );

			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;

		}

	}

}

class TubeGeometry extends BufferGeometry {

	constructor( path, tubularSegments = 64, radius = 1, radialSegments = 8, closed = false ) {

		super();
		this.type = 'TubeGeometry';

		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};

		const frames = path.computeFrenetFrames( tubularSegments, closed );

		// expose internals

		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;

		// helper variables

		const vertex = new Vector3$1();
		const normal = new Vector3$1();
		const uv = new Vector2();
		let P = new Vector3$1();

		// buffer

		const vertices = [];
		const normals = [];
		const uvs = [];
		const indices = [];

		// create buffer data

		generateBufferData();

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

		// functions

		function generateBufferData() {

			for ( let i = 0; i < tubularSegments; i ++ ) {

				generateSegment( i );

			}

			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

			generateSegment( ( closed === false ) ? tubularSegments : 0 );

			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries

			generateUVs();

			// finally create faces

			generateIndices();

		}

		function generateSegment( i ) {

			// we use getPointAt to sample evenly distributed points from the given path

			P = path.getPointAt( i / tubularSegments, P );

			// retrieve corresponding normal and binormal

			const N = frames.normals[ i ];
			const B = frames.binormals[ i ];

			// generate normals and vertices for the current segment

			for ( let j = 0; j <= radialSegments; j ++ ) {

				const v = j / radialSegments * Math.PI * 2;

				const sin = Math.sin( v );
				const cos = - Math.cos( v );

				// normal

				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();

				normals.push( normal.x, normal.y, normal.z );

				// vertex

				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;

				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		}

		function generateIndices() {

			for ( let j = 1; j <= tubularSegments; j ++ ) {

				for ( let i = 1; i <= radialSegments; i ++ ) {

					const a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					const b = ( radialSegments + 1 ) * j + ( i - 1 );
					const c = ( radialSegments + 1 ) * j + i;
					const d = ( radialSegments + 1 ) * ( j - 1 ) + i;

					// faces

					indices.push( a, b, d );
					indices.push( b, c, d );

				}

			}

		}

		function generateUVs() {

			for ( let i = 0; i <= tubularSegments; i ++ ) {

				for ( let j = 0; j <= radialSegments; j ++ ) {

					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;

					uvs.push( uv.x, uv.y );

				}

			}

		}

	}
	toJSON() {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.path = this.parameters.path.toJSON();

		return data;

	}

}

class WireframeGeometry extends BufferGeometry {

	constructor( geometry ) {

		super();
		this.type = 'WireframeGeometry';

		if ( geometry.isGeometry === true ) {

			console.error( 'THREE.WireframeGeometry no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
			return;

		}

		// buffer

		const vertices = [];

		// helper variables

		const edge = [ 0, 0 ], edges = {};

		const vertex = new Vector3$1();

		if ( geometry.index !== null ) {

			// indexed BufferGeometry

			const position = geometry.attributes.position;
			const indices = geometry.index;
			let groups = geometry.groups;

			if ( groups.length === 0 ) {

				groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];

			}

			// create a data structure that contains all eges without duplicates

			for ( let o = 0, ol = groups.length; o < ol; ++ o ) {

				const group = groups[ o ];

				const start = group.start;
				const count = group.count;

				for ( let i = start, l = ( start + count ); i < l; i += 3 ) {

					for ( let j = 0; j < 3; j ++ ) {

						const edge1 = indices.getX( i + j );
						const edge2 = indices.getX( i + ( j + 1 ) % 3 );
						edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
						edge[ 1 ] = Math.max( edge1, edge2 );

						const key = edge[ 0 ] + ',' + edge[ 1 ];

						if ( edges[ key ] === undefined ) {

							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };

						}

					}

				}

			}

			// generate vertices

			for ( const key in edges ) {

				const e = edges[ key ];

				vertex.fromBufferAttribute( position, e.index1 );
				vertices.push( vertex.x, vertex.y, vertex.z );

				vertex.fromBufferAttribute( position, e.index2 );
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

		} else {

			// non-indexed BufferGeometry

			const position = geometry.attributes.position;

			for ( let i = 0, l = ( position.count / 3 ); i < l; i ++ ) {

				for ( let j = 0; j < 3; j ++ ) {

					// three edges per triangle, an edge is represented as (index1, index2)
					// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

					const index1 = 3 * i + j;
					vertex.fromBufferAttribute( position, index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );

					const index2 = 3 * i + ( ( j + 1 ) % 3 );
					vertex.fromBufferAttribute( position, index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );

				}

			}

		}

		// build geometry

		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );

	}

}

var Geometries = /*#__PURE__*/Object.freeze({
	__proto__: null,
	BoxGeometry: BoxGeometry,
	BoxBufferGeometry: BoxGeometry,
	CircleGeometry: CircleGeometry,
	CircleBufferGeometry: CircleGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronGeometry,
	EdgesGeometry: EdgesGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	ExtrudeBufferGeometry: ExtrudeGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricGeometry,
	PlaneGeometry: PlaneGeometry,
	PlaneBufferGeometry: PlaneGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeGeometry,
	SphereGeometry: SphereGeometry,
	SphereBufferGeometry: SphereGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronGeometry,
	TextGeometry: TextGeometry,
	TextBufferGeometry: TextGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeGeometry,
	WireframeGeometry: WireframeGeometry
});

/**
 * parameters = {
 *  color: <THREE.Color>
 * }
 */

class ShadowMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'ShadowMaterial';

		this.color = new Color$1( 0x000000 );
		this.transparent = true;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		return this;

	}

}

ShadowMaterial.prototype.isShadowMaterial = true;

class RawShaderMaterial extends ShaderMaterial {

	constructor( parameters ) {

		super( parameters );

		this.type = 'RawShaderMaterial';

	}

}

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color$1( 0xffffff ); // diffuse
	this.roughness = 1.0;
	this.metalness = 0.0;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color$1( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalMapType = TangentSpaceNormalMap;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.flatShading = false;

	this.vertexTangents = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalMapType = source.normalMapType;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.flatShading = source.flatShading;

	this.vertexTangents = source.vertexTangents;

	return this;

};

/**
 * parameters = {
 *  clearcoat: <float>,
 *  clearcoatMap: new THREE.Texture( <Image> ),
 *  clearcoatRoughness: <float>,
 *  clearcoatRoughnessMap: new THREE.Texture( <Image> ),
 *  clearcoatNormalScale: <Vector2>,
 *  clearcoatNormalMap: new THREE.Texture( <Image> ),
 *
 *  reflectivity: <float>,
 *  ior: <float>,
 *
 *  sheen: <Color>,
 *
 *  transmission: <float>,
 *  transmissionMap: new THREE.Texture( <Image> )
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.type = 'MeshPhysicalMaterial';

	this.clearcoat = 0.0;
	this.clearcoatMap = null;
	this.clearcoatRoughness = 0.0;
	this.clearcoatRoughnessMap = null;
	this.clearcoatNormalScale = new Vector2( 1, 1 );
	this.clearcoatNormalMap = null;

	this.reflectivity = 0.5; // maps to F0 = 0.04

	Object.defineProperty( this, 'ior', {
		get: function () {

			return ( 1 + 0.4 * this.reflectivity ) / ( 1 - 0.4 * this.reflectivity );

		},
		set: function ( ior ) {

			this.reflectivity = MathUtils.clamp( 2.5 * ( ior - 1 ) / ( ior + 1 ), 0, 1 );

		}
	} );

	this.sheen = null; // null will disable sheen bsdf

	this.transmission = 0.0;
	this.transmissionMap = null;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = {

		'STANDARD': '',
		'PHYSICAL': ''

	};

	this.clearcoat = source.clearcoat;
	this.clearcoatMap = source.clearcoatMap;
	this.clearcoatRoughness = source.clearcoatRoughness;
	this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
	this.clearcoatNormalMap = source.clearcoatNormalMap;
	this.clearcoatNormalScale.copy( source.clearcoatNormalScale );

	this.reflectivity = source.reflectivity;

	if ( source.sheen ) {

		this.sheen = ( this.sheen || new Color$1() ).copy( source.sheen );

	} else {

		this.sheen = null;

	}

	this.transmission = source.transmission;
	this.transmissionMap = source.transmissionMap;

	return this;

};

/**
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.MultiplyOperation,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshPhongMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshPhongMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse
		this.specular = new Color$1( 0x111111 );
		this.shininess = 30;

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *
 *  map: new THREE.Texture( <Image> ),
 *  gradientMap: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshToonMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'TOON': '' };

		this.type = 'MeshToonMaterial';

		this.color = new Color$1( 0xffffff );

		this.map = null;
		this.gradientMap = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;
		this.gradientMap = source.gradientMap;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshToonMaterial.prototype.isMeshToonMaterial = true;

/**
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>,
 *
 *  flatShading: <bool>
 * }
 */

class MeshNormalMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshNormalMaterial';

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

class MeshLambertMaterial extends Material {

	constructor( parameters ) {

		super();

		this.type = 'MeshLambertMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse

		this.map = null;

		this.lightMap = null;
		this.lightMapIntensity = 1.0;

		this.aoMap = null;
		this.aoMapIntensity = 1.0;

		this.emissive = new Color$1( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;

		this.specularMap = null;

		this.alphaMap = null;

		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;

		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );

		this.map = source.map;

		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;

		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;

		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;

		this.specularMap = source.specularMap;

		this.alphaMap = source.alphaMap;

		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	}

}

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  matcap: new THREE.Texture( <Image> ),
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalMapType: THREE.TangentSpaceNormalMap,
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 *
 *  flatShading: <bool>
 * }
 */

class MeshMatcapMaterial extends Material {

	constructor( parameters ) {

		super();

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color$1( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.flatShading = false;

		this.setValues( parameters );

	}


	copy( source ) {

		super.copy( source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.flatShading = source.flatShading;

		return this;

	}

}

MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

/**
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

class LineDashedMaterial extends LineBasicMaterial {

	constructor( parameters ) {

		super();

		this.type = 'LineDashedMaterial';

		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;

		this.setValues( parameters );

	}

	copy( source ) {

		super.copy( source );

		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;

		return this;

	}

}

LineDashedMaterial.prototype.isLineDashedMaterial = true;

var Materials = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshDistanceMaterial: MeshDistanceMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	MeshMatcapMaterial: MeshMatcapMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

const AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function ( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			// in ios9 array.subarray(from, undefined) will return empty array
			// but array.subarray(from) or array.subarray(from, len) is correct
			return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function ( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
			! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function ( object ) {

		return ArrayBuffer.isView( object ) &&
			! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function ( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		const n = times.length;
		const result = new Array( n );
		for ( let i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function ( values, stride, order ) {

		const nValues = values.length;
		const result = new values.constructor( nValues );

		for ( let i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			const srcOffset = order[ i ] * stride;

			for ( let j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

		let i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		let value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {

			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {

			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	},

	subclip: function ( sourceClip, name, startFrame, endFrame, fps = 30 ) {

		const clip = sourceClip.clone();

		clip.name = name;

		const tracks = [];

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			const track = clip.tracks[ i ];
			const valueSize = track.getValueSize();

			const times = [];
			const values = [];

			for ( let j = 0; j < track.times.length; ++ j ) {

				const frame = track.times[ j ] * fps;

				if ( frame < startFrame || frame >= endFrame ) continue;

				times.push( track.times[ j ] );

				for ( let k = 0; k < valueSize; ++ k ) {

					values.push( track.values[ j * valueSize + k ] );

				}

			}

			if ( times.length === 0 ) continue;

			track.times = AnimationUtils.convertArray( times, track.times.constructor );
			track.values = AnimationUtils.convertArray( values, track.values.constructor );

			tracks.push( track );

		}

		clip.tracks = tracks;

		// find minimum .times value across all tracks in the trimmed clip

		let minStartTime = Infinity;

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

				minStartTime = clip.tracks[ i ].times[ 0 ];

			}

		}

		// shift all tracks such that clip begins at t=0

		for ( let i = 0; i < clip.tracks.length; ++ i ) {

			clip.tracks[ i ].shift( - 1 * minStartTime );

		}

		clip.resetDuration();

		return clip;

	},

	makeClipAdditive: function ( targetClip, referenceFrame = 0, referenceClip = targetClip, fps = 30 ) {

		if ( fps <= 0 ) fps = 30;

		const numTracks = referenceClip.tracks.length;
		const referenceTime = referenceFrame / fps;

		// Make each track's values relative to the values at the reference frame
		for ( let i = 0; i < numTracks; ++ i ) {

			const referenceTrack = referenceClip.tracks[ i ];
			const referenceTrackType = referenceTrack.ValueTypeName;

			// Skip this track if it's non-numeric
			if ( referenceTrackType === 'bool' || referenceTrackType === 'string' ) continue;

			// Find the track in the target clip whose name and type matches the reference track
			const targetTrack = targetClip.tracks.find( function ( track ) {

				return track.name === referenceTrack.name
					&& track.ValueTypeName === referenceTrackType;

			} );

			if ( targetTrack === undefined ) continue;

			let referenceOffset = 0;
			const referenceValueSize = referenceTrack.getValueSize();

			if ( referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				referenceOffset = referenceValueSize / 3;

			}

			let targetOffset = 0;
			const targetValueSize = targetTrack.getValueSize();

			if ( targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline ) {

				targetOffset = targetValueSize / 3;

			}

			const lastIndex = referenceTrack.times.length - 1;
			let referenceValue;

			// Find the value to subtract out of the track
			if ( referenceTime <= referenceTrack.times[ 0 ] ) {

				// Reference frame is earlier than the first keyframe, so just use the first keyframe
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else if ( referenceTime >= referenceTrack.times[ lastIndex ] ) {

				// Reference frame is after the last keyframe, so just use the last keyframe
				const startIndex = lastIndex * referenceValueSize + referenceOffset;
				const endIndex = startIndex + referenceValueSize - referenceOffset;
				referenceValue = AnimationUtils.arraySlice( referenceTrack.values, startIndex, endIndex );

			} else {

				// Interpolate to the reference value
				const interpolant = referenceTrack.createInterpolant();
				const startIndex = referenceOffset;
				const endIndex = referenceValueSize - referenceOffset;
				interpolant.evaluate( referenceTime );
				referenceValue = AnimationUtils.arraySlice( interpolant.resultBuffer, startIndex, endIndex );

			}

			// Conjugate the quaternion
			if ( referenceTrackType === 'quaternion' ) {

				const referenceQuat = new Quaternion().fromArray( referenceValue ).normalize().conjugate();
				referenceQuat.toArray( referenceValue );

			}

			// Subtract the reference value from all of the track values

			const numTimes = targetTrack.times.length;
			for ( let j = 0; j < numTimes; ++ j ) {

				const valueStart = j * targetValueSize + targetOffset;

				if ( referenceTrackType === 'quaternion' ) {

					// Multiply the conjugate for quaternion track types
					Quaternion.multiplyQuaternionsFlat(
						targetTrack.values,
						valueStart,
						referenceValue,
						0,
						targetTrack.values,
						valueStart
					);

				} else {

					const valueEnd = targetValueSize - targetOffset * 2;

					// Subtract each value for all other numeric track types
					for ( let k = 0; k < valueEnd; ++ k ) {

						targetTrack.values[ valueStart + k ] -= referenceValue[ k ];

					}

				}

			}

		}

		targetClip.blendMode = AdditiveAnimationBlendMode;

		return targetClip;

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 */

function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
		resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Object.assign( Interpolant.prototype, {

	evaluate: function ( t ) {

		const pp = this.parameterPositions;
		let i1 = this._cachedIndex,
			t1 = pp[ i1 ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				let right;

				linear_scan: {

					//- See http://jsperf.com/comparison-to-undefined/3
					//- slower code:
					//-
					//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( let giveUpAt = i1 + 2; ; ) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

					//- slower code:
					//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						const t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( let giveUpAt = i1 - 2; ; ) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					const mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[ i1 ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function () {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function ( index ) {

		// copies a sample value to the result buffer

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function ( /* i1, t0, t, t1 */ ) {

		throw new Error( 'call to abstract method' );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function ( /* i1, t0, t1 */ ) {

		// empty

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( Interpolant.prototype, {

	//( 0, t, t0 ), returns this.resultBuffer
	beforeStart_: Interpolant.prototype.copySampleValue_,

	//( N-1, tN-1, t ), returns this.resultBuffer
	afterEnd_: Interpolant.prototype.copySampleValue_,

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 */

function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = - 0;
	this._offsetPrev = - 0;
	this._weightNext = - 0;
	this._offsetNext = - 0;

}

CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: ZeroCurvatureEnding,
		endingEnd: ZeroCurvatureEnding

	},

	intervalChanged_: function ( i1, t0, t1 ) {

		const pp = this.parameterPositions;
		let iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		const halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		const sP = - wP * ppp + 2 * wP * pp - wP * p;
		const s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
		const s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
		const sN = wN * ppp - wN * pp;

		// combine data linearly

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( let i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 */

function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function ( i1 /*, t0, t, t1 */ ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

class KeyframeTrack {

	constructor( name, times, values, interpolation ) {

		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );

		this.name = name;

		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

		this.setInterpolation( interpolation || this.DefaultInterpolation );

	}

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	static toJSON( track ) {

		const trackType = track.constructor;

		let json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== this.toJSON ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			const interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	}

	InterpolantFactoryMethodDiscrete( result ) {

		return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodLinear( result ) {

		return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	InterpolantFactoryMethodSmooth( result ) {

		return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );

	}

	setInterpolation( interpolation ) {

		let factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			const message = 'unsupported interpolation for ' +
				this.ValueTypeName + ' keyframe track named ' + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( 'THREE.KeyframeTrack:', message );
			return this;

		}

		this.createInterpolant = factoryMethod;

		return this;

	}

	getInterpolation() {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	}

	getValueSize() {

		return this.values.length / this.times.length;

	}

	// move all keyframes either forwards or backwards in time
	shift( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	}

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale( timeScale ) {

		if ( timeScale !== 1.0 ) {

			const times = this.times;

			for ( let i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	}

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim( startTime, endTime ) {

		const times = this.times,
			nKeys = times.length;

		let from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) {

			++ from;

		}

		while ( to !== - 1 && times[ to ] > endTime ) {

			-- to;

		}

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) {

				to = Math.max( to, 1 );
				from = to - 1;

			}

			const stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	}

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate() {

		let valid = true;

		const valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
			valid = false;

		}

		const times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( 'THREE.KeyframeTrack: Track is empty.', this );
			valid = false;

		}

		let prevTime = null;

		for ( let i = 0; i !== nKeys; i ++ ) {

			const currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( let i = 0, n = values.length; i !== n; ++ i ) {

					const value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	}

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize() {

		// times or values may be shared with other tracks, so overwriting is unsafe
		const times = AnimationUtils.arraySlice( this.times ),
			values = AnimationUtils.arraySlice( this.values ),
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			lastIndex = times.length - 1;

		let writeIndex = 1;

		for ( let i = 1; i < lastIndex; ++ i ) {

			let keep = false;

			const time = times[ i ];
			const timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== times[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					const offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( let j = 0; j !== stride; ++ j ) {

						const value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
							value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else {

					keep = true;

				}

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					const readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( let j = 0; j !== stride; ++ j ) {

						values[ writeOffset + j ] = values[ readOffset + j ];

					}

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {

				values[ writeOffset + j ] = values[ readOffset + j ];

			}

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		} else {

			this.times = times;
			this.values = values;

		}

		return this;

	}

	clone() {

		const times = AnimationUtils.arraySlice( this.times, 0 );
		const values = AnimationUtils.arraySlice( this.values, 0 );

		const TypedKeyframeTrack = this.constructor;
		const track = new TypedKeyframeTrack( this.name, times, values );

		// Interpolant argument to constructor is not saved, so copy the factory method directly.
		track.createInterpolant = this.createInterpolant;

		return track;

	}

}

KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

/**
 * A Track of Boolean keyframe values.
 */
class BooleanKeyframeTrack extends KeyframeTrack {}

BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of keyframe values that represent color.
 */
class ColorKeyframeTrack extends KeyframeTrack {}

ColorKeyframeTrack.prototype.ValueTypeName = 'color';

/**
 * A Track of numeric keyframe values.
 */
class NumberKeyframeTrack extends KeyframeTrack {}

NumberKeyframeTrack.prototype.ValueTypeName = 'number';

/**
 * Spherical linear unit quaternion interpolant.
 */

function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function ( i1, t0, t, t1 ) {

		const result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			alpha = ( t - t0 ) / ( t1 - t0 );

		let offset = i1 * stride;

		for ( let end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 * A Track of quaternion keyframe values.
 */
class QuaternionKeyframeTrack extends KeyframeTrack {

	InterpolantFactoryMethodLinear( result ) {

		return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );

	}

}

QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
// ValueBufferType is inherited
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track that interpolates Strings
 */
class StringKeyframeTrack extends KeyframeTrack {}

StringKeyframeTrack.prototype.ValueTypeName = 'string';
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

/**
 * A Track of vectored keyframe values.
 */
class VectorKeyframeTrack extends KeyframeTrack {}

VectorKeyframeTrack.prototype.ValueTypeName = 'vector';

class AnimationClip {

	constructor( name, duration = - 1, tracks, blendMode = NormalAnimationBlendMode ) {

		this.name = name;
		this.tracks = tracks;
		this.duration = duration;
		this.blendMode = blendMode;

		this.uuid = MathUtils.generateUUID();

		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {

			this.resetDuration();

		}

	}


	static parse( json ) {

		const tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( let i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );

		}

		const clip = new this( json.name, json.duration, tracks, json.blendMode );
		clip.uuid = json.uuid;

		return clip;

	}

	static toJSON( clip ) {

		const tracks = [],
			clipTracks = clip.tracks;

		const json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks,
			'uuid': clip.uuid,
			'blendMode': clip.blendMode

		};

		for ( let i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	}

	static CreateFromMorphTargetSequence( name, morphTargetSequence, fps, noLoop ) {

		const numMorphTargets = morphTargetSequence.length;
		const tracks = [];

		for ( let i = 0; i < numMorphTargets; i ++ ) {

			let times = [];
			let values = [];

			times.push(
				( i + numMorphTargets - 1 ) % numMorphTargets,
				i,
				( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			const order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
				new NumberKeyframeTrack(
					'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
					times, values
				).scale( 1.0 / fps ) );

		}

		return new this( name, - 1, tracks );

	}

	static findByName( objectOrClipArray, name ) {

		let clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			const o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( let i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}

		}

		return null;

	}

	static CreateClipsFromMorphTargetSequences( morphTargets, fps, noLoop ) {

		const animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		const pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( let i = 0, il = morphTargets.length; i < il; i ++ ) {

			const morphTarget = morphTargets[ i ];
			const parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				const name = parts[ 1 ];

				let animationMorphTargets = animationToMorphTargets[ name ];

				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		const clips = [];

		for ( const name in animationToMorphTargets ) {

			clips.push( this.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	}

	// parse the animation.hierarchy format
	static parseAnimation( animation, bones ) {

		if ( ! animation ) {

			console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
			return null;

		}

		const addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				const times = [];
				const values = [];

				AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		const tracks = [];

		const clipName = animation.name || 'default';
		const fps = animation.fps || 30;
		const blendMode = animation.blendMode;

		// automatic length determination in AnimationClip.
		let duration = animation.length || - 1;

		const hierarchyTracks = animation.hierarchy || [];

		for ( let h = 0; h < hierarchyTracks.length; h ++ ) {

			const animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets
			if ( animationKeys[ 0 ].morphTargets ) {

				// figure out all morph targets used in this track
				const morphTargetNames = {};

				let k;

				for ( k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[ k ].morphTargets ) {

						for ( let m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;

						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( const morphTargetName in morphTargetNames ) {

					const times = [];
					const values = [];

					for ( let m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {

						const animationKey = animationKeys[ k ];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {

				// ...assume skeletal animation

				const boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.position',
					animationKeys, 'pos', tracks );

				addNonemptyTrack(
					QuaternionKeyframeTrack, boneName + '.quaternion',
					animationKeys, 'rot', tracks );

				addNonemptyTrack(
					VectorKeyframeTrack, boneName + '.scale',
					animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		const clip = new this( clipName, duration, tracks, blendMode );

		return clip;

	}

	resetDuration() {

		const tracks = this.tracks;
		let duration = 0;

		for ( let i = 0, n = tracks.length; i !== n; ++ i ) {

			const track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

		return this;

	}

	trim() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	}

	validate() {

		let valid = true;

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			valid = valid && this.tracks[ i ].validate();

		}

		return valid;

	}

	optimize() {

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

	clone() {

		const tracks = [];

		for ( let i = 0; i < this.tracks.length; i ++ ) {

			tracks.push( this.tracks[ i ].clone() );

		}

		return new this.constructor( this.name, this.duration, tracks, this.blendMode );

	}

	toJSON() {

		return this.constructor.toJSON( this );

	}

}

function getTrackTypeForValueTypeName( typeName ) {

	switch ( typeName.toLowerCase() ) {

		case 'scalar':
		case 'double':
		case 'float':
		case 'number':
		case 'integer':

			return NumberKeyframeTrack;

		case 'vector':
		case 'vector2':
		case 'vector3':
		case 'vector4':

			return VectorKeyframeTrack;

		case 'color':

			return ColorKeyframeTrack;

		case 'quaternion':

			return QuaternionKeyframeTrack;

		case 'bool':
		case 'boolean':

			return BooleanKeyframeTrack;

		case 'string':

			return StringKeyframeTrack;

	}

	throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );

}

function parseKeyframeTrack( json ) {

	if ( json.type === undefined ) {

		throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );

	}

	const trackType = getTrackTypeForValueTypeName( json.type );

	if ( json.times === undefined ) {

		const times = [], values = [];

		AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

		json.times = times;
		json.values = values;

	}

	// derived classes can define a static parse method
	if ( trackType.parse !== undefined ) {

		return trackType.parse( json );

	} else {

		// by default, we assume a constructor compatible with the base
		return new trackType( json.name, json.times, json.values, json.interpolation );

	}

}

const Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

function LoadingManager( onLoad, onProgress, onError ) {

	const scope = this;

	let isLoading = false;
	let itemsLoaded = 0;
	let itemsTotal = 0;
	let urlModifier = undefined;
	const handlers = [];

	// Refer to #5689 for the reason why we don't set .onStart
	// in the constructor

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

	this.resolveURL = function ( url ) {

		if ( urlModifier ) {

			return urlModifier( url );

		}

		return url;

	};

	this.setURLModifier = function ( transform ) {

		urlModifier = transform;

		return this;

	};

	this.addHandler = function ( regex, loader ) {

		handlers.push( regex, loader );

		return this;

	};

	this.removeHandler = function ( regex ) {

		const index = handlers.indexOf( regex );

		if ( index !== - 1 ) {

			handlers.splice( index, 2 );

		}

		return this;

	};

	this.getHandler = function ( file ) {

		for ( let i = 0, l = handlers.length; i < l; i += 2 ) {

			const regex = handlers[ i ];
			const loader = handlers[ i + 1 ];

			if ( regex.global ) regex.lastIndex = 0; // see #17920

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	};

}

const DefaultLoadingManager = new LoadingManager();

function Loader$1( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.crossOrigin = 'anonymous';
	this.withCredentials = false;
	this.path = '';
	this.resourcePath = '';
	this.requestHeader = {};

}

Object.assign( Loader$1.prototype, {

	load: function ( /* url, onLoad, onProgress, onError */ ) {},

	loadAsync: function ( url, onProgress ) {

		const scope = this;

		return new Promise( function ( resolve, reject ) {

			scope.load( url, resolve, onProgress, reject );

		} );

	},

	parse: function ( /* data */ ) {},

	setCrossOrigin: function ( crossOrigin ) {

		this.crossOrigin = crossOrigin;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( path ) {

		this.path = path;
		return this;

	},

	setResourcePath: function ( resourcePath ) {

		this.resourcePath = resourcePath;
		return this;

	},

	setRequestHeader: function ( requestHeader ) {

		this.requestHeader = requestHeader;
		return this;

	}

} );

const loading = {};

function FileLoader( manager ) {

	Loader$1.call( this, manager );

}

FileLoader.prototype = Object.assign( Object.create( Loader$1.prototype ), {

	constructor: FileLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check if request is duplicate

		if ( loading[ url ] !== undefined ) {

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			return;

		}

		// Check for data: URI
		const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		const dataUriRegexResult = url.match( dataUriRegex );
		let request;

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			const mimeType = dataUriRegexResult[ 1 ];
			const isBase64 = !! dataUriRegexResult[ 2 ];

			let data = dataUriRegexResult[ 3 ];
			data = decodeURIComponent( data );

			if ( isBase64 ) data = atob( data );

			try {

				let response;
				const responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

						const view = new Uint8Array( data.length );

						for ( let i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ view.buffer ], { type: mimeType } );

						} else {

							response = view.buffer;

						}

						break;

					case 'document':

						const parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick like standard XMLHttpRequest event dispatching does
				setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, 0 );

			}

		} else {

			// Initialise array for duplicate requests

			loading[ url ] = [];

			loading[ url ].push( {

				onLoad: onLoad,
				onProgress: onProgress,
				onError: onError

			} );

			request = new XMLHttpRequest();

			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				const response = this.response;

				const callbacks = loading[ url ];

				delete loading[ url ];

				if ( this.status === 200 || this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					// Add to cache only on HTTP success, so that we do not cache
					// error response bodies as proper responses to requests.
					Cache.add( url, response );

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onLoad ) callback.onLoad( response );

					}

					scope.manager.itemEnd( url );

				} else {

					for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

						const callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}

			}, false );

			request.addEventListener( 'progress', function ( event ) {

				const callbacks = loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onProgress ) callback.onProgress( event );

				}

			}, false );

			request.addEventListener( 'error', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			request.addEventListener( 'abort', function ( event ) {

				const callbacks = loading[ url ];

				delete loading[ url ];

				for ( let i = 0, il = callbacks.length; i < il; i ++ ) {

					const callback = callbacks[ i ];
					if ( callback.onError ) callback.onError( event );

				}

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			for ( const header in this.requestHeader ) {

				request.setRequestHeader( header, this.requestHeader[ header ] );

			}

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

class AnimationLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const animations = [];

		for ( let i = 0; i < json.length; i ++ ) {

			const clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	}

}

/**
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function CompressedTextureLoader( manager ) {

	Loader$1.call( this, manager );

}

CompressedTextureLoader.prototype = Object.assign( Object.create( Loader$1.prototype ), {

	constructor: CompressedTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const images = [];

		const texture = new CompressedTexture();

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 ) texture.minFilter = LinearFilter;

					texture.image = images;
					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			for ( let i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				const texDatas = scope.parse( buffer, true );

				if ( texDatas.isCubemap ) {

					const faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( let f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps: [] };

						for ( let i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

					texture.image = images;

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	}

} );

class ImageLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

		function onImageLoad() {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			Cache.add( url, this );

			if ( onLoad ) onLoad( this );

			scope.manager.itemEnd( url );

		}

		function onImageError( event ) {

			image.removeEventListener( 'load', onImageLoad, false );
			image.removeEventListener( 'error', onImageError, false );

			if ( onError ) onError( event );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		}

		image.addEventListener( 'load', onImageLoad, false );
		image.addEventListener( 'error', onImageError, false );

		if ( url.substr( 0, 5 ) !== 'data:' ) {

			if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

		}

		scope.manager.itemStart( url );

		image.src = url;

		return image;

	}

}

class CubeTextureLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( urls, onLoad, onProgress, onError ) {

		const texture = new CubeTexture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		let loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( let i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	}

}

/**
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 *
 * Sub classes have to implement the parse() method which will be used in load().
 */

function DataTextureLoader( manager ) {

	Loader$1.call( this, manager );

}

DataTextureLoader.prototype = Object.assign( Object.create( Loader$1.prototype ), {

	constructor: DataTextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const scope = this;

		const texture = new DataTexture();

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setRequestHeader( this.requestHeader );
		loader.setPath( this.path );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( buffer ) {

			const texData = scope.parse( buffer );

			if ( ! texData ) return;

			if ( texData.image !== undefined ) {

				texture.image = texData.image;

			} else if ( texData.data !== undefined ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
			texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;

			texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;

			if ( texData.encoding !== undefined ) {

				texture.encoding = texData.encoding;

			}

			if ( texData.flipY !== undefined ) {

				texture.flipY = texData.flipY;

			}

			if ( texData.format !== undefined ) {

				texture.format = texData.format;

			}

			if ( texData.type !== undefined ) {

				texture.type = texData.type;

			}

			if ( texData.mipmaps !== undefined ) {

				texture.mipmaps = texData.mipmaps;
				texture.minFilter = LinearMipmapLinearFilter; // presumably...

			}

			if ( texData.mipmapCount === 1 ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

function TextureLoader( manager ) {

	Loader$1.call( this, manager );

}

TextureLoader.prototype = Object.assign( Object.create( Loader$1.prototype ), {

	constructor: TextureLoader,

	load: function ( url, onLoad, onProgress, onError ) {

		const texture = new Texture();

		const loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		loader.load( url, function ( image ) {

			texture.image = image;

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			const isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	}

} );

/**
 * Extensible curve object.
 *
 * Some common of curve methods:
 * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
 * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following curves inherit from THREE.Curve:
 *
 * -- 2D curves --
 * THREE.ArcCurve
 * THREE.CubicBezierCurve
 * THREE.EllipseCurve
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.SplineCurve
 *
 * -- 3D curves --
 * THREE.CatmullRomCurve3
 * THREE.CubicBezierCurve3
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath.
 *
 **/

function Curve() {

	this.type = 'Curve';

	this.arcLengthDivisions = 200;

}

Object.assign( Curve.prototype, {

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( /* t, optionalTarget */ ) {

		console.warn( 'THREE.Curve: .getPoint() not implemented.' );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getPoint( t, optionalTarget );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions = 5 ) {

		const points = [];

		for ( let d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		const lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( divisions === undefined ) divisions = this.arcLengthDivisions;

		if ( this.cacheArcLengths &&
			( this.cacheArcLengths.length === divisions + 1 ) &&
			! this.needsUpdate ) {

			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		const cache = [];
		let current, last = this.getPoint( 0 );
		let sum = 0;

		cache.push( 0 );

		for ( let p = 1; p <= divisions; p ++ ) {

			current = this.getPoint( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum: sum }; Sum is in the last element.

	},

	updateArcLengths: function () {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		const arcLengths = this.getLengths();

		let i = 0;
		const il = arcLengths.length;

		let targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		// binary search for the index with largest value smaller than target u distance

		let low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		if ( arcLengths[ i ] === targetArcLength ) {

			return i / ( il - 1 );

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		const lengthBefore = arcLengths[ i ];
		const lengthAfter = arcLengths[ i + 1 ];

		const segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		const segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		const t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function ( t, optionalTarget ) {

		const delta = 0.0001;
		let t1 = t - delta;
		let t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		const pt1 = this.getPoint( t1 );
		const pt2 = this.getPoint( t2 );

		const tangent = optionalTarget || ( ( pt1.isVector2 ) ? new Vector2() : new Vector3$1() );

		tangent.copy( pt2 ).sub( pt1 ).normalize();

		return tangent;

	},

	getTangentAt: function ( u, optionalTarget ) {

		const t = this.getUtoTmapping( u );
		return this.getTangent( t, optionalTarget );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		const normal = new Vector3$1();

		const tangents = [];
		const normals = [];
		const binormals = [];

		const vec = new Vector3$1();
		const mat = new Matrix4();

		// compute the tangent vectors for each segment on the curve

		for ( let i = 0; i <= segments; i ++ ) {

			const u = i / segments;

			tangents[ i ] = this.getTangentAt( u, new Vector3$1() );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3$1();
		binormals[ 0 ] = new Vector3$1();
		let min = Number.MAX_VALUE;
		const tx = Math.abs( tangents[ 0 ].x );
		const ty = Math.abs( tangents[ 0 ].y );
		const tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( let i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				const theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			let theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( let i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.arcLengthDivisions = source.arcLengthDivisions;

		return this;

	},

	toJSON: function () {

		const data = {
			metadata: {
				version: 4.5,
				type: 'Curve',
				generator: 'Curve.toJSON'
			}
		};

		data.arcLengthDivisions = this.arcLengthDivisions;
		data.type = this.type;

		return data;

	},

	fromJSON: function ( json ) {

		this.arcLengthDivisions = json.arcLengthDivisions;

		return this;

	}

} );

class EllipseCurve extends Curve {

	constructor( aX = 0, aY = 0, xRadius = 1, yRadius = 1, aStartAngle = 0, aEndAngle = Math.PI * 2, aClockwise = false, aRotation = 0 ) {

		super();

		this.type = 'EllipseCurve';

		this.aX = aX;
		this.aY = aY;

		this.xRadius = xRadius;
		this.yRadius = yRadius;

		this.aStartAngle = aStartAngle;
		this.aEndAngle = aEndAngle;

		this.aClockwise = aClockwise;

		this.aRotation = aRotation;

	}

	getPoint( t, optionalTarget ) {

		const point = optionalTarget || new Vector2();

		const twoPi = Math.PI * 2;
		let deltaAngle = this.aEndAngle - this.aStartAngle;
		const samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		const angle = this.aStartAngle + t * deltaAngle;
		let x = this.aX + this.xRadius * Math.cos( angle );
		let y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			const cos = Math.cos( this.aRotation );
			const sin = Math.sin( this.aRotation );

			const tx = x - this.aX;
			const ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	}

	copy( source ) {

		super.copy( source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	}

}

EllipseCurve.prototype.isEllipseCurve = true;

class ArcCurve extends EllipseCurve {

	constructor( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		super( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

}

ArcCurve.prototype.isArcCurve = true;

/**
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */


/*
Based on an optimized c++ solution in
 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
 - http://ideone.com/NoEbVM

This CubicPoly class could be used for reusing some variables and calculations,
but for three.js curve use, it could be possible inlined and flatten into a single function call
which can be placed in CurveUtils.
*/

function CubicPoly() {

	let c0 = 0, c1 = 0, c2 = 0, c3 = 0;

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	function init( x0, x1, t0, t1 ) {

		c0 = x0;
		c1 = t0;
		c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		c3 = 2 * x0 - 2 * x1 + t0 + t1;

	}

	return {

		initCatmullRom: function ( x0, x1, x2, x3, tension ) {

			init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

		},

		initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

			// compute tangents when parameterized in [t1,t2]
			let t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
			let t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

			// rescale tangents for parametrization in [0,1]
			t1 *= dt1;
			t2 *= dt1;

			init( x1, x2, t1, t2 );

		},

		calc: function ( t ) {

			const t2 = t * t;
			const t3 = t2 * t;
			return c0 + c1 * t + c2 * t2 + c3 * t3;

		}

	};

}

//

const tmp = new Vector3$1();
const px$1 = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

class CatmullRomCurve3 extends Curve {

	constructor( points = [], closed = false, curveType = 'centripetal', tension = 0.5 ) {

		super();

		this.type = 'CatmullRomCurve3';

		this.points = points;
		this.closed = closed;
		this.curveType = curveType;
		this.tension = tension;

	}

	getPoint( t, optionalTarget = new Vector3$1() ) {

		const point = optionalTarget;

		const points = this.points;
		const l = points.length;

		const p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		let intPoint = Math.floor( p );
		let weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		let p0, p3; // 4 points (p1 & p2 defined below)

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		const p1 = points[ intPoint % l ];
		const p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			const pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			let dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			let dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			let dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px$1.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px$1.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px$1.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector3$1().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	}

}

CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

/**
 * Bezier Curves formulas obtained from
 * http://en.wikipedia.org/wiki/Bézier_curve
 */

function CatmullRom( t, p0, p1, p2, p3 ) {

	const v0 = ( p2 - p0 ) * 0.5;
	const v1 = ( p3 - p1 ) * 0.5;
	const t2 = t * t;
	const t3 = t * t2;
	return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

}

//

function QuadraticBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * p;

}

function QuadraticBezierP1( t, p ) {

	return 2 * ( 1 - t ) * t * p;

}

function QuadraticBezierP2( t, p ) {

	return t * t * p;

}

function QuadraticBezier( t, p0, p1, p2 ) {

	return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
		QuadraticBezierP2( t, p2 );

}

//

function CubicBezierP0( t, p ) {

	const k = 1 - t;
	return k * k * k * p;

}

function CubicBezierP1( t, p ) {

	const k = 1 - t;
	return 3 * k * k * t * p;

}

function CubicBezierP2( t, p ) {

	return 3 * ( 1 - t ) * t * t * p;

}

function CubicBezierP3( t, p ) {

	return t * t * t * p;

}

function CubicBezier( t, p0, p1, p2, p3 ) {

	return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
		CubicBezierP3( t, p3 );

}

class CubicBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2(), v3 = new Vector2() ) {

		super();

		this.type = 'CubicBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve.prototype.isCubicBezierCurve = true;

class CubicBezierCurve3 extends Curve {

	constructor( v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1(), v3 = new Vector3$1() ) {

		super();

		this.type = 'CubicBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	}

	getPoint( t, optionalTarget = new Vector3$1() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	}

}

CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

class LineCurve extends Curve {

	constructor( v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'LineCurve';

		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}

	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}

	getTangent( t, optionalTarget ) {

		const tangent = optionalTarget || new Vector2();

		tangent.copy( this.v2 ).sub( this.v1 ).normalize();

		return tangent;

	}

	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

LineCurve.prototype.isLineCurve = true;

class LineCurve3 extends Curve {

	constructor( v1 = new Vector3$1(), v2 = new Vector3$1() ) {

		super();

		this.type = 'LineCurve3';
		this.isLineCurve3 = true;

		this.v1 = v1;
		this.v2 = v2;

	}
	getPoint( t, optionalTarget = new Vector3$1() ) {

		const point = optionalTarget;

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	}
	// Line curve is linear, so we can overwrite default getPointAt
	getPointAt( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	}
	copy( source ) {

		super.copy( source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}
	toJSON() {

		const data = super.toJSON();

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}
	fromJSON( json ) {

		super.fromJSON( json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

class QuadraticBezierCurve extends Curve {

	constructor( v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2() ) {

		super();

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

class QuadraticBezierCurve3 extends Curve {

	constructor( v0 = new Vector3$1(), v1 = new Vector3$1(), v2 = new Vector3$1() ) {

		super();

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	}

	getPoint( t, optionalTarget = new Vector3$1() ) {

		const point = optionalTarget;

		const v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	}

}

QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

class SplineCurve extends Curve {

	constructor( points = [] ) {

		super();

		this.type = 'SplineCurve';

		this.points = points;

	}

	getPoint( t, optionalTarget = new Vector2() ) {

		const point = optionalTarget;

		const points = this.points;
		const p = ( points.length - 1 ) * t;

		const intPoint = Math.floor( p );
		const weight = p - intPoint;

		const p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		const p1 = points[ intPoint ];
		const p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		const p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	}

	copy( source ) {

		super.copy( source );

		this.points = [];

		for ( let i = 0, l = source.points.length; i < l; i ++ ) {

			const point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.points = [];

		for ( let i = 0, l = this.points.length; i < l; i ++ ) {

			const point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.points = [];

		for ( let i = 0, l = json.points.length; i < l; i ++ ) {

			const point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	}

}

SplineCurve.prototype.isSplineCurve = true;

var Curves = /*#__PURE__*/Object.freeze({
	__proto__: null,
	ArcCurve: ArcCurve,
	CatmullRomCurve3: CatmullRomCurve3,
	CubicBezierCurve: CubicBezierCurve,
	CubicBezierCurve3: CubicBezierCurve3,
	EllipseCurve: EllipseCurve,
	LineCurve: LineCurve,
	LineCurve3: LineCurve3,
	QuadraticBezierCurve: QuadraticBezierCurve,
	QuadraticBezierCurve3: QuadraticBezierCurve3,
	SplineCurve: SplineCurve
});

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

class CurvePath extends Curve {

	constructor() {

		super();

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	add( curve ) {

		this.curves.push( curve );

	}

	closePath() {

		// Add a line curve if start and end of lines are not connected
		const startPoint = this.curves[ 0 ].getPoint( 0 );
		const endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	}

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint( t ) {

		const d = t * this.getLength();
		const curveLengths = this.getCurveLengths();
		let i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				const diff = curveLengths[ i ] - d;
				const curve = this.curves[ i ];

				const segmentLength = curve.getLength();
				const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	}

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength() {

		const lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	}

	// cacheLengths must be recalculated.
	updateArcLengths() {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getCurveLengths();

	}

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths() {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		const lengths = [];
		let sums = 0;

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	}

	getSpacedPoints( divisions = 40 ) {

		const points = [];

		for ( let i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	getPoints( divisions = 12 ) {

		const points = [];
		let last;

		for ( let i = 0, curves = this.curves; i < curves.length; i ++ ) {

			const curve = curves[ i ];
			const resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
				: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
					: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
						: divisions;

			const pts = curve.getPoints( resolution );

			for ( let j = 0; j < pts.length; j ++ ) {

				const point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	}

	copy( source ) {

		super.copy( source );

		this.curves = [];

		for ( let i = 0, l = source.curves.length; i < l; i ++ ) {

			const curve = source.curves[ i ];

			this.curves.push( curve.clone() );

		}

		this.autoClose = source.autoClose;

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.autoClose = this.autoClose;
		data.curves = [];

		for ( let i = 0, l = this.curves.length; i < l; i ++ ) {

			const curve = this.curves[ i ];
			data.curves.push( curve.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.autoClose = json.autoClose;
		this.curves = [];

		for ( let i = 0, l = json.curves.length; i < l; i ++ ) {

			const curve = json.curves[ i ];
			this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

		}

		return this;

	}

}

class Path extends CurvePath {

	constructor( points ) {

		super();
		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	setFromPoints( points ) {

		this.moveTo( points[ 0 ].x, points[ 0 ].y );

		for ( let i = 1, l = points.length; i < l; i ++ ) {

			this.lineTo( points[ i ].x, points[ i ].y );

		}

		return this;

	}

	moveTo( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

		return this;

	}

	lineTo( x, y ) {

		const curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		const curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		const curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

		return this;

	}

	splineThru( pts /*Array of Vector*/ ) {

		const npts = [ this.currentPoint.clone() ].concat( pts );

		const curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

		return this;

	}

	arc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	absarc( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		return this;

	}

	ellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const x0 = this.currentPoint.x;
		const y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		return this;

	}

	absellipse( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		const curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			const firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		const lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

		return this;

	}

	copy( source ) {

		super.copy( source );

		this.currentPoint.copy( source.currentPoint );

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.currentPoint = this.currentPoint.toArray();

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.currentPoint.fromArray( json.currentPoint );

		return this;

	}

}

class Shape extends Path {

	constructor( points ) {

		super( points );

		this.uuid = MathUtils.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	getPointsHoles( divisions ) {

		const holesPts = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	}

	// get points of shape and holes (keypoints based on segments parameter)

	extractPoints( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	}

	copy( source ) {

		super.copy( source );

		this.holes = [];

		for ( let i = 0, l = source.holes.length; i < l; i ++ ) {

			const hole = source.holes[ i ];

			this.holes.push( hole.clone() );

		}

		return this;

	}

	toJSON() {

		const data = super.toJSON();

		data.uuid = this.uuid;
		data.holes = [];

		for ( let i = 0, l = this.holes.length; i < l; i ++ ) {

			const hole = this.holes[ i ];
			data.holes.push( hole.toJSON() );

		}

		return data;

	}

	fromJSON( json ) {

		super.fromJSON( json );

		this.uuid = json.uuid;
		this.holes = [];

		for ( let i = 0, l = json.holes.length; i < l; i ++ ) {

			const hole = json.holes[ i ];
			this.holes.push( new Path().fromJSON( hole ) );

		}

		return this;

	}

}

class Light$1 extends Object3D {

	constructor( color, intensity = 1 ) {

		super();

		this.type = 'Light';

		this.color = new Color$1( color );
		this.intensity = intensity;

	}

	copy( source ) {

		super.copy( source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

}

Light$1.prototype.isLight = true;

class HemisphereLight$1 extends Light$1 {

	constructor( skyColor, groundColor, intensity ) {

		super( skyColor, intensity );

		this.type = 'HemisphereLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.groundColor = new Color$1( groundColor );

	}

	copy( source ) {

		Light$1.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

}

HemisphereLight$1.prototype.isHemisphereLight = true;

const _projScreenMatrix = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld = /*@__PURE__*/ new Vector3$1();
const _lookTarget = /*@__PURE__*/ new Vector3$1();

class LightShadow {

	constructor( camera ) {

		this.camera = camera;

		this.bias = 0;
		this.normalBias = 0;
		this.radius = 1;

		this.mapSize = new Vector2( 512, 512 );

		this.map = null;
		this.mapPass = null;
		this.matrix = new Matrix4();

		this.autoUpdate = true;
		this.needsUpdate = false;

		this._frustum = new Frustum$1();
		this._frameExtents = new Vector2( 1, 1 );

		this._viewportCount = 1;

		this._viewports = [

			new Vector4( 0, 0, 1, 1 )

		];

	}

	getViewportCount() {

		return this._viewportCount;

	}

	getFrustum() {

		return this._frustum;

	}

	updateMatrices( light ) {

		const shadowCamera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
		shadowCamera.position.copy( _lightPositionWorld );

		_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
		shadowCamera.lookAt( _lookTarget );
		shadowCamera.updateMatrixWorld();

		_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix );

		shadowMatrix.set(
			0.5, 0.0, 0.0, 0.5,
			0.0, 0.5, 0.0, 0.5,
			0.0, 0.0, 0.5, 0.5,
			0.0, 0.0, 0.0, 1.0
		);

		shadowMatrix.multiply( shadowCamera.projectionMatrix );
		shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

	}

	getViewport( viewportIndex ) {

		return this._viewports[ viewportIndex ];

	}

	getFrameExtents() {

		return this._frameExtents;

	}

	copy( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	toJSON() {

		const object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.normalBias !== 0 ) object.normalBias = this.normalBias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

}

class SpotLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 50, 1, 0.5, 500 ) );

		this.focus = 1;

	}

	updateMatrices( light ) {

		const camera = this.camera;

		const fov = MathUtils.RAD2DEG * 2 * light.angle * this.focus;
		const aspect = this.mapSize.width / this.mapSize.height;
		const far = light.distance || camera.far;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

		super.updateMatrices( light );

	}

}

SpotLightShadow.prototype.isSpotLightShadow = true;

class SpotLight$1 extends Light$1 {

	constructor( color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'SpotLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.distance = distance;
		this.angle = angle;
		this.penumbra = penumbra;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new SpotLightShadow();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / Math.PI;

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

}

SpotLight$1.prototype.isSpotLight = true;

const _projScreenMatrix$1 = /*@__PURE__*/ new Matrix4();
const _lightPositionWorld$1 = /*@__PURE__*/ new Vector3$1();
const _lookTarget$1 = /*@__PURE__*/ new Vector3$1();

class PointLightShadow extends LightShadow {

	constructor() {

		super( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

		this._frameExtents = new Vector2( 4, 2 );

		this._viewportCount = 6;

		this._viewports = [
			// These viewports map a cube-map onto a 2D texture with the
			// following orientation:
			//
			//  xzXZ
			//   y Y
			//
			// X - Positive x direction
			// x - Negative x direction
			// Y - Positive y direction
			// y - Negative y direction
			// Z - Positive z direction
			// z - Negative z direction

			// positive X
			new Vector4( 2, 1, 1, 1 ),
			// negative X
			new Vector4( 0, 1, 1, 1 ),
			// positive Z
			new Vector4( 3, 1, 1, 1 ),
			// negative Z
			new Vector4( 1, 1, 1, 1 ),
			// positive Y
			new Vector4( 3, 0, 1, 1 ),
			// negative Y
			new Vector4( 1, 0, 1, 1 )
		];

		this._cubeDirections = [
			new Vector3$1( 1, 0, 0 ), new Vector3$1( - 1, 0, 0 ), new Vector3$1( 0, 0, 1 ),
			new Vector3$1( 0, 0, - 1 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, - 1, 0 )
		];

		this._cubeUps = [
			new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 1, 0 ),
			new Vector3$1( 0, 1, 0 ), new Vector3$1( 0, 0, 1 ),	new Vector3$1( 0, 0, - 1 )
		];

	}

	updateMatrices( light, viewportIndex = 0 ) {

		const camera = this.camera;
		const shadowMatrix = this.matrix;

		_lightPositionWorld$1.setFromMatrixPosition( light.matrixWorld );
		camera.position.copy( _lightPositionWorld$1 );

		_lookTarget$1.copy( camera.position );
		_lookTarget$1.add( this._cubeDirections[ viewportIndex ] );
		camera.up.copy( this._cubeUps[ viewportIndex ] );
		camera.lookAt( _lookTarget$1 );
		camera.updateMatrixWorld();

		shadowMatrix.makeTranslation( - _lightPositionWorld$1.x, - _lightPositionWorld$1.y, - _lightPositionWorld$1.z );

		_projScreenMatrix$1.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		this._frustum.setFromProjectionMatrix( _projScreenMatrix$1 );

	}

}

PointLightShadow.prototype.isPointLightShadow = true;

class PointLight$1 extends Light$1 {

	constructor( color, intensity, distance = 0, decay = 1 ) {

		super( color, intensity );

		this.type = 'PointLight';

		this.distance = distance;
		this.decay = decay; // for physically correct lights, should be 2.

		this.shadow = new PointLightShadow();

	}

	get power() {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		return this.intensity * 4 * Math.PI;

	}

	set power( power ) {

		// intensity = power per solid angle.
		// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
		this.intensity = power / ( 4 * Math.PI );

	}

	copy( source ) {

		super.copy( source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

}

PointLight$1.prototype.isPointLight = true;

class OrthographicCamera extends Camera$1 {

	constructor( left = - 1, right = 1, top = 1, bottom = - 1, near = 0.1, far = 2000 ) {

		super();

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = left;
		this.right = right;
		this.top = top;
		this.bottom = bottom;

		this.near = near;
		this.far = far;

		this.updateProjectionMatrix();

	}

	copy( source, recursive ) {

		super.copy( source, recursive );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	}

	setViewOffset( fullWidth, fullHeight, x, y, width, height ) {

		if ( this.view === null ) {

			this.view = {
				enabled: true,
				fullWidth: 1,
				fullHeight: 1,
				offsetX: 0,
				offsetY: 0,
				width: 1,
				height: 1
			};

		}

		this.view.enabled = true;
		this.view.fullWidth = fullWidth;
		this.view.fullHeight = fullHeight;
		this.view.offsetX = x;
		this.view.offsetY = y;
		this.view.width = width;
		this.view.height = height;

		this.updateProjectionMatrix();

	}

	clearViewOffset() {

		if ( this.view !== null ) {

			this.view.enabled = false;

		}

		this.updateProjectionMatrix();

	}

	updateProjectionMatrix() {

		const dx = ( this.right - this.left ) / ( 2 * this.zoom );
		const dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		const cx = ( this.right + this.left ) / 2;
		const cy = ( this.top + this.bottom ) / 2;

		let left = cx - dx;
		let right = cx + dx;
		let top = cy + dy;
		let bottom = cy - dy;

		if ( this.view !== null && this.view.enabled ) {

			const scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
			const scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

			left += scaleW * this.view.offsetX;
			right = left + scaleW * this.view.width;
			top -= scaleH * this.view.offsetY;
			bottom = top - scaleH * this.view.height;

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

		this.projectionMatrixInverse.copy( this.projectionMatrix ).invert();

	}

	toJSON( meta ) {

		const data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

}

OrthographicCamera.prototype.isOrthographicCamera = true;

class DirectionalLightShadow extends LightShadow {

	constructor() {

		super( new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

	}

}

DirectionalLightShadow.prototype.isDirectionalLightShadow = true;

class DirectionalLight extends Light$1 {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'DirectionalLight';

		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();

		this.target = new Object3D();

		this.shadow = new DirectionalLightShadow();

	}

	copy( source ) {

		super.copy( source );

		this.target = source.target.clone();
		this.shadow = source.shadow.clone();

		return this;

	}

}

DirectionalLight.prototype.isDirectionalLight = true;

class AmbientLight$1 extends Light$1 {

	constructor( color, intensity ) {

		super( color, intensity );

		this.type = 'AmbientLight';

	}

}

AmbientLight$1.prototype.isAmbientLight = true;

class RectAreaLight extends Light$1 {

	constructor( color, intensity, width = 10, height = 10 ) {

		super( color, intensity );

		this.type = 'RectAreaLight';

		this.width = width;
		this.height = height;

	}

	copy( source ) {

		super.copy( source );

		this.width = source.width;
		this.height = source.height;

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.width = this.width;
		data.object.height = this.height;

		return data;

	}

}

RectAreaLight.prototype.isRectAreaLight = true;

/**
 * Primary reference:
 *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
 *
 * Secondary reference:
 *   https://www.ppsloan.org/publications/StupidSH36.pdf
 */

// 3-band SH defined by 9 coefficients

class SphericalHarmonics3 {

	constructor() {

		this.coefficients = [];

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients.push( new Vector3$1() );

		}

	}

	set( coefficients ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].copy( coefficients[ i ] );

		}

		return this;

	}

	zero() {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].set( 0, 0, 0 );

		}

		return this;

	}

	// get the radiance in the direction of the normal
	// target is a Vector3
	getAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.282095 );

		// band 1
		target.addScaledVector( coeff[ 1 ], 0.488603 * y );
		target.addScaledVector( coeff[ 2 ], 0.488603 * z );
		target.addScaledVector( coeff[ 3 ], 0.488603 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 1.092548 * ( x * y ) );
		target.addScaledVector( coeff[ 5 ], 1.092548 * ( y * z ) );
		target.addScaledVector( coeff[ 6 ], 0.315392 * ( 3.0 * z * z - 1.0 ) );
		target.addScaledVector( coeff[ 7 ], 1.092548 * ( x * z ) );
		target.addScaledVector( coeff[ 8 ], 0.546274 * ( x * x - y * y ) );

		return target;

	}

	// get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
	// target is a Vector3
	// https://graphics.stanford.edu/papers/envmap/envmap.pdf
	getIrradianceAt( normal, target ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		const coeff = this.coefficients;

		// band 0
		target.copy( coeff[ 0 ] ).multiplyScalar( 0.886227 ); // π * 0.282095

		// band 1
		target.addScaledVector( coeff[ 1 ], 2.0 * 0.511664 * y ); // ( 2 * π / 3 ) * 0.488603
		target.addScaledVector( coeff[ 2 ], 2.0 * 0.511664 * z );
		target.addScaledVector( coeff[ 3 ], 2.0 * 0.511664 * x );

		// band 2
		target.addScaledVector( coeff[ 4 ], 2.0 * 0.429043 * x * y ); // ( π / 4 ) * 1.092548
		target.addScaledVector( coeff[ 5 ], 2.0 * 0.429043 * y * z );
		target.addScaledVector( coeff[ 6 ], 0.743125 * z * z - 0.247708 ); // ( π / 4 ) * 0.315392 * 3
		target.addScaledVector( coeff[ 7 ], 2.0 * 0.429043 * x * z );
		target.addScaledVector( coeff[ 8 ], 0.429043 * ( x * x - y * y ) ); // ( π / 4 ) * 0.546274

		return target;

	}

	add( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].add( sh.coefficients[ i ] );

		}

		return this;

	}

	addScaledSH( sh, s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].addScaledVector( sh.coefficients[ i ], s );

		}

		return this;

	}

	scale( s ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].multiplyScalar( s );

		}

		return this;

	}

	lerp( sh, alpha ) {

		for ( let i = 0; i < 9; i ++ ) {

			this.coefficients[ i ].lerp( sh.coefficients[ i ], alpha );

		}

		return this;

	}

	equals( sh ) {

		for ( let i = 0; i < 9; i ++ ) {

			if ( ! this.coefficients[ i ].equals( sh.coefficients[ i ] ) ) {

				return false;

			}

		}

		return true;

	}

	copy( sh ) {

		return this.set( sh.coefficients );

	}

	clone() {

		return new this.constructor().copy( this );

	}

	fromArray( array, offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].fromArray( array, offset + ( i * 3 ) );

		}

		return this;

	}

	toArray( array = [], offset = 0 ) {

		const coefficients = this.coefficients;

		for ( let i = 0; i < 9; i ++ ) {

			coefficients[ i ].toArray( array, offset + ( i * 3 ) );

		}

		return array;

	}

	// evaluate the basis functions
	// shBasis is an Array[ 9 ]
	static getBasisAt( normal, shBasis ) {

		// normal is assumed to be unit length

		const x = normal.x, y = normal.y, z = normal.z;

		// band 0
		shBasis[ 0 ] = 0.282095;

		// band 1
		shBasis[ 1 ] = 0.488603 * y;
		shBasis[ 2 ] = 0.488603 * z;
		shBasis[ 3 ] = 0.488603 * x;

		// band 2
		shBasis[ 4 ] = 1.092548 * x * y;
		shBasis[ 5 ] = 1.092548 * y * z;
		shBasis[ 6 ] = 0.315392 * ( 3 * z * z - 1 );
		shBasis[ 7 ] = 1.092548 * x * z;
		shBasis[ 8 ] = 0.546274 * ( x * x - y * y );

	}

}

SphericalHarmonics3.prototype.isSphericalHarmonics3 = true;

class LightProbe extends Light$1 {

	constructor( sh = new SphericalHarmonics3(), intensity = 1 ) {

		super( undefined, intensity );

		this.sh = sh;

	}

	copy( source ) {

		super.copy( source );

		this.sh.copy( source.sh );

		return this;

	}

	fromJSON( json ) {

		this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
		this.sh.fromArray( json.sh );

		return this;

	}

	toJSON( meta ) {

		const data = super.toJSON( meta );

		data.object.sh = this.sh.toArray();

		return data;

	}

}

LightProbe.prototype.isLightProbe = true;

class MaterialLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );
		this.textures = {};

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		const material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined && material.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.sheen !== undefined ) material.sheen = new Color$1().setHex( json.sheen );
		if ( json.emissive !== undefined && material.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined && material.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearcoat !== undefined ) material.clearcoat = json.clearcoat;
		if ( json.clearcoatRoughness !== undefined ) material.clearcoatRoughness = json.clearcoatRoughness;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.combine !== undefined ) material.combine = json.combine;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;

		if ( json.stencilWrite !== undefined ) material.stencilWrite = json.stencilWrite;
		if ( json.stencilWriteMask !== undefined ) material.stencilWriteMask = json.stencilWriteMask;
		if ( json.stencilFunc !== undefined ) material.stencilFunc = json.stencilFunc;
		if ( json.stencilRef !== undefined ) material.stencilRef = json.stencilRef;
		if ( json.stencilFuncMask !== undefined ) material.stencilFuncMask = json.stencilFuncMask;
		if ( json.stencilFail !== undefined ) material.stencilFail = json.stencilFail;
		if ( json.stencilZFail !== undefined ) material.stencilZFail = json.stencilZFail;
		if ( json.stencilZPass !== undefined ) material.stencilZPass = json.stencilZPass;

		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;

		if ( json.rotation !== undefined ) material.rotation = json.rotation;

		if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
		if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
		if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
		if ( json.scale !== undefined ) material.scale = json.scale;

		if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
		if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
		if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;

		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
		if ( json.morphNormals !== undefined ) material.morphNormals = json.morphNormals;
		if ( json.dithering !== undefined ) material.dithering = json.dithering;

		if ( json.vertexTangents !== undefined ) material.vertexTangents = json.vertexTangents;

		if ( json.visible !== undefined ) material.visible = json.visible;

		if ( json.toneMapped !== undefined ) material.toneMapped = json.toneMapped;

		if ( json.userData !== undefined ) material.userData = json.userData;

		if ( json.vertexColors !== undefined ) {

			if ( typeof json.vertexColors === 'number' ) {

				material.vertexColors = ( json.vertexColors > 0 ) ? true : false;

			} else {

				material.vertexColors = json.vertexColors;

			}

		}

		// Shader Material

		if ( json.uniforms !== undefined ) {

			for ( const name in json.uniforms ) {

				const uniform = json.uniforms[ name ];

				material.uniforms[ name ] = {};

				switch ( uniform.type ) {

					case 't':
						material.uniforms[ name ].value = getTexture( uniform.value );
						break;

					case 'c':
						material.uniforms[ name ].value = new Color$1().setHex( uniform.value );
						break;

					case 'v2':
						material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
						break;

					case 'v3':
						material.uniforms[ name ].value = new Vector3$1().fromArray( uniform.value );
						break;

					case 'v4':
						material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
						break;

					case 'm3':
						material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
						break;

					case 'm4':
						material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
						break;

					default:
						material.uniforms[ name ].value = uniform.value;

				}

			}

		}

		if ( json.defines !== undefined ) material.defines = json.defines;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;

		if ( json.extensions !== undefined ) {

			for ( const key in json.extensions ) {

				material.extensions[ key ] = json.extensions[ key ];

			}

		}

		// Deprecated

		if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );
		if ( json.matcap !== undefined ) material.matcap = getTexture( json.matcap );

		if ( json.alphaMap !== undefined ) material.alphaMap = getTexture( json.alphaMap );

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
		if ( json.normalScale !== undefined ) {

			let normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
		if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
		if ( json.refractionRatio !== undefined ) material.refractionRatio = json.refractionRatio;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		if ( json.clearcoatMap !== undefined ) material.clearcoatMap = getTexture( json.clearcoatMap );
		if ( json.clearcoatRoughnessMap !== undefined ) material.clearcoatRoughnessMap = getTexture( json.clearcoatRoughnessMap );
		if ( json.clearcoatNormalMap !== undefined ) material.clearcoatNormalMap = getTexture( json.clearcoatNormalMap );
		if ( json.clearcoatNormalScale !== undefined ) material.clearcoatNormalScale = new Vector2().fromArray( json.clearcoatNormalScale );

		if ( json.transmission !== undefined ) material.transmission = json.transmission;
		if ( json.transmissionMap !== undefined ) material.transmissionMap = getTexture( json.transmissionMap );

		return material;

	}

	setTextures( value ) {

		this.textures = value;
		return this;

	}

}

const LoaderUtils = {

	decodeText: function ( array ) {

		if ( typeof TextDecoder !== 'undefined' ) {

			return new TextDecoder().decode( array );

		}

		// Avoid the String.fromCharCode.apply(null, array) shortcut, which
		// throws a "maximum call stack size exceeded" error for large arrays.

		let s = '';

		for ( let i = 0, il = array.length; i < il; i ++ ) {

			// Implicitly assumes little-endian.
			s += String.fromCharCode( array[ i ] );

		}

		try {

			// merges multi-byte utf-8 characters.

			return decodeURIComponent( escape( s ) );

		} catch ( e ) { // see #16358

			return s;

		}

	},

	extractUrlBase: function ( url ) {

		const index = url.lastIndexOf( '/' );

		if ( index === - 1 ) return './';

		return url.substr( 0, index + 1 );

	}

};

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.instanceCount = Infinity;

}

InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

	constructor: InstancedBufferGeometry,

	isInstancedBufferGeometry: true,

	copy: function ( source ) {

		BufferGeometry.prototype.copy.call( this, source );

		this.instanceCount = source.instanceCount;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		const data = BufferGeometry.prototype.toJSON.call( this );

		data.instanceCount = this.instanceCount;

		data.isInstancedBufferGeometry = true;

		return data;

	}

} );

function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

	if ( typeof ( normalized ) === 'number' ) {

		meshPerAttribute = normalized;

		normalized = false;

		console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

	}

	BufferAttribute.call( this, array, itemSize, normalized );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

	constructor: InstancedBufferAttribute,

	isInstancedBufferAttribute: true,

	copy: function ( source ) {

		BufferAttribute.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	toJSON: function ()	{

		const data = BufferAttribute.prototype.toJSON.call( this );

		data.meshPerAttribute = this.meshPerAttribute;

		data.isInstancedBufferAttribute = true;

		return data;

	}

} );

class BufferGeometryLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( scope.manager );
		loader.setPath( scope.path );
		loader.setRequestHeader( scope.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			try {

				onLoad( scope.parse( JSON.parse( text ) ) );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

	parse( json ) {

		const interleavedBufferMap = {};
		const arrayBufferMap = {};

		function getInterleavedBuffer( json, uuid ) {

			if ( interleavedBufferMap[ uuid ] !== undefined ) return interleavedBufferMap[ uuid ];

			const interleavedBuffers = json.interleavedBuffers;
			const interleavedBuffer = interleavedBuffers[ uuid ];

			const buffer = getArrayBuffer( json, interleavedBuffer.buffer );

			const array = getTypedArray( interleavedBuffer.type, buffer );
			const ib = new InterleavedBuffer( array, interleavedBuffer.stride );
			ib.uuid = interleavedBuffer.uuid;

			interleavedBufferMap[ uuid ] = ib;

			return ib;

		}

		function getArrayBuffer( json, uuid ) {

			if ( arrayBufferMap[ uuid ] !== undefined ) return arrayBufferMap[ uuid ];

			const arrayBuffers = json.arrayBuffers;
			const arrayBuffer = arrayBuffers[ uuid ];

			const ab = new Uint32Array( arrayBuffer ).buffer;

			arrayBufferMap[ uuid ] = ab;

			return ab;

		}

		const geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();

		const index = json.data.index;

		if ( index !== undefined ) {

			const typedArray = getTypedArray( index.type, index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		const attributes = json.data.attributes;

		for ( const key in attributes ) {

			const attribute = attributes[ key ];
			let bufferAttribute;

			if ( attribute.isInterleavedBufferAttribute ) {

				const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
				bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

			} else {

				const typedArray = getTypedArray( attribute.type, attribute.array );
				const bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
				bufferAttribute = new bufferAttributeConstr( typedArray, attribute.itemSize, attribute.normalized );

			}

			if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
			geometry.setAttribute( key, bufferAttribute );

		}

		const morphAttributes = json.data.morphAttributes;

		if ( morphAttributes ) {

			for ( const key in morphAttributes ) {

				const attributeArray = morphAttributes[ key ];

				const array = [];

				for ( let i = 0, il = attributeArray.length; i < il; i ++ ) {

					const attribute = attributeArray[ i ];
					let bufferAttribute;

					if ( attribute.isInterleavedBufferAttribute ) {

						const interleavedBuffer = getInterleavedBuffer( json.data, attribute.data );
						bufferAttribute = new InterleavedBufferAttribute( interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized );

					} else {

						const typedArray = getTypedArray( attribute.type, attribute.array );
						bufferAttribute = new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized );

					}

					if ( attribute.name !== undefined ) bufferAttribute.name = attribute.name;
					array.push( bufferAttribute );

				}

				geometry.morphAttributes[ key ] = array;

			}

		}

		const morphTargetsRelative = json.data.morphTargetsRelative;

		if ( morphTargetsRelative ) {

			geometry.morphTargetsRelative = true;

		}

		const groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( let i = 0, n = groups.length; i !== n; ++ i ) {

				const group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		const boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			const center = new Vector3$1();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere$1( center, boundingSphere.radius );

		}

		if ( json.name ) geometry.name = json.name;
		if ( json.userData ) geometry.userData = json.userData;

		return geometry;

	}

}

class ObjectLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const path = ( this.path === '' ) ? LoaderUtils.extractUrlBase( url ) : this.path;
		this.resourcePath = this.resourcePath || path;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			let json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				if ( onError !== undefined ) onError( error );

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );

				return;

			}

			const metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	}

	parse( json, onLoad ) {

		const animations = this.parseAnimations( json.animations );
		const shapes = this.parseShapes( json.shapes );
		const geometries = this.parseGeometries( json.geometries, shapes );

		const images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		const textures = this.parseTextures( json.textures, images );
		const materials = this.parseMaterials( json.materials, textures );

		const object = this.parseObject( json.object, geometries, materials, animations );
		const skeletons = this.parseSkeletons( json.skeletons, object );

		this.bindSkeletons( object, skeletons );

		//

		if ( onLoad !== undefined ) {

			let hasImages = false;

			for ( const uuid in images ) {

				if ( images[ uuid ] instanceof HTMLImageElement ) {

					hasImages = true;
					break;

				}

			}

			if ( hasImages === false ) onLoad( object );

		}

		return object;

	}

	parseShapes( json ) {

		const shapes = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const shape = new Shape().fromJSON( json[ i ] );

				shapes[ shape.uuid ] = shape;

			}

		}

		return shapes;

	}

	parseSkeletons( json, object ) {

		const skeletons = {};
		const bones = {};

		// generate bone lookup table

		object.traverse( function ( child ) {

			if ( child.isBone ) bones[ child.uuid ] = child;

		} );

		// create skeletons

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const skeleton = new Skeleton().fromJSON( json[ i ], bones );

				skeletons[ skeleton.uuid ] = skeleton;

			}

		}

		return skeletons;

	}

	parseGeometries( json, shapes ) {

		const geometries = {};
		let geometryShapes;

		if ( json !== undefined ) {

			const bufferGeometryLoader = new BufferGeometryLoader();

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				let geometry;
				const data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'DodecahedronBufferGeometry':
					case 'IcosahedronGeometry':
					case 'IcosahedronBufferGeometry':
					case 'OctahedronGeometry':
					case 'OctahedronBufferGeometry':
					case 'TetrahedronGeometry':
					case 'TetrahedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'TubeGeometry':
					case 'TubeBufferGeometry':

						// This only works for built-in curves (e.g. CatmullRomCurve3).
						// User defined curves or instances of CurvePath will not be deserialized.
						geometry = new Geometries[ data.type ](
							new Curves[ data.path.type ]().fromJSON( data.path ),
							data.tubularSegments,
							data.radius,
							data.radialSegments,
							data.closed
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'PolyhedronGeometry':
					case 'PolyhedronBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.vertices,
							data.indices,
							data.radius,
							data.details
						);

						break;

					case 'ShapeGeometry':
					case 'ShapeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.curveSegments
						);

						break;


					case 'ExtrudeGeometry':
					case 'ExtrudeBufferGeometry':

						geometryShapes = [];

						for ( let j = 0, jl = data.shapes.length; j < jl; j ++ ) {

							const shape = shapes[ data.shapes[ j ] ];

							geometryShapes.push( shape );

						}

						const extrudePath = data.options.extrudePath;

						if ( extrudePath !== undefined ) {

							data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );

						}

						geometry = new Geometries[ data.type ](
							geometryShapes,
							data.options
						);

						break;

					case 'BufferGeometry':
					case 'InstancedBufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						console.error( 'THREE.ObjectLoader: Loading "Geometry" is not supported anymore.' );

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;
				if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	}

	parseMaterials( json, textures ) {

		const cache = {}; // MultiMaterial
		const materials = {};

		if ( json !== undefined ) {

			const loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.type === 'MultiMaterial' ) {

					// Deprecated

					const array = [];

					for ( let j = 0; j < data.materials.length; j ++ ) {

						const material = data.materials[ j ];

						if ( cache[ material.uuid ] === undefined ) {

							cache[ material.uuid ] = loader.parse( material );

						}

						array.push( cache[ material.uuid ] );

					}

					materials[ data.uuid ] = array;

				} else {

					if ( cache[ data.uuid ] === undefined ) {

						cache[ data.uuid ] = loader.parse( data );

					}

					materials[ data.uuid ] = cache[ data.uuid ];

				}

			}

		}

		return materials;

	}

	parseAnimations( json ) {

		const animations = {};

		if ( json !== undefined ) {

			for ( let i = 0; i < json.length; i ++ ) {

				const data = json[ i ];

				const clip = AnimationClip.parse( data );

				animations[ clip.uuid ] = clip;

			}

		}

		return animations;

	}

	parseImages( json, onLoad ) {

		const scope = this;
		const images = {};

		let loader;

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

		}

		function deserializeImage( image ) {

			if ( typeof image === 'string' ) {

				const url = image;

				const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( url ) ? url : scope.resourcePath + url;

				return loadImage( path );

			} else {

				if ( image.data ) {

					return {
						data: getTypedArray( image.type, image.data ),
						width: image.width,
						height: image.height
					};

				} else {

					return null;

				}

			}

		}

		if ( json !== undefined && json.length > 0 ) {

			const manager = new LoadingManager( onLoad );

			loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( let i = 0, il = json.length; i < il; i ++ ) {

				const image = json[ i ];
				const url = image.url;

				if ( Array.isArray( url ) ) {

					// load array of images e.g CubeTexture

					images[ image.uuid ] = [];

					for ( let j = 0, jl = url.length; j < jl; j ++ ) {

						const currentUrl = url[ j ];

						const deserializedImage = deserializeImage( currentUrl );

						if ( deserializedImage !== null ) {

							if ( deserializedImage instanceof HTMLImageElement ) {

								images[ image.uuid ].push( deserializedImage );

							} else {

								// special case: handle array of data textures for cube textures

								images[ image.uuid ].push( new DataTexture( deserializedImage.data, deserializedImage.width, deserializedImage.height ) );

							}

						}

					}

				} else {

					// load single image

					const deserializedImage = deserializeImage( image.url );

					if ( deserializedImage !== null ) {

						images[ image.uuid ] = deserializedImage;

					}

				}

			}

		}

		return images;

	}

	parseTextures( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof value === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		const textures = {};

		if ( json !== undefined ) {

			for ( let i = 0, l = json.length; i < l; i ++ ) {

				const data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				let texture;
				const image = images[ data.image ];

				if ( Array.isArray( image ) ) {

					texture = new CubeTexture( image );

					if ( image.length === 6 ) texture.needsUpdate = true;

				} else {

					if ( image && image.data ) {

						texture = new DataTexture( image.data, image.width, image.height );

					} else {

						texture = new Texture( image );

					}

					if ( image ) texture.needsUpdate = true; // textures can have undefined image data

				}

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.center !== undefined ) texture.center.fromArray( data.center );
				if ( data.rotation !== undefined ) texture.rotation = data.rotation;

				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );

				}

				if ( data.format !== undefined ) texture.format = data.format;
				if ( data.type !== undefined ) texture.type = data.type;
				if ( data.encoding !== undefined ) texture.encoding = data.encoding;

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
				if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	}

	parseObject( data, geometries, materials, animations ) {

		let object;

		function getGeometry( name ) {

			if ( geometries[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

			}

			return geometries[ name ];

		}

		function getMaterial( name ) {

			if ( name === undefined ) return undefined;

			if ( Array.isArray( name ) ) {

				const array = [];

				for ( let i = 0, l = name.length; i < l; i ++ ) {

					const uuid = name[ i ];

					if ( materials[ uuid ] === undefined ) {

						console.warn( 'THREE.ObjectLoader: Undefined material', uuid );

					}

					array.push( materials[ uuid ] );

				}

				return array;

			}

			if ( materials[ name ] === undefined ) {

				console.warn( 'THREE.ObjectLoader: Undefined material', name );

			}

			return materials[ name ];

		}

		let geometry, material;

		switch ( data.type ) {

			case 'Scene':

				object = new Scene$2();

				if ( data.background !== undefined ) {

					if ( Number.isInteger( data.background ) ) {

						object.background = new Color$1( data.background );

					}

				}

				if ( data.fog !== undefined ) {

					if ( data.fog.type === 'Fog' ) {

						object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

					} else if ( data.fog.type === 'FogExp2' ) {

						object.fog = new FogExp2( data.fog.color, data.fog.density );

					}

				}

				break;

			case 'PerspectiveCamera':

				object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

				if ( data.focus !== undefined ) object.focus = data.focus;
				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
				if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'OrthographicCamera':

				object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

				if ( data.zoom !== undefined ) object.zoom = data.zoom;
				if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

				break;

			case 'AmbientLight':

				object = new AmbientLight$1( data.color, data.intensity );

				break;

			case 'DirectionalLight':

				object = new DirectionalLight( data.color, data.intensity );

				break;

			case 'PointLight':

				object = new PointLight$1( data.color, data.intensity, data.distance, data.decay );

				break;

			case 'RectAreaLight':

				object = new RectAreaLight( data.color, data.intensity, data.width, data.height );

				break;

			case 'SpotLight':

				object = new SpotLight$1( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

				break;

			case 'HemisphereLight':

				object = new HemisphereLight$1( data.color, data.groundColor, data.intensity );

				break;

			case 'LightProbe':

				object = new LightProbe().fromJSON( data );

				break;

			case 'SkinnedMesh':

				geometry = getGeometry( data.geometry );
			 	material = getMaterial( data.material );

				object = new SkinnedMesh( geometry, material );

				if ( data.bindMode !== undefined ) object.bindMode = data.bindMode;
				if ( data.bindMatrix !== undefined ) object.bindMatrix.fromArray( data.bindMatrix );
				if ( data.skeleton !== undefined ) object.skeleton = data.skeleton;

				break;

			case 'Mesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );

				object = new Mesh( geometry, material );

				break;

			case 'InstancedMesh':

				geometry = getGeometry( data.geometry );
				material = getMaterial( data.material );
				const count = data.count;
				const instanceMatrix = data.instanceMatrix;

				object = new InstancedMesh( geometry, material, count );
				object.instanceMatrix = new BufferAttribute( new Float32Array( instanceMatrix.array ), 16 );

				break;

			case 'LOD':

				object = new LOD();

				break;

			case 'Line':

				object = new Line$1( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineLoop':

				object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'LineSegments':

				object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'PointCloud':
			case 'Points':

				object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

				break;

			case 'Sprite':

				object = new Sprite$1( getMaterial( data.material ) );

				break;

			case 'Group':

				object = new Group();

				break;

			case 'Bone':

				object = new Bone();

				break;

			default:

				object = new Object3D();

		}

		object.uuid = data.uuid;

		if ( data.name !== undefined ) object.name = data.name;

		if ( data.matrix !== undefined ) {

			object.matrix.fromArray( data.matrix );

			if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
			if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );

		} else {

			if ( data.position !== undefined ) object.position.fromArray( data.position );
			if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
			if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
			if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

		}

		if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
		if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

		if ( data.shadow ) {

			if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
			if ( data.shadow.normalBias !== undefined ) object.shadow.normalBias = data.shadow.normalBias;
			if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
			if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
			if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

		}

		if ( data.visible !== undefined ) object.visible = data.visible;
		if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
		if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
		if ( data.userData !== undefined ) object.userData = data.userData;
		if ( data.layers !== undefined ) object.layers.mask = data.layers;

		if ( data.children !== undefined ) {

			const children = data.children;

			for ( let i = 0; i < children.length; i ++ ) {

				object.add( this.parseObject( children[ i ], geometries, materials, animations ) );

			}

		}

		if ( data.animations !== undefined ) {

			const objectAnimations = data.animations;

			for ( let i = 0; i < objectAnimations.length; i ++ ) {

				const uuid = objectAnimations[ i ];

				object.animations.push( animations[ uuid ] );

			}

		}

		if ( data.type === 'LOD' ) {

			if ( data.autoUpdate !== undefined ) object.autoUpdate = data.autoUpdate;

			const levels = data.levels;

			for ( let l = 0; l < levels.length; l ++ ) {

				const level = levels[ l ];
				const child = object.getObjectByProperty( 'uuid', level.object );

				if ( child !== undefined ) {

					object.addLevel( child, level.distance );

				}

			}

		}

		return object;

	}

	bindSkeletons( object, skeletons ) {

		if ( Object.keys( skeletons ).length === 0 ) return;

		object.traverse( function ( child ) {

			if ( child.isSkinnedMesh === true && child.skeleton !== undefined ) {

				const skeleton = skeletons[ child.skeleton ];

				if ( skeleton === undefined ) {

					console.warn( 'THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton );

				} else {

					child.bind( skeleton, child.bindMatrix );

				}

			}

		} );

	}

	/* DEPRECATED */

	setTexturePath( value ) {

		console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
		return this.setResourcePath( value );

	}

}

const TEXTURE_MAPPING = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};

const TEXTURE_WRAPPING = {
	RepeatWrapping: RepeatWrapping$1,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};

const TEXTURE_FILTER = {
	NearestFilter: NearestFilter,
	NearestMipmapNearestFilter: NearestMipmapNearestFilter,
	NearestMipmapLinearFilter: NearestMipmapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipmapNearestFilter: LinearMipmapNearestFilter,
	LinearMipmapLinearFilter: LinearMipmapLinearFilter
};

function ImageBitmapLoader( manager ) {

	if ( typeof createImageBitmap === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

	}

	if ( typeof fetch === 'undefined' ) {

		console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

	}

	Loader$1.call( this, manager );

	this.options = { premultiplyAlpha: 'none' };

}

ImageBitmapLoader.prototype = Object.assign( Object.create( Loader$1.prototype ), {

	constructor: ImageBitmapLoader,

	isImageBitmapLoader: true,

	setOptions: function setOptions( options ) {

		this.options = options;

		return this;

	},

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		url = this.manager.resolveURL( url );

		const scope = this;

		const cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		const fetchOptions = {};
		fetchOptions.credentials = ( this.crossOrigin === 'anonymous' ) ? 'same-origin' : 'include';
		fetchOptions.headers = this.requestHeader;

		fetch( url, fetchOptions ).then( function ( res ) {

			return res.blob();

		} ).then( function ( blob ) {

			return createImageBitmap( blob, Object.assign( scope.options, { colorSpaceConversion: 'none' } ) );

		} ).then( function ( imageBitmap ) {

			Cache.add( url, imageBitmap );

			if ( onLoad ) onLoad( imageBitmap );

			scope.manager.itemEnd( url );

		} ).catch( function ( e ) {

			if ( onError ) onError( e );

			scope.manager.itemError( url );
			scope.manager.itemEnd( url );

		} );

		scope.manager.itemStart( url );

	}

} );

class ShapePath {

	constructor() {

		this.type = 'ShapePath';

		this.color = new Color$1();

		this.subPaths = [];
		this.currentPath = null;

	}

	moveTo( x, y ) {

		this.currentPath = new Path();
		this.subPaths.push( this.currentPath );
		this.currentPath.moveTo( x, y );

		return this;

	}

	lineTo( x, y ) {

		this.currentPath.lineTo( x, y );

		return this;

	}

	quadraticCurveTo( aCPx, aCPy, aX, aY ) {

		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

		return this;

	}

	bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

		return this;

	}

	splineThru( pts ) {

		this.currentPath.splineThru( pts );

		return this;

	}

	toShapes( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			const shapes = [];

			for ( let i = 0, l = inSubpaths.length; i < l; i ++ ) {

				const tmpPath = inSubpaths[ i ];

				const tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			const polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			let inside = false;
			for ( let p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				let edgeLowPt = inPolygon[ p ];
				let edgeHighPt = inPolygon[ q ];

				let edgeDx = edgeHighPt.x - edgeLowPt.x;
				let edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}

					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						const perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		const isClockWise = ShapeUtils.isClockWise;

		const subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		let solid, tmpPath, tmpShape;
		const shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		let holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		const betterShapeHoles = [];
		const newShapes = [];
		let newShapeHoles = [];
		let mainIdx = 0;
		let tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( let i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			let ambiguous = false;
			const toChange = [];

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				const sho = newShapeHoles[ sIdx ];

				for ( let hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					const ho = sho[ hIdx ];
					let hole_unassigned = true;

					for ( let s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}

					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);

			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		let tmpHoles;

		for ( let i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( let j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}

}

class Font {

	constructor( data ) {

		this.type = 'Font';

		this.data = data;

	}

	generateShapes( text, size = 100 ) {

		const shapes = [];
		const paths = createPaths( text, size, this.data );

		for ( let p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

}

function createPaths( text, size, data ) {

	const chars = Array.from( text );
	const scale = size / data.resolution;
	const line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

	const paths = [];

	let offsetX = 0, offsetY = 0;

	for ( let i = 0; i < chars.length; i ++ ) {

		const char = chars[ i ];

		if ( char === '\n' ) {

			offsetX = 0;
			offsetY -= line_height;

		} else {

			const ret = createPath( char, scale, offsetX, offsetY, data );
			offsetX += ret.offsetX;
			paths.push( ret.path );

		}

	}

	return paths;

}

function createPath( char, scale, offsetX, offsetY, data ) {

	const glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

	if ( ! glyph ) {

		console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

		return;

	}

	const path = new ShapePath();

	let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

	if ( glyph.o ) {

		const outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

		for ( let i = 0, l = outline.length; i < l; ) {

			const action = outline[ i ++ ];

			switch ( action ) {

				case 'm': // moveTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.moveTo( x, y );

					break;

				case 'l': // lineTo

					x = outline[ i ++ ] * scale + offsetX;
					y = outline[ i ++ ] * scale + offsetY;

					path.lineTo( x, y );

					break;

				case 'q': // quadraticCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;

					path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

					break;

				case 'b': // bezierCurveTo

					cpx = outline[ i ++ ] * scale + offsetX;
					cpy = outline[ i ++ ] * scale + offsetY;
					cpx1 = outline[ i ++ ] * scale + offsetX;
					cpy1 = outline[ i ++ ] * scale + offsetY;
					cpx2 = outline[ i ++ ] * scale + offsetX;
					cpy2 = outline[ i ++ ] * scale + offsetY;

					path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

					break;

			}

		}

	}

	return { offsetX: glyph.ha * scale, path: path };

}

Font.prototype.isFont = true;

class FontLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( scope.withCredentials );
		loader.load( url, function ( text ) {

			let json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			const font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	}

	parse( json ) {

		return new Font( json );

	}

}

let _context;

const AudioContext = {

	getContext: function () {

		if ( _context === undefined ) {

			_context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return _context;

	},

	setContext: function ( value ) {

		_context = value;

	}

};

class AudioLoader extends Loader$1 {

	constructor( manager ) {

		super( manager );

	}

	load( url, onLoad, onProgress, onError ) {

		const scope = this;

		const loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.setPath( this.path );
		loader.setRequestHeader( this.requestHeader );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( buffer ) {

			try {

				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				const bufferCopy = buffer.slice( 0 );

				const context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {

					onLoad( audioBuffer );

				} );

			} catch ( e ) {

				if ( onError ) {

					onError( e );

				} else {

					console.error( e );

				}

				scope.manager.itemError( url );

			}

		}, onProgress, onError );

	}

}

class HemisphereLightProbe extends LightProbe {

	constructor( skyColor, groundColor, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color$1().set( skyColor );
		const color2 = new Color$1().set( groundColor );

		const sky = new Vector3$1( color1.r, color1.g, color1.b );
		const ground = new Vector3$1( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		const c0 = Math.sqrt( Math.PI );
		const c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

}

HemisphereLightProbe.prototype.isHemisphereLightProbe = true;

class AmbientLightProbe extends LightProbe {

	constructor( color, intensity = 1 ) {

		super( undefined, intensity );

		const color1 = new Color$1().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

}

AmbientLightProbe.prototype.isAmbientLightProbe = true;

const _eyeRight = new Matrix4();
const _eyeLeft = new Matrix4();

class StereoCamera {

	constructor() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	update( camera ) {

		const cache = this._cache;

		const needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
			cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
			cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

		if ( needsUpdate ) {

			cache.focus = camera.focus;
			cache.fov = camera.fov;
			cache.aspect = camera.aspect * this.aspect;
			cache.near = camera.near;
			cache.far = camera.far;
			cache.zoom = camera.zoom;
			cache.eyeSep = this.eyeSep;

			// Off-axis stereoscopic effect based on
			// http://paulbourke.net/stereographics/stereorender/

			const projectionMatrix = camera.projectionMatrix.clone();
			const eyeSepHalf = cache.eyeSep / 2;
			const eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
			const ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
			let xmin, xmax;

			// translate xOffset

			_eyeLeft.elements[ 12 ] = - eyeSepHalf;
			_eyeRight.elements[ 12 ] = eyeSepHalf;

			// for left eye

			xmin = - ymax * cache.aspect + eyeSepOnProjection;
			xmax = ymax * cache.aspect + eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraL.projectionMatrix.copy( projectionMatrix );

			// for right eye

			xmin = - ymax * cache.aspect - eyeSepOnProjection;
			xmax = ymax * cache.aspect - eyeSepOnProjection;

			projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
			projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

			this.cameraR.projectionMatrix.copy( projectionMatrix );

		}

		this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
		this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

	}

}

class Clock {

	constructor( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	start() {

		this.startTime = now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	}

	stop() {

		this.getElapsedTime();
		this.running = false;
		this.autoStart = false;

	}

	getElapsedTime() {

		this.getDelta();
		return this.elapsedTime;

	}

	getDelta() {

		let diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();
			return 0;

		}

		if ( this.running ) {

			const newTime = now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

}

function now() {

	return ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

}

const _position$2 = /*@__PURE__*/ new Vector3$1();
const _quaternion$3 = /*@__PURE__*/ new Quaternion();
const _scale$1 = /*@__PURE__*/ new Vector3$1();
const _orientation = /*@__PURE__*/ new Vector3$1();

class AudioListener extends Object3D {

	constructor() {

		super();

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	getInput() {

		return this.gain;

	}

	removeFilter() {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

		return this;

	}

	getFilter() {

		return this.filter;

	}

	setFilter( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

		return this;

	}

	getMasterVolume() {

		return this.gain.gain.value;

	}

	setMasterVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		const listener = this.context.listener;
		const up = this.up;

		this.timeDelta = this._clock.getDelta();

		this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

		_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

		if ( listener.positionX ) {

			// code path for Chrome (see #14393)

			const endTime = this.context.currentTime + this.timeDelta;

			listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
			listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
			listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
			listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
			listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
			listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
			listener.upX.linearRampToValueAtTime( up.x, endTime );
			listener.upY.linearRampToValueAtTime( up.y, endTime );
			listener.upZ.linearRampToValueAtTime( up.z, endTime );

		} else {

			listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
			listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

		}

	}

}

class Audio$2 extends Object3D {

	constructor( listener ) {

		super();

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.source = null;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._progress = 0;
		this._connected = false;

		this.filters = [];

	}

	getOutput() {

		return this.gain;

	}

	setNodeSource( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	}

	setMediaElementSource( mediaElement ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaNode';
		this.source = this.context.createMediaElementSource( mediaElement );
		this.connect();

		return this;

	}

	setMediaStreamSource( mediaStream ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'mediaStreamNode';
		this.source = this.context.createMediaStreamSource( mediaStream );
		this.connect();

		return this;

	}

	setBuffer( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	}

	play( delay = 0 ) {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._startedAt = this.context.currentTime + delay;

		const source = this.context.createBufferSource();
		source.buffer = this.buffer;
		source.loop = this.loop;
		source.loopStart = this.loopStart;
		source.loopEnd = this.loopEnd;
		source.onended = this.onEnded.bind( this );
		source.start( this._startedAt, this._progress + this.offset, this.duration );

		this.isPlaying = true;

		this.source = source;

		this.setDetune( this.detune );
		this.setPlaybackRate( this.playbackRate );

		return this.connect();

	}

	pause() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		if ( this.isPlaying === true ) {

			// update current progress

			this._progress += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

			if ( this.loop === true ) {

				// ensure _progress does not exceed duration with looped audios

				this._progress = this._progress % ( this.duration || this.buffer.duration );

			}

			this.source.stop();
			this.source.onended = null;

			this.isPlaying = false;

		}

		return this;

	}

	stop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this._progress = 0;

		this.source.stop();
		this.source.onended = null;
		this.isPlaying = false;

		return this;

	}

	connect() {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		this._connected = true;

		return this;

	}

	disconnect() {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( let i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		this._connected = false;

		return this;

	}

	getFilters() {

		return this.filters;

	}

	setFilters( value ) {

		if ( ! value ) value = [];

		if ( this._connected === true ) {

			this.disconnect();
			this.filters = value.slice();
			this.connect();

		} else {

			this.filters = value.slice();

		}

		return this;

	}

	setDetune( value ) {

		this.detune = value;

		if ( this.source.detune === undefined ) return; // only set detune when available

		if ( this.isPlaying === true ) {

			this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getDetune() {

		return this.detune;

	}

	getFilter() {

		return this.getFilters()[ 0 ];

	}

	setFilter( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	}

	setPlaybackRate( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

		}

		return this;

	}

	getPlaybackRate() {

		return this.playbackRate;

	}

	onEnded() {

		this.isPlaying = false;

	}

	getLoop() {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	}

	setLoop( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	}

	setLoopStart( value ) {

		this.loopStart = value;

		return this;

	}

	setLoopEnd( value ) {

		this.loopEnd = value;

		return this;

	}

	getVolume() {

		return this.gain.gain.value;

	}

	setVolume( value ) {

		this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

		return this;

	}

}

const _position$3 = /*@__PURE__*/ new Vector3$1();
const _quaternion$4 = /*@__PURE__*/ new Quaternion();
const _scale$2 = /*@__PURE__*/ new Vector3$1();
const _orientation$1 = /*@__PURE__*/ new Vector3$1();

class PositionalAudio extends Audio$2 {

	constructor( listener ) {

		super( listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	getOutput() {

		return this.panner;

	}

	getRefDistance() {

		return this.panner.refDistance;

	}

	setRefDistance( value ) {

		this.panner.refDistance = value;

		return this;

	}

	getRolloffFactor() {

		return this.panner.rolloffFactor;

	}

	setRolloffFactor( value ) {

		this.panner.rolloffFactor = value;

		return this;

	}

	getDistanceModel() {

		return this.panner.distanceModel;

	}

	setDistanceModel( value ) {

		this.panner.distanceModel = value;

		return this;

	}

	getMaxDistance() {

		return this.panner.maxDistance;

	}

	setMaxDistance( value ) {

		this.panner.maxDistance = value;

		return this;

	}

	setDirectionalCone( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

		this.panner.coneInnerAngle = coneInnerAngle;
		this.panner.coneOuterAngle = coneOuterAngle;
		this.panner.coneOuterGain = coneOuterGain;

		return this;

	}

	updateMatrixWorld( force ) {

		super.updateMatrixWorld( force );

		if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

		this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

		_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

		const panner = this.panner;

		if ( panner.positionX ) {

			// code path for Chrome and Firefox (see #14393)

			const endTime = this.context.currentTime + this.listener.timeDelta;

			panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
			panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
			panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
			panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
			panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
			panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

		} else {

			panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
			panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

		}

	}

}

class AudioAnalyser {

	constructor( audio, fftSize = 2048 ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}


	getFrequencyData() {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	}

	getAverageFrequency() {

		let value = 0;
		const data = this.getFrequencyData();

		for ( let i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

}

class PropertyMixer {

	constructor( binding, typeName, valueSize ) {

		this.binding = binding;
		this.valueSize = valueSize;

		let mixFunction,
			mixFunctionAdditive,
			setIdentity;

		// buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
		//
		// 'add' is used for additive cumulative results
		//
		// 'work' is optional and is only present for quaternion types. It is used
		// to store intermediate quaternion multiplication results

		switch ( typeName ) {

			case 'quaternion':
				mixFunction = this._slerp;
				mixFunctionAdditive = this._slerpAdditive;
				setIdentity = this._setAdditiveIdentityQuaternion;

				this.buffer = new Float64Array( valueSize * 6 );
				this._workIndex = 5;
				break;

			case 'string':
			case 'bool':
				mixFunction = this._select;

				// Use the regular mix function and for additive on these types,
				// additive is not relevant for non-numeric types
				mixFunctionAdditive = this._select;

				setIdentity = this._setAdditiveIdentityOther;

				this.buffer = new Array( valueSize * 5 );
				break;

			default:
				mixFunction = this._lerp;
				mixFunctionAdditive = this._lerpAdditive;
				setIdentity = this._setAdditiveIdentityNumeric;

				this.buffer = new Float64Array( valueSize * 5 );

		}

		this._mixBufferRegion = mixFunction;
		this._mixBufferRegionAdditive = mixFunctionAdditive;
		this._setIdentity = setIdentity;
		this._origIndex = 3;
		this._addIndex = 4;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		this.useCount = 0;
		this.referenceCount = 0;

	}

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride;

		let currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			const mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	}

	// accumulate data in the 'incoming' region into 'add'
	accumulateAdditive( weight ) {

		const buffer = this.buffer,
			stride = this.valueSize,
			offset = stride * this._addIndex;

		if ( this.cumulativeWeightAdditive === 0 ) {

			// add = identity

			this._setIdentity();

		}

		// add := add + incoming * weight

		this._mixBufferRegionAdditive( buffer, offset, 0, weight, stride );
		this.cumulativeWeightAdditive += weight;

	}

	// apply the state of 'accu<i>' to the binding when accus differ
	apply( accuIndex ) {

		const stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,
			weightAdditive = this.cumulativeWeightAdditive,

			binding = this.binding;

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			const originalValueOffset = stride * this._origIndex;

			this._mixBufferRegion(
				buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		if ( weightAdditive > 0 ) {

			// accuN := accuN + additive accuN

			this._mixBufferRegionAdditive( buffer, offset, this._addIndex * stride, 1, stride );

		}

		for ( let i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	}

	// remember the state of the bound property and copy it to both accus
	saveOriginalState() {

		const binding = this.binding;

		const buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * this._origIndex;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( let i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		// Add to identity for additive
		this._setIdentity();

		this.cumulativeWeight = 0;
		this.cumulativeWeightAdditive = 0;

	}

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState() {

		const originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	}

	_setAdditiveIdentityNumeric() {

		const startIndex = this._addIndex * this.valueSize;
		const endIndex = startIndex + this.valueSize;

		for ( let i = startIndex; i < endIndex; i ++ ) {

			this.buffer[ i ] = 0;

		}

	}

	_setAdditiveIdentityQuaternion() {

		this._setAdditiveIdentityNumeric();
		this.buffer[ this._addIndex * this.valueSize + 3 ] = 1;

	}

	_setAdditiveIdentityOther() {

		const startIndex = this._origIndex * this.valueSize;
		const targetIndex = this._addIndex * this.valueSize;

		for ( let i = 0; i < this.valueSize; i ++ ) {

			this.buffer[ targetIndex + i ] = this.buffer[ startIndex + i ];

		}

	}


	// mix functions

	_select( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( let i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	}

	_slerp( buffer, dstOffset, srcOffset, t ) {

		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );

	}

	_slerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		const workOffset = this._workIndex * stride;

		// Store result in intermediate buffer offset
		Quaternion.multiplyQuaternionsFlat( buffer, workOffset, buffer, dstOffset, buffer, srcOffset );

		// Slerp to the intermediate result
		Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t );

	}

	_lerp( buffer, dstOffset, srcOffset, t, stride ) {

		const s = 1 - t;

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

	_lerpAdditive( buffer, dstOffset, srcOffset, t, stride ) {

		for ( let i = 0; i !== stride; ++ i ) {

			const j = dstOffset + i;

			buffer[ j ] = buffer[ j ] + buffer[ srcOffset + i ] * t;

		}

	}

}

// Characters [].:/ are reserved for track binding syntax.
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
const _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

// Attempts to allow node names from any language. ES5's `\w` regexp matches
// only latin characters, and the unicode \p{L} is not yet supported. So
// instead, we exclude reserved characters and match everything else.
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

// Parent directories, delimited by '/' or ':'. Currently unused, but must
// be matched to parse the rest of the track name.
const _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
const _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

// Object on target node, and accessor. May not contain reserved
// characters. Accessor may contain any character except closing bracket.
const _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

// Property and accessor. May not contain reserved characters. Accessor may
// contain any non-bracket characters.
const _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

const _trackRe = new RegExp( ''
	+ '^'
	+ _directoryRe
	+ _nodeRe
	+ _objectRe
	+ _propertyRe
	+ '$'
);

const _supportedObjectNames = [ 'material', 'materials', 'bones' ];

function Composite( targetGroup, path, optionalParsedPath ) {

	const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

}

Object.assign( Composite.prototype, {

	getValue: function ( array, offset ) {

		this.bind(); // bind all binding

		const firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function ( array, offset ) {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function () {

		const bindings = this._bindings;

		for ( let i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

} );


function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

Object.assign( PropertyBinding, {

	Composite: Composite,

	create: function ( root, path, parsedPath ) {

		if ( ! ( root && root.isAnimationObjectGroup ) ) {

			return new PropertyBinding( root, path, parsedPath );

		} else {

			return new PropertyBinding.Composite( root, path, parsedPath );

		}

	},

	/**
	 * Replaces spaces with underscores and removes unsupported characters from
	 * node names, to ensure compatibility with parseTrackName().
	 *
	 * @param {string} name Node name to be sanitized.
	 * @return {string}
	 */
	sanitizeNodeName: function ( name ) {

		return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

	},

	parseTrackName: function ( trackName ) {

		const matches = _trackRe.exec( trackName );

		if ( ! matches ) {

			throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

		}

		const results = {
			// directoryName: matches[ 1 ], // (tschw) currently unused
			nodeName: matches[ 2 ],
			objectName: matches[ 3 ],
			objectIndex: matches[ 4 ],
			propertyName: matches[ 5 ], // required
			propertyIndex: matches[ 6 ]
		};

		const lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

		if ( lastDot !== undefined && lastDot !== - 1 ) {

			const objectName = results.nodeName.substring( lastDot + 1 );

			// Object names must be checked against an allowlist. Otherwise, there
			// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
			// 'bar' could be the objectName, or part of a nodeName (which can
			// include '.' characters).
			if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

				results.nodeName = results.nodeName.substring( 0, lastDot );
				results.objectName = objectName;

			}

		}

		if ( results.propertyName === null || results.propertyName.length === 0 ) {

			throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

		}

		return results;

	},

	findNode: function ( root, nodeName ) {

		if ( ! nodeName || nodeName === '' || nodeName === '.' || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

			return root;

		}

		// search into skeleton bones.
		if ( root.skeleton ) {

			const bone = root.skeleton.getBoneByName( nodeName );

			if ( bone !== undefined ) {

				return bone;

			}

		}

		// search into node subtree.
		if ( root.children ) {

			const searchNodeSubtree = function ( children ) {

				for ( let i = 0; i < children.length; i ++ ) {

					const childNode = children[ i ];

					if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

						return childNode;

					}

					const result = searchNodeSubtree( childNode.children );

					if ( result ) return result;

				}

				return null;

			};

			const subTreeNode = searchNodeSubtree( root.children );

			if ( subTreeNode ) {

				return subTreeNode;

			}

		}

		return null;

	}

} );

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function () {},
	_setValue_unavailable: function () {},

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			const source = this.resolvedProperty;

			for ( let i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.targetObject[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				const dest = this.resolvedProperty;

				for ( let i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	],

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function () {

		let targetObject = this.node;
		const parsedPath = this.parsedPath;

		const objectName = parsedPath.objectName;
		const propertyName = parsedPath.propertyName;
		let propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
			return;

		}

		if ( objectName ) {

			let objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( let i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		const nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			const nodeName = parsedPath.nodeName;

			console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
				'.' + propertyName + ' but it wasn\'t found.', targetObject );
			return;

		}

		// determine versioning scheme
		let versioning = this.Versioning.None;

		this.targetObject = targetObject;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;

		}

		// determine how the property gets bound
		let bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {

			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === 'morphTargetInfluences' ) {

				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
					return;

				}

				if ( targetObject.geometry.isBufferGeometry ) {

					if ( ! targetObject.geometry.morphAttributes ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
						return;

					}

					if ( targetObject.morphTargetDictionary[ propertyIndex ] !== undefined ) {

						propertyIndex = targetObject.morphTargetDictionary[ propertyIndex ];

					}


				} else {

					console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences on THREE.Geometry. Use THREE.BufferGeometry instead.', this );
					return;

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( Array.isArray( nodeProperty ) ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function () {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

} );

// DECLARE ALIAS AFTER assign prototype
Object.assign( PropertyBinding.prototype, {

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

} );

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 *  - Add objects you would otherwise pass as 'root' to the
 *    constructor or the .clipAction method of AnimationMixer.
 *
 *  - Instead pass this object as 'root'.
 *
 *  - You can also add and remove objects later when the mixer
 *    is running.
 *
 * Note:
 *
 *    Objects of this class appear as one object to the mixer,
 *    so cache control of the individual objects must be done
 *    on the group.
 *
 * Limitation:
 *
 *  - The animated properties must be compatible among the
 *    all objects in the group.
 *
 *  - A single property can either be controlled through a
 *    target group or directly, but not both.
 */

class AnimationObjectGroup {

	constructor() {

		this.uuid = MathUtils.generateUUID();

		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );

		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite

		const indices = {};
		this._indicesByUUID = indices; // for bookkeeping

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			indices[ arguments[ i ].uuid ] = i;

		}

		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays

		const scope = this;

		this.stats = {

			objects: {
				get total() {

					return scope._objects.length;

				},
				get inUse() {

					return this.total - scope.nCachedObjects_;

				}
			},
			get bindingsPerObject() {

				return scope._bindings.length;

			}

		};

	}

	add() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		let knownObject = undefined,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid;
			let index = indicesByUUID[ uuid ];

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				const firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ];

					let binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject ) {

				console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
					'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	remove() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				const lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( let j = 0, m = nBindings; j !== m; ++ j ) {

					const bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// remove & forget
	uncache() {

		const objects = this._objects,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		let nCachedObjects = this.nCachedObjects_,
			nObjects = objects.length;

		for ( let i = 0, n = arguments.length; i !== n; ++ i ) {

			const object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					const firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					const lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					if ( lastIndex > 0 ) {

						indicesByUUID[ lastObject.uuid ] = index;

					}

					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( let j = 0, m = nBindings; j !== m; ++ j ) {

						const bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	}

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_( path, parsedPath ) {

		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		const indicesByPath = this._bindingsIndicesByPath;
		let index = indicesByPath[ path ];
		const bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		const paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( let i = nCachedObjects, n = objects.length; i !== n; ++ i ) {

			const object = objects[ i ];
			bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	}

	unsubscribe_( path ) {

		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		const indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			const paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

}

AnimationObjectGroup.prototype.isAnimationObjectGroup = true;

class AnimationAction {

	constructor( mixer, clip, localRoot = null, blendMode = clip.blendMode ) {

		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot;
		this.blendMode = blendMode;

		const tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );

		const interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};

		for ( let i = 0; i !== nTracks; ++ i ) {

			const interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;

		}

		this._interpolantSettings = interpolantSettings;

		this._interpolants = interpolants; // bound by the mixer

		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );

		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager

		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;

		this.loop = LoopRepeat;
		this._loopCount = - 1;

		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;

		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;

		this.timeScale = 1;
		this._effectiveTimeScale = 1;

		this.weight = 1;
		this._effectiveWeight = 1;

		this.repetitions = Infinity; // no. of repetitions when looping

		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight

		this.clampWhenFinished = false;// keep feeding the last frame?

		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end

	}

	// State & Scheduling

	play() {

		this._mixer._activateAction( this );

		return this;

	}

	stop() {

		this._mixer._deactivateAction( this );

		return this.reset();

	}

	reset() {

		this.paused = false;
		this.enabled = true;

		this.time = 0; // restart clip
		this._loopCount = - 1;// forget previous loops
		this._startTime = null;// forget scheduling

		return this.stopFading().stopWarping();

	}

	isRunning() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
			this._startTime === null && this._mixer._isActiveAction( this );

	}

	// return true when play has been called
	isScheduled() {

		return this._mixer._isActiveAction( this );

	}

	startAt( time ) {

		this._startTime = time;

		return this;

	}

	setLoop( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	}

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	}

	// return the weight considering fading and .enabled
	getEffectiveWeight() {

		return this._effectiveWeight;

	}

	fadeIn( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	}

	fadeOut( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	}

	crossFadeFrom( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if ( warp ) {

			const fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	}

	crossFadeTo( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	}

	stopFading() {

		const weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	}

	// Time Scale Control

	// set the time scale stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 : timeScale;

		return this.stopWarping();

	}

	// return the time scale considering warping and .paused
	getEffectiveTimeScale() {

		return this._effectiveTimeScale;

	}

	setDuration( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	}

	syncWith( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	}

	halt( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	}

	warp( startTimeScale, endTimeScale, duration ) {

		const mixer = this._mixer,
			now = mixer.time,
			timeScale = this.timeScale;

		let interpolant = this._timeScaleInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	}

	stopWarping() {

		const timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	}

	// Object Accessors

	getMixer() {

		return this._mixer;

	}

	getClip() {

		return this._clip;

	}

	getRoot() {

		return this._localRoot || this._mixer._root;

	}

	// Interna

	_update( time, deltaTime, timeDirection, accuIndex ) {

		// called by the mixer

		if ( ! this.enabled ) {

			// call ._updateWeight() to update ._effectiveWeight

			this._updateWeight( time );
			return;

		}

		const startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			const timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		const clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		const weight = this._updateWeight( time );

		if ( weight > 0 ) {

			const interpolants = this._interpolants;
			const propertyMixers = this._propertyBindings;

			switch ( this.blendMode ) {

				case AdditiveAnimationBlendMode:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulateAdditive( weight );

					}

					break;

				case NormalAnimationBlendMode:
				default:

					for ( let j = 0, m = interpolants.length; j !== m; ++ j ) {

						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );

					}

			}

		}

	}

	_updateWeight( time ) {

		let weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			const interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	}

	_updateTimeScale( time ) {

		let timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			const interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				const interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	}

	_updateTime( deltaTime ) {

		const duration = this._clip.duration;
		const loop = this.loop;

		let time = this.time + deltaTime;
		let loopCount = this._loopCount;

		const pingPong = ( loop === LoopPingPong );

		if ( deltaTime === 0 ) {

			if ( loopCount === - 1 ) return time;

			return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;

		}

		if ( loop === LoopOnce ) {

			if ( loopCount === - 1 ) {

				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else {

					this.time = time;

					break handle_stop;

				}

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this.time = time;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? - 1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			if ( loopCount === - 1 ) {

				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings( true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings( this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {

				// wrap around

				const loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				const pending = this.repetitions - loopCount;

				if ( pending <= 0 ) {

					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : - 1
					} );

				} else {

					// keep running

					if ( pending === 1 ) {

						// entering the last round

						const atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this.time = time;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			} else {

				this.time = time;

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {

				// invert time for the "pong round"

				return duration - time;

			}

		}

		return time;

	}

	_setEndings( atStart, atEnd, pingPong ) {

		const settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart = ZeroSlopeEnding;
			settings.endingEnd = ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	}

	_scheduleFading( duration, weightNow, weightThen ) {

		const mixer = this._mixer, now = mixer.time;
		let interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		const times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;
		values[ 1 ] = weightThen;

		return this;

	}

}

class AnimationMixer extends EventDispatcher {

	constructor( root ) {

		super();

		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
		this.time = 0;
		this.timeScale = 1.0;

	}

	_bindAction( action, prototypeAction ) {

		const root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName;

		let bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( let i = 0; i !== nTracks; ++ i ) {

			const track = tracks[ i ],
				trackName = track.name;

			let binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				const path = prototypeAction && prototypeAction.
					_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
					PropertyBinding.create( root, trackName, path ),
					track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	}

	_activateAction( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				const rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
					actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			const bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	}

	_deactivateAction( action ) {

		if ( this._isActiveAction( action ) ) {

			const bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

				const binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	}

	// Memory manager

	_initMemoryManager() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 	knownActions: Array< AnimationAction > - used as prototypes
		// 	actionByRoot: AnimationAction - lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		const scope = this;

		this.stats = {

			actions: {
				get total() {

					return scope._actions.length;

				},
				get inUse() {

					return scope._nActiveActions;

				}
			},
			bindings: {
				get total() {

					return scope._bindings.length;

				},
				get inUse() {

					return scope._nActiveBindings;

				}
			},
			controlInterpolants: {
				get total() {

					return scope._controlInterpolants.length;

				},
				get inUse() {

					return scope._nActiveControlInterpolants;

				}
			}

		};

	}

	// Memory management for AnimationAction objects

	_isActiveAction( action ) {

		const index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	}

	_addInactiveAction( action, clipUuid, rootUuid ) {

		const actions = this._actions,
			actionsByClip = this._actionsByClip;

		let actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			const knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	}

	_removeInactiveAction( action ) {

		const actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		const clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		const actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( action._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	}

	_removeInactiveBindingsForAction( action ) {

		const bindings = action._propertyBindings;

		for ( let i = 0, n = bindings.length; i !== n; ++ i ) {

			const binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	}

	_lendAction( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	}

	_takeBackAction( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		const actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	}

	// Memory management for PropertyMixer objects

	_addInactiveBinding( binding, rootUuid, trackName ) {

		const bindingsByRoot = this._bindingsByRootAndName,
			bindings = this._bindings;

		let bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	}

	_removeInactiveBinding( binding ) {

		const bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		if ( Object.keys( bindingByName ).length === 0 ) {

			delete bindingsByRoot[ rootUuid ];

		}

	}

	_lendBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	}

	_takeBackBinding( binding ) {

		const bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	}


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant() {

		const interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++;

		let interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
				new Float32Array( 2 ), new Float32Array( 2 ),
				1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	}

	_takeBackControlInterpolant( interpolant ) {

		const interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	}

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction( clip, optionalRoot, blendMode ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid;

		let clipObject = typeof clip === 'string' ? AnimationClip.findByName( root, clip ) : clip;

		const clipUuid = clipObject !== null ? clipObject.uuid : clip;

		const actionsForClip = this._actionsByClip[ clipUuid ];
		let prototypeAction = null;

		if ( blendMode === undefined ) {

			if ( clipObject !== null ) {

				blendMode = clipObject.blendMode;

			} else {

				blendMode = NormalAnimationBlendMode;

			}

		}

		if ( actionsForClip !== undefined ) {

			const existingAction = actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined && existingAction.blendMode === blendMode ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		const newAction = new AnimationAction( this, clipObject, optionalRoot, blendMode );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	}

	// get an existing action
	existingAction( clip, optionalRoot ) {

		const root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
				AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	}

	// deactivates all previously scheduled actions
	stopAllAction() {

		const actions = this._actions,
			nActions = this._nActiveActions;

		for ( let i = nActions - 1; i >= 0; -- i ) {

			actions[ i ].stop();

		}

		return this;

	}

	// advance the time and update apply the animation
	update( deltaTime ) {

		deltaTime *= this.timeScale;

		const actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( let i = 0; i !== nActions; ++ i ) {

			const action = actions[ i ];

			action._update( time, deltaTime, timeDirection, accuIndex );

		}

		// update scene graph

		const bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( let i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	}

	// Allows you to seek to a specific time in an animation.
	setTime( timeInSeconds ) {

		this.time = 0; // Zero out time attribute for AnimationMixer object;
		for ( let i = 0; i < this._actions.length; i ++ ) {

			this._actions[ i ].time = 0; // Zero out time attribute for all associated AnimationAction objects.

		}

		return this.update( timeInSeconds ); // Update used to set exact time. Returns "this" AnimationMixer object.

	}

	// return this mixer's root target object
	getRoot() {

		return this._root;

	}

	// free all resources specific to a particular clip
	uncacheClip( clip ) {

		const actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			const actionsToRemove = actionsForClip.knownActions;

			for ( let i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				const action = actionsToRemove[ i ];

				this._deactivateAction( action );

				const cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	}

	// free all resources specific to a particular root target object
	uncacheRoot( root ) {

		const rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( const clipUuid in actionsByClip ) {

			const actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		const bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( const trackName in bindingByName ) {

				const binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	}

	// remove a targeted clip from the cache
	uncacheAction( clip, optionalRoot ) {

		const action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

}

AnimationMixer.prototype._controlInterpolantsResultBuffer = new Float32Array( 1 );

class Uniform {

	constructor( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	clone() {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	}

}

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

	constructor: InstancedInterleavedBuffer,

	isInstancedInterleavedBuffer: true,

	copy: function ( source ) {

		InterleavedBuffer.prototype.copy.call( this, source );

		this.meshPerAttribute = source.meshPerAttribute;

		return this;

	},

	clone: function ( data ) {

		const ib = InterleavedBuffer.prototype.clone.call( this, data );

		ib.meshPerAttribute = this.meshPerAttribute;

		return ib;

	},

	toJSON: function ( data ) {

		const json = InterleavedBuffer.prototype.toJSON.call( this, data );

		json.isInstancedInterleavedBuffer = true;
		json.meshPerAttribute = this.meshPerAttribute;

		return json;

	}

} );

function GLBufferAttribute( buffer, type, itemSize, elementSize, count ) {

	this.buffer = buffer;
	this.type = type;
	this.itemSize = itemSize;
	this.elementSize = elementSize;
	this.count = count;

	this.version = 0;

}

Object.defineProperty( GLBufferAttribute.prototype, 'needsUpdate', {

	set: function ( value ) {

		if ( value === true ) this.version ++;

	}

} );

Object.assign( GLBufferAttribute.prototype, {

	isGLBufferAttribute: true,

	setBuffer: function ( buffer ) {

		this.buffer = buffer;

		return this;

	},

	setType: function ( type, elementSize ) {

		this.type = type;
		this.elementSize = elementSize;

		return this;

	},

	setItemSize: function ( itemSize ) {

		this.itemSize = itemSize;

		return this;

	},

	setCount: function ( count ) {

		this.count = count;

		return this;

	},

} );

function Raycaster( origin, direction, near = 0, far = Infinity ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near;
	this.far = far;
	this.camera = null;
	this.layers = new Layers();

	this.params = {
		Mesh: {},
		Line: { threshold: 1 },
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {

				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;

			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.layers.test( raycaster.layers ) ) {

		object.raycast( raycaster, intersects );

	}

	if ( recursive === true ) {

		const children = object.children;

		for ( let i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

Object.assign( Raycaster.prototype, {

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( camera && camera.isPerspectiveCamera ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
			this.camera = camera;

		} else if ( camera && camera.isOrthographicCamera ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
			this.camera = camera;

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type: ' + camera.type );

		}

	},

	intersectObject: function ( object, recursive = false, intersects = [] ) {

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive = false, intersects = [] ) {

		for ( let i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

} );

/**
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
 * The azimuthal angle (theta) is measured from the positive z-axis.
 */

class Spherical {

	constructor( radius = 1, phi = 0, theta = 0 ) {

		this.radius = radius;
		this.phi = phi; // polar angle
		this.theta = theta; // azimuthal angle

		return this;

	}

	set( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	}

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe() {

		const EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + y * y + z * z );

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( x, z );
			this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

		}

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

/**
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 */

class Cylindrical {

	constructor( radius = 1, theta = 0, y = 0 ) {

		this.radius = radius; // distance from the origin to a point in the x-z plane
		this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = y; // height above the x-z plane

		return this;

	}

	set( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	}

	copy( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	}

	setFromVector3( v ) {

		return this.setFromCartesianCoords( v.x, v.y, v.z );

	}

	setFromCartesianCoords( x, y, z ) {

		this.radius = Math.sqrt( x * x + z * z );
		this.theta = Math.atan2( x, z );
		this.y = y;

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

const _vector$8 = /*@__PURE__*/ new Vector2();

class Box2 {

	constructor( min = new Vector2( + Infinity, + Infinity ), max = new Vector2( - Infinity, - Infinity ) ) {

		this.min = min;
		this.max = max;

	}

	set( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	}

	setFromPoints( points ) {

		this.makeEmpty();

		for ( let i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	}

	setFromCenterAndSize( center, size ) {

		const halfSize = _vector$8.copy( size ).multiplyScalar( 0.5 );
		this.min.copy( center ).sub( halfSize );
		this.max.copy( center ).add( halfSize );

		return this;

	}

	clone() {

		return new this.constructor().copy( this );

	}

	copy( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	}

	makeEmpty() {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	}

	isEmpty() {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getCenter() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	}

	getSize( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getSize() target is now required' );
			target = new Vector2();

		}

		return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );

	}

	expandByPoint( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	}

	expandByVector( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	}

	expandByScalar( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	}

	containsPoint( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	}

	containsBox( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	}

	getParameter( point, target ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .getParameter() target is now required' );
			target = new Vector2();

		}

		return target.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	}

	intersectsBox( box ) {

		// using 4 splitting planes to rule out intersections

		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	}

	clampPoint( point, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Box2: .clampPoint() target is now required' );
			target = new Vector2();

		}

		return target.copy( point ).clamp( this.min, this.max );

	}

	distanceToPoint( point ) {

		const clampedPoint = _vector$8.copy( point ).clamp( this.min, this.max );
		return clampedPoint.sub( point ).length();

	}

	intersect( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	}

	union( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	}

	translate( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	}

	equals( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

}

Box2.prototype.isBox2 = true;

const _startP = /*@__PURE__*/ new Vector3$1();
const _startEnd = /*@__PURE__*/ new Vector3$1();

class Line3 {

	constructor( start = new Vector3$1(), end = new Vector3$1() ) {

		this.start = start;
		this.end = end;

	}

	set( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	}

	copy( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	}

	getCenter( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .getCenter() target is now required' );
			target = new Vector3$1();

		}

		return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	}

	delta( target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .delta() target is now required' );
			target = new Vector3$1();

		}

		return target.subVectors( this.end, this.start );

	}

	distanceSq() {

		return this.start.distanceToSquared( this.end );

	}

	distance() {

		return this.start.distanceTo( this.end );

	}

	at( t, target ) {

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .at() target is now required' );
			target = new Vector3$1();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	closestPointToPointParameter( point, clampToLine ) {

		_startP.subVectors( point, this.start );
		_startEnd.subVectors( this.end, this.start );

		const startEnd2 = _startEnd.dot( _startEnd );
		const startEnd_startP = _startEnd.dot( _startP );

		let t = startEnd_startP / startEnd2;

		if ( clampToLine ) {

			t = MathUtils.clamp( t, 0, 1 );

		}

		return t;

	}

	closestPointToPoint( point, clampToLine, target ) {

		const t = this.closestPointToPointParameter( point, clampToLine );

		if ( target === undefined ) {

			console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
			target = new Vector3$1();

		}

		return this.delta( target ).multiplyScalar( t ).add( this.start );

	}

	applyMatrix4( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	}

	equals( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

	clone() {

		return new this.constructor().copy( this );

	}

}

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( /* renderCallback */ ) {};

	this.hasPositions = false;
	this.hasNormals = false;
	this.hasColors = false;
	this.hasUvs = false;

	this.positionArray = null;
	this.normalArray = null;
	this.colorArray = null;
	this.uvArray = null;

	this.count = 0;

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

const _vector$9 = /*@__PURE__*/ new Vector3$1();

class SpotLightHelper extends Object3D {

	constructor( light, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new BufferGeometry();

		const positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];

		for ( let i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

			const p1 = ( i / l ) * Math.PI * 2;
			const p2 = ( j / l ) * Math.PI * 2;

			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );

		this.update();

	}

	dispose() {

		this.cone.geometry.dispose();
		this.cone.material.dispose();

	}

	update() {

		this.light.updateMatrixWorld();

		const coneLength = this.light.distance ? this.light.distance : 1000;
		const coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		_vector$9.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( _vector$9 );

		if ( this.color !== undefined ) {

			this.cone.material.color.set( this.color );

		} else {

			this.cone.material.color.copy( this.light.color );

		}

	}

}

const _vector$a = /*@__PURE__*/ new Vector3$1();
const _boneMatrix = /*@__PURE__*/ new Matrix4();
const _matrixWorldInv = /*@__PURE__*/ new Matrix4();


class SkeletonHelper extends LineSegments {

	constructor( object ) {

		const bones = getBoneList( object );

		const geometry = new BufferGeometry();

		const vertices = [];
		const colors = [];

		const color1 = new Color$1( 0, 0, 1 );
		const color2 = new Color$1( 0, 1, 0 );

		for ( let i = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );

			}

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, depthTest: false, depthWrite: false, toneMapped: false, transparent: true } );

		super( geometry, material );

		this.type = 'SkeletonHelper';
		this.isSkeletonHelper = true;

		this.root = object;
		this.bones = bones;

		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;

	}

	updateMatrixWorld( force ) {

		const bones = this.bones;

		const geometry = this.geometry;
		const position = geometry.getAttribute( 'position' );

		_matrixWorldInv.copy( this.root.matrixWorld ).invert();

		for ( let i = 0, j = 0; i < bones.length; i ++ ) {

			const bone = bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.matrixWorld );
				_vector$a.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j, _vector$a.x, _vector$a.y, _vector$a.z );

				_boneMatrix.multiplyMatrices( _matrixWorldInv, bone.parent.matrixWorld );
				_vector$a.setFromMatrixPosition( _boneMatrix );
				position.setXYZ( j + 1, _vector$a.x, _vector$a.y, _vector$a.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

		super.updateMatrixWorld( force );

	}

}


function getBoneList( object ) {

	const boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( let i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );

	}

	return boneList;

}

class PointLightHelper extends Mesh {

	constructor( light, sphereSize, color ) {

		const geometry = new SphereGeometry( sphereSize, 4, 2 );
		const material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );

		super( geometry, material );

		this.light = light;
		this.light.updateMatrixWorld();

		this.color = color;

		this.type = 'PointLightHelper';

		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.update();


		/*
	// TODO: delete this comment?
	const distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
	const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	const d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

	}

	dispose() {

		this.geometry.dispose();
		this.material.dispose();

	}

	update() {

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			this.material.color.copy( this.light.color );

		}

		/*
		const d = this.light.distance;

		if ( d === 0.0 ) {

			this.lightDistance.visible = false;

		} else {

			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );

		}
		*/

	}

}

const _vector$b = /*@__PURE__*/ new Vector3$1();
const _color1 = /*@__PURE__*/ new Color$1();
const _color2 = /*@__PURE__*/ new Color$1();

class HemisphereLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		const geometry = new OctahedronGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );

		this.material = new MeshBasicMaterial( { wireframe: true, fog: false, toneMapped: false } );
		if ( this.color === undefined ) this.material.vertexColors = true;

		const position = geometry.getAttribute( 'position' );
		const colors = new Float32Array( position.count * 3 );

		geometry.setAttribute( 'color', new BufferAttribute( colors, 3 ) );

		this.add( new Mesh( geometry, this.material ) );

		this.update();

	}

	dispose() {

		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();

	}

	update() {

		const mesh = this.children[ 0 ];

		if ( this.color !== undefined ) {

			this.material.color.set( this.color );

		} else {

			const colors = mesh.geometry.getAttribute( 'color' );

			_color1.copy( this.light.color );
			_color2.copy( this.light.groundColor );

			for ( let i = 0, l = colors.count; i < l; i ++ ) {

				const color = ( i < ( l / 2 ) ) ? _color1 : _color2;

				colors.setXYZ( i, color.r, color.g, color.b );

			}

			colors.needsUpdate = true;

		}

		mesh.lookAt( _vector$b.setFromMatrixPosition( this.light.matrixWorld ).negate() );

	}

}

class GridHelper extends LineSegments {

	constructor( size = 10, divisions = 10, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color$1( color1 );
		color2 = new Color$1( color2 );

		const center = divisions / 2;
		const step = size / divisions;
		const halfSize = size / 2;

		const vertices = [], colors = [];

		for ( let i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {

			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );

			const color = i === center ? color1 : color2;

			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'GridHelper';

	}

}

class PolarGridHelper extends LineSegments {

	constructor( radius = 10, radials = 16, circles = 8, divisions = 64, color1 = 0x444444, color2 = 0x888888 ) {

		color1 = new Color$1( color1 );
		color2 = new Color$1( color2 );

		const vertices = [];
		const colors = [];

		// create the radials

		for ( let i = 0; i <= radials; i ++ ) {

			const v = ( i / radials ) * ( Math.PI * 2 );

			const x = Math.sin( v ) * radius;
			const z = Math.cos( v ) * radius;

			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );

			const color = ( i & 1 ) ? color1 : color2;

			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );

		}

		// create the circles

		for ( let i = 0; i <= circles; i ++ ) {

			const color = ( i & 1 ) ? color1 : color2;

			const r = radius - ( radius / circles * i );

			for ( let j = 0; j < divisions; j ++ ) {

				// first vertex

				let v = ( j / divisions ) * ( Math.PI * 2 );

				let x = Math.sin( v ) * r;
				let z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

				// second vertex

				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;

				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );

			}

		}

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'PolarGridHelper';

	}

}

const _v1$6 = /*@__PURE__*/ new Vector3$1();
const _v2$3 = /*@__PURE__*/ new Vector3$1();
const _v3$1 = /*@__PURE__*/ new Vector3$1();

class DirectionalLightHelper extends Object3D {

	constructor( light, size, color ) {

		super();
		this.light = light;
		this.light.updateMatrixWorld();

		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;

		this.color = color;

		if ( size === undefined ) size = 1;

		let geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );

		const material = new LineBasicMaterial( { fog: false, toneMapped: false } );

		this.lightPlane = new Line$1( geometry, material );
		this.add( this.lightPlane );

		geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

		this.targetLine = new Line$1( geometry, material );
		this.add( this.targetLine );

		this.update();

	}

	dispose() {

		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();

	}

	update() {

		_v1$6.setFromMatrixPosition( this.light.matrixWorld );
		_v2$3.setFromMatrixPosition( this.light.target.matrixWorld );
		_v3$1.subVectors( _v2$3, _v1$6 );

		this.lightPlane.lookAt( _v2$3 );

		if ( this.color !== undefined ) {

			this.lightPlane.material.color.set( this.color );
			this.targetLine.material.color.set( this.color );

		} else {

			this.lightPlane.material.color.copy( this.light.color );
			this.targetLine.material.color.copy( this.light.color );

		}

		this.targetLine.lookAt( _v2$3 );
		this.targetLine.scale.z = _v3$1.length();

	}

}

const _vector$c = /*@__PURE__*/ new Vector3$1();
const _camera$1 = /*@__PURE__*/ new Camera$1();

/**
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

class CameraHelper extends LineSegments {

	constructor( camera ) {

		const geometry = new BufferGeometry();
		const material = new LineBasicMaterial( { color: 0xffffff, vertexColors: true, toneMapped: false } );

		const vertices = [];
		const colors = [];

		const pointMap = {};

		// colors

		const colorFrustum = new Color$1( 0xffaa00 );
		const colorCone = new Color$1( 0xff0000 );
		const colorUp = new Color$1( 0x00aaff );
		const colorTarget = new Color$1( 0xffffff );
		const colorCross = new Color$1( 0x333333 );

		// near

		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );

		// far

		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );

		// sides

		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );

		// cone

		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );

		// up

		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );

		// target

		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );

		// cross

		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );

		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );

		function addLine( a, b, color ) {

			addPoint( a, color );
			addPoint( b, color );

		}

		function addPoint( id, color ) {

			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );

			if ( pointMap[ id ] === undefined ) {

				pointMap[ id ] = [];

			}

			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

		}

		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		super( geometry, material );

		this.type = 'CameraHelper';

		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;

		this.pointMap = pointMap;

		this.update();

	}

	update() {

		const geometry = this.geometry;
		const pointMap = this.pointMap;

		const w = 1, h = 1;

		// we need just camera projection matrix inverse
		// world matrix must be identity

		_camera$1.projectionMatrixInverse.copy( this.camera.projectionMatrixInverse );

		// center / target

		setPoint( 'c', pointMap, geometry, _camera$1, 0, 0, - 1 );
		setPoint( 't', pointMap, geometry, _camera$1, 0, 0, 1 );

		// near

		setPoint( 'n1', pointMap, geometry, _camera$1, - w, - h, - 1 );
		setPoint( 'n2', pointMap, geometry, _camera$1, w, - h, - 1 );
		setPoint( 'n3', pointMap, geometry, _camera$1, - w, h, - 1 );
		setPoint( 'n4', pointMap, geometry, _camera$1, w, h, - 1 );

		// far

		setPoint( 'f1', pointMap, geometry, _camera$1, - w, - h, 1 );
		setPoint( 'f2', pointMap, geometry, _camera$1, w, - h, 1 );
		setPoint( 'f3', pointMap, geometry, _camera$1, - w, h, 1 );
		setPoint( 'f4', pointMap, geometry, _camera$1, w, h, 1 );

		// up

		setPoint( 'u1', pointMap, geometry, _camera$1, w * 0.7, h * 1.1, - 1 );
		setPoint( 'u2', pointMap, geometry, _camera$1, - w * 0.7, h * 1.1, - 1 );
		setPoint( 'u3', pointMap, geometry, _camera$1, 0, h * 2, - 1 );

		// cross

		setPoint( 'cf1', pointMap, geometry, _camera$1, - w, 0, 1 );
		setPoint( 'cf2', pointMap, geometry, _camera$1, w, 0, 1 );
		setPoint( 'cf3', pointMap, geometry, _camera$1, 0, - h, 1 );
		setPoint( 'cf4', pointMap, geometry, _camera$1, 0, h, 1 );

		setPoint( 'cn1', pointMap, geometry, _camera$1, - w, 0, - 1 );
		setPoint( 'cn2', pointMap, geometry, _camera$1, w, 0, - 1 );
		setPoint( 'cn3', pointMap, geometry, _camera$1, 0, - h, - 1 );
		setPoint( 'cn4', pointMap, geometry, _camera$1, 0, h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	}

}


function setPoint( point, pointMap, geometry, camera, x, y, z ) {

	_vector$c.set( x, y, z ).unproject( camera );

	const points = pointMap[ point ];

	if ( points !== undefined ) {

		const position = geometry.getAttribute( 'position' );

		for ( let i = 0, l = points.length; i < l; i ++ ) {

			position.setXYZ( points[ i ], _vector$c.x, _vector$c.y, _vector$c.z );

		}

	}

}

const _box$3 = /*@__PURE__*/ new Box3();

class BoxHelper extends LineSegments {

	constructor( object, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		const positions = new Float32Array( 8 * 3 );

		const geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.setAttribute( 'position', new BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.object = object;
		this.type = 'BoxHelper';

		this.matrixAutoUpdate = false;

		this.update();

	}

	update( object ) {

		if ( object !== undefined ) {

			console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );

		}

		if ( this.object !== undefined ) {

			_box$3.setFromObject( this.object );

		}

		if ( _box$3.isEmpty() ) return;

		const min = _box$3.min;
		const max = _box$3.max;

		/*
			5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		const position = this.geometry.attributes.position;
		const array = position.array;

		array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
		array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
		array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
		array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();


	}

	setFromObject( object ) {

		this.object = object;
		this.update();

		return this;

	}

	copy( source ) {

		LineSegments.prototype.copy.call( this, source );

		this.object = source.object;

		return this;

	}

}

class Box3Helper extends LineSegments {

	constructor( box, color = 0xffff00 ) {

		const indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );

		const positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];

		const geometry = new BufferGeometry();

		geometry.setIndex( new BufferAttribute( indices, 1 ) );

		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.box = box;

		this.type = 'Box3Helper';

		this.geometry.computeBoundingSphere();

	}

	updateMatrixWorld( force ) {

		const box = this.box;

		if ( box.isEmpty() ) return;

		box.getCenter( this.position );

		box.getSize( this.scale );

		this.scale.multiplyScalar( 0.5 );

		super.updateMatrixWorld( force );

	}

}

class PlaneHelper extends Line$1 {

	constructor( plane, size = 1, hex = 0xffff00 ) {

		const color = hex;

		const positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();

		super( geometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );

		this.type = 'PlaneHelper';

		this.plane = plane;

		this.size = size;

		const positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];

		const geometry2 = new BufferGeometry();
		geometry2.setAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();

		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false, toneMapped: false } ) ) );

	}

	updateMatrixWorld( force ) {

		let scale = - this.plane.constant;

		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter

		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );

		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here

		this.lookAt( this.plane.normal );

		super.updateMatrixWorld( force );

	}

}

const _axis = /*@__PURE__*/ new Vector3$1();
let _lineGeometry, _coneGeometry;

class ArrowHelper extends Object3D {

	// dir is assumed to be normalized

	constructor( dir = new Vector3$1( 0, 0, 1 ), origin = new Vector3$1( 0, 0, 0 ), length = 1, color = 0xffff00, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		super();

		this.type = 'ArrowHelper';

		if ( _lineGeometry === undefined ) {

			_lineGeometry = new BufferGeometry();
			_lineGeometry.setAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

			_coneGeometry = new CylinderGeometry( 0, 0.5, 1, 5, 1 );
			_coneGeometry.translate( 0, - 0.5, 0 );

		}

		this.position.copy( origin );

		this.line = new Line$1( _lineGeometry, new LineBasicMaterial( { color: color, toneMapped: false } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );

		this.cone = new Mesh( _coneGeometry, new MeshBasicMaterial( { color: color, toneMapped: false } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );

		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );

	}

	setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			_axis.set( dir.z, 0, - dir.x ).normalize();

			const radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( _axis, radians );

		}

	}

	setLength( length, headLength = length * 0.2, headWidth = headLength * 0.2 ) {

		this.line.scale.set( 1, Math.max( 0.0001, length - headLength ), 1 ); // see #17458
		this.line.updateMatrix();

		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();

	}

	setColor( color ) {

		this.line.material.color.set( color );
		this.cone.material.color.set( color );

	}

	copy( source ) {

		super.copy( source, false );

		this.line.copy( source.line );
		this.cone.copy( source.cone );

		return this;

	}

}

class AxesHelper$1 extends LineSegments {

	constructor( size = 1 ) {

		const vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];

		const colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];

		const geometry = new BufferGeometry();
		geometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.setAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

		const material = new LineBasicMaterial( { vertexColors: true, toneMapped: false } );

		super( geometry, material );

		this.type = 'AxesHelper';

	}

}

const _floatView = new Float32Array( 1 );
const _int32View = new Int32Array( _floatView.buffer );

const DataUtils = {

	// Converts float32 to float16 (stored as uint16 value).

	toHalfFloat: function ( val ) {

		// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410

		/* This method is faster than the OpenEXR implementation (very often
		* used, eg. in Ogre), with the additional benefit of rounding, inspired
		* by James Tursa?s half-precision code. */

		_floatView[ 0 ] = val;
		const x = _int32View[ 0 ];

		let bits = ( x >> 16 ) & 0x8000; /* Get the sign */
		let m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */
		const e = ( x >> 23 ) & 0xff; /* Using int is faster here */

		/* If zero, or denormal, or exponent underflows too much for a denormal
			* half, return signed zero. */
		if ( e < 103 ) return bits;

		/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */
		if ( e > 142 ) {

			bits |= 0x7c00;
			/* If exponent was 0xff and one mantissa bit was set, it means NaN,
						* not Inf, so make sure we set one mantissa bit too. */
			bits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );
			return bits;

		}

		/* If exponent underflows but not too much, return a denormal */
		if ( e < 113 ) {

			m |= 0x0800;
			/* Extra rounding may overflow and set mantissa to 0 and exponent
				* to 1, which is OK. */
			bits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );
			return bits;

		}

		bits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );
		/* Extra rounding. An overflow will set mantissa to 0 and increment
			* the exponent, which is OK. */
		bits += m & 1;
		return bits;

	}

};

const LOD_MIN = 4;
const LOD_MAX = 8;
const SIZE_MAX = Math.pow( 2, LOD_MAX );

// The standard deviations (radians) associated with the extra mips. These are
// chosen to approximate a Trowbridge-Reitz distribution function times the
// geometric shadowing function. These sigma values squared must match the
// variance #defines in cube_uv_reflection_fragment.glsl.js.
const EXTRA_LOD_SIGMA = [ 0.125, 0.215, 0.35, 0.446, 0.526, 0.582 ];

const TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;

// The maximum length of the blur for loop. Smaller sigmas will use fewer
// samples and exit early, but not recompile the shader.
const MAX_SAMPLES = 20;

const ENCODINGS = {
	[ LinearEncoding ]: 0,
	[ sRGBEncoding ]: 1,
	[ RGBEEncoding ]: 2,
	[ RGBM7Encoding ]: 3,
	[ RGBM16Encoding ]: 4,
	[ RGBDEncoding ]: 5,
	[ GammaEncoding ]: 6
};

const backgroundMaterial = new MeshBasicMaterial( {
	side: BackSide,
	depthWrite: false,
	depthTest: false,
} );
const backgroundBox = new Mesh( new BoxGeometry(), backgroundMaterial );

const _flatCamera = /*@__PURE__*/ new OrthographicCamera();
const { _lodPlanes, _sizeLods, _sigmas } = /*@__PURE__*/ _createPlanes();
const _clearColor = /*@__PURE__*/ new Color$1();
let _oldTarget = null;

// Golden Ratio
const PHI = ( 1 + Math.sqrt( 5 ) ) / 2;
const INV_PHI = 1 / PHI;

// Vertices of a dodecahedron (except the opposites, which represent the
// same axis), used as axis directions evenly spread on a sphere.
const _axisDirections = [
	/*@__PURE__*/ new Vector3$1( 1, 1, 1 ),
	/*@__PURE__*/ new Vector3$1( - 1, 1, 1 ),
	/*@__PURE__*/ new Vector3$1( 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3$1( - 1, 1, - 1 ),
	/*@__PURE__*/ new Vector3$1( 0, PHI, INV_PHI ),
	/*@__PURE__*/ new Vector3$1( 0, PHI, - INV_PHI ),
	/*@__PURE__*/ new Vector3$1( INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3$1( - INV_PHI, 0, PHI ),
	/*@__PURE__*/ new Vector3$1( PHI, INV_PHI, 0 ),
	/*@__PURE__*/ new Vector3$1( - PHI, INV_PHI, 0 ) ];

/**
 * This class generates a Prefiltered, Mipmapped Radiance Environment Map
 * (PMREM) from a cubeMap environment texture. This allows different levels of
 * blur to be quickly accessed based on material roughness. It is packed into a
 * special CubeUV format that allows us to perform custom interpolation so that
 * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
 * chain, it only goes down to the LOD_MIN level (above), and then creates extra
 * even more filtered 'mips' at the same LOD_MIN resolution, associated with
 * higher roughness levels. In this way we maintain resolution to smoothly
 * interpolate diffuse lighting while limiting sampling computation.
 */

function convertLinearToRGBE( color ) {

	const maxComponent = Math.max( color.r, color.g, color.b );
	const fExp = Math.min( Math.max( Math.ceil( Math.log2( maxComponent ) ), - 128.0 ), 127.0 );
	color.multiplyScalar( Math.pow( 2.0, - fExp ) );

	const alpha = ( fExp + 128.0 ) / 255.0;
	return alpha;

}

class PMREMGenerator {

	constructor( renderer ) {

		this._renderer = renderer;
		this._pingPongRenderTarget = null;

		this._blurMaterial = _getBlurShader( MAX_SAMPLES );
		this._equirectShader = null;
		this._cubemapShader = null;

		this._compileMaterial( this._blurMaterial );

	}

	/**
	 * Generates a PMREM from a supplied Scene, which can be faster than using an
	 * image if networking bandwidth is low. Optional sigma specifies a blur radius
	 * in radians to be applied to the scene before PMREM generation. Optional near
	 * and far planes ensure the scene is rendered in its entirety (the cubeCamera
	 * is placed at the origin).
	 */
	fromScene( scene, sigma = 0, near = 0.1, far = 100 ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets();

		this._sceneToCubeUV( scene, near, far, cubeUVRenderTarget );
		if ( sigma > 0 ) {

			this._blur( cubeUVRenderTarget, 0, 0, sigma );

		}

		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	/**
	 * Generates a PMREM from an equirectangular texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input image size is 1k (1024 x 512),
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromEquirectangular( equirectangular ) {

		return this._fromTexture( equirectangular );

	}

	/**
	 * Generates a PMREM from an cubemap texture, which can be either LDR
	 * (RGBFormat) or HDR (RGBEFormat). The ideal input cube size is 256 x 256,
	 * as this matches best with the 256 x 256 cubemap output.
	 */
	fromCubemap( cubemap ) {

		return this._fromTexture( cubemap );

	}

	/**
	 * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileCubemapShader() {

		if ( this._cubemapShader === null ) {

			this._cubemapShader = _getCubemapShader();
			this._compileMaterial( this._cubemapShader );

		}

	}

	/**
	 * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
	 * your texture's network fetch for increased concurrency.
	 */
	compileEquirectangularShader() {

		if ( this._equirectShader === null ) {

			this._equirectShader = _getEquirectShader();
			this._compileMaterial( this._equirectShader );

		}

	}

	/**
	 * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
	 * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
	 * one of them will cause any others to also become unusable.
	 */
	dispose() {

		this._blurMaterial.dispose();

		if ( this._cubemapShader !== null ) this._cubemapShader.dispose();
		if ( this._equirectShader !== null ) this._equirectShader.dispose();

		for ( let i = 0; i < _lodPlanes.length; i ++ ) {

			_lodPlanes[ i ].dispose();

		}

	}

	// private interface

	_cleanup( outputTarget ) {

		this._pingPongRenderTarget.dispose();
		this._renderer.setRenderTarget( _oldTarget );
		outputTarget.scissorTest = false;
		_setViewport( outputTarget, 0, 0, outputTarget.width, outputTarget.height );

	}

	_fromTexture( texture ) {

		_oldTarget = this._renderer.getRenderTarget();
		const cubeUVRenderTarget = this._allocateTargets( texture );
		this._textureToCubeUV( texture, cubeUVRenderTarget );
		this._applyPMREM( cubeUVRenderTarget );
		this._cleanup( cubeUVRenderTarget );

		return cubeUVRenderTarget;

	}

	_allocateTargets( texture ) { // warning: null texture is valid

		const params = {
			magFilter: NearestFilter,
			minFilter: NearestFilter,
			generateMipmaps: false,
			type: UnsignedByteType,
			format: RGBEFormat,
			encoding: _isLDR( texture ) ? texture.encoding : RGBEEncoding,
			depthBuffer: false
		};

		const cubeUVRenderTarget = _createRenderTarget( params );
		cubeUVRenderTarget.depthBuffer = texture ? false : true;
		this._pingPongRenderTarget = _createRenderTarget( params );
		return cubeUVRenderTarget;

	}

	_compileMaterial( material ) {

		const tmpMesh = new Mesh( _lodPlanes[ 0 ], material );
		this._renderer.compile( tmpMesh, _flatCamera );

	}

	_sceneToCubeUV( scene, near, far, cubeUVRenderTarget ) {

		const fov = 90;
		const aspect = 1;
		const cubeCamera = new PerspectiveCamera( fov, aspect, near, far );
		const upSign = [ 1, - 1, 1, 1, 1, 1 ];
		const forwardSign = [ 1, 1, 1, - 1, - 1, - 1 ];
		const renderer = this._renderer;

		const originalAutoClear = renderer.autoClear;
		const outputEncoding = renderer.outputEncoding;
		const toneMapping = renderer.toneMapping;
		renderer.getClearColor( _clearColor );

		renderer.toneMapping = NoToneMapping;
		renderer.outputEncoding = LinearEncoding;
		renderer.autoClear = false;

		let useSolidColor = false;
		const background = scene.background;
		if ( background ) {

			if ( background.isColor ) {

				backgroundMaterial.color.copy( background ).convertSRGBToLinear();
				scene.background = null;

				const alpha = convertLinearToRGBE( backgroundMaterial.color );
				backgroundMaterial.opacity = alpha;
				useSolidColor = true;

			}

		} else {

			backgroundMaterial.color.copy( _clearColor ).convertSRGBToLinear();

			const alpha = convertLinearToRGBE( backgroundMaterial.color );
			backgroundMaterial.opacity = alpha;
			useSolidColor = true;

		}


		for ( let i = 0; i < 6; i ++ ) {

			const col = i % 3;
			if ( col == 0 ) {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( forwardSign[ i ], 0, 0 );

			} else if ( col == 1 ) {

				cubeCamera.up.set( 0, 0, upSign[ i ] );
				cubeCamera.lookAt( 0, forwardSign[ i ], 0 );

			} else {

				cubeCamera.up.set( 0, upSign[ i ], 0 );
				cubeCamera.lookAt( 0, 0, forwardSign[ i ] );

			}

			_setViewport( cubeUVRenderTarget,
				col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX );
			renderer.setRenderTarget( cubeUVRenderTarget );

			if ( useSolidColor ) {

				renderer.render( backgroundBox, cubeCamera );

			}

			renderer.render( scene, cubeCamera );

		}

		renderer.toneMapping = toneMapping;
		renderer.outputEncoding = outputEncoding;
		renderer.autoClear = originalAutoClear;

	}

	_textureToCubeUV( texture, cubeUVRenderTarget ) {

		const renderer = this._renderer;

		if ( texture.isCubeTexture ) {

			if ( this._cubemapShader == null ) {

				this._cubemapShader = _getCubemapShader();

			}

		} else {

			if ( this._equirectShader == null ) {

				this._equirectShader = _getEquirectShader();

			}

		}

		const material = texture.isCubeTexture ? this._cubemapShader : this._equirectShader;
		const mesh = new Mesh( _lodPlanes[ 0 ], material );

		const uniforms = material.uniforms;

		uniforms[ 'envMap' ].value = texture;

		if ( ! texture.isCubeTexture ) {

			uniforms[ 'texelSize' ].value.set( 1.0 / texture.image.width, 1.0 / texture.image.height );

		}

		uniforms[ 'inputEncoding' ].value = ENCODINGS[ texture.encoding ];
		uniforms[ 'outputEncoding' ].value = ENCODINGS[ cubeUVRenderTarget.texture.encoding ];

		_setViewport( cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX );

		renderer.setRenderTarget( cubeUVRenderTarget );
		renderer.render( mesh, _flatCamera );

	}

	_applyPMREM( cubeUVRenderTarget ) {

		const renderer = this._renderer;
		const autoClear = renderer.autoClear;
		renderer.autoClear = false;

		for ( let i = 1; i < TOTAL_LODS; i ++ ) {

			const sigma = Math.sqrt( _sigmas[ i ] * _sigmas[ i ] - _sigmas[ i - 1 ] * _sigmas[ i - 1 ] );

			const poleAxis = _axisDirections[ ( i - 1 ) % _axisDirections.length ];

			this._blur( cubeUVRenderTarget, i - 1, i, sigma, poleAxis );

		}

		renderer.autoClear = autoClear;

	}

	/**
	 * This is a two-pass Gaussian blur for a cubemap. Normally this is done
	 * vertically and horizontally, but this breaks down on a cube. Here we apply
	 * the blur latitudinally (around the poles), and then longitudinally (towards
	 * the poles) to approximate the orthogonally-separable blur. It is least
	 * accurate at the poles, but still does a decent job.
	 */
	_blur( cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis ) {

		const pingPongRenderTarget = this._pingPongRenderTarget;

		this._halfBlur(
			cubeUVRenderTarget,
			pingPongRenderTarget,
			lodIn,
			lodOut,
			sigma,
			'latitudinal',
			poleAxis );

		this._halfBlur(
			pingPongRenderTarget,
			cubeUVRenderTarget,
			lodOut,
			lodOut,
			sigma,
			'longitudinal',
			poleAxis );

	}

	_halfBlur( targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis ) {

		const renderer = this._renderer;
		const blurMaterial = this._blurMaterial;

		if ( direction !== 'latitudinal' && direction !== 'longitudinal' ) {

			console.error(
				'blur direction must be either latitudinal or longitudinal!' );

		}

		// Number of standard deviations at which to cut off the discrete approximation.
		const STANDARD_DEVIATIONS = 3;

		const blurMesh = new Mesh( _lodPlanes[ lodOut ], blurMaterial );
		const blurUniforms = blurMaterial.uniforms;

		const pixels = _sizeLods[ lodIn ] - 1;
		const radiansPerPixel = isFinite( sigmaRadians ) ? Math.PI / ( 2 * pixels ) : 2 * Math.PI / ( 2 * MAX_SAMPLES - 1 );
		const sigmaPixels = sigmaRadians / radiansPerPixel;
		const samples = isFinite( sigmaRadians ) ? 1 + Math.floor( STANDARD_DEVIATIONS * sigmaPixels ) : MAX_SAMPLES;

		if ( samples > MAX_SAMPLES ) {

			console.warn( `sigmaRadians, ${
				sigmaRadians}, is too large and will clip, as it requested ${
				samples} samples when the maximum is set to ${MAX_SAMPLES}` );

		}

		const weights = [];
		let sum = 0;

		for ( let i = 0; i < MAX_SAMPLES; ++ i ) {

			const x = i / sigmaPixels;
			const weight = Math.exp( - x * x / 2 );
			weights.push( weight );

			if ( i == 0 ) {

				sum += weight;

			} else if ( i < samples ) {

				sum += 2 * weight;

			}

		}

		for ( let i = 0; i < weights.length; i ++ ) {

			weights[ i ] = weights[ i ] / sum;

		}

		blurUniforms[ 'envMap' ].value = targetIn.texture;
		blurUniforms[ 'samples' ].value = samples;
		blurUniforms[ 'weights' ].value = weights;
		blurUniforms[ 'latitudinal' ].value = direction === 'latitudinal';

		if ( poleAxis ) {

			blurUniforms[ 'poleAxis' ].value = poleAxis;

		}

		blurUniforms[ 'dTheta' ].value = radiansPerPixel;
		blurUniforms[ 'mipInt' ].value = LOD_MAX - lodIn;
		blurUniforms[ 'inputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];
		blurUniforms[ 'outputEncoding' ].value = ENCODINGS[ targetIn.texture.encoding ];

		const outputSize = _sizeLods[ lodOut ];
		const x = 3 * Math.max( 0, SIZE_MAX - 2 * outputSize );
		const y = ( lodOut === 0 ? 0 : 2 * SIZE_MAX ) + 2 * outputSize * ( lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0 );

		_setViewport( targetOut, x, y, 3 * outputSize, 2 * outputSize );
		renderer.setRenderTarget( targetOut );
		renderer.render( blurMesh, _flatCamera );

	}

}

function _isLDR( texture ) {

	if ( texture === undefined || texture.type !== UnsignedByteType ) return false;

	return texture.encoding === LinearEncoding || texture.encoding === sRGBEncoding || texture.encoding === GammaEncoding;

}

function _createPlanes() {

	const _lodPlanes = [];
	const _sizeLods = [];
	const _sigmas = [];

	let lod = LOD_MAX;

	for ( let i = 0; i < TOTAL_LODS; i ++ ) {

		const sizeLod = Math.pow( 2, lod );
		_sizeLods.push( sizeLod );
		let sigma = 1.0 / sizeLod;

		if ( i > LOD_MAX - LOD_MIN ) {

			sigma = EXTRA_LOD_SIGMA[ i - LOD_MAX + LOD_MIN - 1 ];

		} else if ( i == 0 ) {

			sigma = 0;

		}

		_sigmas.push( sigma );

		const texelSize = 1.0 / ( sizeLod - 1 );
		const min = - texelSize / 2;
		const max = 1 + texelSize / 2;
		const uv1 = [ min, min, max, min, max, max, min, min, max, max, min, max ];

		const cubeFaces = 6;
		const vertices = 6;
		const positionSize = 3;
		const uvSize = 2;
		const faceIndexSize = 1;

		const position = new Float32Array( positionSize * vertices * cubeFaces );
		const uv = new Float32Array( uvSize * vertices * cubeFaces );
		const faceIndex = new Float32Array( faceIndexSize * vertices * cubeFaces );

		for ( let face = 0; face < cubeFaces; face ++ ) {

			const x = ( face % 3 ) * 2 / 3 - 1;
			const y = face > 2 ? 0 : - 1;
			const coordinates = [
				x, y, 0,
				x + 2 / 3, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y, 0,
				x + 2 / 3, y + 1, 0,
				x, y + 1, 0
			];
			position.set( coordinates, positionSize * vertices * face );
			uv.set( uv1, uvSize * vertices * face );
			const fill = [ face, face, face, face, face, face ];
			faceIndex.set( fill, faceIndexSize * vertices * face );

		}

		const planes = new BufferGeometry();
		planes.setAttribute( 'position', new BufferAttribute( position, positionSize ) );
		planes.setAttribute( 'uv', new BufferAttribute( uv, uvSize ) );
		planes.setAttribute( 'faceIndex', new BufferAttribute( faceIndex, faceIndexSize ) );
		_lodPlanes.push( planes );

		if ( lod > LOD_MIN ) {

			lod --;

		}

	}

	return { _lodPlanes, _sizeLods, _sigmas };

}

function _createRenderTarget( params ) {

	const cubeUVRenderTarget = new WebGLRenderTarget( 3 * SIZE_MAX, 3 * SIZE_MAX, params );
	cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
	cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
	cubeUVRenderTarget.scissorTest = true;
	return cubeUVRenderTarget;

}

function _setViewport( target, x, y, width, height ) {

	target.viewport.set( x, y, width, height );
	target.scissor.set( x, y, width, height );

}

function _getBlurShader( maxSamples ) {

	const weights = new Float32Array( maxSamples );
	const poleAxis = new Vector3$1( 0, 1, 0 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'SphericalGaussianBlur',

		defines: { 'n': maxSamples },

		uniforms: {
			'envMap': { value: null },
			'samples': { value: 1 },
			'weights': { value: weights },
			'latitudinal': { value: false },
			'dTheta': { value: 0 },
			'mipInt': { value: 0 },
			'poleAxis': { value: poleAxis },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			${ _getEncodings() }

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getEquirectShader() {

	const texelSize = new Vector2( 1, 1 );
	const shaderMaterial = new RawShaderMaterial( {

		name: 'EquirectangularToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'texelSize': { value: texelSize },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform vec2 texelSize;

			${ _getEncodings() }

			#include <common>

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				vec2 f = fract( uv / texelSize - 0.5 );
				uv -= f * texelSize;
				vec3 tl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x += texelSize.x;
				vec3 tr = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.y += texelSize.y;
				vec3 br = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;
				uv.x -= texelSize.x;
				vec3 bl = envMapTexelToLinear( texture2D ( envMap, uv ) ).rgb;

				vec3 tm = mix( tl, tr, f.x );
				vec3 bm = mix( bl, br, f.x );
				gl_FragColor.rgb = mix( tm, bm, f.y );

				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCubemapShader() {

	const shaderMaterial = new RawShaderMaterial( {

		name: 'CubemapToCubeUV',

		uniforms: {
			'envMap': { value: null },
			'inputEncoding': { value: ENCODINGS[ LinearEncoding ] },
			'outputEncoding': { value: ENCODINGS[ LinearEncoding ] }
		},

		vertexShader: _getCommonVertexShader(),

		fragmentShader: /* glsl */`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			${ _getEncodings() }

			void main() {

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb = envMapTexelToLinear( textureCube( envMap, vec3( - vOutputDirection.x, vOutputDirection.yz ) ) ).rgb;
				gl_FragColor = linearToOutputTexel( gl_FragColor );

			}
		`,

		blending: NoBlending,
		depthTest: false,
		depthWrite: false

	} );

	return shaderMaterial;

}

function _getCommonVertexShader() {

	return /* glsl */`

		precision mediump float;
		precision mediump int;

		attribute vec3 position;
		attribute vec2 uv;
		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`;

}

function _getEncodings() {

	return /* glsl */`

		uniform int inputEncoding;
		uniform int outputEncoding;

		#include <encodings_pars_fragment>

		vec4 inputTexelToLinear( vec4 value ) {

			if ( inputEncoding == 0 ) {

				return value;

			} else if ( inputEncoding == 1 ) {

				return sRGBToLinear( value );

			} else if ( inputEncoding == 2 ) {

				return RGBEToLinear( value );

			} else if ( inputEncoding == 3 ) {

				return RGBMToLinear( value, 7.0 );

			} else if ( inputEncoding == 4 ) {

				return RGBMToLinear( value, 16.0 );

			} else if ( inputEncoding == 5 ) {

				return RGBDToLinear( value, 256.0 );

			} else {

				return GammaToLinear( value, 2.2 );

			}

		}

		vec4 linearToOutputTexel( vec4 value ) {

			if ( outputEncoding == 0 ) {

				return value;

			} else if ( outputEncoding == 1 ) {

				return LinearTosRGB( value );

			} else if ( outputEncoding == 2 ) {

				return LinearToRGBE( value );

			} else if ( outputEncoding == 3 ) {

				return LinearToRGBM( value, 7.0 );

			} else if ( outputEncoding == 4 ) {

				return LinearToRGBM( value, 16.0 );

			} else if ( outputEncoding == 5 ) {

				return LinearToRGBD( value, 256.0 );

			} else {

				return LinearToGamma( value, 2.2 );

			}

		}

		vec4 envMapTexelToLinear( vec4 color ) {

			return inputTexelToLinear( color );

		}
	`;

}

const LineStrip = 0;
const LinePieces = 1;
const NoColors = 0;
const FaceColors = 1;
const VertexColors = 2;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
	return materials;

}

function MultiMaterial( materials = [] ) {

	console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
	materials.isMultiMaterial = true;
	materials.materials = materials;
	materials.clone = function () {

		return materials.slice();

	};

	return materials;

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite$1( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3$1( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setUsage( THREE.DynamicDrawUsage ) instead.' );
	return new BufferAttribute( array, itemSize ).setUsage( DynamicDrawUsage );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

Curve.create = function ( construct, getPoint ) {

	console.log( 'THREE.Curve.create() has been deprecated' );

	construct.prototype = Object.create( Curve.prototype );
	construct.prototype.constructor = construct;
	construct.prototype.getPoint = getPoint;

	return construct;

};

//

Path.prototype.fromPoints = function ( points ) {

	console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
	return this.setFromPoints( points );

};

//

function AxisHelper( size ) {

	console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
	return new AxesHelper$1( size );

}

function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

SkeletonHelper.prototype.update = function () {

	console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

Loader$1.prototype.extractUrlBase = function ( url ) {

	console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
	return LoaderUtils.extractUrlBase( url );

};

Loader$1.Handlers = {

	add: function ( /* regex, loader */ ) {

		console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

	},

	get: function ( /* file */ ) {

		console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

	}

};

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

function BinaryTextureLoader( manager ) {

	console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
	return new DataTextureLoader( manager );

}

//

Box2.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box2.prototype.empty = function () {

	console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box2.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box2.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Box3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

Box3.prototype.empty = function () {

	console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

Box3.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Box3.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

Box3.prototype.size = function ( optionalTarget ) {

	console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
	return this.getSize( optionalTarget );

};

//

Sphere$1.prototype.empty = function () {

	console.warn( 'THREE.Sphere: .empty() has been renamed to .isEmpty().' );
	return this.isEmpty();

};

//

Frustum$1.prototype.setFromMatrix = function ( m ) {

	console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
	return this.setFromProjectionMatrix( m );

};

//

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

//

MathUtils.random16 = function () {

	console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

MathUtils.nearestPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
	return MathUtils.floorPowerOfTwo( value );

};

MathUtils.nextPowerOfTwo = function ( value ) {

	console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
	return MathUtils.ceilPowerOfTwo( value );

};

//

Matrix3.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix3.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
	return vector.applyMatrix3( this );

};

Matrix3.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

};

Matrix3.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
	return attribute.applyMatrix3( this );

};

Matrix3.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

};

Matrix3.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix3: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Matrix4.prototype.extractPosition = function ( m ) {

	console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
	return this.copyPosition( m );

};

Matrix4.prototype.flattenToArrayOffset = function ( array, offset ) {

	console.warn( 'THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead.' );
	return this.toArray( array, offset );

};

Matrix4.prototype.getPosition = function () {

	console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
	return new Vector3$1().setFromMatrixColumn( this, 3 );

};

Matrix4.prototype.setRotationFromQuaternion = function ( q ) {

	console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
	return this.makeRotationFromQuaternion( q );

};

Matrix4.prototype.multiplyToArray = function () {

	console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

};

Matrix4.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector4 = function ( vector ) {

	console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.multiplyVector3Array = function ( /* a */ ) {

	console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

};

Matrix4.prototype.rotateAxis = function ( v ) {

	console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
	v.transformDirection( this );

};

Matrix4.prototype.crossVector = function ( vector ) {

	console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
	return vector.applyMatrix4( this );

};

Matrix4.prototype.translate = function () {

	console.error( 'THREE.Matrix4: .translate() has been removed.' );

};

Matrix4.prototype.rotateX = function () {

	console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

};

Matrix4.prototype.rotateY = function () {

	console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

};

Matrix4.prototype.rotateZ = function () {

	console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

};

Matrix4.prototype.rotateByAxis = function () {

	console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

};

Matrix4.prototype.applyToBufferAttribute = function ( attribute ) {

	console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
	return attribute.applyMatrix4( this );

};

Matrix4.prototype.applyToVector3Array = function ( /* array, offset, length */ ) {

	console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

};

Matrix4.prototype.makeFrustum = function ( left, right, bottom, top, near, far ) {

	console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
	return this.makePerspective( left, right, top, bottom, near, far );

};

Matrix4.prototype.getInverse = function ( matrix ) {

	console.warn( 'THREE.Matrix4: .getInverse() has been removed. Use matrixInv.copy( matrix ).invert(); instead.' );
	return this.copy( matrix ).invert();

};

//

Plane$1.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

//

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Quaternion.prototype.inverse = function ( ) {

	console.warn( 'THREE.Quaternion: .inverse() has been renamed to invert().' );
	return this.invert();

};

//

Ray.prototype.isIntersectionBox = function ( box ) {

	console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
	return this.intersectsBox( box );

};

Ray.prototype.isIntersectionPlane = function ( plane ) {

	console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
	return this.intersectsPlane( plane );

};

Ray.prototype.isIntersectionSphere = function ( sphere ) {

	console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
	return this.intersectsSphere( sphere );

};

//

Triangle.prototype.area = function () {

	console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
	return this.getArea();

};

Triangle.prototype.barycoordFromPoint = function ( point, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return this.getBarycoord( point, target );

};

Triangle.prototype.midpoint = function ( target ) {

	console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
	return this.getMidpoint( target );

};

Triangle.prototypenormal = function ( target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return this.getNormal( target );

};

Triangle.prototype.plane = function ( target ) {

	console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
	return this.getPlane( target );

};

Triangle.barycoordFromPoint = function ( point, a, b, c, target ) {

	console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
	return Triangle.getBarycoord( point, a, b, c, target );

};

Triangle.normal = function ( a, b, c, target ) {

	console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
	return Triangle.getNormal( a, b, c, target );

};

//

Shape.prototype.extractAllPoints = function ( divisions ) {

	console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
	return this.extractPoints( divisions );

};

Shape.prototype.extrude = function ( options ) {

	console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
	return new ExtrudeGeometry( this, options );

};

Shape.prototype.makeGeometry = function ( options ) {

	console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
	return new ShapeGeometry( this, options );

};

//

Vector2.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector2.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector2.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector3$1.prototype.setEulerFromRotationMatrix = function () {

	console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

};

Vector3$1.prototype.setEulerFromQuaternion = function () {

	console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

};

Vector3$1.prototype.getPositionFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
	return this.setFromMatrixPosition( m );

};

Vector3$1.prototype.getScaleFromMatrix = function ( m ) {

	console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
	return this.setFromMatrixScale( m );

};

Vector3$1.prototype.getColumnFromMatrix = function ( index, matrix ) {

	console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
	return this.setFromMatrixColumn( matrix, index );

};

Vector3$1.prototype.applyProjection = function ( m ) {

	console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
	return this.applyMatrix4( m );

};

Vector3$1.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector3$1.prototype.distanceToManhattan = function ( v ) {

	console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
	return this.manhattanDistanceTo( v );

};

Vector3$1.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Vector4.prototype.fromAttribute = function ( attribute, index, offset ) {

	console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
	return this.fromBufferAttribute( attribute, index, offset );

};

Vector4.prototype.lengthManhattan = function () {

	console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
	return this.manhattanLength();

};

//

Object3D.prototype.getChildByName = function ( name ) {

	console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
	return this.getObjectByName( name );

};

Object3D.prototype.renderDepth = function () {

	console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

};

Object3D.prototype.translate = function ( distance, axis ) {

	console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
	return this.translateOnAxis( axis, distance );

};

Object3D.prototype.getWorldRotation = function () {

	console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

};

Object3D.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Mesh.prototype.setDrawMode = function () {

	console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

};

Object.defineProperties( Mesh.prototype, {

	drawMode: {
		get: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
			return TrianglesDrawMode;

		},
		set: function () {

			console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

	get: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	},
	set: function () {

		console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

	}

} );

SkinnedMesh.prototype.initBones = function () {

	console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );

};

Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

	get: function () {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		return this.arcLengthDivisions;

	},
	set: function ( value ) {

		console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
		this.arcLengthDivisions = value;

	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( 'THREE.PerspectiveCamera.setLens is deprecated. ' +
			'Use .setFocalLength and .filmGauge for a photographic setup.' );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light$1.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	},
	dynamic: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
			this.setUsage( DynamicDrawUsage );

		}
	}

} );

BufferAttribute.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

BufferAttribute.prototype.copyIndicesArray = function ( /* indices */ ) {

	console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

},

BufferAttribute.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

BufferGeometry.prototype.addIndex = function ( index ) {

	console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
	this.setIndex( index );

};

BufferGeometry.prototype.addAttribute = function ( name, attribute ) {

	console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

	if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

		console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

		return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

	}

	if ( name === 'index' ) {

		console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
		this.setIndex( attribute );

		return this;

	}

	return this.setAttribute( name, attribute );

};

BufferGeometry.prototype.addDrawCall = function ( start, count, indexOffset ) {

	if ( indexOffset !== undefined ) {

		console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

	}

	console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
	this.addGroup( start, count );

};

BufferGeometry.prototype.clearDrawCalls = function () {

	console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
	this.clearGroups();

};

BufferGeometry.prototype.computeOffsets = function () {

	console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

};

BufferGeometry.prototype.removeAttribute = function ( name ) {

	console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

	return this.deleteAttribute( name );

};

BufferGeometry.prototype.applyMatrix = function ( matrix ) {

	console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
	return this.applyMatrix4( matrix );

};

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

Object.defineProperties( InstancedBufferGeometry.prototype, {

	maxInstancedCount: {
		get: function () {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			return this.instanceCount;

		},
		set: function ( value ) {

			console.warn( 'THREE.InstancedBufferGeometry: .maxInstancedCount has been renamed to .instanceCount.' );
			this.instanceCount = value;

		}
	}

} );

Object.defineProperties( Raycaster.prototype, {

	linePrecision: {
		get: function () {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			return this.params.Line.threshold;

		},
		set: function ( value ) {

			console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
			this.params.Line.threshold = value;

		}
	}

} );

Object.defineProperties( InterleavedBuffer.prototype, {

	dynamic: {
		get: function () {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			return this.usage === DynamicDrawUsage;

		},
		set: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
			this.setUsage( value );

		}
	}

} );

InterleavedBuffer.prototype.setDynamic = function ( value ) {

	console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
	this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
	return this;

};

InterleavedBuffer.prototype.setArray = function ( /* array */ ) {

	console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

};

//

ExtrudeGeometry.prototype.getArrays = function () {

	console.error( 'THREE.ExtrudeGeometry: .getArrays() has been removed.' );

};

ExtrudeGeometry.prototype.addShapeList = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShapeList() has been removed.' );

};

ExtrudeGeometry.prototype.addShape = function () {

	console.error( 'THREE.ExtrudeGeometry: .addShape() has been removed.' );

};

//

Scene$2.prototype.dispose = function () {

	console.error( 'THREE.Scene: .dispose() has been removed.' );

};

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .wrapAround has been removed.' );

		}
	},

	overdraw: {
		get: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Material: .overdraw has been removed.' );

		}
	},

	wrapRGB: {
		get: function () {

			console.warn( 'THREE.Material: .wrapRGB has been removed.' );
			return new Color$1();

		}
	},

	shading: {
		get: function () {

			console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
			this.flatShading = ( value === FlatShading );

		}
	},

	stencilMask: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			return this.stencilFuncMask;

		},
		set: function ( value ) {

			console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
			this.stencilFuncMask = value;

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( MeshPhysicalMaterial.prototype, {

	transparency: {
		get: function () {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			return this.transmission;

		},
		set: function ( value ) {

			console.warn( 'THREE.MeshPhysicalMaterial: .transparency has been renamed to .transmission.' );
			this.transmission = value;

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

WebGLRenderer.prototype.clearTarget = function ( renderTarget, color, depth, stencil ) {

	console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
	this.setRenderTarget( renderTarget );
	this.clear( color, depth, stencil );

};

WebGLRenderer.prototype.animate = function ( callback ) {

	console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
	this.setAnimationLoop( callback );

};

WebGLRenderer.prototype.getCurrentRenderTarget = function () {

	console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
	return this.getRenderTarget();

};

WebGLRenderer.prototype.getMaxAnisotropy = function () {

	console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
	return this.capabilities.getMaxAnisotropy();

};

WebGLRenderer.prototype.getPrecision = function () {

	console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
	return this.capabilities.precision;

};

WebGLRenderer.prototype.resetGLState = function () {

	console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
	return this.state.reset();

};

WebGLRenderer.prototype.supportsFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
	return this.extensions.get( 'OES_texture_float' );

};

WebGLRenderer.prototype.supportsHalfFloatTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
	return this.extensions.get( 'OES_texture_half_float' );

};

WebGLRenderer.prototype.supportsStandardDerivatives = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
	return this.extensions.get( 'OES_standard_derivatives' );

};

WebGLRenderer.prototype.supportsCompressedTextureS3TC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

};

WebGLRenderer.prototype.supportsCompressedTexturePVRTC = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
	return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

};

WebGLRenderer.prototype.supportsBlendMinMax = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
	return this.extensions.get( 'EXT_blend_minmax' );

};

WebGLRenderer.prototype.supportsVertexTextures = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
	return this.capabilities.vertexTextures;

};

WebGLRenderer.prototype.supportsInstancedArrays = function () {

	console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
	return this.extensions.get( 'ANGLE_instanced_arrays' );

};

WebGLRenderer.prototype.enableScissorTest = function ( boolean ) {

	console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
	this.setScissorTest( boolean );

};

WebGLRenderer.prototype.initMaterial = function () {

	console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

};

WebGLRenderer.prototype.addPrePlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

};

WebGLRenderer.prototype.addPostPlugin = function () {

	console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

};

WebGLRenderer.prototype.updateShadowMap = function () {

	console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

};

WebGLRenderer.prototype.setFaceCulling = function () {

	console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

};

WebGLRenderer.prototype.allocTextureUnit = function () {

	console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

};

WebGLRenderer.prototype.setTexture = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

};

WebGLRenderer.prototype.setTexture2D = function () {

	console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

};

WebGLRenderer.prototype.setTextureCube = function () {

	console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

};

WebGLRenderer.prototype.getActiveMipMapLevel = function () {

	console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
	return this.getActiveMipmapLevel();

};

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* value */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	context: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
			return this.getContext();

		}
	},
	vr: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
			return this.xr;

		}
	},
	gammaInput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

		}
	},
	gammaOutput: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			return false;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
			this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

		}
	},
	toneMappingWhitePoint: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );
			return 1.0;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .toneMappingWhitePoint has been removed.' );

		}
	},

} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function ( /* cullFace */ ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderReverseSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

		}
	},
	renderSingleSided: {
		get: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
			return undefined;

		},
		set: function () {

			console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

		}
	}

} );

function WebGLRenderTargetCube( width, height, options ) {

	console.warn( 'THREE.WebGLRenderTargetCube( width, height, options ) is now WebGLCubeRenderTarget( size, options ).' );
	return new WebGLCubeRenderTarget( width, options );

}

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Object.defineProperties( Audio$2.prototype, {

	load: {
		value: function ( file ) {

			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			const scope = this;
			const audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {

				scope.setBuffer( buffer );

			} );
			return this;

		}
	},
	startTime: {
		set: function () {

			console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

		}
	}

} );

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

	console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
	return this.update( renderer, scene );

};

CubeCamera.prototype.clear = function ( renderer, color, depth, stencil ) {

	console.warn( 'THREE.CubeCamera: .clear() is now .renderTarget.clear().' );
	return this.renderTarget.clear( renderer, color, depth, stencil );

};

ImageUtils.crossOrigin = undefined;

ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

	const loader = new TextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( url, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

	console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

	const loader = new CubeTextureLoader();
	loader.setCrossOrigin( this.crossOrigin );

	const texture = loader.load( urls, onLoad, undefined, onError );

	if ( mapping ) texture.mapping = mapping;

	return texture;

};

ImageUtils.loadCompressedTexture = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

};

ImageUtils.loadCompressedTextureCube = function () {

	console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

};

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been removed' );

}

//

function JSONLoader() {

	console.error( 'THREE.JSONLoader has been removed.' );

}

//

const SceneUtils = {

	createMultiMaterialObject: function ( /* geometry, materials */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	detach: function ( /* child, parent, scene */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	},

	attach: function ( /* child, scene, parent */ ) {

		console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

	}

};

//

function LensFlare() {

	console.error( 'THREE.LensFlare has been moved to /examples/jsm/objects/Lensflare.js' );

}

if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

	/* eslint-disable no-undef */
	__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
		revision: REVISION,
	} } ) );
	/* eslint-enable no-undef */

}

if ( typeof window !== 'undefined' ) {

	if ( window.__THREE__ ) {

		console.warn( 'WARNING: Multiple instances of Three.js being imported.' );

	} else {

		window.__THREE__ = REVISION;

	}

}var three_module=/*#__PURE__*/Object.freeze({__proto__:null,ACESFilmicToneMapping:ACESFilmicToneMapping,AddEquation:AddEquation,AddOperation:AddOperation,AdditiveAnimationBlendMode:AdditiveAnimationBlendMode,AdditiveBlending:AdditiveBlending,AlphaFormat:AlphaFormat,AlwaysDepth:AlwaysDepth,AlwaysStencilFunc:AlwaysStencilFunc,AmbientLight:AmbientLight$1,AmbientLightProbe:AmbientLightProbe,AnimationClip:AnimationClip,AnimationLoader:AnimationLoader,AnimationMixer:AnimationMixer,AnimationObjectGroup:AnimationObjectGroup,AnimationUtils:AnimationUtils,ArcCurve:ArcCurve,ArrayCamera:ArrayCamera,ArrowHelper:ArrowHelper,Audio:Audio$2,AudioAnalyser:AudioAnalyser,AudioContext:AudioContext,AudioListener:AudioListener,AudioLoader:AudioLoader,AxesHelper:AxesHelper$1,AxisHelper:AxisHelper,BackSide:BackSide,BasicDepthPacking:BasicDepthPacking,BasicShadowMap:BasicShadowMap,BinaryTextureLoader:BinaryTextureLoader,Bone:Bone,BooleanKeyframeTrack:BooleanKeyframeTrack,BoundingBoxHelper:BoundingBoxHelper,Box2:Box2,Box3:Box3,Box3Helper:Box3Helper,BoxBufferGeometry:BoxGeometry,BoxGeometry:BoxGeometry,BoxHelper:BoxHelper,BufferAttribute:BufferAttribute,BufferGeometry:BufferGeometry,BufferGeometryLoader:BufferGeometryLoader,ByteType:ByteType,Cache:Cache,Camera:Camera$1,CameraHelper:CameraHelper,CanvasRenderer:CanvasRenderer,CanvasTexture:CanvasTexture,CatmullRomCurve3:CatmullRomCurve3,CineonToneMapping:CineonToneMapping,CircleBufferGeometry:CircleGeometry,CircleGeometry:CircleGeometry,ClampToEdgeWrapping:ClampToEdgeWrapping,Clock:Clock,Color:Color$1,ColorKeyframeTrack:ColorKeyframeTrack,CompressedTexture:CompressedTexture,CompressedTextureLoader:CompressedTextureLoader,ConeBufferGeometry:ConeGeometry,ConeGeometry:ConeGeometry,CubeCamera:CubeCamera,CubeReflectionMapping:CubeReflectionMapping,CubeRefractionMapping:CubeRefractionMapping,CubeTexture:CubeTexture,CubeTextureLoader:CubeTextureLoader,CubeUVReflectionMapping:CubeUVReflectionMapping,CubeUVRefractionMapping:CubeUVRefractionMapping,CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:CubicBezierCurve3,CubicInterpolant:CubicInterpolant,CullFaceBack:CullFaceBack,CullFaceFront:CullFaceFront,CullFaceFrontBack:CullFaceFrontBack,CullFaceNone:CullFaceNone,Curve:Curve,CurvePath:CurvePath,CustomBlending:CustomBlending,CustomToneMapping:CustomToneMapping,CylinderBufferGeometry:CylinderGeometry,CylinderGeometry:CylinderGeometry,Cylindrical:Cylindrical,DataTexture:DataTexture,DataTexture2DArray:DataTexture2DArray,DataTexture3D:DataTexture3D,DataTextureLoader:DataTextureLoader,DataUtils:DataUtils,DecrementStencilOp:DecrementStencilOp,DecrementWrapStencilOp:DecrementWrapStencilOp,DefaultLoadingManager:DefaultLoadingManager,DepthFormat:DepthFormat,DepthStencilFormat:DepthStencilFormat,DepthTexture:DepthTexture,DirectionalLight:DirectionalLight,DirectionalLightHelper:DirectionalLightHelper,DiscreteInterpolant:DiscreteInterpolant,DodecahedronBufferGeometry:DodecahedronGeometry,DodecahedronGeometry:DodecahedronGeometry,DoubleSide:DoubleSide,DstAlphaFactor:DstAlphaFactor,DstColorFactor:DstColorFactor,DynamicBufferAttribute:DynamicBufferAttribute,DynamicCopyUsage:DynamicCopyUsage,DynamicDrawUsage:DynamicDrawUsage,DynamicReadUsage:DynamicReadUsage,EdgesGeometry:EdgesGeometry,EdgesHelper:EdgesHelper,EllipseCurve:EllipseCurve,EqualDepth:EqualDepth,EqualStencilFunc:EqualStencilFunc,EquirectangularReflectionMapping:EquirectangularReflectionMapping,EquirectangularRefractionMapping:EquirectangularRefractionMapping,Euler:Euler,EventDispatcher:EventDispatcher,ExtrudeBufferGeometry:ExtrudeGeometry,ExtrudeGeometry:ExtrudeGeometry,FaceColors:FaceColors,FileLoader:FileLoader,FlatShading:FlatShading,Float16BufferAttribute:Float16BufferAttribute,Float32Attribute:Float32Attribute,Float32BufferAttribute:Float32BufferAttribute,Float64Attribute:Float64Attribute,Float64BufferAttribute:Float64BufferAttribute,FloatType:FloatType$1,Fog:Fog,FogExp2:FogExp2,Font:Font,FontLoader:FontLoader,FrontSide:FrontSide,Frustum:Frustum$1,GLBufferAttribute:GLBufferAttribute,GLSL1:GLSL1,GLSL3:GLSL3,GammaEncoding:GammaEncoding,GreaterDepth:GreaterDepth,GreaterEqualDepth:GreaterEqualDepth,GreaterEqualStencilFunc:GreaterEqualStencilFunc,GreaterStencilFunc:GreaterStencilFunc,GridHelper:GridHelper,Group:Group,HalfFloatType:HalfFloatType,HemisphereLight:HemisphereLight$1,HemisphereLightHelper:HemisphereLightHelper,HemisphereLightProbe:HemisphereLightProbe,IcosahedronBufferGeometry:IcosahedronGeometry,IcosahedronGeometry:IcosahedronGeometry,ImageBitmapLoader:ImageBitmapLoader,ImageLoader:ImageLoader,ImageUtils:ImageUtils,ImmediateRenderObject:ImmediateRenderObject,IncrementStencilOp:IncrementStencilOp,IncrementWrapStencilOp:IncrementWrapStencilOp,InstancedBufferAttribute:InstancedBufferAttribute,InstancedBufferGeometry:InstancedBufferGeometry,InstancedInterleavedBuffer:InstancedInterleavedBuffer,InstancedMesh:InstancedMesh,Int16Attribute:Int16Attribute,Int16BufferAttribute:Int16BufferAttribute,Int32Attribute:Int32Attribute,Int32BufferAttribute:Int32BufferAttribute,Int8Attribute:Int8Attribute,Int8BufferAttribute:Int8BufferAttribute,IntType:IntType,InterleavedBuffer:InterleavedBuffer,InterleavedBufferAttribute:InterleavedBufferAttribute,Interpolant:Interpolant,InterpolateDiscrete:InterpolateDiscrete,InterpolateLinear:InterpolateLinear,InterpolateSmooth:InterpolateSmooth,InvertStencilOp:InvertStencilOp,JSONLoader:JSONLoader,KeepStencilOp:KeepStencilOp,KeyframeTrack:KeyframeTrack,LOD:LOD,LatheBufferGeometry:LatheGeometry,LatheGeometry:LatheGeometry,Layers:Layers,LensFlare:LensFlare,LessDepth:LessDepth,LessEqualDepth:LessEqualDepth,LessEqualStencilFunc:LessEqualStencilFunc,LessStencilFunc:LessStencilFunc,Light:Light$1,LightProbe:LightProbe,Line:Line$1,Line3:Line3,LineBasicMaterial:LineBasicMaterial,LineCurve:LineCurve,LineCurve3:LineCurve3,LineDashedMaterial:LineDashedMaterial,LineLoop:LineLoop,LinePieces:LinePieces,LineSegments:LineSegments,LineStrip:LineStrip,LinearEncoding:LinearEncoding,LinearFilter:LinearFilter,LinearInterpolant:LinearInterpolant,LinearMipMapLinearFilter:LinearMipMapLinearFilter,LinearMipMapNearestFilter:LinearMipMapNearestFilter,LinearMipmapLinearFilter:LinearMipmapLinearFilter,LinearMipmapNearestFilter:LinearMipmapNearestFilter,LinearToneMapping:LinearToneMapping,Loader:Loader$1,LoaderUtils:LoaderUtils,LoadingManager:LoadingManager,LogLuvEncoding:LogLuvEncoding,LoopOnce:LoopOnce,LoopPingPong:LoopPingPong,LoopRepeat:LoopRepeat,LuminanceAlphaFormat:LuminanceAlphaFormat,LuminanceFormat:LuminanceFormat,MOUSE:MOUSE,Material:Material,MaterialLoader:MaterialLoader,Math:MathUtils,MathUtils:MathUtils,Matrix3:Matrix3,Matrix4:Matrix4,MaxEquation:MaxEquation,Mesh:Mesh,MeshBasicMaterial:MeshBasicMaterial,MeshDepthMaterial:MeshDepthMaterial,MeshDistanceMaterial:MeshDistanceMaterial,MeshFaceMaterial:MeshFaceMaterial,MeshLambertMaterial:MeshLambertMaterial,MeshMatcapMaterial:MeshMatcapMaterial,MeshNormalMaterial:MeshNormalMaterial,MeshPhongMaterial:MeshPhongMaterial,MeshPhysicalMaterial:MeshPhysicalMaterial,MeshStandardMaterial:MeshStandardMaterial,MeshToonMaterial:MeshToonMaterial,MinEquation:MinEquation,MirroredRepeatWrapping:MirroredRepeatWrapping,MixOperation:MixOperation,MultiMaterial:MultiMaterial,MultiplyBlending:MultiplyBlending,MultiplyOperation:MultiplyOperation,NearestFilter:NearestFilter,NearestMipMapLinearFilter:NearestMipMapLinearFilter,NearestMipMapNearestFilter:NearestMipMapNearestFilter,NearestMipmapLinearFilter:NearestMipmapLinearFilter,NearestMipmapNearestFilter:NearestMipmapNearestFilter,NeverDepth:NeverDepth,NeverStencilFunc:NeverStencilFunc,NoBlending:NoBlending,NoColors:NoColors,NoToneMapping:NoToneMapping,NormalAnimationBlendMode:NormalAnimationBlendMode,NormalBlending:NormalBlending,NotEqualDepth:NotEqualDepth,NotEqualStencilFunc:NotEqualStencilFunc,NumberKeyframeTrack:NumberKeyframeTrack,Object3D:Object3D,ObjectLoader:ObjectLoader,ObjectSpaceNormalMap:ObjectSpaceNormalMap,OctahedronBufferGeometry:OctahedronGeometry,OctahedronGeometry:OctahedronGeometry,OneFactor:OneFactor,OneMinusDstAlphaFactor:OneMinusDstAlphaFactor,OneMinusDstColorFactor:OneMinusDstColorFactor,OneMinusSrcAlphaFactor:OneMinusSrcAlphaFactor,OneMinusSrcColorFactor:OneMinusSrcColorFactor,OrthographicCamera:OrthographicCamera,PCFShadowMap:PCFShadowMap,PCFSoftShadowMap:PCFSoftShadowMap,PMREMGenerator:PMREMGenerator,ParametricBufferGeometry:ParametricGeometry,ParametricGeometry:ParametricGeometry,Particle:Particle,ParticleBasicMaterial:ParticleBasicMaterial,ParticleSystem:ParticleSystem,ParticleSystemMaterial:ParticleSystemMaterial,Path:Path,PerspectiveCamera:PerspectiveCamera,Plane:Plane$1,PlaneBufferGeometry:PlaneGeometry,PlaneGeometry:PlaneGeometry,PlaneHelper:PlaneHelper,PointCloud:PointCloud,PointCloudMaterial:PointCloudMaterial,PointLight:PointLight$1,PointLightHelper:PointLightHelper,Points:Points,PointsMaterial:PointsMaterial,PolarGridHelper:PolarGridHelper,PolyhedronBufferGeometry:PolyhedronGeometry,PolyhedronGeometry:PolyhedronGeometry,PositionalAudio:PositionalAudio,PropertyBinding:PropertyBinding,PropertyMixer:PropertyMixer,QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,Quaternion:Quaternion,QuaternionKeyframeTrack:QuaternionKeyframeTrack,QuaternionLinearInterpolant:QuaternionLinearInterpolant,REVISION:REVISION,RGBADepthPacking:RGBADepthPacking,RGBAFormat:RGBAFormat,RGBAIntegerFormat:RGBAIntegerFormat,RGBA_ASTC_10x10_Format:RGBA_ASTC_10x10_Format,RGBA_ASTC_10x5_Format:RGBA_ASTC_10x5_Format,RGBA_ASTC_10x6_Format:RGBA_ASTC_10x6_Format,RGBA_ASTC_10x8_Format:RGBA_ASTC_10x8_Format,RGBA_ASTC_12x10_Format:RGBA_ASTC_12x10_Format,RGBA_ASTC_12x12_Format:RGBA_ASTC_12x12_Format,RGBA_ASTC_4x4_Format:RGBA_ASTC_4x4_Format,RGBA_ASTC_5x4_Format:RGBA_ASTC_5x4_Format,RGBA_ASTC_5x5_Format:RGBA_ASTC_5x5_Format,RGBA_ASTC_6x5_Format:RGBA_ASTC_6x5_Format,RGBA_ASTC_6x6_Format:RGBA_ASTC_6x6_Format,RGBA_ASTC_8x5_Format:RGBA_ASTC_8x5_Format,RGBA_ASTC_8x6_Format:RGBA_ASTC_8x6_Format,RGBA_ASTC_8x8_Format:RGBA_ASTC_8x8_Format,RGBA_BPTC_Format:RGBA_BPTC_Format,RGBA_ETC2_EAC_Format:RGBA_ETC2_EAC_Format,RGBA_PVRTC_2BPPV1_Format:RGBA_PVRTC_2BPPV1_Format,RGBA_PVRTC_4BPPV1_Format:RGBA_PVRTC_4BPPV1_Format,RGBA_S3TC_DXT1_Format:RGBA_S3TC_DXT1_Format,RGBA_S3TC_DXT3_Format:RGBA_S3TC_DXT3_Format,RGBA_S3TC_DXT5_Format:RGBA_S3TC_DXT5_Format,RGBDEncoding:RGBDEncoding,RGBEEncoding:RGBEEncoding,RGBEFormat:RGBEFormat,RGBFormat:RGBFormat,RGBIntegerFormat:RGBIntegerFormat,RGBM16Encoding:RGBM16Encoding,RGBM7Encoding:RGBM7Encoding,RGB_ETC1_Format:RGB_ETC1_Format,RGB_ETC2_Format:RGB_ETC2_Format,RGB_PVRTC_2BPPV1_Format:RGB_PVRTC_2BPPV1_Format,RGB_PVRTC_4BPPV1_Format:RGB_PVRTC_4BPPV1_Format,RGB_S3TC_DXT1_Format:RGB_S3TC_DXT1_Format,RGFormat:RGFormat,RGIntegerFormat:RGIntegerFormat,RawShaderMaterial:RawShaderMaterial,Ray:Ray,Raycaster:Raycaster,RectAreaLight:RectAreaLight,RedFormat:RedFormat,RedIntegerFormat:RedIntegerFormat,ReinhardToneMapping:ReinhardToneMapping,RepeatWrapping:RepeatWrapping$1,ReplaceStencilOp:ReplaceStencilOp,ReverseSubtractEquation:ReverseSubtractEquation,RingBufferGeometry:RingGeometry,RingGeometry:RingGeometry,SRGB8_ALPHA8_ASTC_10x10_Format:SRGB8_ALPHA8_ASTC_10x10_Format,SRGB8_ALPHA8_ASTC_10x5_Format:SRGB8_ALPHA8_ASTC_10x5_Format,SRGB8_ALPHA8_ASTC_10x6_Format:SRGB8_ALPHA8_ASTC_10x6_Format,SRGB8_ALPHA8_ASTC_10x8_Format:SRGB8_ALPHA8_ASTC_10x8_Format,SRGB8_ALPHA8_ASTC_12x10_Format:SRGB8_ALPHA8_ASTC_12x10_Format,SRGB8_ALPHA8_ASTC_12x12_Format:SRGB8_ALPHA8_ASTC_12x12_Format,SRGB8_ALPHA8_ASTC_4x4_Format:SRGB8_ALPHA8_ASTC_4x4_Format,SRGB8_ALPHA8_ASTC_5x4_Format:SRGB8_ALPHA8_ASTC_5x4_Format,SRGB8_ALPHA8_ASTC_5x5_Format:SRGB8_ALPHA8_ASTC_5x5_Format,SRGB8_ALPHA8_ASTC_6x5_Format:SRGB8_ALPHA8_ASTC_6x5_Format,SRGB8_ALPHA8_ASTC_6x6_Format:SRGB8_ALPHA8_ASTC_6x6_Format,SRGB8_ALPHA8_ASTC_8x5_Format:SRGB8_ALPHA8_ASTC_8x5_Format,SRGB8_ALPHA8_ASTC_8x6_Format:SRGB8_ALPHA8_ASTC_8x6_Format,SRGB8_ALPHA8_ASTC_8x8_Format:SRGB8_ALPHA8_ASTC_8x8_Format,Scene:Scene$2,SceneUtils:SceneUtils,ShaderChunk:ShaderChunk,ShaderLib:ShaderLib,ShaderMaterial:ShaderMaterial,ShadowMaterial:ShadowMaterial,Shape:Shape,ShapeBufferGeometry:ShapeGeometry,ShapeGeometry:ShapeGeometry,ShapePath:ShapePath,ShapeUtils:ShapeUtils,ShortType:ShortType,Skeleton:Skeleton,SkeletonHelper:SkeletonHelper,SkinnedMesh:SkinnedMesh,SmoothShading:SmoothShading,Sphere:Sphere$1,SphereBufferGeometry:SphereGeometry,SphereGeometry:SphereGeometry,Spherical:Spherical,SphericalHarmonics3:SphericalHarmonics3,SplineCurve:SplineCurve,SpotLight:SpotLight$1,SpotLightHelper:SpotLightHelper,Sprite:Sprite$1,SpriteMaterial:SpriteMaterial,SrcAlphaFactor:SrcAlphaFactor,SrcAlphaSaturateFactor:SrcAlphaSaturateFactor,SrcColorFactor:SrcColorFactor,StaticCopyUsage:StaticCopyUsage,StaticDrawUsage:StaticDrawUsage,StaticReadUsage:StaticReadUsage,StereoCamera:StereoCamera,StreamCopyUsage:StreamCopyUsage,StreamDrawUsage:StreamDrawUsage,StreamReadUsage:StreamReadUsage,StringKeyframeTrack:StringKeyframeTrack,SubtractEquation:SubtractEquation,SubtractiveBlending:SubtractiveBlending,TOUCH:TOUCH,TangentSpaceNormalMap:TangentSpaceNormalMap,TetrahedronBufferGeometry:TetrahedronGeometry,TetrahedronGeometry:TetrahedronGeometry,TextBufferGeometry:TextGeometry,TextGeometry:TextGeometry,Texture:Texture,TextureLoader:TextureLoader,TorusBufferGeometry:TorusGeometry,TorusGeometry:TorusGeometry,TorusKnotBufferGeometry:TorusKnotGeometry,TorusKnotGeometry:TorusKnotGeometry,Triangle:Triangle,TriangleFanDrawMode:TriangleFanDrawMode,TriangleStripDrawMode:TriangleStripDrawMode,TrianglesDrawMode:TrianglesDrawMode,TubeBufferGeometry:TubeGeometry,TubeGeometry:TubeGeometry,UVMapping:UVMapping,Uint16Attribute:Uint16Attribute,Uint16BufferAttribute:Uint16BufferAttribute,Uint32Attribute:Uint32Attribute,Uint32BufferAttribute:Uint32BufferAttribute,Uint8Attribute:Uint8Attribute,Uint8BufferAttribute:Uint8BufferAttribute,Uint8ClampedAttribute:Uint8ClampedAttribute,Uint8ClampedBufferAttribute:Uint8ClampedBufferAttribute,Uniform:Uniform,UniformsLib:UniformsLib,UniformsUtils:UniformsUtils,UnsignedByteType:UnsignedByteType,UnsignedInt248Type:UnsignedInt248Type,UnsignedIntType:UnsignedIntType,UnsignedShort4444Type:UnsignedShort4444Type,UnsignedShort5551Type:UnsignedShort5551Type,UnsignedShort565Type:UnsignedShort565Type,UnsignedShortType:UnsignedShortType,VSMShadowMap:VSMShadowMap,Vector2:Vector2,Vector3:Vector3$1,Vector4:Vector4,VectorKeyframeTrack:VectorKeyframeTrack,Vertex:Vertex,VertexColors:VertexColors,VideoTexture:VideoTexture,WebGL1Renderer:WebGL1Renderer,WebGLCubeRenderTarget:WebGLCubeRenderTarget,WebGLMultisampleRenderTarget:WebGLMultisampleRenderTarget,WebGLRenderTarget:WebGLRenderTarget,WebGLRenderTargetCube:WebGLRenderTargetCube,WebGLRenderer:WebGLRenderer,WebGLUtils:WebGLUtils,WireframeGeometry:WireframeGeometry,WireframeHelper:WireframeHelper,WrapAroundEnding:WrapAroundEnding,XHRLoader:XHRLoader,ZeroCurvatureEnding:ZeroCurvatureEnding,ZeroFactor:ZeroFactor,ZeroSlopeEnding:ZeroSlopeEnding,ZeroStencilOp:ZeroStencilOp,sRGBEncoding:sRGBEncoding});var PREFIX = '[Mage]';
var DEPRECATED = '[DEPRECATED]';
var DEPRECATIONS = {
  PARTICLES_ADD_PARTICLE_EMITTER: "".concat(PREFIX, " ").concat(DEPRECATED, " Particles.addParticleEmitter is deprecated, use Particles.add instead. Will be removed in the next major release"),
  MODELS_GETMODEL: "".concat(PREFIX, " ").concat(DEPRECATED, " Models.getModel is deprecated, use Models.get instead. Will be removed in next major release"),
  SCRIPTS_CREATE: "".concat(PREFIX, " ").concat(DEPRECATED, " Scripts.create is deprecated, use Scripts.register instead. Will be removed in next major release."),
  ELEMENT_SET_TEXTURE_MAP: "".concat(PREFIX, " ").concat(DEPRECATED, " Element.setTextureMap is deprecated, use Element.setTexture() instead. Will be removed in next major release.")
};
var ONCREATE_NOT_AVAILABLE = "".concat(PREFIX, " Your scene needs a onCreate method.");
var PATH_NOT_FOUND = "".concat(PREFIX, " can't find requested path");
var STORE_DOESNT_EXIST = "".concat(PREFIX, " Store hasn't been created yet.");
var LOCALSTORAGE_NOT_AVAILABLE = "".concat(PREFIX, " localStorage is not available.");
var WORKERS_NOT_AVAILABLE = "".concat(PREFIX, " Your browser doesn't support Workers.");
var BOUNDINGBOX_NOT_AVAILABLE = "".concat(PREFIX, " Selected element does not have a computed bounding box.");
var INVALID_EMITTER_ID = "".concat(PREFIX, " The selected emitter id is not valid.");
var EMITTER_NOT_FOUND = "".concat(PREFIX, " The requested emitter could not be found");
var FEATURE_NOT_SUPPORTED = "".concat(PREFIX, " The following features are not supported: ");
var METHOD_NOT_SUPPORTED = "".concat(PREFIX, " This method is not supported.");
var ANIMATION_NOT_FOUND = "".concat(PREFIX, " Required animation can't be found.");
var ANIMATION_HANDLER_NOT_FOUND = "".concat(PREFIX, " AnimationHander hasn't been defined yet.");
var ELEMENT_NOT_SET$1 = "".concat(PREFIX, " Body hasn't been defined yet.");
var ELEMENT_SET_COLOR_MISSING_COLOR = "".concat(PREFIX, " Can't set color for this element, missing color");
var ELEMENT_MATERIAL_NO_SUPPORT_FOR_TEXTURE = "".concat(PREFIX, " This element's material does not support texture: ");
var ENTITY_NOT_SET = "".concat(PREFIX, " This entity does not have a body.");
var ENTITY_TYPE_NOT_ALLOWED = "".concat(PREFIX, " The desired Entity type is not allowed.");
var ENTITY_CANT_ADD_NOT_ENTITY = "".concat(PREFIX, " Entity.add requires an Entity.");
var ERROR_LOADING_TEXTURE = "".concat(PREFIX, " Error while loading texture:");
var TAG_CANT_BE_REMOVED = "".concat(PREFIX, " The default tag can't be removed.");
var TAG_ALREADY_EXISTS = "".concat(PREFIX, " The following tag has already been added: ");
var TAG_NOT_EXISTING_REMOVAL = "".concat(PREFIX, " The following tag has can't be removed because it hasnt been added: ");
var USER_DATA_IS_MISSING = "".concat(PREFIX, " This entity cannot hold custom data.");
var KEY_IS_MISSING = "".concat(PREFIX, " You need to provide a valid key");
var KEY_VALUE_IS_MISSING = "".concat(PREFIX, " You need to provide a valid key/value pair");
var STATE_MACHINE_NOT_AVAILABLE = "".concat(PREFIX, " State Machine is not enabled.");
var EFFECT_COULD_NOT_BE_CREATED = "".concat(PREFIX, "  Could not create requested effect.");
var EFFECT_UNAVAILABLE = "".concat(PREFIX, "  Requested effect is not available.");
var SCRIPT_NOT_FOUND = "".concat(PREFIX, " Could not find desired script.");
var KEYBOARD_COMBO_ALREADY_REGISTERED = "".concat(PREFIX, " Keyboard combo already registered.");
var PHYSICS_ELEMENT_CANT_BE_REMOVED = "".concat(PREFIX, " This element can't be removed from physics world.");
var PHYSICS_ELEMENT_ALREADY_STORED = "".concat(PREFIX, " This element has already been added to the world.");
var ASSETS_AUDIO_LOAD_FAIL = "".concat(PREFIX, " Could not load audio.");
var ASSETS_MODEL_LOAD_FAIL = "".concat(PREFIX, " Could not load model.");
var AUDIO_CONTEXT_NOT_AVAILABLE = "".concat(PREFIX, " No Audio Context available, sorry.");
var AUDIO_UNABLE_TO_LOAD_SOUND = "".concat(PREFIX, " Unable to load sound, sorry.");
var LIGHT_NOT_FOUND = "".concat(PREFIX, " This light was not created properly.");
var LIGHT_HOLDER_MODEL_NOT_FOUND = "".concat(PREFIX, " This light holder model can't be found.");
var LABEL_DOMELEMENT_MISSING = "".concat(PREFIX, " Could not create Label, domElement is missing. Did you forget to set the this.element ref on your component?");var BaseScript = /*#__PURE__*/function () {
  _createClass(BaseScript, [{
    key: "__check",
    value: function __check() {
      return true;
    }
  }, {
    key: "__hasStarted",
    value: function __hasStarted() {
      return this.hasStarted;
    }
  }, {
    key: "__isDisposed",
    value: function __isDisposed() {
      return this.isDisposed;
    }
  }, {
    key: "__setStartedFlag",
    value: function __setStartedFlag(flag) {
      this.hasStarted = flag;
    }
  }, {
    key: "__setDisposedFlag",
    value: function __setDisposedFlag(flag) {
      this.isDisposed = flag;
    }
  }]);

  function BaseScript(name) {
    _classCallCheck(this, BaseScript);

    this.__name = name || this.contructor.name;
    this.hasStarted = false;
    this.options = {};
  }

  _createClass(BaseScript, [{
    key: "getName",
    value: function getName() {
      return this.__name;
    }
  }, {
    key: "start",
    value: function start(element, options) {}
  }, {
    key: "update",
    value: function update(dt) {}
  }, {
    key: "physicsUpdate",
    value: function physicsUpdate(dt) {}
  }, {
    key: "onDispose",
    value: function onDispose() {}
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        name: this.name()
      };
    }
  }]);

  return BaseScript;
}();/*!
 * hotkeys-js v3.7.2
 * A simple micro-library for defining and dispatching keyboard shortcuts. It has no dependencies.
 * 
 * Copyright (c) 2019 kenny wong <wowohoo@qq.com>
 * http://jaywcjlove.github.io/hotkeys
 * 
 * Licensed under the MIT license.
 */

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var isff = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase().indexOf('firefox') > 0 : false; // 绑定事件

function addEvent(object, event, method) {
  if (object.addEventListener) {
    object.addEventListener(event, method, false);
  } else if (object.attachEvent) {
    object.attachEvent("on".concat(event), function () {
      method(window.event);
    });
  }
} // 修饰键转换成对应的键码


function getMods(modifier, key) {
  var mods = key.slice(0, key.length - 1);

  for (var i = 0; i < mods.length; i++) {
    mods[i] = modifier[mods[i].toLowerCase()];
  }

  return mods;
} // 处理传的key字符串转换成数组


function getKeys(key) {
  if (typeof key !== 'string') key = '';
  key = key.replace(/\s/g, ''); // 匹配任何空白字符,包括空格、制表符、换页符等等

  var keys = key.split(','); // 同时设置多个快捷键，以','分割

  var index = keys.lastIndexOf(''); // 快捷键可能包含','，需特殊处理

  for (; index >= 0;) {
    keys[index - 1] += ',';
    keys.splice(index, 1);
    index = keys.lastIndexOf('');
  }

  return keys;
} // 比较修饰键的数组


function compareArray(a1, a2) {
  var arr1 = a1.length >= a2.length ? a1 : a2;
  var arr2 = a1.length >= a2.length ? a2 : a1;
  var isIndex = true;

  for (var i = 0; i < arr1.length; i++) {
    if (arr2.indexOf(arr1[i]) === -1) isIndex = false;
  }

  return isIndex;
}

var _keyMap = {
  backspace: 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "return": 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  "delete": 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  '⇪': 20,
  ',': 188,
  '.': 190,
  '/': 191,
  '`': 192,
  '-': isff ? 173 : 189,
  '=': isff ? 61 : 187,
  ';': isff ? 59 : 186,
  '\'': 222,
  '[': 219,
  ']': 221,
  '\\': 220
}; // Modifier Keys

var _modifier = {
  // shiftKey
  '⇧': 16,
  shift: 16,
  // altKey
  '⌥': 18,
  alt: 18,
  option: 18,
  // ctrlKey
  '⌃': 17,
  ctrl: 17,
  control: 17,
  // metaKey
  '⌘': 91,
  cmd: 91,
  command: 91
};
var modifierMap = {
  16: 'shiftKey',
  18: 'altKey',
  17: 'ctrlKey',
  91: 'metaKey',
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
};
var _mods = {
  16: false,
  18: false,
  17: false,
  91: false
};
var _handlers = {}; // F1~F12 special key

for (var k$1 = 1; k$1 < 20; k$1++) {
  _keyMap["f".concat(k$1)] = 111 + k$1;
}

var _downKeys = []; // 记录摁下的绑定键

var _scope = 'all'; // 默认热键范围

var elementHasBindEvent = []; // 已绑定事件的节点记录
// 返回键码

var code = function code(x) {
  return _keyMap[x.toLowerCase()] || _modifier[x.toLowerCase()] || x.toUpperCase().charCodeAt(0);
}; // 设置获取当前范围（默认为'所有'）


function setScope(scope) {
  _scope = scope || 'all';
} // 获取当前范围


function getScope() {
  return _scope || 'all';
} // 获取摁下绑定键的键值


function getPressedKeyCodes() {
  return _downKeys.slice(0);
} // 表单控件控件判断 返回 Boolean
// hotkey is effective only when filter return true


function filter$1(event) {
  var target = event.target || event.srcElement;
  var tagName = target.tagName;
  var flag = true; // ignore: isContentEditable === 'true', <input> and <textarea> when readOnly state is false, <select>

  if (target.isContentEditable || tagName === 'TEXTAREA' || (tagName === 'INPUT' || tagName === 'TEXTAREA') && !target.readOnly) {
    flag = false;
  }

  return flag;
} // 判断摁下的键是否为某个键，返回true或者false


function isPressed(keyCode) {
  if (typeof keyCode === 'string') {
    keyCode = code(keyCode); // 转换成键码
  }

  return _downKeys.indexOf(keyCode) !== -1;
} // 循环删除handlers中的所有 scope(范围)


function deleteScope(scope, newScope) {
  var handlers;
  var i; // 没有指定scope，获取scope

  if (!scope) scope = getScope();

  for (var key in _handlers) {
    if (Object.prototype.hasOwnProperty.call(_handlers, key)) {
      handlers = _handlers[key];

      for (i = 0; i < handlers.length;) {
        if (handlers[i].scope === scope) handlers.splice(i, 1);else i++;
      }
    }
  } // 如果scope被删除，将scope重置为all


  if (getScope() === scope) setScope(newScope || 'all');
} // 清除修饰键


function clearModifier(event) {
  var key = event.keyCode || event.which || event.charCode;

  var i = _downKeys.indexOf(key); // 从列表中清除按压过的键


  if (i >= 0) {
    _downKeys.splice(i, 1);
  } // 特殊处理 cmmand 键，在 cmmand 组合快捷键 keyup 只执行一次的问题


  if (event.key && event.key.toLowerCase() === 'meta') {
    _downKeys.splice(0, _downKeys.length);
  } // 修饰键 shiftKey altKey ctrlKey (command||metaKey) 清除


  if (key === 93 || key === 224) key = 91;

  if (key in _mods) {
    _mods[key] = false; // 将修饰键重置为false

    for (var k in _modifier) {
      if (_modifier[k] === key) hotkeys[k] = false;
    }
  }
}

function unbind(keysInfo) {
  // unbind(), unbind all keys
  if (!keysInfo) {
    Object.keys(_handlers).forEach(function (key) {
      return delete _handlers[key];
    });
  } else if (Array.isArray(keysInfo)) {
    // support like : unbind([{key: 'ctrl+a', scope: 's1'}, {key: 'ctrl-a', scope: 's2', splitKey: '-'}])
    keysInfo.forEach(function (info) {
      if (info.key) eachUnbind(info);
    });
  } else if (_typeof(keysInfo) === 'object') {
    // support like unbind({key: 'ctrl+a, ctrl+b', scope:'abc'})
    if (keysInfo.key) eachUnbind(keysInfo);
  } else if (typeof keysInfo === 'string') {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    // support old method
    // eslint-disable-line
    var scope = args[0],
        method = args[1];

    if (typeof scope === 'function') {
      method = scope;
      scope = '';
    }

    eachUnbind({
      key: keysInfo,
      scope: scope,
      method: method,
      splitKey: '+'
    });
  }
} // 解除绑定某个范围的快捷键


var eachUnbind = function eachUnbind(_ref) {
  var key = _ref.key,
      scope = _ref.scope,
      method = _ref.method,
      _ref$splitKey = _ref.splitKey,
      splitKey = _ref$splitKey === void 0 ? '+' : _ref$splitKey;
  var multipleKeys = getKeys(key);
  multipleKeys.forEach(function (originKey) {
    var unbindKeys = originKey.split(splitKey);
    var len = unbindKeys.length;
    var lastKey = unbindKeys[len - 1];
    var keyCode = lastKey === '*' ? '*' : code(lastKey);
    if (!_handlers[keyCode]) return; // 判断是否传入范围，没有就获取范围

    if (!scope) scope = getScope();
    var mods = len > 1 ? getMods(_modifier, unbindKeys) : [];
    _handlers[keyCode] = _handlers[keyCode].map(function (record) {
      // 通过函数判断，是否解除绑定，函数相等直接返回
      var isMatchingMethod = method ? record.method === method : true;

      if (isMatchingMethod && record.scope === scope && compareArray(record.mods, mods)) {
        return {};
      }

      return record;
    });
  });
}; // 对监听对应快捷键的回调函数进行处理


function eventHandler(event, handler, scope) {
  var modifiersMatch; // 看它是否在当前范围

  if (handler.scope === scope || handler.scope === 'all') {
    // 检查是否匹配修饰符（如果有返回true）
    modifiersMatch = handler.mods.length > 0;

    for (var y in _mods) {
      if (Object.prototype.hasOwnProperty.call(_mods, y)) {
        if (!_mods[y] && handler.mods.indexOf(+y) > -1 || _mods[y] && handler.mods.indexOf(+y) === -1) {
          modifiersMatch = false;
        }
      }
    } // 调用处理程序，如果是修饰键不做处理


    if (handler.mods.length === 0 && !_mods[16] && !_mods[18] && !_mods[17] && !_mods[91] || modifiersMatch || handler.shortcut === '*') {
      if (handler.method(event, handler) === false) {
        if (event.preventDefault) event.preventDefault();else event.returnValue = false;
        if (event.stopPropagation) event.stopPropagation();
        if (event.cancelBubble) event.cancelBubble = true;
      }
    }
  }
} // 处理keydown事件


function dispatch$9(event) {
  var asterisk = _handlers['*'];
  var key = event.keyCode || event.which || event.charCode; // 表单控件过滤 默认表单控件不触发快捷键

  if (!hotkeys.filter.call(this, event)) return; // Gecko(Firefox)的command键值224，在Webkit(Chrome)中保持一致
  // Webkit左右 command 键值不一样

  if (key === 93 || key === 224) key = 91;
  /**
   * Collect bound keys
   * If an Input Method Editor is processing key input and the event is keydown, return 229.
   * https://stackoverflow.com/questions/25043934/is-it-ok-to-ignore-keydown-events-with-keycode-229
   * http://lists.w3.org/Archives/Public/www-dom/2010JulSep/att-0182/keyCode-spec.html
   */

  if (_downKeys.indexOf(key) === -1 && key !== 229) _downKeys.push(key);
  /**
   * Jest test cases are required.
   * ===============================
   */

  ['ctrlKey', 'altKey', 'shiftKey', 'metaKey'].forEach(function (keyName) {
    var keyNum = modifierMap[keyName];

    if (event[keyName] && _downKeys.indexOf(keyNum) === -1) {
      _downKeys.push(keyNum);
    } else if (!event[keyName] && _downKeys.indexOf(keyNum) > -1) {
      _downKeys.splice(_downKeys.indexOf(keyNum), 1);
    }
  });
  /**
   * -------------------------------
   */

  if (key in _mods) {
    _mods[key] = true; // 将特殊字符的key注册到 hotkeys 上

    for (var k in _modifier) {
      if (_modifier[k] === key) hotkeys[k] = true;
    }

    if (!asterisk) return;
  } // 将 modifierMap 里面的修饰键绑定到 event 中


  for (var e in _mods) {
    if (Object.prototype.hasOwnProperty.call(_mods, e)) {
      _mods[e] = event[modifierMap[e]];
    }
  } // 获取范围 默认为 `all`


  var scope = getScope(); // 对任何快捷键都需要做的处理

  if (asterisk) {
    for (var i = 0; i < asterisk.length; i++) {
      if (asterisk[i].scope === scope && (event.type === 'keydown' && asterisk[i].keydown || event.type === 'keyup' && asterisk[i].keyup)) {
        eventHandler(event, asterisk[i], scope);
      }
    }
  } // key 不在 _handlers 中返回


  if (!(key in _handlers)) return;

  for (var _i = 0; _i < _handlers[key].length; _i++) {
    if (event.type === 'keydown' && _handlers[key][_i].keydown || event.type === 'keyup' && _handlers[key][_i].keyup) {
      if (_handlers[key][_i].key) {
        var record = _handlers[key][_i];
        var splitKey = record.splitKey;
        var keyShortcut = record.key.split(splitKey);
        var _downKeysCurrent = []; // 记录当前按键键值

        for (var a = 0; a < keyShortcut.length; a++) {
          _downKeysCurrent.push(code(keyShortcut[a]));
        }

        if (_downKeysCurrent.sort().join('') === _downKeys.sort().join('')) {
          // 找到处理内容
          eventHandler(event, record, scope);
        }
      }
    }
  }
} // 判断 element 是否已经绑定事件


function isElementBind(element) {
  return elementHasBindEvent.indexOf(element) > -1;
}

function hotkeys(key, option, method) {
  _downKeys = [];
  var keys = getKeys(key); // 需要处理的快捷键列表

  var mods = [];
  var scope = 'all'; // scope默认为all，所有范围都有效

  var element = document; // 快捷键事件绑定节点

  var i = 0;
  var keyup = false;
  var keydown = true;
  var splitKey = '+'; // 对为设定范围的判断

  if (method === undefined && typeof option === 'function') {
    method = option;
  }

  if (Object.prototype.toString.call(option) === '[object Object]') {
    if (option.scope) scope = option.scope; // eslint-disable-line

    if (option.element) element = option.element; // eslint-disable-line

    if (option.keyup) keyup = option.keyup; // eslint-disable-line

    if (option.keydown !== undefined) keydown = option.keydown; // eslint-disable-line

    if (typeof option.splitKey === 'string') splitKey = option.splitKey; // eslint-disable-line
  }

  if (typeof option === 'string') scope = option; // 对于每个快捷键进行处理

  for (; i < keys.length; i++) {
    key = keys[i].split(splitKey); // 按键列表

    mods = []; // 如果是组合快捷键取得组合快捷键

    if (key.length > 1) mods = getMods(_modifier, key); // 将非修饰键转化为键码

    key = key[key.length - 1];
    key = key === '*' ? '*' : code(key); // *表示匹配所有快捷键
    // 判断key是否在_handlers中，不在就赋一个空数组

    if (!(key in _handlers)) _handlers[key] = [];

    _handlers[key].push({
      keyup: keyup,
      keydown: keydown,
      scope: scope,
      mods: mods,
      shortcut: keys[i],
      method: method,
      key: keys[i],
      splitKey: splitKey
    });
  } // 在全局document上设置快捷键


  if (typeof element !== 'undefined' && !isElementBind(element) && window) {
    elementHasBindEvent.push(element);
    addEvent(element, 'keydown', function (e) {
      dispatch$9(e);
    });
    addEvent(window, 'focus', function () {
      _downKeys = [];
    });
    addEvent(element, 'keyup', function (e) {
      dispatch$9(e);
      clearModifier(e);
    });
  }
}

var _api = {
  setScope: setScope,
  getScope: getScope,
  deleteScope: deleteScope,
  getPressedKeyCodes: getPressedKeyCodes,
  isPressed: isPressed,
  filter: filter$1,
  unbind: unbind
};

for (var a in _api) {
  if (Object.prototype.hasOwnProperty.call(_api, a)) {
    hotkeys[a] = _api[a];
  }
}

if (typeof window !== 'undefined') {
  var _hotkeys = window.hotkeys;

  hotkeys.noConflict = function (deep) {
    if (deep && window.hotkeys === hotkeys) {
      window.hotkeys = _hotkeys;
    }

    return hotkeys;
  };

  window.hotkeys = hotkeys;
}var DEFAULT_OPTIONS = {
  keyup: true,
  keydown: true
};
var KEY_PRESS = 'keyPress';
var KEY_DOWN = 'keyDown';
var KEY_UP = 'keyUp';

var Keyboard = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Keyboard, _EventDispatcher);

  var _super = _createSuper(Keyboard);

  function Keyboard() {
    var _this;

    _classCallCheck(this, Keyboard);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "handleKeydown", function (event) {
      _this.dispatchEvent({
        type: KEY_DOWN,
        event: event
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleKeyup", function (event) {
      _this.dispatchEvent({
        type: KEY_UP,
        event: event
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleKeypress", function (event) {
      _this.dispatchEvent({
        type: KEY_PRESS,
        event: event
      });
    });

    _this.combos = [];
    _this.enabled = false;
    return _this;
  }

  _createClass(Keyboard, [{
    key: "register",
    value: function register(combo, handler) {
      if (this.enabled) {
        if (this.combos.includes(combo)) {
          console.warn(KEYBOARD_COMBO_ALREADY_REGISTERED);
          return;
        }

        this.combos.push(combo);
        hotkeys(combo, DEFAULT_OPTIONS, handler);
      }
    }
  }, {
    key: "enable",
    value: function enable() {
      this.enabled = true;
      window.addEventListener(KEY_DOWN, this.handleKeydown.bind(this));
      window.addEventListener(KEY_UP, this.handleKeyup.bind(this));
      window.addEventListener(KEY_PRESS, this.handleKeypress.bind(this));
    }
  }, {
    key: "disable",
    value: function disable() {
      this.enabled = false;
      window.removeEventListener(KEY_DOWN, this.handleKeydown.bind(this));
      window.removeEventListener(KEY_UP, this.handleKeyup.bind(this));
      window.removeEventListener(KEY_PRESS, this.handleKeypress.bind(this));
    }
  }, {
    key: "isPressed",
    value: function isPressed(key) {
      return hotkeys.isPressed(key);
    }
  }]);

  return Keyboard;
}(EventDispatcher);var SHADOW_TYPES = {
  BASIC: 'BASIC',
  SOFT: 'SOFT',
  HARD: 'HARD'
};
var DEFAULT_SHADOWTYPE = SHADOW_TYPES.BASIC;var light_contants=/*#__PURE__*/Object.freeze({__proto__:null,SHADOW_TYPES:SHADOW_TYPES,DEFAULT_SHADOWTYPE:DEFAULT_SHADOWTYPE});var upperCaseFirst = function upperCaseFirst() {
  var sentence = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return sentence && typeof sentence === 'string' && sentence.length ? "".concat(sentence[0].toUpperCase()).concat(sentence.slice(1, sentence.length)) : '';
};
var removeFirst = function removeFirst(sentence) {
  return sentence.slice(1, sentence.length);
};var strings=/*#__PURE__*/Object.freeze({__proto__:null,upperCaseFirst:upperCaseFirst,removeFirst:removeFirst});var isClassname = function isClassname(word) {
  return word.startsWith('.');
};
var isId = function isId(word) {
  return word.startsWith('#');
};
var DEFAULT_FULL_SIZE_STYLE = {
  position: 'absolute',
  height: '100%',
  width: '100%',
  margin: '0'
};
var removeElement = function removeElement(selector) {
  return document.querySelector(selector).remove();
};
var createElementFromSelector = function createElementFromSelector(selector) {
  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'div';
  var style = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_FULL_SIZE_STYLE;
  var element = document.createElement(type);
  Object.keys(style).forEach(function (property) {
    element.style.setProperty(property, style[property]);
  });

  if (isClassname(selector)) {
    element.className = removeFirst(selector);
  } else if (isId(selector)) {
    element.id = removeFirst(selector);
  }

  return element;
};var getWindow = function getWindow() {
  try {
    var win = window || __webpack_require__.g.window;
    return win;
  } catch (e) {
    return null;
  }
};var DEFAULT_HEIGHT$1 = 600;
var DEFAULT_WIDTH = 800;
var DEFAULT_RATIO = DEFAULT_WIDTH / DEFAULT_HEIGHT$1;

var Config = /*#__PURE__*/function () {
  function Config() {
    _classCallCheck(this, Config);

    this.default = {
      tests: [],
      screen: {
        frameRate: 60,
        alpha: true
      },
      postprocessing: {
        enabled: false
      },
      fog: {
        enabled: false,
        density: 0,
        color: '#ffffff'
      },
      lights: {
        shadows: true,
        shadowType: SHADOW_TYPES.BASIC,
        textureAnisotropy: 16
      },
      physics: {
        enabled: false,
        path: './mage.physics.js'
      },
      camera: {
        //handling useful informations about our camera.
        fov: 75,
        near: 0.1,
        far: 100
      },
      ui: {
        enabled: true
      }
    };
    this.isDefault = true;
  }

  _createClass(Config, [{
    key: "setContainer",
    value: function setContainer(container) {
      this._container = container;
    }
  }, {
    key: "setConfig",
    value: function setConfig(config) {
      if (this.isDefault) {
        this.isDefault = false;
        this.config = _objectSpread2$1(_objectSpread2$1({}, this.default), config);
      } else {
        this.config = _objectSpread2$1(_objectSpread2$1({}, this.config), {}, {
          config: config
        });
      }
    }
  }, {
    key: "container",
    value: function container() {
      var container = document && document.querySelector(this._container);

      if (!container) {
        container = createElementFromSelector(this._container);
        document.body.appendChild(container);
      }

      return container;
    }
  }, {
    key: "tests",
    value: function tests() {
      return this.config.tests;
    }
  }, {
    key: "lights",
    value: function lights() {
      return this.config.lights;
    }
  }, {
    key: "fog",
    value: function fog() {
      return this.config.fog;
    }
  }, {
    key: "getContainerSize",
    value: function getContainerSize() {
      var container = this.container();
      if (!container) return false;
      var height = container.offsetHeight;
      var width = container.offsetWidth;
      var ratio = width / height;
      return {
        h: height,
        w: width,
        ratio: ratio
      };
    }
  }, {
    key: "getWindowSize",
    value: function getWindowSize() {
      var win = getWindow();
      if (!win) return false;
      var height = win.innerHeight;
      var width = win.innerWidth;
      var ratio = width / height;
      return {
        h: height,
        w: width,
        ratio: ratio
      };
    }
  }, {
    key: "getScreenDefaults",
    value: function getScreenDefaults() {
      return {
        h: DEFAULT_HEIGHT$1,
        w: DEFAULT_WIDTH,
        ratio: DEFAULT_RATIO
      };
    }
  }, {
    key: "screen",
    value: function screen() {
      var _ref = this.getContainerSize() || this.getWindowSize() || this.getScreenDefaults(),
          h = _ref.h,
          w = _ref.w,
          ratio = _ref.ratio;

      this.config.screen = _objectSpread2$1(_objectSpread2$1({}, this.config.screen), {}, {
        h: h,
        w: w,
        ratio: ratio,
        devicePixelRatio: window.devicePixelRatio
      });
      return this.config.screen;
    }
  }, {
    key: "postprocessing",
    value: function postprocessing() {
      return this.config.postprocessing;
    }
  }, {
    key: "ui",
    value: function ui() {
      return this.config.ui;
    }
  }, {
    key: "physics",
    value: function physics() {
      return this.config.physics;
    }
  }, {
    key: "camera",
    value: function camera() {
      return this.config.camera;
    }
  }]);

  return Config;
}();

var Config$1 = new Config();var Universe = /*#__PURE__*/function () {
  function Universe() {
    var _this = this;

    _classCallCheck(this, Universe);

    _defineProperty$1(this, "reset", function () {
      _this.reality = {};
      _this.realityUUID = {};
    });

    _defineProperty$1(this, "forEach", function (callback) {
      Object.keys(_this.reality).forEach(function (k) {
        return callback(_this.reality[k], k);
      });
    });

    _defineProperty$1(this, "forEachAsync", function (callback) {
      var keys = Object.keys(_this.reality);
      return new Promise(function (resolve) {
        Promise.all(keys.map(function (k) {
          return callback(_this.reality[k], k);
        })).then(resolve);
      });
    });

    _defineProperty$1(this, "bigfreeze", function () {
      _this.forEach(function (o) {
        o && o.dispose && o.dispose();
      });

      _this.reset();
    });

    this.reality = {};
    this.realityUUID = {};
    this.worker = undefined;
  }

  _createClass(Universe, [{
    key: "get",
    value: function get(id) {
      return this.reality[id];
    }
  }, {
    key: "find",
    value: function find(element) {
      var found;
      this.forEach(function (el) {
        if (el.has(element) && !found) {
          found = el;
        }
      });
      return found;
    }
  }, {
    key: "getByUUID",
    value: function getByUUID(uuid) {
      var id = this.realityUUID[uuid.toString()];

      if (id) {
        return this.get(id);
      }
    }
  }, {
    key: "getByTag",
    value: function getByTag(tagName) {
      var elements = [];
      this.forEach(function (element) {
        if (element.hasTag(tagName)) {
          elements.push(element);
        }
      });
      return elements;
    }
  }, {
    key: "set",
    value: function set(id, value) {
      this.reality[id] = value;
    }
  }, {
    key: "storeUUIDToElementNameReference",
    value: function storeUUIDToElementNameReference(uuid, name) {
      this.realityUUID[uuid] = name;
    }
  }, {
    key: "remove",
    value: function remove(id) {
      delete this.reality[id];
    }
  }, {
    key: "update",
    value: function update(dt) {
      var _this2 = this;

      Object.keys(this.reality).forEach(function (k) {
        return _this2.reality[k].update(dt);
      });
    }
  }, {
    key: "onPhysicsUpdate",
    value: function onPhysicsUpdate(dt) {
      var _this3 = this;

      Object.keys(this.reality).forEach(function (k) {
        return _this3.reality[k].onPhysicsUpdate(dt);
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this4 = this;

      var elements = Object.keys(this.reality).map(function (k) {
        return _this4.get(k);
      }).filter(function (element) {
        return element.serializable && element.isMesh();
      }).map(function (element) {
        return element.toJSON();
      });
      return {
        elements: elements
      };
    }
  }]);

  return Universe;
}();
var Universe$1 = new Universe();var generateUUID = function generateUUID() {
  var s4 = function s4() {
    return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
  };

  return s4() + s4();
};
var generateRandomName = function generateRandomName(prefix) {
  return "".concat(prefix, "_").concat(generateUUID());
};var uuid$1=/*#__PURE__*/Object.freeze({__proto__:null,generateUUID:generateUUID,generateRandomName:generateRandomName});var UP$1 = 'UP';
var DOWN$1 = 'DOWN';
var LEFT = 'LEFT';
var RIGHT = 'RIGHT';
var FRONT = 'FRONT';
var BACK = 'BACK';
var VECTOR_UP = {
  type: UP$1,
  vector: new Vector3$1(0, 1, 0)
};
var VECTOR_DOWN = {
  type: DOWN$1,
  vector: new Vector3$1(0, -1, 0)
};
var VECTOR_LEFT = {
  type: LEFT,
  vector: new Vector3$1(1, 0, 0)
};
var VECTOR_RIGHT = {
  type: RIGHT,
  vector: new Vector3$1(-1, 0, 0)
};
var VECTOR_FRONT = {
  type: FRONT,
  vector: new Vector3$1(0, 0, 1)
};
var VECTOR_BACK = {
  type: BACK,
  vector: new Vector3$1(0, 0, -1)
};
var ORIGIN = new Vector3$1(0, 0, 0);
var ZERO_QUATERNION = new Quaternion().identity();
var MATERIALS = {
  BASIC: 'BASIC',
  LAMBERT: 'LAMBERT',
  PHONG: 'PHONG',
  DEPTH: 'DEPTH',
  STANDARD: 'STANDARD',
  TOON: 'TOOM',
  THREE_TOON: 'THREE_TOON'
};
var TEXTURES = {
  ALPHA: 'alphaMap',
  AO: 'aoMap',
  ENV: 'envMap',
  MAP: 'map',
  LIGHT: 'lightMap',
  SPECULAR: 'specularMap',
  EMISSIVE: 'emissiveMap',
  BUMP: 'bumpMap',
  DISPLACEMENT: 'displacementMap',
  NORMAL: 'normalMap',
  METALNESS: 'metalnessMap',
  ROUGHNESS: 'roughnessMap',
  GRADIENT: 'gradientMap'
};
var EFFECTS = {
  SEPIA: 'SEPIAEFFECT',
  HUE_SATURATION: 'HUESATURATIONEFFECT',
  BLOOM: 'BLOOM',
  DEPTH_OF_FIELD: 'DOF',
  SELECTIVE_OUTLINE: 'SELECTIVEOUTLINE',
  OUTLINE: 'OUTLINE',
  GLITCH: 'GLITCH',
  PIXEL: 'PIXEL'
};
var COLLISION_EVENT = 'COLLISION_EVENT';
var COLORS = {
  WHITE: '#ffffff',
  BLACK: '#000000'
};
var ASSETS_TYPES = {
  AUDIO: 'audio',
  VIDEO: 'video',
  IMAGES: 'images',
  TEXTURES: 'textures',
  CUBETEXTURES: 'cubetextures',
  MODELS: 'models',
  PARTICLES: 'particles',
  SCRIPTS: 'scripts',
  SHADERS: 'shaders'
};
var OUTPUT_ENCODINGS = {
  LINEAR: LinearEncoding,
  SRGB: sRGBEncoding,
  GAMMA: GammaEncoding,
  RGBE: RGBEEncoding,
  RGBM7: RGBM7Encoding,
  RGBM16: RGBM16Encoding,
  RGBD: RGBDEncoding,
  BASICDEPTH: BasicDepthPacking,
  RGBADEPTH: RGBADepthPacking
};
var DEFAULT_OUTPUT_ENCODING = OUTPUT_ENCODINGS.LINEAR;
var ROOT = '/';
var DIVIDER = '/';
var HASH = '#';
var EMPTY$2 = '';
var QUERY_START = '?';
var DEFAULT_SELECTOR = '#gameContainer';
var BEFORE_UNLOAD = 'beforeunload';
var HASH_CHANGE = 'hashchange';var lib_constants=/*#__PURE__*/Object.freeze({__proto__:null,UP:UP$1,DOWN:DOWN$1,LEFT:LEFT,RIGHT:RIGHT,FRONT:FRONT,BACK:BACK,VECTOR_UP:VECTOR_UP,VECTOR_DOWN:VECTOR_DOWN,VECTOR_LEFT:VECTOR_LEFT,VECTOR_RIGHT:VECTOR_RIGHT,VECTOR_FRONT:VECTOR_FRONT,VECTOR_BACK:VECTOR_BACK,ORIGIN:ORIGIN,ZERO_QUATERNION:ZERO_QUATERNION,MATERIALS:MATERIALS,TEXTURES:TEXTURES,EFFECTS:EFFECTS,COLLISION_EVENT:COLLISION_EVENT,COLORS:COLORS,ASSETS_TYPES:ASSETS_TYPES,OUTPUT_ENCODINGS:OUTPUT_ENCODINGS,DEFAULT_OUTPUT_ENCODING:DEFAULT_OUTPUT_ENCODING,ROOT:ROOT,DIVIDER:DIVIDER,HASH:HASH,EMPTY:EMPTY$2,QUERY_START:QUERY_START,DEFAULT_SELECTOR:DEFAULT_SELECTOR,BEFORE_UNLOAD:BEFORE_UNLOAD,HASH_CHANGE:HASH_CHANGE});var buildAssetId = function buildAssetId(name, level) {
  return level ? "".concat(level, "_").concat(name) : name;
};
var isLevelName = function isLevelName(level) {
  return level.startsWith(DIVIDER);
};var Images = /*#__PURE__*/function () {
  function Images() {
    var _this = this;

    _classCallCheck(this, Images);

    _defineProperty$1(this, "setCurrentLevel", function (level) {
      _this.currentLevel = level;
    });

    _defineProperty$1(this, "areThereImagesToLoad", function () {
      return Object.keys(_this.textures).length + Object.keys(_this.images).length + Object.keys(_this.cubeTextures).length > 0;
    });

    _defineProperty$1(this, "load", function () {
      var images = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var textures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var cubeTextures = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var level = arguments.length > 3 ? arguments[3] : undefined;
      // extending assets images with our defaults
      _this.images = images;
      _this.textures = textures;
      _this.cubeTextures = cubeTextures;

      if (!_this.areThereImagesToLoad()) {
        return Promise.resolve('images');
      }

      var promises = Object.keys(_this.textures).map(function (name) {
        return _this.loadSingleTexture(name, level);
      }).concat(Object.keys(_this.images).map(function (name) {
        return _this.loadSingleImage(name, level);
      })).concat(Object.keys(_this.cubeTextures).map(function (cubeTexture) {
        return _this.loadSingleCubeTexture(cubeTexture, level);
      }));
      return Promise.all(promises);
    });

    _defineProperty$1(this, "loadSingleImage", function (name, level) {
      var id = buildAssetId(name, level);
      var path = _this.images[name];
      return new Promise(function (resolve, reject) {
        try {
          _this.imageLoader.load(path, function (image) {
            _this.add(id, image);

            resolve(image);
          }, function () {}, resolve);
        } catch (e) {
          console.log(ERROR_LOADING_TEXTURE, name, path);
          reject();
        }
      });
    });

    _defineProperty$1(this, "loadSingleTexture", function (name, level) {
      var id = buildAssetId(name, level);
      var path = _this.textures[name];
      return new Promise(function (resolve, reject) {
        try {
          _this.loader.load(path, function (texture) {
            _this.add(id, texture);

            resolve(texture);
          }, function () {}, function () {
            console.log(ERROR_LOADING_TEXTURE, name, path);
            resolve();
          });
        } catch (e) {
          console.log(ERROR_LOADING_TEXTURE, name, path);
          reject();
        }
      });
    });

    _defineProperty$1(this, "loadSingleCubeTexture", function (name, level) {
      var id = buildAssetId(name, level);
      var paths = _this.cubeTextures[name];
      return new Promise(function (resolve, reject) {
        try {
          if (paths instanceof Array) {
            _this.cubeTexturesLoader.load(paths, function (texture) {
              _this.add(id, texture);

              resolve(texture);
            }, function () {}, function () {
              console.log(ERROR_LOADING_TEXTURE, name, paths);
              resolve();
            });
          } else {
            console.log(CUBE_TEXTURES_NOT_LIST);
            reject();
          }
        } catch (e) {
          console.log(ERROR_LOADING_TEXTURE, name, path);
          reject();
        }
      });
    });

    this.defaults = {};
    this.imagesDefault = {};
    this.map = {};
    this.numImages = 0;
    this.loader = new TextureLoader();
    this.imageLoader = new ImageLoader();
    this.cubeTexturesLoader = new CubeTextureLoader();
    this.images = {};
    this.textures = {};
    this.currentLevel = ROOT;
  }

  _createClass(Images, [{
    key: "get",
    value: function get(id) {
      return this.map[id] || this.map[buildAssetId(id, this.currentLevel)] || false;
    }
  }, {
    key: "disposeTexture",
    value: function disposeTexture(id) {
      var texture = this.get(id);
      texture.dispose();
      this.map[id] = null;
    }
  }, {
    key: "add",
    value: function add(id, image) {
      if (id && image) {
        this.map[id] = image;
      }
    }
  }]);

  return Images;
}();
var Images$1 = new Images();var mapShadowTypeToShadowMap = function mapShadowTypeToShadowMap() {
  var _SHADOW_TYPES$BASIC$S;

  var shadowType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SHADOWTYPE;
  return (_SHADOW_TYPES$BASIC$S = {}, _defineProperty$1(_SHADOW_TYPES$BASIC$S, SHADOW_TYPES.BASIC, BasicShadowMap), _defineProperty$1(_SHADOW_TYPES$BASIC$S, SHADOW_TYPES.SOFT, PCFSoftShadowMap), _defineProperty$1(_SHADOW_TYPES$BASIC$S, SHADOW_TYPES.HARD, PCFShadowMap), _SHADOW_TYPES$BASIC$S)[shadowType] || BasicShadowMap;
};function decodeBase64(base64, enableUnicode) {
    var binaryString = atob(base64);
    if (enableUnicode) {
        var binaryView = new Uint8Array(binaryString.length);
        for (var i = 0, n = binaryString.length; i < n; ++i) {
            binaryView[i] = binaryString.charCodeAt(i);
        }
        return String.fromCharCode.apply(null, new Uint16Array(binaryView.buffer));
    }
    return binaryString;
}

function createURL(base64, sourcemapArg, enableUnicodeArg) {
    var sourcemap = sourcemapArg === undefined ? null : sourcemapArg;
    var enableUnicode = enableUnicodeArg === undefined ? false : enableUnicodeArg;
    var source = decodeBase64(base64, enableUnicode);
    var start = source.indexOf('\n', 10) + 1;
    var body = source.substring(start) + (sourcemap ? '\/\/# sourceMappingURL=' + sourcemap : '');
    var blob = new Blob([body], { type: 'application/javascript' });
    return URL.createObjectURL(blob);
}

function createBase64WorkerFactory(base64, sourcemapArg, enableUnicodeArg) {
    var url;
    return function WorkerFactory(options) {
        url = url || createURL(base64, sourcemapArg, enableUnicodeArg);
        return new Worker(url, options);
    };
}var WorkerFactory = createBase64WorkerFactory('Lyogcm9sbHVwLXBsdWdpbi13ZWItd29ya2VyLWxvYWRlciAqLwooZnVuY3Rpb24gKCkgewogICAgJ3VzZSBzdHJpY3QnOwoKICAgIHZhciBMSUJSQVJZX05BTUUgPSAnYW1tby5qcyc7CiAgICB2YXIgVFlQRVMgPSB7CiAgICAgIEJPWDogJ0JPWCcsCiAgICAgIFNQSEVSRTogJ1NQSEVSRScsCiAgICAgIFZFSElDTEU6ICdWRUhJQ0xFJywKICAgICAgTUVTSDogJ01FU0gnLAogICAgICBQTEFZRVI6ICdQTEFZRVInCiAgICB9OwogICAgdmFyIERFRkFVTFRfVkVISUNMRV9TVEFURSA9IHsKICAgICAgdmVoaWNsZVN0ZWVyaW5nOiAwLAogICAgICBhY2NlbGVyYXRpb246IGZhbHNlLAogICAgICBicmVha2luZzogZmFsc2UsCiAgICAgIHJpZ2h0OiBmYWxzZSwKICAgICAgbGVmdDogZmFsc2UKICAgIH07CiAgICB2YXIgREVGQVVMVF9SSUdJREJPRFlfU1RBVEUgPSB7CiAgICAgIHZlbG9jaXR5OiB7CiAgICAgICAgeDogMCwKICAgICAgICB5OiAwLAogICAgICAgIHo6IDAKICAgICAgfSwKICAgICAgbW92ZW1lbnQ6IHsKICAgICAgICBmb3J3YXJkOiBmYWxzZSwKICAgICAgICBiYWNrd2FyZHM6IGZhbHNlLAogICAgICAgIGxlZnQ6IGZhbHNlLAogICAgICAgIHJpZ2h0OiBmYWxzZQogICAgICB9LAogICAgICBkaXJlY3Rpb246IHsKICAgICAgICB4OiAwLAogICAgICAgIHk6IDAsCiAgICAgICAgejogMAogICAgICB9CiAgICB9OwogICAgdmFyIERFRkFVTFRfU0NBTEUgPSB7CiAgICAgIHg6IDEsCiAgICAgIHk6IDEsCiAgICAgIHo6IDEKICAgIH07CiAgICB2YXIgREVGQVVMVF9MSU5FQVJfVkVMT0NJVFkgPSB7CiAgICAgIHg6IDAsCiAgICAgIHk6IDAsCiAgICAgIHo6IDAKICAgIH07CiAgICB2YXIgREVGQVVMVF9JTVBVTFNFID0gewogICAgICB4OiAwLAogICAgICB5OiAwLAogICAgICB6OiAwCiAgICB9OwogICAgdmFyIERJU0FCTEVfREVBQ1RJVkFUSU9OID0gNDsKICAgIHZhciBHUkFWSVRZID0gewogICAgICB4OiAwLAogICAgICB5OiAtMTAsCiAgICAgIHo6IDAKICAgIH07CiAgICB2YXIgRlJPTlRfTEVGVCA9IDA7CiAgICB2YXIgRlJPTlRfUklHSFQgPSAxOwogICAgdmFyIEJBQ0tfTEVGVCA9IDI7CiAgICB2YXIgQkFDS19SSUdIVCA9IDM7CiAgICB2YXIgREVGQVVMVF9TVEVFUklOR19JTkNSRU1FTlQgPSAuMDQ7CiAgICB2YXIgREVGQVVMVF9TVEVFUklOR19DTEFNUCA9IC41OwogICAgdmFyIERFRkFVTFRfTUFYX0VOR0lORV9GT1JDRSA9IDIwMDA7CiAgICB2YXIgREVGQVVMVF9NQVhfQlJFQUtJTkdfRk9SQ0UgPSAxMDA7CiAgICB2YXIgRVhQTE9TSU9OX1NJWkVTID0gewogICAgICBTTUFMTDogNCwKICAgICAgTUVESVVNOiA2LAogICAgICBMQVJHRTogOCwKICAgICAgTUFTU0lWRTogMTIKICAgIH07CiAgICB2YXIgRVhQTE9TSU9OX1NUUkVOR1RIUyA9IHsKICAgICAgVkVSWV9XRUFLOiAyLAogICAgICBXRUFLOiA0LAogICAgICBNRURJVU06IDgsCiAgICAgIExBUkdFOiAxNiwKICAgICAgTUFTU0lWRTogMzIsCiAgICAgIE9LX05POiA2NAogICAgfTsKCiAgICB2YXIgUEhZU0lDU19FVkVOVFMgPSB7CiAgICAgIERJU1BBVENIOiAncGh5c2ljczpkaXNwYXRjaCcsCiAgICAgIFRFUk1JTkFURTogJ3BoeXNpY3M6dGVybWluYXRlJywKICAgICAgTE9BRDogewogICAgICAgIEFNTU86ICdwaHlzaWNzOmxvYWQ6YW1tbycKICAgICAgfSwKICAgICAgUkVBRFk6ICdwaHlzaWNzOnJlYWR5JywKICAgICAgSU5JVDogJ3BoeXNpY3M6aW5pdCcsCiAgICAgIFVQREFURTogJ3BoeXNpY3M6dXBkYXRlJywKICAgICAgQUREOiB7CiAgICAgICAgQk9YOiAncGh5c2ljczphZGQ6Ym94JywKICAgICAgICBWRUhJQ0xFOiAncGh5c2ljczphZGQ6dmVoaWNsZScsCiAgICAgICAgTU9ERUw6ICdwaHlzaWNzOmFkZDptb2RlbCcsCiAgICAgICAgUExBWUVSOiAncGh5c2ljczphZGQ6cGxheWVyJywKICAgICAgICBTUEhFUkU6ICdwaHlzaWNzOmFkZDpzcGhlcmUnCiAgICAgIH0sCiAgICAgIEVMRU1FTlQ6IHsKICAgICAgICBESVNQT1NFOiAncGh5c2ljczplbGVtZW50OmRpc3Bvc2UnLAogICAgICAgIENPTExJU0lPTjogJ3BoeXNpY3M6ZWxlbWVudDpjb2xsaXNpb24nLAogICAgICAgIFVQREFURTogJ3BoeXNpY3M6ZWxlbWVudDp1cGRhdGUnLAogICAgICAgIENSRUFURUQ6ICdwaHlzaWNzOmVsZW1lbnQ6Y3JlYXRlZCcsCiAgICAgICAgU0VUOiB7CiAgICAgICAgICBQT1NJVElPTjogJ3BoeXNpY3M6ZWxlbWVudDpzZXQ6cG9zaXRpb24nLAogICAgICAgICAgUVVBVEVSTklPTjogJ3BoeXNpY3M6ZWxlbWVudDpzZXQ6cXVhdGVybmlvbicsCiAgICAgICAgICBMSU5FQVJfVkVMT0NJVFk6ICdwaHlzaWNzOmVsZW1lbnQ6c2V0OmxpbmVhcl92ZWxvY2l0eScKICAgICAgICB9LAogICAgICAgIFJFU0VUOiAncGh5c2ljczplbGVtZW50OnJlc2V0JywKICAgICAgICBBUFBMWTogewogICAgICAgICAgSU1QVUxTRTogJ3BoeXNpY3M6ZWxlbWVudDphcHBseTppbXB1bHNlJwogICAgICAgIH0KICAgICAgfSwKICAgICAgVkVISUNMRTogewogICAgICAgIFNFVDogewogICAgICAgICAgUE9TSVRJT046ICdwaHlzaWNzOnZlaGljbGU6c2V0OnBvc2l0aW9uJywKICAgICAgICAgIFFVQVRFUk5JT046ICdwaHlzaWNzOnZlaGljbGU6c2V0OnF1YXRlcm5pb24nCiAgICAgICAgfSwKICAgICAgICBSRVNFVDogJ3BoeXNpY3M6dmVoaWNsZTpyZXNldCcsCiAgICAgICAgU1BFRUQ6ICdwaHlzaWNzOnZlaGljbGU6c3BlZWQnLAogICAgICAgIERJUkVDVElPTjogJ3BoeXNpY3M6dmVoaWNsZTpkaXJlY3Rpb24nCiAgICAgIH0sCiAgICAgIEVGRkVDVFM6IHsKICAgICAgICBFWFBMT1NJT046ICdwaHlzaWNzOmVmZmVjdHM6ZXhwbG9zaW9uJwogICAgICB9CiAgICB9OwoKICAgIGZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgewogICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7CgogICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgewogICAgICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOwogICAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7CiAgICAgICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7CiAgICAgIH0KCiAgICAgIHJldHVybiBrZXlzOwogICAgfQoKICAgIGZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkgewogICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OwogICAgICAgIGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgewogICAgICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7CiAgICAgICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsKICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOwogICAgICAgIH0pOwogICAgICB9CgogICAgICByZXR1cm4gdGFyZ2V0OwogICAgfQoKICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsKICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsKICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb24iKTsKICAgICAgfQogICAgfQoKICAgIGZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07CiAgICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOwogICAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsKICAgICAgICBpZiAoInZhbHVlIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsKICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7CiAgICAgIH0KICAgIH0KCiAgICBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7CiAgICAgIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOwogICAgICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7CiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgInByb3RvdHlwZSIsIHsKICAgICAgICB3cml0YWJsZTogZmFsc2UKICAgICAgfSk7CiAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjsKICAgIH0KCiAgICBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7CiAgICAgIGlmIChrZXkgaW4gb2JqKSB7CiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7CiAgICAgICAgICB2YWx1ZTogdmFsdWUsCiAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLAogICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLAogICAgICAgICAgd3JpdGFibGU6IHRydWUKICAgICAgICB9KTsKICAgICAgfSBlbHNlIHsKICAgICAgICBvYmpba2V5XSA9IHZhbHVlOwogICAgICB9CgogICAgICByZXR1cm4gb2JqOwogICAgfQoKICAgIHZhciBEaXNwYXRjaGVyID0gZnVuY3Rpb24gRGlzcGF0Y2hlcigpIHsKICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERpc3BhdGNoZXIpOwoKICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJzZW5kUGh5c2ljc1VwZGF0ZSIsIGZ1bmN0aW9uIChkdCkgewogICAgICAgIHJldHVybiBwb3N0TWVzc2FnZSh7CiAgICAgICAgICBldmVudDogUEhZU0lDU19FVkVOVFMuVVBEQVRFLAogICAgICAgICAgZHQ6IGR0CiAgICAgICAgfSk7CiAgICAgIH0pOwoKICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJzZW5kUmVhZHlFdmVudCIsIGZ1bmN0aW9uICgpIHsKICAgICAgICByZXR1cm4gcG9zdE1lc3NhZ2UoewogICAgICAgICAgZXZlbnQ6IFBIWVNJQ1NfRVZFTlRTLlJFQURZCiAgICAgICAgfSk7CiAgICAgIH0pOwoKICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJzZW5kVGVybWluYXRlRXZlbnQiLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlKHsKICAgICAgICAgIGV2ZW50OiBQSFlTSUNTX0VWRU5UUy5URVJNSU5BVEUKICAgICAgICB9KTsKICAgICAgfSk7CgogICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInNlbmRCb2R5VXBkYXRlIiwgZnVuY3Rpb24gKHV1aWQsIHBvc2l0aW9uLCByb3RhdGlvbiwgZHQsIGV4dHJhRGF0YSkgewogICAgICAgIHJldHVybiBwb3N0TWVzc2FnZShfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7CiAgICAgICAgICBldmVudDogUEhZU0lDU19FVkVOVFMuRUxFTUVOVC5VUERBVEUsCiAgICAgICAgICB1dWlkOiB1dWlkLAogICAgICAgICAgcG9zaXRpb246IHsKICAgICAgICAgICAgeDogcG9zaXRpb24ueCgpLAogICAgICAgICAgICB5OiBwb3NpdGlvbi55KCksCiAgICAgICAgICAgIHo6IHBvc2l0aW9uLnooKQogICAgICAgICAgfSwKICAgICAgICAgIHF1YXRlcm5pb246IHsKICAgICAgICAgICAgeDogcm90YXRpb24ueCgpLAogICAgICAgICAgICB5OiByb3RhdGlvbi55KCksCiAgICAgICAgICAgIHo6IHJvdGF0aW9uLnooKSwKICAgICAgICAgICAgdzogcm90YXRpb24udygpCiAgICAgICAgICB9CiAgICAgICAgfSwgZXh0cmFEYXRhKSwge30sIHsKICAgICAgICAgIGR0OiBkdAogICAgICAgIH0pKTsKICAgICAgfSk7CgogICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInNlbmREaXNwYXRjaEV2ZW50IiwgZnVuY3Rpb24gKHV1aWQsIGV2ZW50TmFtZSwgZXZlbnREYXRhKSB7CiAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlKHsKICAgICAgICAgIGV2ZW50OiBQSFlTSUNTX0VWRU5UUy5ESVNQQVRDSCwKICAgICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSwKICAgICAgICAgIGV2ZW50RGF0YTogZXZlbnREYXRhCiAgICAgICAgfSk7CiAgICAgIH0pOwogICAgfTsKICAgIHZhciBkaXNwYXRjaGVyJDEgPSBuZXcgRGlzcGF0Y2hlcigpOwoKICAgIHZhciBhcHBseU1hdHJpeDRUb1ZlY3RvcjMgPSBmdW5jdGlvbiBhcHBseU1hdHJpeDRUb1ZlY3RvcjMoX3JlZikgewogICAgICB2YXIgX3JlZiR4ID0gX3JlZi54LAogICAgICAgICAgeCA9IF9yZWYkeCA9PT0gdm9pZCAwID8gMCA6IF9yZWYkeCwKICAgICAgICAgIF9yZWYkeSA9IF9yZWYueSwKICAgICAgICAgIHkgPSBfcmVmJHkgPT09IHZvaWQgMCA/IDAgOiBfcmVmJHksCiAgICAgICAgICBfcmVmJHogPSBfcmVmLnosCiAgICAgICAgICB6ID0gX3JlZiR6ID09PSB2b2lkIDAgPyAwIDogX3JlZiR6OwogICAgICB2YXIgbWF0cml4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBbXTsKICAgICAgdmFyIHcgPSAxIC8gKG1hdHJpeFszXSAqIHggKyBtYXRyaXhbN10gKiB5ICsgbWF0cml4WzExXSAqIHogKyBtYXRyaXhbMTVdKTsKICAgICAgcmV0dXJuIHsKICAgICAgICB4OiAobWF0cml4WzBdICogeCArIG1hdHJpeFs0XSAqIHkgKyBtYXRyaXhbOF0gKiB6ICsgbWF0cml4WzEyXSkgKiB3LAogICAgICAgIHk6IChtYXRyaXhbMV0gKiB4ICsgbWF0cml4WzVdICogeSArIG1hdHJpeFs5XSAqIHogKyBtYXRyaXhbMTNdKSAqIHcsCiAgICAgICAgejogKG1hdHJpeFsyXSAqIHggKyBtYXRyaXhbNl0gKiB5ICsgbWF0cml4WzEwXSAqIHogKyBtYXRyaXhbMTRdKSAqIHcKICAgICAgfTsKICAgIH07CgogICAgdmFyIGNyZWF0ZVJpZ2lkQm9keSA9IGZ1bmN0aW9uIGNyZWF0ZVJpZ2lkQm9keShzaGFwZSwgb3B0aW9ucykgewogICAgICB2YXIgdXVpZCA9IG9wdGlvbnMudXVpZCwKICAgICAgICAgIHBvc2l0aW9uID0gb3B0aW9ucy5wb3NpdGlvbiwKICAgICAgICAgIHF1YXRlcm5pb24gPSBvcHRpb25zLnF1YXRlcm5pb24sCiAgICAgICAgICBtYXNzID0gb3B0aW9ucy5tYXNzLAogICAgICAgICAgZnJpY3Rpb24gPSBvcHRpb25zLmZyaWN0aW9uLAogICAgICAgICAgX29wdGlvbnMkcmVzdGl0dXRpb24gPSBvcHRpb25zLnJlc3RpdHV0aW9uLAogICAgICAgICAgcmVzdGl0dXRpb24gPSBfb3B0aW9ucyRyZXN0aXR1dGlvbiA9PT0gdm9pZCAwID8gLjkgOiBfb3B0aW9ucyRyZXN0aXR1dGlvbiwKICAgICAgICAgIF9vcHRpb25zJGRhbXBpbmcgPSBvcHRpb25zLmRhbXBpbmcsCiAgICAgICAgICBkYW1waW5nID0gX29wdGlvbnMkZGFtcGluZyA9PT0gdm9pZCAwID8gewogICAgICAgIGxpbmVhcjogMC4yLAogICAgICAgIGFuZ3VsYXI6IDAuMgogICAgICB9IDogX29wdGlvbnMkZGFtcGluZzsKICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgIHRyYW5zZm9ybS5zZXRJZGVudGl0eSgpOwogICAgICB0cmFuc2Zvcm0uc2V0T3JpZ2luKG5ldyBBbW1vLmJ0VmVjdG9yMyhwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KSk7CiAgICAgIHRyYW5zZm9ybS5zZXRSb3RhdGlvbihuZXcgQW1tby5idFF1YXRlcm5pb24ocXVhdGVybmlvbi54LCBxdWF0ZXJuaW9uLnksIHF1YXRlcm5pb24ueiwgcXVhdGVybmlvbi53KSk7CiAgICAgIHZhciBtb3Rpb25TdGF0ZSA9IG5ldyBBbW1vLmJ0RGVmYXVsdE1vdGlvblN0YXRlKHRyYW5zZm9ybSk7CiAgICAgIHZhciBsb2NhbEluZXJ0aWEgPSBuZXcgQW1tby5idFZlY3RvcjMoMCwgMCwgMCk7CiAgICAgIHNoYXBlLmNhbGN1bGF0ZUxvY2FsSW5lcnRpYShtYXNzLCBsb2NhbEluZXJ0aWEpOwogICAgICB2YXIgcmJJbmZvID0gbmV3IEFtbW8uYnRSaWdpZEJvZHlDb25zdHJ1Y3Rpb25JbmZvKG1hc3MsIG1vdGlvblN0YXRlLCBzaGFwZSwgbG9jYWxJbmVydGlhKTsKICAgICAgdmFyIGJvZHkgPSBuZXcgQW1tby5idFJpZ2lkQm9keShyYkluZm8pOwoKICAgICAgaWYgKG1hc3MgPiAwKSB7CiAgICAgICAgYm9keS5zZXRGcmljdGlvbihmcmljdGlvbik7CiAgICAgICAgYm9keS5zZXRSZXN0aXR1dGlvbihyZXN0aXR1dGlvbik7CiAgICAgICAgYm9keS5zZXREYW1waW5nKGRhbXBpbmcubGluZWFyLCBkYW1waW5nLmFuZ3VsYXIpOwogICAgICAgIGJvZHkuc2V0QWN0aXZhdGlvblN0YXRlKERJU0FCTEVfREVBQ1RJVkFUSU9OKTsKICAgICAgfSAvLyBzdG9yaW5nIHV1aWQgZm9yIGZ1dHVyZSByZWZlcmVuY2UKCgogICAgICBib2R5LnV1aWQgPSB1dWlkOwogICAgICB3b3JsZC5hZGRSaWdpZEJvZHkoYm9keSk7CiAgICAgIHJldHVybiBib2R5OwogICAgfTsKICAgIHZhciBhZGRNb2RlbCA9IGZ1bmN0aW9uIGFkZE1vZGVsKG9wdGlvbnMpIHsKICAgICAgdmFyIHV1aWQgPSBvcHRpb25zLnV1aWQsCiAgICAgICAgICB2ZXJ0aWNlcyA9IG9wdGlvbnMudmVydGljZXMsCiAgICAgICAgICBtYXRyaWNlcyA9IG9wdGlvbnMubWF0cmljZXMsCiAgICAgICAgICBpbmRleGVzID0gb3B0aW9ucy5pbmRleGVzLAogICAgICAgICAgcG9zaXRpb24gPSBvcHRpb25zLnBvc2l0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiA9IG9wdGlvbnMucXVhdGVybmlvbiwKICAgICAgICAgIF9vcHRpb25zJG1hc3MgPSBvcHRpb25zLm1hc3MsCiAgICAgICAgICBtYXNzID0gX29wdGlvbnMkbWFzcyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJG1hc3MsCiAgICAgICAgICBfb3B0aW9ucyRmcmljdGlvbiA9IG9wdGlvbnMuZnJpY3Rpb24sCiAgICAgICAgICBmcmljdGlvbiA9IF9vcHRpb25zJGZyaWN0aW9uID09PSB2b2lkIDAgPyAyIDogX29wdGlvbnMkZnJpY3Rpb247CiAgICAgIHZhciBzY2FsZSA9IERFRkFVTFRfU0NBTEU7CiAgICAgIHZhciBidGEgPSBuZXcgQW1tby5idFZlY3RvcjMoKTsKICAgICAgdmFyIGJ0YiA9IG5ldyBBbW1vLmJ0VmVjdG9yMygpOwogICAgICB2YXIgYnRjID0gbmV3IEFtbW8uYnRWZWN0b3IzKCk7CiAgICAgIHZhciB0cmlNZXNoID0gbmV3IEFtbW8uYnRUcmlhbmdsZU1lc2godHJ1ZSwgZmFsc2UpOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2ZXJ0aWNlcy5sZW5ndGg7IGkrKykgewogICAgICAgIHZhciBjb21wb25lbnRzID0gdmVydGljZXNbaV07CiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tpXSA/IGluZGV4ZXNbaV0gOiBudWxsOwogICAgICAgIHZhciBtYXRyaXggPSBBcnJheS5mcm9tKG1hdHJpY2VzW2ldKTsKCiAgICAgICAgaWYgKGluZGV4KSB7CiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGV4Lmxlbmd0aDsgaiArPSAzKSB7CiAgICAgICAgICAgIHZhciBhaSA9IGluZGV4W2pdICogMzsKICAgICAgICAgICAgdmFyIGJpID0gaW5kZXhbaiArIDFdICogMzsKICAgICAgICAgICAgdmFyIGNpID0gaW5kZXhbaiArIDJdICogMzsKICAgICAgICAgICAgdmFyIHZhID0gYXBwbHlNYXRyaXg0VG9WZWN0b3IzKHsKICAgICAgICAgICAgICB4OiBjb21wb25lbnRzW2FpXSwKICAgICAgICAgICAgICB5OiBjb21wb25lbnRzW2FpICsgMV0sCiAgICAgICAgICAgICAgejogY29tcG9uZW50c1thaSArIDJdCiAgICAgICAgICAgIH0sIG1hdHJpeCk7CiAgICAgICAgICAgIHZhciB2YiA9IGFwcGx5TWF0cml4NFRvVmVjdG9yMyh7CiAgICAgICAgICAgICAgeDogY29tcG9uZW50c1tiaV0sCiAgICAgICAgICAgICAgeTogY29tcG9uZW50c1tiaSArIDFdLAogICAgICAgICAgICAgIHo6IGNvbXBvbmVudHNbYmkgKyAyXQogICAgICAgICAgICB9LCBtYXRyaXgpOwogICAgICAgICAgICB2YXIgdmMgPSBhcHBseU1hdHJpeDRUb1ZlY3RvcjMoewogICAgICAgICAgICAgIHg6IGNvbXBvbmVudHNbY2ldLAogICAgICAgICAgICAgIHk6IGNvbXBvbmVudHNbY2kgKyAxXSwKICAgICAgICAgICAgICB6OiBjb21wb25lbnRzW2NpICsgMl0KICAgICAgICAgICAgfSwgbWF0cml4KTsKICAgICAgICAgICAgYnRhLnNldFZhbHVlKHZhLngsIHZhLnksIHZhLnopOwogICAgICAgICAgICBidGIuc2V0VmFsdWUodmIueCwgdmIueSwgdmIueik7CiAgICAgICAgICAgIGJ0Yy5zZXRWYWx1ZSh2Yy54LCB2Yy55LCB2Yy56KTsKICAgICAgICAgICAgdHJpTWVzaC5hZGRUcmlhbmdsZShidGEsIGJ0YiwgYnRjLCBmYWxzZSk7CiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBjb21wb25lbnRzLmxlbmd0aDsgX2ogKz0gOSkgewogICAgICAgICAgICB2YXIgX3ZhID0gYXBwbHlNYXRyaXg0VG9WZWN0b3IzKHsKICAgICAgICAgICAgICB4OiBjb21wb25lbnRzW19qICsgMF0sCiAgICAgICAgICAgICAgeTogY29tcG9uZW50c1tfaiArIDFdLAogICAgICAgICAgICAgIHo6IGNvbXBvbmVudHNbX2ogKyAyXQogICAgICAgICAgICB9LCBtYXRyaXgpOwoKICAgICAgICAgICAgdmFyIF92YiA9IGFwcGx5TWF0cml4NFRvVmVjdG9yMyh7CiAgICAgICAgICAgICAgeDogY29tcG9uZW50c1tfaiArIDNdLAogICAgICAgICAgICAgIHk6IGNvbXBvbmVudHNbX2ogKyA0XSwKICAgICAgICAgICAgICB6OiBjb21wb25lbnRzW19qICsgNV0KICAgICAgICAgICAgfSwgbWF0cml4KTsKCiAgICAgICAgICAgIHZhciBfdmMgPSBhcHBseU1hdHJpeDRUb1ZlY3RvcjMoewogICAgICAgICAgICAgIHg6IGNvbXBvbmVudHNbX2ogKyA2XSwKICAgICAgICAgICAgICB5OiBjb21wb25lbnRzW19qICsgN10sCiAgICAgICAgICAgICAgejogY29tcG9uZW50c1tfaiArIDhdCiAgICAgICAgICAgIH0sIG1hdHJpeCk7CgogICAgICAgICAgICBidGEuc2V0VmFsdWUoX3ZhLngsIF92YS55LCBfdmEueik7CiAgICAgICAgICAgIGJ0Yi5zZXRWYWx1ZShfdmIueCwgX3ZiLnksIF92Yi56KTsKICAgICAgICAgICAgYnRjLnNldFZhbHVlKF92Yy54LCBfdmMueSwgX3ZjLnopOwogICAgICAgICAgICB0cmlNZXNoLmFkZFRyaWFuZ2xlKGJ0YSwgYnRiLCBidGMsIGZhbHNlKTsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KCiAgICAgIHZhciBsb2NhbFNjYWxlID0gbmV3IEFtbW8uYnRWZWN0b3IzKHNjYWxlLngsIHNjYWxlLnksIHNjYWxlLnopOwogICAgICB0cmlNZXNoLnNldFNjYWxpbmcobG9jYWxTY2FsZSk7CiAgICAgIEFtbW8uZGVzdHJveShsb2NhbFNjYWxlKTsKICAgICAgdmFyIGNvbGxpc2lvblNoYXBlID0gbmV3IEFtbW8uYnRCdmhUcmlhbmdsZU1lc2hTaGFwZSh0cmlNZXNoLCB0cnVlLCB0cnVlKTsKICAgICAgY29sbGlzaW9uU2hhcGUucmVzb3VyY2VzID0gW3RyaU1lc2hdOwogICAgICBBbW1vLmRlc3Ryb3koYnRhKTsKICAgICAgQW1tby5kZXN0cm95KGJ0Yik7CiAgICAgIEFtbW8uZGVzdHJveShidGMpOwogICAgICB2YXIgYm9keSA9IGNyZWF0ZVJpZ2lkQm9keShjb2xsaXNpb25TaGFwZSwgewogICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLAogICAgICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sCiAgICAgICAgbWFzczogbWFzcywKICAgICAgICBmcmljdGlvbjogZnJpY3Rpb24KICAgICAgfSk7CiAgICAgIHdvcmxkLmFkZEVsZW1lbnQoewogICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgYm9keTogYm9keSwKICAgICAgICB0eXBlOiBUWVBFUy5NRVNILAogICAgICAgIHN0YXRlOiBERUZBVUxUX1JJR0lEQk9EWV9TVEFURQogICAgICB9KTsKICAgIH07CiAgICB2YXIgYWRkQm94ID0gZnVuY3Rpb24gYWRkQm94KGRhdGEpIHsKICAgICAgdmFyIHV1aWQgPSBkYXRhLnV1aWQsCiAgICAgICAgICB3aWR0aCA9IGRhdGEud2lkdGgsCiAgICAgICAgICBsZW5ndGggPSBkYXRhLmxlbmd0aCwKICAgICAgICAgIGhlaWdodCA9IGRhdGEuaGVpZ2h0LAogICAgICAgICAgcG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiA9IGRhdGEucXVhdGVybmlvbiwKICAgICAgICAgIF9kYXRhJG1hc3MgPSBkYXRhLm1hc3MsCiAgICAgICAgICBtYXNzID0gX2RhdGEkbWFzcyA9PT0gdm9pZCAwID8gMCA6IF9kYXRhJG1hc3MsCiAgICAgICAgICBfZGF0YSRmcmljdGlvbiA9IGRhdGEuZnJpY3Rpb24sCiAgICAgICAgICBmcmljdGlvbiA9IF9kYXRhJGZyaWN0aW9uID09PSB2b2lkIDAgPyAyIDogX2RhdGEkZnJpY3Rpb247CiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBBbW1vLmJ0Qm94U2hhcGUobmV3IEFtbW8uYnRWZWN0b3IzKHdpZHRoICogMC41LCBoZWlnaHQgKiAwLjUsIGxlbmd0aCAqIDAuNSkpOwogICAgICB2YXIgYm9keSA9IGNyZWF0ZVJpZ2lkQm9keShnZW9tZXRyeSwgewogICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLAogICAgICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sCiAgICAgICAgbWFzczogbWFzcywKICAgICAgICBmcmljdGlvbjogZnJpY3Rpb24KICAgICAgfSk7CiAgICAgIHdvcmxkLmFkZEVsZW1lbnQoewogICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgYm9keTogYm9keSwKICAgICAgICB0eXBlOiBUWVBFUy5CT1gsCiAgICAgICAgc3RhdGU6IERFRkFVTFRfUklHSURCT0RZX1NUQVRFCiAgICAgIH0pOwogICAgfTsKICAgIHZhciBhZGRTcGhlcmUgPSBmdW5jdGlvbiBhZGRTcGhlcmUoZGF0YSkgewogICAgICB2YXIgdXVpZCA9IGRhdGEudXVpZCwKICAgICAgICAgIHJhZGl1cyA9IGRhdGEucmFkaXVzLAogICAgICAgICAgcG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiA9IGRhdGEucXVhdGVybmlvbiwKICAgICAgICAgIF9kYXRhJG1hc3MyID0gZGF0YS5tYXNzLAogICAgICAgICAgbWFzcyA9IF9kYXRhJG1hc3MyID09PSB2b2lkIDAgPyAwIDogX2RhdGEkbWFzczIsCiAgICAgICAgICBfZGF0YSRmcmljdGlvbjIgPSBkYXRhLmZyaWN0aW9uLAogICAgICAgICAgZnJpY3Rpb24gPSBfZGF0YSRmcmljdGlvbjIgPT09IHZvaWQgMCA/IDIgOiBfZGF0YSRmcmljdGlvbjI7CiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBBbW1vLmJ0U3BoZXJlU2hhcGUocmFkaXVzKTsKICAgICAgdmFyIGJvZHkgPSBjcmVhdGVSaWdpZEJvZHkoZ2VvbWV0cnksIHsKICAgICAgICB1dWlkOiB1dWlkLAogICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbiwKICAgICAgICBxdWF0ZXJuaW9uOiBxdWF0ZXJuaW9uLAogICAgICAgIG1hc3M6IG1hc3MsCiAgICAgICAgZnJpY3Rpb246IGZyaWN0aW9uCiAgICAgIH0pOwogICAgICB3b3JsZC5hZGRFbGVtZW50KHsKICAgICAgICB1dWlkOiB1dWlkLAogICAgICAgIGJvZHk6IGJvZHksCiAgICAgICAgdHlwZTogVFlQRVMuU1BIRVJFLAogICAgICAgIHN0YXRlOiBERUZBVUxUX1JJR0lEQk9EWV9TVEFURQogICAgICB9KTsKICAgIH07CiAgICB2YXIgc2V0TGluZWFyVmVsb2NpdHkgPSBmdW5jdGlvbiBzZXRMaW5lYXJWZWxvY2l0eShkYXRhKSB7CiAgICAgIHZhciB1dWlkID0gZGF0YS51dWlkLAogICAgICAgICAgX2RhdGEkdmVsb2NpdHkgPSBkYXRhLnZlbG9jaXR5LAogICAgICAgICAgdmVsb2NpdHkgPSBfZGF0YSR2ZWxvY2l0eSA9PT0gdm9pZCAwID8gREVGQVVMVF9MSU5FQVJfVkVMT0NJVFkgOiBfZGF0YSR2ZWxvY2l0eTsKCiAgICAgIHZhciBfd29ybGQkZ2V0RWxlbWVudCA9IHdvcmxkLmdldEVsZW1lbnQodXVpZCksCiAgICAgICAgICBib2R5ID0gX3dvcmxkJGdldEVsZW1lbnQuYm9keTsKCiAgICAgIHZhciBtb3Rpb25TdGF0ZSA9IGJvZHkuZ2V0TW90aW9uU3RhdGUoKTsKCiAgICAgIGlmIChtb3Rpb25TdGF0ZSkgewogICAgICAgIHZhciBsaW5lYXJWZWxvY2l0eSA9IG5ldyBBbW1vLmJ0VmVjdG9yMyh2ZWxvY2l0eS54LCB2ZWxvY2l0eS55LCB2ZWxvY2l0eS56KTsKICAgICAgICBib2R5LnNldExpbmVhclZlbG9jaXR5KGxpbmVhclZlbG9jaXR5KTsKICAgICAgICBBbW1vLmRlc3Ryb3kobGluZWFyVmVsb2NpdHkpOwogICAgICB9CiAgICB9OwogICAgdmFyIHNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24oZGF0YSkgewogICAgICB2YXIgdXVpZCA9IGRhdGEudXVpZCwKICAgICAgICAgIHBvc2l0aW9uID0gZGF0YS5wb3NpdGlvbjsKCiAgICAgIHZhciBfd29ybGQkZ2V0RWxlbWVudDIgPSB3b3JsZC5nZXRFbGVtZW50KHV1aWQpLAogICAgICAgICAgYm9keSA9IF93b3JsZCRnZXRFbGVtZW50Mi5ib2R5OwoKICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgIGJvZHkuZ2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgdHJhbnNmb3JtLnNldE9yaWdpbihuZXcgQW1tby5idFZlY3RvcjMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueikpOwogICAgICBib2R5LnNldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICB9OwogICAgdmFyIHJlc2V0RWxlbWVudCA9IGZ1bmN0aW9uIHJlc2V0RWxlbWVudChkYXRhKSB7CiAgICAgIHZhciB1dWlkID0gZGF0YS51dWlkLAogICAgICAgICAgcG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uLAogICAgICAgICAgcXVhdGVybmlvbiA9IGRhdGEucXVhdGVybmlvbjsKCiAgICAgIHZhciBfd29ybGQkZ2V0RWxlbWVudDMgPSB3b3JsZC5nZXRFbGVtZW50KHV1aWQpLAogICAgICAgICAgYm9keSA9IF93b3JsZCRnZXRFbGVtZW50My5ib2R5OwoKICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgIGJvZHkuZ2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgdHJhbnNmb3JtLnNldE9yaWdpbihuZXcgQW1tby5idFZlY3RvcjMocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgcG9zaXRpb24ueikpOwogICAgICB0cmFuc2Zvcm0uc2V0Um90YXRpb24obmV3IEFtbW8uYnRRdWF0ZXJuaW9uKHF1YXRlcm5pb24ueCwgcXVhdGVybmlvbi55LCBxdWF0ZXJuaW9uLnosIHF1YXRlcm5pb24udykpOwogICAgICBib2R5LnNldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICB9OwogICAgdmFyIGFwcGx5SW1wdXNlID0gZnVuY3Rpb24gYXBwbHlJbXB1c2UoX3JlZikgewogICAgICB2YXIgdXVpZCA9IF9yZWYudXVpZCwKICAgICAgICAgIF9yZWYkaW1wdWxzZSA9IF9yZWYuaW1wdWxzZSwKICAgICAgICAgIGltcHVsc2UgPSBfcmVmJGltcHVsc2UgPT09IHZvaWQgMCA/IERFRkFVTFRfSU1QVUxTRSA6IF9yZWYkaW1wdWxzZTsKCiAgICAgIHZhciBfd29ybGQkZ2V0RWxlbWVudDQgPSB3b3JsZC5nZXRFbGVtZW50KHV1aWQpLAogICAgICAgICAgYm9keSA9IF93b3JsZCRnZXRFbGVtZW50NC5ib2R5OwoKICAgICAgdmFyIG1vdGlvblN0YXRlID0gYm9keS5nZXRNb3Rpb25TdGF0ZSgpOwoKICAgICAgaWYgKG1vdGlvblN0YXRlKSB7CiAgICAgICAgdmFyIGltcHVsc2VWZWN0b3IgPSBuZXcgQW1tby5idFZlY3RvcjMoaW1wdWxzZS54LCBpbXB1bHNlLnksIGltcHVsc2Uueik7CiAgICAgICAgYm9keS5hcHBseUNlbnRyYWxJbXB1bHNlKGltcHVsc2VWZWN0b3IpOwogICAgICAgIEFtbW8uZGVzdHJveShpbXB1bHNlVmVjdG9yKTsKICAgICAgfQogICAgfTsKICAgIHZhciBoYW5kbGVFbGVtZW50VXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlRWxlbWVudFVwZGF0ZShfcmVmMiwgZHQpIHsKICAgICAgdmFyIGJvZHkgPSBfcmVmMi5ib2R5LAogICAgICAgICAgdXVpZCA9IF9yZWYyLnV1aWQ7CiAgICAgICAgICBfcmVmMi5zdGF0ZTsKICAgICAgdmFyIG1vdGlvblN0YXRlID0gYm9keS5nZXRNb3Rpb25TdGF0ZSgpOwoKICAgICAgaWYgKG1vdGlvblN0YXRlKSB7CiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgICAgbW90aW9uU3RhdGUuZ2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgICB2YXIgb3JpZ2luID0gdHJhbnNmb3JtLmdldE9yaWdpbigpOwogICAgICAgIHZhciByb3RhdGlvbiA9IHRyYW5zZm9ybS5nZXRSb3RhdGlvbigpOwogICAgICAgIGRpc3BhdGNoZXIkMS5zZW5kQm9keVVwZGF0ZSh1dWlkLCBvcmlnaW4sIHJvdGF0aW9uLCBkdCk7CiAgICAgICAgQW1tby5kZXN0cm95KHRyYW5zZm9ybSk7CiAgICAgIH0KICAgIH07CgogICAgdmFyIGFkZFBsYXllciA9IGZ1bmN0aW9uIGFkZFBsYXllcihkYXRhKSB7CiAgICAgIHZhciB1dWlkID0gZGF0YS51dWlkLAogICAgICAgICAgd2lkdGggPSBkYXRhLndpZHRoLAogICAgICAgICAgaGVpZ2h0ID0gZGF0YS5oZWlnaHQsCiAgICAgICAgICBwb3NpdGlvbiA9IGRhdGEucG9zaXRpb24sCiAgICAgICAgICBxdWF0ZXJuaW9uID0gZGF0YS5xdWF0ZXJuaW9uLAogICAgICAgICAgbWFzcyA9IGRhdGEubWFzcywKICAgICAgICAgIGZyaWN0aW9uID0gZGF0YS5mcmljdGlvbjsKICAgICAgdmFyIGNhcHN1bGUgPSBuZXcgQW1tby5idENhcHN1bGVTaGFwZSh3aWR0aCwgaGVpZ2h0KTsKICAgICAgdmFyIGJvZHkgPSBjcmVhdGVSaWdpZEJvZHkoY2Fwc3VsZSwgewogICAgICAgIHV1aWQ6IHV1aWQsCiAgICAgICAgcG9zaXRpb246IHBvc2l0aW9uLAogICAgICAgIHF1YXRlcm5pb246IHF1YXRlcm5pb24sCiAgICAgICAgbWFzczogbWFzcywKICAgICAgICBmcmljdGlvbjogZnJpY3Rpb24KICAgICAgfSk7IC8vIGRpc2FibGlpbmcgcm90YXRpb24gZm9yIGNvbGxpc2lvbnMKCiAgICAgIGJvZHkuc2V0QW5ndWxhckZhY3RvcigwKTsKICAgICAgd29ybGQuYWRkUmlnaWRCb2R5KGJvZHkpOwogICAgICB3b3JsZC5hZGRFbGVtZW50KHsKICAgICAgICB1dWlkOiB1dWlkLAogICAgICAgIGJvZHk6IGJvZHksCiAgICAgICAgdHlwZTogVFlQRVMuUExBWUVSLAogICAgICAgIHN0YXRlOiBERUZBVUxUX1JJR0lEQk9EWV9TVEFURQogICAgICB9KTsKICAgIH07CiAgICB2YXIgaGFuZGxlUGxheWVyVXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlUGxheWVyVXBkYXRlKF9yZWYsIGR0KSB7CiAgICAgIHZhciBib2R5ID0gX3JlZi5ib2R5LAogICAgICAgICAgdXVpZCA9IF9yZWYudXVpZCwKICAgICAgICAgIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlLAogICAgICAgICAgc3RhdGUgPSBfcmVmJHN0YXRlID09PSB2b2lkIDAgPyBERUZBVUxUX1JJR0lEQk9EWV9TVEFURSA6IF9yZWYkc3RhdGU7CiAgICAgIHZhciBtb3ZlbWVudCA9IHN0YXRlLm1vdmVtZW50OwogICAgICAgICAgc3RhdGUuZGlyZWN0aW9uOwogICAgICAgICAgdmFyIGNhbWVyYURpcmVjdGlvbiA9IHN0YXRlLmNhbWVyYURpcmVjdGlvbjsKICAgICAgICAgIHN0YXRlLnF1YXRlcm5pb247CiAgICAgICAgICBzdGF0ZS5wb3NpdGlvbjsKICAgICAgdmFyIE1BWF9TUEVFRCA9IDE7CiAgICAgIHZhciB3YWxrVmVsb2NpdHkgPSAuMTsKICAgICAgdmFyIG1vdGlvblN0YXRlID0gYm9keS5nZXRNb3Rpb25TdGF0ZSgpOwoKICAgICAgaWYgKG1vdGlvblN0YXRlKSB7CiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgICAgbW90aW9uU3RhdGUuZ2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgICB2YXIgbGluZWFyVmVsb2NpdHkgPSBib2R5LmdldExpbmVhclZlbG9jaXR5KCk7CiAgICAgICAgdmFyIHNwZWVkID0gbGluZWFyVmVsb2NpdHkubGVuZ3RoKCk7CiAgICAgICAgdmFyIGZvcndhcmREaXIgPSB0cmFuc2Zvcm0uZ2V0QmFzaXMoKS5nZXRSb3coMik7CiAgICAgICAgZm9yd2FyZERpci5ub3JtYWxpemUoKTsKICAgICAgICB2YXIgd2Fsa0RpcmVjdGlvbiA9IG5ldyBBbW1vLmJ0VmVjdG9yMygwLjAsIDAuMCwgMC4wKTsKICAgICAgICB2YXIgd2Fsa1NwZWVkID0gd2Fsa1ZlbG9jaXR5ICogZHQ7CgogICAgICAgIGlmIChtb3ZlbWVudC5mb3J3YXJkKSB7CiAgICAgICAgICB3YWxrRGlyZWN0aW9uLnNldFgod2Fsa0RpcmVjdGlvbi54KCkgKyBmb3J3YXJkRGlyLngoKSk7IC8vd2Fsa0RpcmVjdGlvbi5zZXRZKCB3YWxrRGlyZWN0aW9uLnkoKSArIGZvcndhcmREaXIueSgpKTsKCiAgICAgICAgICB3YWxrRGlyZWN0aW9uLnNldFood2Fsa0RpcmVjdGlvbi56KCkgKyBmb3J3YXJkRGlyLnooKSk7CiAgICAgICAgfQoKICAgICAgICBpZiAobW92ZW1lbnQuYmFja3dhcmRzKSB7CiAgICAgICAgICB3YWxrRGlyZWN0aW9uLnNldFgod2Fsa0RpcmVjdGlvbi54KCkgLSBmb3J3YXJkRGlyLngoKSk7IC8vd2Fsa0RpcmVjdGlvbi5zZXRZKCB3YWxrRGlyZWN0aW9uLnkoKSAtIGZvcndhcmREaXIueSgpKTsKCiAgICAgICAgICB3YWxrRGlyZWN0aW9uLnNldFood2Fsa0RpcmVjdGlvbi56KCkgLSBmb3J3YXJkRGlyLnooKSk7CiAgICAgICAgfQoKICAgICAgICBpZiAoIW1vdmVtZW50LmZvcndhcmQgJiYgIW1vdmVtZW50LmJhY2t3YXJkcykgewogICAgICAgICAgbGluZWFyVmVsb2NpdHkuc2V0WChsaW5lYXJWZWxvY2l0eS54KCkgKiAwLjIpOwogICAgICAgICAgbGluZWFyVmVsb2NpdHkuc2V0WihsaW5lYXJWZWxvY2l0eS56KCkgKiAwLjIpOwogICAgICAgIH0gZWxzZSBpZiAoc3BlZWQgPCBNQVhfU1BFRUQpIHsKICAgICAgICAgIGxpbmVhclZlbG9jaXR5LnNldFgobGluZWFyVmVsb2NpdHkueCgpICsgY2FtZXJhRGlyZWN0aW9uLnggKiB3YWxrU3BlZWQpOwogICAgICAgICAgbGluZWFyVmVsb2NpdHkuc2V0WihsaW5lYXJWZWxvY2l0eS56KCkgKyBjYW1lcmFEaXJlY3Rpb24ueiAqIHdhbGtTcGVlZCk7CiAgICAgICAgfQoKICAgICAgICBib2R5LnNldExpbmVhclZlbG9jaXR5KGxpbmVhclZlbG9jaXR5KTsKICAgICAgICBib2R5LmdldE1vdGlvblN0YXRlKCkuc2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgICBib2R5LnNldENlbnRlck9mTWFzc1RyYW5zZm9ybSh0cmFuc2Zvcm0pOwogICAgICAgIHZhciBvcmlnaW4gPSB0cmFuc2Zvcm0uZ2V0T3JpZ2luKCk7CiAgICAgICAgdmFyIHJvdGF0aW9uID0gdHJhbnNmb3JtLmdldFJvdGF0aW9uKCk7CiAgICAgICAgZGlzcGF0Y2hlci5zZW5kQm9keVVwZGF0ZSh1dWlkLCBvcmlnaW4sIHJvdGF0aW9uLCBkdCk7CiAgICAgIH0KICAgIH07CgogICAgdmFyIENsb2NrID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAgICAgZnVuY3Rpb24gQ2xvY2soKSB7CiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENsb2NrKTsKCiAgICAgICAgdGhpcy50aW1lc3RhbXAgPSBudWxsOwogICAgICB9CgogICAgICBfY3JlYXRlQ2xhc3MoQ2xvY2ssIFt7CiAgICAgICAga2V5OiAiZ2V0RGVsdGEiLAogICAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWx0YSgpIHsKICAgICAgICAgIHZhciB0aW1lID0gRGF0ZS5ub3coKTsKCiAgICAgICAgICBpZiAodGhpcy50aW1lc3RhbXApIHsKICAgICAgICAgICAgdmFyIGRlbHRhID0gdGltZSAtIHRoaXMudGltZXN0YW1wOwogICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCA9IHRpbWU7CiAgICAgICAgICAgIHJldHVybiBkZWx0YTsKICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdGltZTsKICAgICAgICAgICAgcmV0dXJuIDA7CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9XSk7CgogICAgICByZXR1cm4gQ2xvY2s7CiAgICB9KCk7CgogICAgdmFyIFdvcmxkID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHsKICAgICAgZnVuY3Rpb24gV29ybGQoKSB7CiAgICAgICAgdmFyIF90aGlzID0gdGhpczsKCiAgICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFdvcmxkKTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJpbml0IiwgZnVuY3Rpb24gKG9wdGlvbnMpIHsKICAgICAgICAgIHZhciBfb3B0aW9ucyRncmF2aXR5ID0gb3B0aW9ucy5ncmF2aXR5LAogICAgICAgICAgICAgIGdyYXZpdHkgPSBfb3B0aW9ucyRncmF2aXR5ID09PSB2b2lkIDAgPyBHUkFWSVRZIDogX29wdGlvbnMkZ3Jhdml0eTsKICAgICAgICAgIF90aGlzLmNvbGxpc2lvbkNvbmZpZ3VyYXRpb24gPSBuZXcgQW1tby5idERlZmF1bHRDb2xsaXNpb25Db25maWd1cmF0aW9uKCk7CiAgICAgICAgICBfdGhpcy5kaXNwYXRjaGVyID0gbmV3IEFtbW8uYnRDb2xsaXNpb25EaXNwYXRjaGVyKF90aGlzLmNvbGxpc2lvbkNvbmZpZ3VyYXRpb24pOwogICAgICAgICAgX3RoaXMuYnJvYWRwaGFzZSA9IG5ldyBBbW1vLmJ0RGJ2dEJyb2FkcGhhc2UoKTsKICAgICAgICAgIF90aGlzLnNvbHZlciA9IG5ldyBBbW1vLmJ0U2VxdWVudGlhbEltcHVsc2VDb25zdHJhaW50U29sdmVyKCk7CiAgICAgICAgICBfdGhpcy5keW5hbWljc1dvcmxkID0gbmV3IEFtbW8uYnREaXNjcmV0ZUR5bmFtaWNzV29ybGQoX3RoaXMuZGlzcGF0Y2hlciwgX3RoaXMuYnJvYWRwaGFzZSwgX3RoaXMuc29sdmVyLCBfdGhpcy5jb2xsaXNpb25Db25maWd1cmF0aW9uKTsKCiAgICAgICAgICBfdGhpcy5keW5hbWljc1dvcmxkLnNldEdyYXZpdHkobmV3IEFtbW8uYnRWZWN0b3IzKGdyYXZpdHkueCwgZ3Jhdml0eS55LCBncmF2aXR5LnopKTsgLy8gdGhpcyBpcyBuZWVkZWQgZm9yIGdob3N0T2JqZWN0IGNvbGxpc2lvbnMKCgogICAgICAgICAgX3RoaXMuZHluYW1pY3NXb3JsZC5nZXRCcm9hZHBoYXNlKCkuZ2V0T3ZlcmxhcHBpbmdQYWlyQ2FjaGUoKS5zZXRJbnRlcm5hbEdob3N0UGFpckNhbGxiYWNrKG5ldyBBbW1vLmJ0R2hvc3RQYWlyQ2FsbGJhY2soKSk7CgogICAgICAgICAgX3RoaXMuaW5pdGlhbGlzZWQgPSB0cnVlOwogICAgICAgIH0pOwoKICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInJlbW92ZUVsZW1lbnQiLCBmdW5jdGlvbiAodXVpZCkgewogICAgICAgICAgaWYgKF90aGlzLmhhc0VsZW1lbnQodXVpZCkpIHsKICAgICAgICAgICAgX3RoaXMuZWxlbWVudHNbdXVpZF0uZGVsZXRlZCA9IHRydWU7CiAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAicmVtb3ZlRGVsZXRlZEVsZW1lbnRzIiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKF90aGlzLmVsZW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKHV1aWQpIHsKICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVsZW1lbnRzW3V1aWRdLmRlbGV0ZWQ7CiAgICAgICAgICB9KS5mb3JFYWNoKGZ1bmN0aW9uICh1dWlkKSB7CiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy5lbGVtZW50c1t1dWlkXTsKICAgICAgICAgIH0pOwogICAgICAgIH0pOwoKICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgImhhc0VsZW1lbnQiLCBmdW5jdGlvbiAodXVpZCkgewogICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKF90aGlzLmVsZW1lbnRzKS5pbmNsdWRlcyh1dWlkKTsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJnZXRFbGVtZW50IiwgZnVuY3Rpb24gKHV1aWQpIHsKICAgICAgICAgIHJldHVybiBfdGhpcy5lbGVtZW50c1t1dWlkXTsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJpc0luaXRpYWxpc2VkIiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgcmV0dXJuIF90aGlzLmluaXRpYWxpc2VkOwogICAgICAgIH0pOwoKICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgImdldER5bmFtaWNzV29ybGQiLCBmdW5jdGlvbiAoKSB7CiAgICAgICAgICByZXR1cm4gX3RoaXMuZHluYW1pY3NXb3JsZDsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJhZGRSaWdpZEJvZHkiLCBmdW5jdGlvbiAoYm9keSkgewogICAgICAgICAgX3RoaXMuZHluYW1pY3NXb3JsZC5hZGRSaWdpZEJvZHkoYm9keSk7CiAgICAgICAgfSk7CgogICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAiYWRkQWN0aW9uIiwgZnVuY3Rpb24gKGFjdGlvbikgewogICAgICAgICAgX3RoaXMuZHluYW1pY3NXb3JsZC5hZGRBY3Rpb24oYWN0aW9uKTsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJhZGRDb2xsaXNpb25PYmplY3QiLCBmdW5jdGlvbiAoY29sbGlzaW9uT2JqZWN0KSB7CiAgICAgICAgICBfdGhpcy5keW5hbWljc1dvcmxkLmFkZENvbGxpc2lvbk9iamVjdChjb2xsaXNpb25PYmplY3QpOwogICAgICAgIH0pOwoKICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInN0ZXBTaW11bGF0aW9uIiwgZnVuY3Rpb24gKGR0KSB7CiAgICAgICAgICBfdGhpcy5keW5hbWljc1dvcmxkLnN0ZXBTaW11bGF0aW9uKGR0KTsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJzaW11bGF0ZSIsIGZ1bmN0aW9uICgpIHsKICAgICAgICAgIHZhciBkdCA9IF90aGlzLmNsb2NrLmdldERlbHRhKCk7CgogICAgICAgICAgX3RoaXMuc3RlcFNpbXVsYXRpb24oZHQpOwoKICAgICAgICAgIE9iamVjdC5rZXlzKF90aGlzLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uICh1dWlkKSB7CiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gX3RoaXMuZ2V0RWxlbWVudCh1dWlkKTsKCiAgICAgICAgICAgIGlmIChlbGVtZW50KSB7CiAgICAgICAgICAgICAgc3dpdGNoIChlbGVtZW50LnR5cGUpIHsKICAgICAgICAgICAgICAgIGNhc2UgVFlQRVMuQk9YOgogICAgICAgICAgICAgICAgY2FzZSBUWVBFUy5TUEhFUkU6CiAgICAgICAgICAgICAgICBjYXNlIFRZUEVTLk1FU0g6CiAgICAgICAgICAgICAgICAgIGhhbmRsZUVsZW1lbnRVcGRhdGUoZWxlbWVudCwgZHQpOwogICAgICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgICAgICBjYXNlIFRZUEVTLlBMQVlFUjoKICAgICAgICAgICAgICAgICAgaGFuZGxlUGxheWVyVXBkYXRlKGVsZW1lbnQsIGR0KTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICAgICAgY2FzZSBUWVBFUy5WRUhJQ0xFOgogICAgICAgICAgICAgICAgICBoYW5kbGVWZWhpY2xlVXBkYXRlKGVsZW1lbnQsIGR0KTsKICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9KTsKCiAgICAgICAgICBfdGhpcy5jYWxjdWxhdGVDb2xsaXNpb25zKCk7CgogICAgICAgICAgX3RoaXMucmVtb3ZlRGVsZXRlZEVsZW1lbnRzKCk7CgogICAgICAgICAgZGlzcGF0Y2hlciQxLnNlbmRQaHlzaWNzVXBkYXRlKGR0KTsKICAgICAgICAgIF90aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZUlkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKF90aGlzLnNpbXVsYXRlLmJpbmQoX3RoaXMpKTsKICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJjYWxjdWxhdGVDb2xsaXNpb25zIiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgdmFyIGFtbW9EaXNwYXRjaGVyID0gX3RoaXMuZHluYW1pY3NXb3JsZC5nZXREaXNwYXRjaGVyKCk7CgogICAgICAgICAgdmFyIG51bU1hbmlmb2xkcyA9IGFtbW9EaXNwYXRjaGVyLmdldE51bU1hbmlmb2xkcygpOwoKICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtTWFuaWZvbGRzOyBpKyspIHsKICAgICAgICAgICAgdmFyIGNvbnRhY3RNYW5pZm9sZCA9IGFtbW9EaXNwYXRjaGVyLmdldE1hbmlmb2xkQnlJbmRleEludGVybmFsKGkpOwogICAgICAgICAgICB2YXIgcmIwID0gQW1tby5jYXN0T2JqZWN0KGNvbnRhY3RNYW5pZm9sZC5nZXRCb2R5MCgpLCBBbW1vLmJ0UmlnaWRCb2R5KTsKICAgICAgICAgICAgdmFyIHJiMSA9IEFtbW8uY2FzdE9iamVjdChjb250YWN0TWFuaWZvbGQuZ2V0Qm9keTEoKSwgQW1tby5idFJpZ2lkQm9keSk7CiAgICAgICAgICAgIHZhciBudW1Db250YWN0cyA9IGNvbnRhY3RNYW5pZm9sZC5nZXROdW1Db250YWN0cygpOyAvLyB0aGlzIGl0ZXJhdGlvbiBkb2Vzbid0IGhhdmUgdXVpZHMKCiAgICAgICAgICAgIGlmICghcmIwLnV1aWQgfHwgIXJiMS51dWlkKSBjb250aW51ZTsKICAgICAgICAgICAgdmFyIGNvbnRhY3RzID0gW107CgogICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG51bUNvbnRhY3RzOyBqKyspIHsKICAgICAgICAgICAgICB2YXIgY29udGFjdFBvaW50ID0gY29udGFjdE1hbmlmb2xkLmdldENvbnRhY3RQb2ludChqKTsKICAgICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSBjb250YWN0UG9pbnQuZ2V0RGlzdGFuY2UoKTsKICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwLjApIGNvbnRpbnVlOwogICAgICAgICAgICAgIHZhciB2ZWxvY2l0eTAgPSByYjAuZ2V0TGluZWFyVmVsb2NpdHkoKTsKICAgICAgICAgICAgICB2YXIgdmVsb2NpdHkxID0gcmIxLmdldExpbmVhclZlbG9jaXR5KCk7CiAgICAgICAgICAgICAgdmFyIHdvcmxkUG9zMCA9IGNvbnRhY3RQb2ludC5nZXRfbV9wb3NpdGlvbldvcmxkT25BKCk7CiAgICAgICAgICAgICAgdmFyIHdvcmxkUG9zMSA9IGNvbnRhY3RQb2ludC5nZXRfbV9wb3NpdGlvbldvcmxkT25CKCk7CiAgICAgICAgICAgICAgdmFyIGxvY2FsUG9zMCA9IGNvbnRhY3RQb2ludC5nZXRfbV9sb2NhbFBvaW50QSgpOwogICAgICAgICAgICAgIHZhciBsb2NhbFBvczEgPSBjb250YWN0UG9pbnQuZ2V0X21fbG9jYWxQb2ludEIoKTsKICAgICAgICAgICAgICBjb250YWN0cy5wdXNoKHsKICAgICAgICAgICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSwKICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBbewogICAgICAgICAgICAgICAgICB1dWlkOiByYjAudXVpZCwKICAgICAgICAgICAgICAgICAgdmVsb2NpdHk6IHsKICAgICAgICAgICAgICAgICAgICB4OiB2ZWxvY2l0eTAueCgpLAogICAgICAgICAgICAgICAgICAgIHk6IHZlbG9jaXR5MC55KCksCiAgICAgICAgICAgICAgICAgICAgejogdmVsb2NpdHkwLnooKQogICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICB3b3JsZFBvczogewogICAgICAgICAgICAgICAgICAgIHg6IHdvcmxkUG9zMC54KCksCiAgICAgICAgICAgICAgICAgICAgeTogd29ybGRQb3MwLnkoKSwKICAgICAgICAgICAgICAgICAgICB6OiB3b3JsZFBvczAueigpCiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIGxvY2FsUG9zOiB7CiAgICAgICAgICAgICAgICAgICAgeDogbG9jYWxQb3MwLngoKSwKICAgICAgICAgICAgICAgICAgICB5OiBsb2NhbFBvczAueSgpLAogICAgICAgICAgICAgICAgICAgIHo6IGxvY2FsUG9zMC56KCkKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfSwgewogICAgICAgICAgICAgICAgICB1dWlkOiByYjEudXVpZCwKICAgICAgICAgICAgICAgICAgdmVsb2NpdHk6IHsKICAgICAgICAgICAgICAgICAgICB4OiB2ZWxvY2l0eTEueCgpLAogICAgICAgICAgICAgICAgICAgIHk6IHZlbG9jaXR5MS55KCksCiAgICAgICAgICAgICAgICAgICAgejogdmVsb2NpdHkxLnooKQogICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICB3b3JsZFBvczogewogICAgICAgICAgICAgICAgICAgIHg6IHdvcmxkUG9zMS54KCksCiAgICAgICAgICAgICAgICAgICAgeTogd29ybGRQb3MxLnkoKSwKICAgICAgICAgICAgICAgICAgICB6OiB3b3JsZFBvczEueigpCiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIGxvY2FsUG9zOiB7CiAgICAgICAgICAgICAgICAgICAgeDogbG9jYWxQb3MxLngoKSwKICAgICAgICAgICAgICAgICAgICB5OiBsb2NhbFBvczEueSgpLAogICAgICAgICAgICAgICAgICAgIHo6IGxvY2FsUG9zMS56KCkKICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfV0KICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgfQoKICAgICAgICAgICAgZGlzcGF0Y2hlciQxLnNlbmREaXNwYXRjaEV2ZW50KHJiMC51dWlkLCBQSFlTSUNTX0VWRU5UUy5FTEVNRU5ULkNPTExJU0lPTiwgewogICAgICAgICAgICAgIGNvbnRhY3RzOiBjb250YWN0cwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgZGlzcGF0Y2hlciQxLnNlbmREaXNwYXRjaEV2ZW50KHJiMS51dWlkLCBQSFlTSUNTX0VWRU5UUy5FTEVNRU5ULkNPTExJU0lPTiwgewogICAgICAgICAgICAgIGNvbnRhY3RzOiBjb250YWN0cwogICAgICAgICAgICB9KTsKICAgICAgICAgIH0KICAgICAgICB9KTsKCiAgICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsICJhZGRFbGVtZW50IiwgZnVuY3Rpb24gKGRhdGEpIHsKICAgICAgICAgIF90aGlzLmVsZW1lbnRzW2RhdGEudXVpZF0gPSBkYXRhOwogICAgICAgIH0pOwoKICAgICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgInVwZGF0ZUJvZHlTdGF0ZSIsIGZ1bmN0aW9uIChfcmVmKSB7CiAgICAgICAgICB2YXIgdXVpZCA9IF9yZWYudXVpZCwKICAgICAgICAgICAgICBzdGF0ZSA9IF9yZWYuc3RhdGU7CgogICAgICAgICAgaWYgKF90aGlzLmhhc0VsZW1lbnQodXVpZCkpIHsKICAgICAgICAgICAgX3RoaXMuZWxlbWVudHNbdXVpZF0uc3RhdGUgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgX3RoaXMuZWxlbWVudHNbdXVpZF0uc3RhdGUpLCBzdGF0ZSk7CiAgICAgICAgICB9CiAgICAgICAgfSk7CgogICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCAidGVybWluYXRlIiwgZnVuY3Rpb24gKCkgewogICAgICAgICAgQW1tby5kZXN0cm95KF90aGlzLmR5bmFtaWNzV29ybGQpOwogICAgICAgICAgQW1tby5kZXN0cm95KF90aGlzLnNvbHZlcik7CiAgICAgICAgICBBbW1vLmRlc3Ryb3koX3RoaXMuZGlzcGF0Y2hlcik7CiAgICAgICAgICBBbW1vLmRlc3Ryb3koX3RoaXMuY29sbGlzaW9uQ29uZmlndXJhdGlvbik7CiAgICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWVJZCk7CiAgICAgICAgICBkaXNwYXRjaGVyJDEuc2VuZFRlcm1pbmF0ZUV2ZW50KCk7CiAgICAgICAgfSk7CgogICAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTsKICAgICAgICB0aGlzLmluaXRpYWxpc2VkID0gZmFsc2U7CiAgICAgICAgdGhpcy5jb2xsaXNpb25Db25maWd1cmF0aW9uID0gdW5kZWZpbmVkOwogICAgICAgIHRoaXMuZGlzcGF0Y2hlciA9IHVuZGVmaW5lZDsKICAgICAgICB0aGlzLmJyb2FkcGhhc2UgPSB1bmRlZmluZWQ7CiAgICAgICAgdGhpcy5zb2x2ZXIgPSB1bmRlZmluZWQ7CiAgICAgICAgdGhpcy5keW5hbWljc1dvcmxkID0gdW5kZWZpbmVkOwogICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lSWQgPSBudWxsOwogICAgICAgIHRoaXMuY2xvY2sgPSBuZXcgQ2xvY2soKTsKICAgICAgfQoKICAgICAgX2NyZWF0ZUNsYXNzKFdvcmxkLCBbewogICAgICAgIGtleTogImRpc3Bvc2VCb2R5IiwKICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGlzcG9zZUJvZHkoX3JlZjIpIHsKICAgICAgICAgIHZhciB1dWlkID0gX3JlZjIudXVpZDsKICAgICAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KHV1aWQpOwogICAgICAgICAgdGhpcy5keW5hbWljc1dvcmxkLnJlbW92ZVJpZ2lkQm9keShlbGVtZW50LmJvZHkpOwogICAgICAgICAgdGhpcy5yZW1vdmVFbGVtZW50KHV1aWQpOwogICAgICAgICAgZGlzcGF0Y2hlciQxLnNlbmRFbGVtZW50RGlzcG9zZWQoewogICAgICAgICAgICB1dWlkOiB1dWlkCiAgICAgICAgICB9KTsKICAgICAgICB9CiAgICAgIH1dKTsKCiAgICAgIHJldHVybiBXb3JsZDsKICAgIH0oKTsKICAgIHZhciB3b3JsZCA9IG5ldyBXb3JsZCgpOwoKICAgIHZhciBERUZBVUxUX1JPTExfSU5GTFVFTkNFID0gMC4yOwogICAgdmFyIERFRkFVTFRfRlJJQ1RJT04gPSAxMDAwOwogICAgdmFyIERFRkFVTFRfTUFTUyA9IDgwMDsKICAgIHZhciBhZGRWZWhpY2xlID0gZnVuY3Rpb24gYWRkVmVoaWNsZShkYXRhKSB7CiAgICAgIHZhciBwb3NpdGlvbiA9IGRhdGEucG9zaXRpb24sCiAgICAgICAgICBxdWF0ZXJuaW9uID0gZGF0YS5xdWF0ZXJuaW9uLAogICAgICAgICAgdXVpZCA9IGRhdGEudXVpZCwKICAgICAgICAgIHdoZWVscyA9IGRhdGEud2hlZWxzLAogICAgICAgICAgX2RhdGEkbWFzcyA9IGRhdGEubWFzcywKICAgICAgICAgIG1hc3MgPSBfZGF0YSRtYXNzID09PSB2b2lkIDAgPyBERUZBVUxUX01BU1MgOiBfZGF0YSRtYXNzLAogICAgICAgICAgX2RhdGEkd2lkdGggPSBkYXRhLndpZHRoLAogICAgICAgICAgd2lkdGggPSBfZGF0YSR3aWR0aCA9PT0gdm9pZCAwID8gMS44IDogX2RhdGEkd2lkdGgsCiAgICAgICAgICBfZGF0YSRoZWlnaHQgPSBkYXRhLmhlaWdodCwKICAgICAgICAgIGhlaWdodCA9IF9kYXRhJGhlaWdodCA9PT0gdm9pZCAwID8gLjYgOiBfZGF0YSRoZWlnaHQsCiAgICAgICAgICBfZGF0YSRsZW5ndGggPSBkYXRhLmxlbmd0aCwKICAgICAgICAgIGxlbmd0aCA9IF9kYXRhJGxlbmd0aCA9PT0gdm9pZCAwID8gNCA6IF9kYXRhJGxlbmd0aCwKICAgICAgICAgIF9kYXRhJGZyaWN0aW9uID0gZGF0YS5mcmljdGlvbiwKICAgICAgICAgIGZyaWN0aW9uID0gX2RhdGEkZnJpY3Rpb24gPT09IHZvaWQgMCA/IERFRkFVTFRfRlJJQ1RJT04gOiBfZGF0YSRmcmljdGlvbiwKICAgICAgICAgIF9kYXRhJHJvbGxJbmZsdWVuY2UgPSBkYXRhLnJvbGxJbmZsdWVuY2UsCiAgICAgICAgICByb2xsSW5mbHVlbmNlID0gX2RhdGEkcm9sbEluZmx1ZW5jZSA9PT0gdm9pZCAwID8gREVGQVVMVF9ST0xMX0lORkxVRU5DRSA6IF9kYXRhJHJvbGxJbmZsdWVuY2UsCiAgICAgICAgICBfZGF0YSR3aGVlbHNPcHRpb25zID0gZGF0YS53aGVlbHNPcHRpb25zLAogICAgICAgICAgd2hlZWxzT3B0aW9ucyA9IF9kYXRhJHdoZWVsc09wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX2RhdGEkd2hlZWxzT3B0aW9ucywKICAgICAgICAgIF9kYXRhJHN1c3BlbnNpb25zID0gZGF0YS5zdXNwZW5zaW9ucywKICAgICAgICAgIHN1c3BlbnNpb25zID0gX2RhdGEkc3VzcGVuc2lvbnMgPT09IHZvaWQgMCA/IHt9IDogX2RhdGEkc3VzcGVuc2lvbnM7CiAgICAgIHZhciBfd2hlZWxzT3B0aW9ucyRiYWNrID0gd2hlZWxzT3B0aW9ucy5iYWNrLAogICAgICAgICAgYmFjayA9IF93aGVlbHNPcHRpb25zJGJhY2sgPT09IHZvaWQgMCA/IHt9IDogX3doZWVsc09wdGlvbnMkYmFjaywKICAgICAgICAgIF93aGVlbHNPcHRpb25zJGZyb250ID0gd2hlZWxzT3B0aW9ucy5mcm9udCwKICAgICAgICAgIGZyb250ID0gX3doZWVsc09wdGlvbnMkZnJvbnQgPT09IHZvaWQgMCA/IHt9IDogX3doZWVsc09wdGlvbnMkZnJvbnQ7CiAgICAgIHZhciBfYmFjayRheGlzUG9zaXRpb24gPSBiYWNrLmF4aXNQb3NpdGlvbiwKICAgICAgICAgIGF4aXNQb3NpdGlvbkJhY2sgPSBfYmFjayRheGlzUG9zaXRpb24gPT09IHZvaWQgMCA/IC0xIDogX2JhY2skYXhpc1Bvc2l0aW9uLAogICAgICAgICAgX2JhY2skcmFkaXVzID0gYmFjay5yYWRpdXMsCiAgICAgICAgICB3aGVlbFJhZGl1c0JhY2sgPSBfYmFjayRyYWRpdXMgPT09IHZvaWQgMCA/IC40IDogX2JhY2skcmFkaXVzLAogICAgICAgICAgX2JhY2skaGFsZlRyYWNrID0gYmFjay5oYWxmVHJhY2ssCiAgICAgICAgICB3aGVlbEhhbGZUcmFja0JhY2sgPSBfYmFjayRoYWxmVHJhY2sgPT09IHZvaWQgMCA/IDEgOiBfYmFjayRoYWxmVHJhY2ssCiAgICAgICAgICBfYmFjayRheGlzSGVpZ2h0ID0gYmFjay5heGlzSGVpZ2h0LAogICAgICAgICAgd2hlZWxBeGlzSGVpZ2h0QmFjayA9IF9iYWNrJGF4aXNIZWlnaHQgPT09IHZvaWQgMCA/IC4zIDogX2JhY2skYXhpc0hlaWdodDsKICAgICAgdmFyIF9mcm9udCRheGlzUG9zaXRpb24gPSBmcm9udC5heGlzUG9zaXRpb24sCiAgICAgICAgICBheGlzUG9zaXRpb25Gcm9udCA9IF9mcm9udCRheGlzUG9zaXRpb24gPT09IHZvaWQgMCA/IDEuNyA6IF9mcm9udCRheGlzUG9zaXRpb24sCiAgICAgICAgICBfZnJvbnQkcmFkaXVzID0gZnJvbnQucmFkaXVzLAogICAgICAgICAgd2hlZWxSYWRpdXNGcm9udCA9IF9mcm9udCRyYWRpdXMgPT09IHZvaWQgMCA/IC40IDogX2Zyb250JHJhZGl1cywKICAgICAgICAgIF9mcm9udCRoYWxmVHJhY2sgPSBmcm9udC5oYWxmVHJhY2ssCiAgICAgICAgICB3aGVlbEhhbGZUcmFja0Zyb250ID0gX2Zyb250JGhhbGZUcmFjayA9PT0gdm9pZCAwID8gMSA6IF9mcm9udCRoYWxmVHJhY2ssCiAgICAgICAgICBfZnJvbnQkYXhpc0hlaWdodCA9IGZyb250LmF4aXNIZWlnaHQsCiAgICAgICAgICB3aGVlbEF4aXNIZWlnaHRGcm9udCA9IF9mcm9udCRheGlzSGVpZ2h0ID09PSB2b2lkIDAgPyAuMyA6IF9mcm9udCRheGlzSGVpZ2h0OwogICAgICB2YXIgX3N1c3BlbnNpb25zJHN0aWZmbmVzID0gc3VzcGVuc2lvbnMuc3RpZmZuZXNzLAogICAgICAgICAgc3RpZmZuZXNzID0gX3N1c3BlbnNpb25zJHN0aWZmbmVzID09PSB2b2lkIDAgPyAyMC4wIDogX3N1c3BlbnNpb25zJHN0aWZmbmVzLAogICAgICAgICAgX3N1c3BlbnNpb25zJGRhbXBpbmcgPSBzdXNwZW5zaW9ucy5kYW1waW5nLAogICAgICAgICAgZGFtcGluZyA9IF9zdXNwZW5zaW9ucyRkYW1waW5nID09PSB2b2lkIDAgPyAyLjMgOiBfc3VzcGVuc2lvbnMkZGFtcGluZywKICAgICAgICAgIF9zdXNwZW5zaW9ucyRjb21wcmVzcyA9IHN1c3BlbnNpb25zLmNvbXByZXNzaW9uLAogICAgICAgICAgY29tcHJlc3Npb24gPSBfc3VzcGVuc2lvbnMkY29tcHJlc3MgPT09IHZvaWQgMCA/IDQuNCA6IF9zdXNwZW5zaW9ucyRjb21wcmVzcywKICAgICAgICAgIF9zdXNwZW5zaW9ucyRyZXN0TGVuZyA9IHN1c3BlbnNpb25zLnJlc3RMZW5ndGgsCiAgICAgICAgICByZXN0TGVuZ3RoID0gX3N1c3BlbnNpb25zJHJlc3RMZW5nID09PSB2b2lkIDAgPyAwLjYgOiBfc3VzcGVuc2lvbnMkcmVzdExlbmc7IC8vIENoYXNzaXMKCiAgICAgIHZhciBnZW9tZXRyeSA9IG5ldyBBbW1vLmJ0Qm94U2hhcGUobmV3IEFtbW8uYnRWZWN0b3IzKHdpZHRoICogLjUsIGhlaWdodCAqIC41LCBsZW5ndGggKiAuNSkpOwogICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IEFtbW8uYnRUcmFuc2Zvcm0oKTsKICAgICAgdHJhbnNmb3JtLnNldElkZW50aXR5KCk7CiAgICAgIHRyYW5zZm9ybS5zZXRPcmlnaW4obmV3IEFtbW8uYnRWZWN0b3IzKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopKTsKICAgICAgdHJhbnNmb3JtLnNldFJvdGF0aW9uKG5ldyBBbW1vLmJ0UXVhdGVybmlvbihxdWF0ZXJuaW9uLngsIHF1YXRlcm5pb24ueSwgcXVhdGVybmlvbi56LCBxdWF0ZXJuaW9uLncpKTsKICAgICAgdmFyIG1vdGlvblN0YXRlID0gbmV3IEFtbW8uYnREZWZhdWx0TW90aW9uU3RhdGUodHJhbnNmb3JtKTsKICAgICAgdmFyIGxvY2FsSW5lcnRpYSA9IG5ldyBBbW1vLmJ0VmVjdG9yMygwLCAwLCAwKTsKICAgICAgZ2VvbWV0cnkuY2FsY3VsYXRlTG9jYWxJbmVydGlhKG1hc3MsIGxvY2FsSW5lcnRpYSk7CiAgICAgIHZhciBjaGFzc2lzID0gbmV3IEFtbW8uYnRSaWdpZEJvZHkobmV3IEFtbW8uYnRSaWdpZEJvZHlDb25zdHJ1Y3Rpb25JbmZvKG1hc3MsIG1vdGlvblN0YXRlLCBnZW9tZXRyeSwgbG9jYWxJbmVydGlhKSk7CiAgICAgIGNoYXNzaXMuc2V0QWN0aXZhdGlvblN0YXRlKERJU0FCTEVfREVBQ1RJVkFUSU9OKTsKICAgICAgd29ybGQuYWRkUmlnaWRCb2R5KGNoYXNzaXMpOyAvLyBSYXljYXN0IFZlaGljbGUKCiAgICAgIHZhciB0dW5pbmcgPSBuZXcgQW1tby5idFZlaGljbGVUdW5pbmcoKTsKICAgICAgdmFyIHJheUNhc3RlciA9IG5ldyBBbW1vLmJ0RGVmYXVsdFZlaGljbGVSYXljYXN0ZXIod29ybGQuZ2V0RHluYW1pY3NXb3JsZCgpKTsKICAgICAgdmFyIHZlaGljbGUgPSBuZXcgQW1tby5idFJheWNhc3RWZWhpY2xlKHR1bmluZywgY2hhc3NpcywgcmF5Q2FzdGVyKTsKICAgICAgdmVoaWNsZS5zZXRDb29yZGluYXRlU3lzdGVtKDAsIDEsIDIpOwogICAgICB3b3JsZC5hZGRBY3Rpb24odmVoaWNsZSk7CiAgICAgIHZhciB3aGVlbERpcmVjdGlvbkNTMCA9IG5ldyBBbW1vLmJ0VmVjdG9yMygwLCAtMSwgMCk7CiAgICAgIHZhciB3aGVlbEF4bGVDUyA9IG5ldyBBbW1vLmJ0VmVjdG9yMygtMSwgMCwgMCk7CgogICAgICB2YXIgYWRkV2hlZWwgPSBmdW5jdGlvbiBhZGRXaGVlbChpc0Zyb250LCBwb3MsIHJhZGl1cykgewogICAgICAgIHZhciB3aGVlbEluZm8gPSB2ZWhpY2xlLmFkZFdoZWVsKHBvcywgd2hlZWxEaXJlY3Rpb25DUzAsIHdoZWVsQXhsZUNTLCByZXN0TGVuZ3RoLCByYWRpdXMsIHR1bmluZywgaXNGcm9udCk7CiAgICAgICAgd2hlZWxJbmZvLnNldF9tX3N1c3BlbnNpb25TdGlmZm5lc3Moc3RpZmZuZXNzKTsKICAgICAgICB3aGVlbEluZm8uc2V0X21fd2hlZWxzRGFtcGluZ1JlbGF4YXRpb24oZGFtcGluZyk7CiAgICAgICAgd2hlZWxJbmZvLnNldF9tX3doZWVsc0RhbXBpbmdDb21wcmVzc2lvbihjb21wcmVzc2lvbik7CiAgICAgICAgd2hlZWxJbmZvLnNldF9tX2ZyaWN0aW9uU2xpcChmcmljdGlvbik7CiAgICAgICAgd2hlZWxJbmZvLnNldF9tX3JvbGxJbmZsdWVuY2Uocm9sbEluZmx1ZW5jZSk7CiAgICAgIH07CgogICAgICBhZGRXaGVlbCh0cnVlLCBuZXcgQW1tby5idFZlY3RvcjMod2hlZWxIYWxmVHJhY2tGcm9udCwgd2hlZWxBeGlzSGVpZ2h0RnJvbnQsIGF4aXNQb3NpdGlvbkZyb250KSwgd2hlZWxSYWRpdXNGcm9udCk7CiAgICAgIGFkZFdoZWVsKHRydWUsIG5ldyBBbW1vLmJ0VmVjdG9yMygtd2hlZWxIYWxmVHJhY2tGcm9udCwgd2hlZWxBeGlzSGVpZ2h0RnJvbnQsIGF4aXNQb3NpdGlvbkZyb250KSwgd2hlZWxSYWRpdXNGcm9udCk7CiAgICAgIGFkZFdoZWVsKGZhbHNlLCBuZXcgQW1tby5idFZlY3RvcjMoLXdoZWVsSGFsZlRyYWNrQmFjaywgd2hlZWxBeGlzSGVpZ2h0QmFjaywgYXhpc1Bvc2l0aW9uQmFjayksIHdoZWVsUmFkaXVzQmFjayk7CiAgICAgIGFkZFdoZWVsKGZhbHNlLCBuZXcgQW1tby5idFZlY3RvcjMod2hlZWxIYWxmVHJhY2tCYWNrLCB3aGVlbEF4aXNIZWlnaHRCYWNrLCBheGlzUG9zaXRpb25CYWNrKSwgd2hlZWxSYWRpdXNCYWNrKTsKICAgICAgdmVoaWNsZS51dWlkID0gdXVpZDsKICAgICAgd29ybGQuYWRkRWxlbWVudCh7CiAgICAgICAgdHlwZTogVFlQRVMuVkVISUNMRSwKICAgICAgICB1dWlkOiB1dWlkLAogICAgICAgIHZlaGljbGU6IHZlaGljbGUsCiAgICAgICAgd2hlZWxzOiB3aGVlbHMsCiAgICAgICAgb3B0aW9uczogZGF0YSwKICAgICAgICBzdGF0ZTogREVGQVVMVF9WRUhJQ0xFX1NUQVRFCiAgICAgIH0pOwogICAgfTsKICAgIHZhciBzZXRWZWhpY2xlUG9zaXRpb24gPSBmdW5jdGlvbiBzZXRWZWhpY2xlUG9zaXRpb24oZGF0YSkgewogICAgICB2YXIgdXVpZCA9IGRhdGEudXVpZCwKICAgICAgICAgIHBvc2l0aW9uID0gZGF0YS5wb3NpdGlvbjsKICAgICAgdmFyIGVsZW1lbnQgPSB3b3JsZC5nZXRFbGVtZW50KHV1aWQpOwoKICAgICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gVFlQRVMuVkVISUNMRSkgewogICAgICAgIHZhciBib2R5ID0gZWxlbWVudC52ZWhpY2xlLmdldFJpZ2lkQm9keSgpOwogICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgQW1tby5idFRyYW5zZm9ybSgpOwogICAgICAgIGJvZHkuZ2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgICB0cmFuc2Zvcm0uc2V0T3JpZ2luKG5ldyBBbW1vLmJ0VmVjdG9yMyhwb3NpdGlvbi54LCBwb3NpdGlvbi55LCBwb3NpdGlvbi56KSk7CiAgICAgICAgYm9keS5zZXRXb3JsZFRyYW5zZm9ybSh0cmFuc2Zvcm0pOwogICAgICB9CiAgICB9OwogICAgdmFyIHNldFZlaGljbGVRdWF0ZXJuaW9uID0gZnVuY3Rpb24gc2V0VmVoaWNsZVF1YXRlcm5pb24oZGF0YSkgewogICAgICB2YXIgdXVpZCA9IGRhdGEudXVpZCwKICAgICAgICAgIHF1YXRlcm5pb24gPSBkYXRhLnF1YXRlcm5pb247CiAgICAgIHZhciBlbGVtZW50ID0gd29ybGQuZ2V0RWxlbWVudCh1dWlkKTsKCiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFRZUEVTLlZFSElDTEUpIHsKICAgICAgICB2YXIgYm9keSA9IGVsZW1lbnQudmVoaWNsZS5nZXRSaWdpZEJvZHkoKTsKICAgICAgICB2YXIgdHJhbnNmb3JtID0gbmV3IEFtbW8uYnRUcmFuc2Zvcm0oKTsKICAgICAgICBib2R5LmdldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICAgICAgdHJhbnNmb3JtLnNldFJvdGF0aW9uKG5ldyBBbW1vLmJ0UXVhdGVybmlvbihxdWF0ZXJuaW9uLngsIHF1YXRlcm5pb24ueSwgcXVhdGVybmlvbi56LCBxdWF0ZXJuaW9uLncpKTsKICAgICAgICBib2R5LnNldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICAgIH0KICAgIH07CiAgICB2YXIgcmVzZXRWZWhpY2xlID0gZnVuY3Rpb24gcmVzZXRWZWhpY2xlKGRhdGEpIHsKICAgICAgdmFyIHV1aWQgPSBkYXRhLnV1aWQsCiAgICAgICAgICBxdWF0ZXJuaW9uID0gZGF0YS5xdWF0ZXJuaW9uLAogICAgICAgICAgcG9zaXRpb24gPSBkYXRhLnBvc2l0aW9uOwogICAgICB2YXIgZWxlbWVudCA9IHdvcmxkLmdldEVsZW1lbnQodXVpZCk7CgogICAgICBpZiAoZWxlbWVudC50eXBlID09PSBUWVBFUy5WRUhJQ0xFKSB7CiAgICAgICAgdmFyIGJvZHkgPSBlbGVtZW50LnZlaGljbGUuZ2V0UmlnaWRCb2R5KCk7CiAgICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgICAgYm9keS5nZXRXb3JsZFRyYW5zZm9ybSh0cmFuc2Zvcm0pOwogICAgICAgIHRyYW5zZm9ybS5zZXRJZGVudGl0eSgpOwogICAgICAgIHRyYW5zZm9ybS5zZXRPcmlnaW4obmV3IEFtbW8uYnRWZWN0b3IzKHBvc2l0aW9uLngsIHBvc2l0aW9uLnksIHBvc2l0aW9uLnopKTsKICAgICAgICB0cmFuc2Zvcm0uc2V0Um90YXRpb24obmV3IEFtbW8uYnRRdWF0ZXJuaW9uKHF1YXRlcm5pb24ueCwgcXVhdGVybmlvbi55LCBxdWF0ZXJuaW9uLnosIHF1YXRlcm5pb24udykpOwogICAgICAgIGJvZHkuc2V0V29ybGRUcmFuc2Zvcm0odHJhbnNmb3JtKTsKICAgICAgfQogICAgfTsKICAgIHZhciBoYW5kbGVWZWhpY2xlVXBkYXRlID0gZnVuY3Rpb24gaGFuZGxlVmVoaWNsZVVwZGF0ZShfcmVmLCBkdCkgewogICAgICB2YXIgdmVoaWNsZSA9IF9yZWYudmVoaWNsZSwKICAgICAgICAgIHdoZWVscyA9IF9yZWYud2hlZWxzLAogICAgICAgICAgdXVpZCA9IF9yZWYudXVpZCwKICAgICAgICAgIF9yZWYkc3RhdGUgPSBfcmVmLnN0YXRlLAogICAgICAgICAgc3RhdGUgPSBfcmVmJHN0YXRlID09PSB2b2lkIDAgPyBERUZBVUxUX1ZFSElDTEVfU1RBVEUgOiBfcmVmJHN0YXRlLAogICAgICAgICAgX3JlZiRvcHRpb25zID0gX3JlZi5vcHRpb25zLAogICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnM7CiAgICAgIHZhciBicmVha2luZ0ZvcmNlID0gMDsKICAgICAgdmFyIGVuZ2luZUZvcmNlID0gMDsKICAgICAgdmFyIF9vcHRpb25zJHN0ZWVyaW5nQ2xhbSA9IG9wdGlvbnMuc3RlZXJpbmdDbGFtcCwKICAgICAgICAgIHN0ZWVyaW5nQ2xhbXAgPSBfb3B0aW9ucyRzdGVlcmluZ0NsYW0gPT09IHZvaWQgMCA/IERFRkFVTFRfU1RFRVJJTkdfQ0xBTVAgOiBfb3B0aW9ucyRzdGVlcmluZ0NsYW0sCiAgICAgICAgICBfb3B0aW9ucyRzdGVlcmluZ0luY3IgPSBvcHRpb25zLnN0ZWVyaW5nSW5jcmVtZW50LAogICAgICAgICAgc3RlZXJpbmdJbmNyZW1lbnQgPSBfb3B0aW9ucyRzdGVlcmluZ0luY3IgPT09IHZvaWQgMCA/IERFRkFVTFRfU1RFRVJJTkdfSU5DUkVNRU5UIDogX29wdGlvbnMkc3RlZXJpbmdJbmNyLAogICAgICAgICAgX29wdGlvbnMkbWF4RW5naW5lRm9yID0gb3B0aW9ucy5tYXhFbmdpbmVGb3JjZSwKICAgICAgICAgIG1heEVuZ2luZUZvcmNlID0gX29wdGlvbnMkbWF4RW5naW5lRm9yID09PSB2b2lkIDAgPyBERUZBVUxUX01BWF9FTkdJTkVfRk9SQ0UgOiBfb3B0aW9ucyRtYXhFbmdpbmVGb3IsCiAgICAgICAgICBfb3B0aW9ucyRtYXhCcmVha2luZ0YgPSBvcHRpb25zLm1heEJyZWFraW5nRm9yY2UsCiAgICAgICAgICBtYXhCcmVha2luZ0ZvcmNlID0gX29wdGlvbnMkbWF4QnJlYWtpbmdGID09PSB2b2lkIDAgPyBERUZBVUxUX01BWF9CUkVBS0lOR19GT1JDRSA6IF9vcHRpb25zJG1heEJyZWFraW5nRjsKCiAgICAgIGlmIChzdGF0ZS5hY2NlbGVyYXRpb24pIHsKICAgICAgICBpZiAoc3BlZWQgPCAtMSkgYnJlYWtpbmdGb3JjZSA9IG1heEJyZWFraW5nRm9yY2U7ZWxzZSBlbmdpbmVGb3JjZSA9IG1heEVuZ2luZUZvcmNlOwogICAgICB9CgogICAgICBpZiAoc3RhdGUuYnJha2luZykgewogICAgICAgIGlmIChzcGVlZCA+IDEpIGJyZWFraW5nRm9yY2UgPSBtYXhCcmVha2luZ0ZvcmNlO2Vsc2UgZW5naW5lRm9yY2UgPSAtbWF4RW5naW5lRm9yY2UgLyAyOwogICAgICB9CgogICAgICBpZiAoc3RhdGUubGVmdCkgewogICAgICAgIGlmIChzdGF0ZS52ZWhpY2xlU3RlZXJpbmcgPCBzdGVlcmluZ0NsYW1wKSBzdGF0ZS52ZWhpY2xlU3RlZXJpbmcgKz0gc3RlZXJpbmdJbmNyZW1lbnQ7CiAgICAgIH0gZWxzZSB7CiAgICAgICAgaWYgKHN0YXRlLnJpZ2h0KSB7CiAgICAgICAgICBpZiAoc3RhdGUudmVoaWNsZVN0ZWVyaW5nID4gLXN0ZWVyaW5nQ2xhbXApIHN0YXRlLnZlaGljbGVTdGVlcmluZyAtPSBzdGVlcmluZ0luY3JlbWVudDsKICAgICAgICB9IGVsc2UgewogICAgICAgICAgaWYgKHN0YXRlLnZlaGljbGVTdGVlcmluZyA8IC1zdGVlcmluZ0luY3JlbWVudCkgc3RhdGUudmVoaWNsZVN0ZWVyaW5nICs9IHN0ZWVyaW5nSW5jcmVtZW50O2Vsc2UgewogICAgICAgICAgICBpZiAoc3RhdGUudmVoaWNsZVN0ZWVyaW5nID4gc3RlZXJpbmdJbmNyZW1lbnQpIHN0YXRlLnZlaGljbGVTdGVlcmluZyAtPSBzdGVlcmluZ0luY3JlbWVudDtlbHNlIHsKICAgICAgICAgICAgICBzdGF0ZS52ZWhpY2xlU3RlZXJpbmcgPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfQogICAgICB9CgogICAgICB2ZWhpY2xlLmFwcGx5RW5naW5lRm9yY2UoZW5naW5lRm9yY2UsIEJBQ0tfTEVGVCk7CiAgICAgIHZlaGljbGUuYXBwbHlFbmdpbmVGb3JjZShlbmdpbmVGb3JjZSwgQkFDS19SSUdIVCk7CiAgICAgIHZlaGljbGUuc2V0QnJha2UoYnJlYWtpbmdGb3JjZSAvIDIsIEZST05UX0xFRlQpOwogICAgICB2ZWhpY2xlLnNldEJyYWtlKGJyZWFraW5nRm9yY2UgLyAyLCBGUk9OVF9SSUdIVCk7CiAgICAgIHZlaGljbGUuc2V0QnJha2UoYnJlYWtpbmdGb3JjZSwgQkFDS19MRUZUKTsKICAgICAgdmVoaWNsZS5zZXRCcmFrZShicmVha2luZ0ZvcmNlLCBCQUNLX1JJR0hUKTsKICAgICAgdmVoaWNsZS5zZXRTdGVlcmluZ1ZhbHVlKHN0YXRlLnZlaGljbGVTdGVlcmluZywgRlJPTlRfTEVGVCk7CiAgICAgIHZlaGljbGUuc2V0U3RlZXJpbmdWYWx1ZShzdGF0ZS52ZWhpY2xlU3RlZXJpbmcsIEZST05UX1JJR0hUKTsKICAgICAgdmFyIHRtLCBwLCBxLCBpOwogICAgICB2YXIgbiA9IHZlaGljbGUuZ2V0TnVtV2hlZWxzKCk7CgogICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgaSsrKSB7CiAgICAgICAgdmVoaWNsZS51cGRhdGVXaGVlbFRyYW5zZm9ybShpLCB0cnVlKTsKICAgICAgICB0bSA9IHZlaGljbGUuZ2V0V2hlZWxUcmFuc2Zvcm1XUyhpKTsKICAgICAgICBwID0gdG0uZ2V0T3JpZ2luKCk7CiAgICAgICAgcSA9IHRtLmdldFJvdGF0aW9uKCk7CiAgICAgICAgdmFyIHdoZWVsVVVJRCA9IHdoZWVsc1tpXTsKICAgICAgICBkaXNwYXRjaGVyJDEuc2VuZEJvZHlVcGRhdGUod2hlZWxVVUlELCBwLCBxLCBkdCk7CiAgICAgIH0KCiAgICAgIHRtID0gdmVoaWNsZS5nZXRDaGFzc2lzV29ybGRUcmFuc2Zvcm0oKTsKICAgICAgcCA9IHRtLmdldE9yaWdpbigpOwogICAgICBxID0gdG0uZ2V0Um90YXRpb24oKTsKICAgICAgdmFyIGRpcmVjdGlvbiA9IHZlaGljbGUuZ2V0Rm9yd2FyZFZlY3RvcigpOwogICAgICB2YXIgc3BlZWQgPSB2ZWhpY2xlLmdldEN1cnJlbnRTcGVlZEttSG91cigpOwogICAgICB2YXIgZXh0cmFEYXRhID0gewogICAgICAgIGRpcmVjdGlvbjogewogICAgICAgICAgeDogZGlyZWN0aW9uLngoKSwKICAgICAgICAgIHk6IGRpcmVjdGlvbi55KCksCiAgICAgICAgICB6OiBkaXJlY3Rpb24ueigpCiAgICAgICAgfSwKICAgICAgICBzcGVlZDogc3BlZWQKICAgICAgfTsKICAgICAgZGlzcGF0Y2hlciQxLnNlbmRCb2R5VXBkYXRlKHV1aWQsIHAsIHEsIGR0LCBleHRyYURhdGEpOwogICAgICB3b3JsZC51cGRhdGVCb2R5U3RhdGUodXVpZCwgc3RhdGUpOwogICAgfTsKCiAgICB2YXIgY3JlYXRlR2hvc3RDb2xsaWRlciA9IGZ1bmN0aW9uIGNyZWF0ZUdob3N0Q29sbGlkZXIocmFkaXVzLCBwb3NpdGlvbikgewogICAgICB2YXIgZ2hvc3RDb2xsaWRlciA9IG5ldyBBbW1vLmJ0R2hvc3RPYmplY3QoKTsKICAgICAgdmFyIHRyYW5zZm9ybSA9IG5ldyBBbW1vLmJ0VHJhbnNmb3JtKCk7CiAgICAgIGdob3N0Q29sbGlkZXIuc2V0Q29sbGlzaW9uU2hhcGUobmV3IEFtbW8uYnRTcGhlcmVTaGFwZShyYWRpdXMpKTsKICAgICAgZ2hvc3RDb2xsaWRlci5nZXRXb3JsZFRyYW5zZm9ybSh0cmFuc2Zvcm0pOwogICAgICB0cmFuc2Zvcm0uc2V0SWRlbnRpdHkoKTsKICAgICAgdHJhbnNmb3JtLnNldE9yaWdpbihwb3NpdGlvbik7CiAgICAgIHRyYW5zZm9ybS5zZXRSb3RhdGlvbihuZXcgQW1tby5idFF1YXRlcm5pb24oMCwgMCwgMCwgMSkpOwogICAgICBnaG9zdENvbGxpZGVyLnNldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICAgIHJldHVybiB7CiAgICAgICAgZ2hvc3RDb2xsaWRlcjogZ2hvc3RDb2xsaWRlciwKICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybQogICAgICB9OwogICAgfTsKICAgIHZhciBmb3JFYWNoR2hvc3RDb2xsaXNpb24gPSBmdW5jdGlvbiBmb3JFYWNoR2hvc3RDb2xsaXNpb24oZ2hvc3RDb2xsaWRlcikgewogICAgICB2YXIgZm9yRWFjaENhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmdW5jdGlvbiAoKSB7fTsKICAgICAgdmFyIGNvbGxpc2lvbnMgPSBnaG9zdENvbGxpZGVyLmdldE51bU92ZXJsYXBwaW5nT2JqZWN0cygpOwoKICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xsaXNpb25zOyBpKyspIHsKICAgICAgICB2YXIgb2JqZWN0ID0gQW1tby5jYXN0T2JqZWN0KGdob3N0Q29sbGlkZXIuZ2V0T3ZlcmxhcHBpbmdPYmplY3QoaSksIEFtbW8uYnRSaWdpZEJvZHkpOwogICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgQW1tby5idFRyYW5zZm9ybSgpOwogICAgICAgIG9iamVjdC5nZXRXb3JsZFRyYW5zZm9ybSh0cmFuc2Zvcm0pOwogICAgICAgIGZvckVhY2hDYWxsYmFjayhvYmplY3QsIHRyYW5zZm9ybSwgaSk7CiAgICAgICAgQW1tby5kZXN0cm95KHRyYW5zZm9ybSk7CiAgICAgIH0KICAgIH07CiAgICB2YXIgZ2V0RXhwbG9zaW9uUG9zaXRpb24gPSBmdW5jdGlvbiBnZXRFeHBsb3Npb25Qb3NpdGlvbih1dWlkLCBwb3NpdGlvbikgewogICAgICB2YXIgZXhwbG9zaW9uUG9zaXRpb24gPSBwb3NpdGlvbjsKCiAgICAgIGlmICghZXhwbG9zaW9uUG9zaXRpb24pIHsKICAgICAgICB2YXIgX3dvcmxkJGdldEVsZW1lbnQgPSB3b3JsZC5nZXRFbGVtZW50KHV1aWQpLAogICAgICAgICAgICBib2R5ID0gX3dvcmxkJGdldEVsZW1lbnQuYm9keTsKCiAgICAgICAgdmFyIG1vdGlvblN0YXRlID0gYm9keS5nZXRNb3Rpb25TdGF0ZSgpOwogICAgICAgIHZhciB0cmFuc2Zvcm0gPSBuZXcgQW1tby5idFRyYW5zZm9ybSgpOwogICAgICAgIG1vdGlvblN0YXRlLmdldFdvcmxkVHJhbnNmb3JtKHRyYW5zZm9ybSk7CiAgICAgICAgZXhwbG9zaW9uUG9zaXRpb24gPSB0cmFuc2Zvcm0uZ2V0T3JpZ2luKCk7CiAgICAgIH0KCiAgICAgIHJldHVybiBleHBsb3Npb25Qb3NpdGlvbjsKICAgIH07CiAgICB2YXIgZ2V0RXhwbG9zaW9uSW1wdWxzZSA9IGZ1bmN0aW9uIGdldEV4cGxvc2lvbkltcHVsc2UocG9zaXRpb24sIGV4cGxvc2lvblBvc2l0aW9uLCBzdHJlbmd0aCkgewogICAgICB2YXIgZGlzdGFuY2UgPSBwb3NpdGlvbi5vcF9zdWIoZXhwbG9zaW9uUG9zaXRpb24pOwogICAgICBkaXN0YW5jZS5ub3JtYWxpemUoKTsKICAgICAgdmFyIGltcHVsc2UgPSBkaXN0YW5jZS5vcF9tdWwoc3RyZW5ndGgpOwogICAgICBpbXB1bHNlLnNldFkoaW1wdWxzZS55KCkgKyBzdHJlbmd0aCk7CiAgICAgIHJldHVybiBpbXB1bHNlOwogICAgfTsKICAgIHZhciBjcmVhdGVFeHBsb3Npb24gPSBmdW5jdGlvbiBjcmVhdGVFeHBsb3Npb24oX3JlZikgewogICAgICB2YXIgdXVpZCA9IF9yZWYudXVpZCwKICAgICAgICAgIHBvc2l0aW9uID0gX3JlZi5wb3NpdGlvbiwKICAgICAgICAgIF9yZWYkcmFkaXVzID0gX3JlZi5yYWRpdXMsCiAgICAgICAgICByYWRpdXMgPSBfcmVmJHJhZGl1cyA9PT0gdm9pZCAwID8gRVhQTE9TSU9OX1NJWkVTLlNNQUxMIDogX3JlZiRyYWRpdXMsCiAgICAgICAgICBfcmVmJHN0cmVuZ3RoID0gX3JlZi5zdHJlbmd0aCwKICAgICAgICAgIHN0cmVuZ3RoID0gX3JlZiRzdHJlbmd0aCA9PT0gdm9pZCAwID8gRVhQTE9TSU9OX1NUUkVOR1RIUy5NRURJVU0gOiBfcmVmJHN0cmVuZ3RoOwoKICAgICAgdHJ5IHsKICAgICAgICB2YXIgZXhwbG9zaW9uUG9zaXRpb24gPSBnZXRFeHBsb3Npb25Qb3NpdGlvbih1dWlkLCBwb3NpdGlvbik7CgogICAgICAgIHZhciBfY3JlYXRlR2hvc3RDb2xsaWRlciA9IGNyZWF0ZUdob3N0Q29sbGlkZXIocmFkaXVzLCBleHBsb3Npb25Qb3NpdGlvbiksCiAgICAgICAgICAgIGdob3N0Q29sbGlkZXIgPSBfY3JlYXRlR2hvc3RDb2xsaWRlci5naG9zdENvbGxpZGVyLAogICAgICAgICAgICB0cmFuc2Zvcm0gPSBfY3JlYXRlR2hvc3RDb2xsaWRlci50cmFuc2Zvcm07CgogICAgICAgIHdvcmxkLmFkZENvbGxpc2lvbk9iamVjdChnaG9zdENvbGxpZGVyKTsKICAgICAgICBmb3JFYWNoR2hvc3RDb2xsaXNpb24oZ2hvc3RDb2xsaWRlciwgZnVuY3Rpb24gKG9iamVjdCwgb2JqZWN0VHJhbnNmb3JtKSB7CiAgICAgICAgICB2YXIgb3JpZ2luID0gb2JqZWN0VHJhbnNmb3JtLmdldE9yaWdpbigpOwogICAgICAgICAgb2JqZWN0LmFjdGl2YXRlKHRydWUpOwogICAgICAgICAgb2JqZWN0LmFwcGx5Q2VudHJhbEltcHVsc2UoZ2V0RXhwbG9zaW9uSW1wdWxzZShvcmlnaW4sIGV4cGxvc2lvblBvc2l0aW9uLCBzdHJlbmd0aCkpOwogICAgICAgIH0pOwogICAgICAgIHdvcmxkLmdldER5bmFtaWNzV29ybGQoKS5yZW1vdmVDb2xsaXNpb25PYmplY3QoZ2hvc3RDb2xsaWRlcik7CiAgICAgICAgQW1tby5kZXN0cm95KGdob3N0Q29sbGlkZXIpOwogICAgICAgIEFtbW8uZGVzdHJveSh0cmFuc2Zvcm0pOwogICAgICB9IGNhdGNoIChlKSB7CiAgICAgICAgY29uc29sZS5sb2coZSk7CiAgICAgIH0KICAgIH07CgogICAgdmFyIGhhbmRsZUxvYWRFdmVudCA9IGZ1bmN0aW9uIGhhbmRsZUxvYWRFdmVudChvcHRpb25zKSB7CiAgICAgIHJldHVybiBmdW5jdGlvbiAoQW1tbykgewogICAgICAgIHNlbGYuQW1tbyA9IEFtbW87CgogICAgICAgIG9ubWVzc2FnZSA9IGZ1bmN0aW9uIG9ubWVzc2FnZShfcmVmKSB7CiAgICAgICAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YTsKCiAgICAgICAgICBzd2l0Y2ggKGRhdGEuZXZlbnQpIHsKICAgICAgICAgICAgY2FzZSBQSFlTSUNTX0VWRU5UUy5BREQuQk9YOgogICAgICAgICAgICAgIGFkZEJveChkYXRhKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgUEhZU0lDU19FVkVOVFMuQURELlNQSEVSRToKICAgICAgICAgICAgICBhZGRTcGhlcmUoZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLkFERC5WRUhJQ0xFOgogICAgICAgICAgICAgIGFkZFZlaGljbGUoZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLkFERC5NT0RFTDoKICAgICAgICAgICAgICBhZGRNb2RlbChkYXRhKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgUEhZU0lDU19FVkVOVFMuQURELlBMQVlFUjoKICAgICAgICAgICAgICBhZGRQbGF5ZXIoZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLkVMRU1FTlQuU0VULkxJTkVBUl9WRUxPQ0lUWToKICAgICAgICAgICAgICBzZXRMaW5lYXJWZWxvY2l0eShkYXRhKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgUEhZU0lDU19FVkVOVFMuRUxFTUVOVC5SRVNFVDoKICAgICAgICAgICAgICByZXNldEVsZW1lbnQoZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLkVMRU1FTlQuU0VULlBPU0lUSU9OOgogICAgICAgICAgICAgIHNldFBvc2l0aW9uKGRhdGEpOwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSBQSFlTSUNTX0VWRU5UUy5WRUhJQ0xFLlNFVC5QT1NJVElPTjoKICAgICAgICAgICAgICBzZXRWZWhpY2xlUG9zaXRpb24oZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLlZFSElDTEUuU0VULlFVQVRFUk5JT046CiAgICAgICAgICAgICAgc2V0VmVoaWNsZVF1YXRlcm5pb24oZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLlZFSElDTEUuUkVTRVQ6CiAgICAgICAgICAgICAgcmVzZXRWZWhpY2xlKGRhdGEpOwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSBQSFlTSUNTX0VWRU5UUy5FTEVNRU5ULkFQUExZLklNUFVMU0U6CiAgICAgICAgICAgICAgYXBwbHlJbXB1c2UoZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLkVMRU1FTlQuVVBEQVRFOgogICAgICAgICAgICAgIHdvcmxkLnVwZGF0ZUJvZHlTdGF0ZShkYXRhKTsKICAgICAgICAgICAgICBicmVhazsKCiAgICAgICAgICAgIGNhc2UgUEhZU0lDU19FVkVOVFMuRUxFTUVOVC5ESVNQT1NFOgogICAgICAgICAgICAgIHdvcmxkLmRpc3Bvc2VCb2R5KGRhdGEpOwogICAgICAgICAgICAgIGJyZWFrOwoKICAgICAgICAgICAgY2FzZSBQSFlTSUNTX0VWRU5UUy5FRkZFQ1RTLkVYUExPU0lPTjoKICAgICAgICAgICAgICBjcmVhdGVFeHBsb3Npb24oZGF0YSk7CiAgICAgICAgICAgICAgYnJlYWs7CgogICAgICAgICAgICBjYXNlIFBIWVNJQ1NfRVZFTlRTLlRFUk1JTkFURToKICAgICAgICAgICAgICB3b3JsZC50ZXJtaW5hdGUoKTsKICAgICAgICAgICAgICBicmVhazsKICAgICAgICAgIH0KICAgICAgICB9OwoKICAgICAgICB3b3JsZC5pbml0KG9wdGlvbnMpOwogICAgICAgIGRpc3BhdGNoZXIkMS5zZW5kUmVhZHlFdmVudCgpOwogICAgICAgIHdvcmxkLnNpbXVsYXRlKCk7CiAgICAgIH07CiAgICB9OwoKICAgIHZhciBsb2FkQW1tbyA9IGZ1bmN0aW9uIGxvYWRBbW1vKG9wdGlvbnMpIHsKICAgICAgdmFyIHNjcmlwdFVybCA9IG9wdGlvbnMuaG9zdCArICcvJyArIChvcHRpb25zLnBhdGggfHwgTElCUkFSWV9OQU1FKTsKICAgICAgaW1wb3J0U2NyaXB0cyhzY3JpcHRVcmwpOwogICAgICBBbW1vKCkudGhlbihoYW5kbGVMb2FkRXZlbnQob3B0aW9ucykpOwogICAgfTsKCiAgICBvbm1lc3NhZ2UgPSBmdW5jdGlvbiBvbm1lc3NhZ2UoX3JlZjIpIHsKICAgICAgdmFyIGRhdGEgPSBfcmVmMi5kYXRhOwoKICAgICAgc3dpdGNoIChkYXRhLmV2ZW50KSB7CiAgICAgICAgY2FzZSBQSFlTSUNTX0VWRU5UUy5MT0FELkFNTU86CiAgICAgICAgICBsb2FkQW1tbyhkYXRhKTsKICAgICAgICAgIGJyZWFrOwogICAgICB9CiAgICB9OwoKfSkoKTsKCg==', null, false);
/* eslint-enable */var PHYSICS_EVENTS = {
  DISPATCH: 'physics:dispatch',
  TERMINATE: 'physics:terminate',
  LOAD: {
    AMMO: 'physics:load:ammo'
  },
  READY: 'physics:ready',
  INIT: 'physics:init',
  UPDATE: 'physics:update',
  ADD: {
    BOX: 'physics:add:box',
    VEHICLE: 'physics:add:vehicle',
    MODEL: 'physics:add:model',
    PLAYER: 'physics:add:player',
    SPHERE: 'physics:add:sphere'
  },
  ELEMENT: {
    DISPOSE: 'physics:element:dispose',
    COLLISION: 'physics:element:collision',
    UPDATE: 'physics:element:update',
    CREATED: 'physics:element:created',
    SET: {
      POSITION: 'physics:element:set:position',
      QUATERNION: 'physics:element:set:quaternion',
      LINEAR_VELOCITY: 'physics:element:set:linear_velocity'
    },
    RESET: 'physics:element:reset',
    APPLY: {
      IMPULSE: 'physics:element:apply:impulse'
    }
  },
  VEHICLE: {
    SET: {
      POSITION: 'physics:vehicle:set:position',
      QUATERNION: 'physics:vehicle:set:quaternion'
    },
    RESET: 'physics:vehicle:reset',
    SPEED: 'physics:vehicle:speed',
    DIRECTION: 'physics:vehicle:direction'
  },
  EFFECTS: {
    EXPLOSION: 'physics:effects:explosion'
  }
};var PI = Math.PI;
var PI_2$1 = PI / 2;
var identity$1 = function identity(a) {
  return a;
};
var pickRandom = function pickRandom() {
  var list = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return list[Math.floor(Math.random() * list.length)];
};
var degToRad = function degToRad(angle) {
  return angle * (PI / 180);
};
var getProportion = function getProportion(max1, b, max2) {
  return max1 * b / max2;
};
var clamp = function clamp(value, min, max) {
  return value < min ? min : value > max ? max : value;
};
var isWithin = function isWithin(value, min, max) {
  return value >= min && value < max;
};
var randomIntFromInterval = function randomIntFromInterval(min, max) {
  // min and max included 
  return Math.floor(Math.random() * (max - min + 1) + min);
};
var getDistance = function getDistance() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref$x = _ref.x,
      xA = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      yA = _ref$y === void 0 ? 0 : _ref$y,
      _ref$z = _ref.z,
      zA = _ref$z === void 0 ? 0 : _ref$z;

  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$x = _ref2.x,
      xB = _ref2$x === void 0 ? 0 : _ref2$x,
      _ref2$y = _ref2.y,
      yB = _ref2$y === void 0 ? 0 : _ref2$y,
      _ref2$z = _ref2.z,
      zB = _ref2$z === void 0 ? 0 : _ref2$z;

  return Math.sqrt(Math.pow(xA - xB, 2) + Math.pow(yA - yB, 2) + Math.pow(zA - zB, 2));
};
var findPointBetweenAtDistance = function findPointBetweenAtDistance() {
  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      _ref3$x = _ref3.x,
      xC = _ref3$x === void 0 ? 0 : _ref3$x,
      _ref3$y = _ref3.y,
      yC = _ref3$y === void 0 ? 0 : _ref3$y,
      _ref3$z = _ref3.z,
      zC = _ref3$z === void 0 ? 0 : _ref3$z;

  var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref4$x = _ref4.x,
      xE = _ref4$x === void 0 ? 0 : _ref4$x,
      _ref4$y = _ref4.y,
      yE = _ref4$y === void 0 ? 0 : _ref4$y,
      _ref4$z = _ref4.z,
      zE = _ref4$z === void 0 ? 0 : _ref4$z;

  var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var vCenter = new Vector3$1(xC, yC, zC);
  var vEnd = new Vector3$1(xE, yE, zE);
  var point = vCenter.add(vEnd.sub(vCenter).normalize().multiplyScalar(distance));
  return {
    x: point.x,
    y: point.y,
    z: point.z
  };
};
var lerpVectors = function lerpVectors(origin, target, speed) {
  var originVector = new Vector3$1(origin.x, origin.y, origin.z);
  var targetVector = new Vector3$1(target.x, target.y, target.z);
  originVector.lerp(targetVector, speed);
  return {
    x: originVector.x,
    y: originVector.y,
    z: originVector.z
  };
};
var lerp = function lerp(x, y, t) {
  return MathUtils.lerp(x, y, t);
};
var scaleVector = function scaleVector(_ref5) {
  var _ref5$x = _ref5.x,
      x = _ref5$x === void 0 ? 0 : _ref5$x,
      _ref5$y = _ref5.y,
      y = _ref5$y === void 0 ? 0 : _ref5$y,
      _ref5$z = _ref5.z,
      z = _ref5$z === void 0 ? 0 : _ref5$z;
  var scale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  return new Vector3$1(x, y, z).multiplyScalar(scale);
};
var getSphereVolume = function getSphereVolume(radius) {
  return 4 * Math.PI * Math.pow(radius, 3) / 3;
};
var repeat = function repeat(t, length) {
  return clamp(t - Math.floor(t / length) * length, 0.0, length);
};
var deltaAngle = function deltaAngle(angle, target) {
  var delta = repeat(target - angle, 360.0);
  if (delta > 180.0) delta -= 360.0;
  return delta;
};
var smoothDamp = function smoothDamp(current, target, currentVelocity, smoothTime) {
  var maxSpeed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
  var dt = arguments.length > 5 ? arguments[5] : undefined;
  smoothTime = Math.max(0.0001, smoothTime);
  var omega = 2 / smoothTime;
  var x = omega * dt;
  var exp = 1 / (1 + x + 0.48 * x * x + 0.235 * x * x * x);
  var change = current - target;
  var originalTo = target; // Clamp maximum speed

  var maxChange = maxSpeed * smoothTime;
  change = clamp(change, -maxChange, maxChange);
  target = current - change;
  var temp = (currentVelocity + omega * change) * dt;
  currentVelocity = (currentVelocity - omega * temp) * exp;
  var output = target + (change + temp) * exp; // Prevent overshooting

  if (originalTo - current > 0.0 == output > originalTo) {
    output = originalTo;
    currentVelocity = (output - originalTo) / dt;
  }

  return [output, currentVelocity];
};
var smoothDampAngle = function smoothDampAngle(current, target, currentVelocity, smoothTime) {
  var maxSpeed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Infinity;
  var dt = arguments.length > 5 ? arguments[5] : undefined;
  target = current + deltaAngle(current, target);
  return smoothDamp(current, target, currentVelocity, smoothTime, maxSpeed, dt);
};var math=/*#__PURE__*/Object.freeze({__proto__:null,PI:PI,PI_2:PI_2$1,identity:identity$1,pickRandom:pickRandom,degToRad:degToRad,getProportion:getProportion,clamp:clamp,isWithin:isWithin,randomIntFromInterval:randomIntFromInterval,getDistance:getDistance,findPointBetweenAtDistance:findPointBetweenAtDistance,lerpVectors:lerpVectors,lerp:lerp,scaleVector:scaleVector,getSphereVolume:getSphereVolume,repeat:repeat,deltaAngle:deltaAngle,smoothDamp:smoothDamp,smoothDampAngle:smoothDampAngle});var LIBRARY_NAME = 'ammo.js';
var TYPES = {
  BOX: 'BOX',
  SPHERE: 'SPHERE',
  VEHICLE: 'VEHICLE',
  MESH: 'MESH',
  PLAYER: 'PLAYER'
};
var COLLIDER_TYPES$1 = {
  BOX: 'BOX',
  VEHICLE: 'VEHICLE',
  PLAYER: 'PLAYER',
  SPHERE: 'SPHERE'
};
var DEFAULT_VEHICLE_STATE = {
  vehicleSteering: 0,
  acceleration: false,
  breaking: false,
  right: false,
  left: false
};
var DEFAULT_RIGIDBODY_STATE = {
  velocity: {
    x: 0,
    y: 0,
    z: 0
  },
  movement: {
    forward: false,
    backwards: false,
    left: false,
    right: false
  },
  direction: {
    x: 0,
    y: 0,
    z: 0
  }
};
var DEFAULT_SCALE$1 = {
  x: 1,
  y: 1,
  z: 1
};
var DEFAULT_QUATERNION = {
  x: 0,
  y: 0,
  z: 0,
  w: 1
};
var DEFAULT_POSITION$4 = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_LINEAR_VELOCITY = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_ANGULAR_VELOCITY = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_IMPULSE = {
  x: 0,
  y: 0,
  z: 0
};
var DISABLE_DEACTIVATION = 4;
var GRAVITY = {
  x: 0,
  y: -10,
  z: 0
};
var FRONT_LEFT = 0;
var FRONT_RIGHT = 1;
var BACK_LEFT = 2;
var BACK_RIGHT = 3;
var DEFAULT_STEERING_INCREMENT = .04;
var DEFAULT_STEERING_CLAMP = .5;
var DEFAULT_MAX_ENGINE_FORCE = 2000;
var DEFAULT_MAX_BREAKING_FORCE = 100;
var EXPLOSION_SIZES = {
  SMALL: 4,
  MEDIUM: 6,
  LARGE: 8,
  MASSIVE: 12
};
var EXPLOSION_STRENGTHS = {
  VERY_WEAK: 2,
  WEAK: 4,
  MEDIUM: 8,
  LARGE: 16,
  MASSIVE: 32,
  OK_NO: 64
};var constants$1=/*#__PURE__*/Object.freeze({__proto__:null,LIBRARY_NAME:LIBRARY_NAME,TYPES:TYPES,COLLIDER_TYPES:COLLIDER_TYPES$1,DEFAULT_VEHICLE_STATE:DEFAULT_VEHICLE_STATE,DEFAULT_RIGIDBODY_STATE:DEFAULT_RIGIDBODY_STATE,DEFAULT_SCALE:DEFAULT_SCALE$1,DEFAULT_QUATERNION:DEFAULT_QUATERNION,DEFAULT_POSITION:DEFAULT_POSITION$4,DEFAULT_LINEAR_VELOCITY:DEFAULT_LINEAR_VELOCITY,DEFAULT_ANGULAR_VELOCITY:DEFAULT_ANGULAR_VELOCITY,DEFAULT_IMPULSE:DEFAULT_IMPULSE,DISABLE_DEACTIVATION:DISABLE_DEACTIVATION,GRAVITY:GRAVITY,FRONT_LEFT:FRONT_LEFT,FRONT_RIGHT:FRONT_RIGHT,BACK_LEFT:BACK_LEFT,BACK_RIGHT:BACK_RIGHT,DEFAULT_STEERING_INCREMENT:DEFAULT_STEERING_INCREMENT,DEFAULT_STEERING_CLAMP:DEFAULT_STEERING_CLAMP,DEFAULT_MAX_ENGINE_FORCE:DEFAULT_MAX_ENGINE_FORCE,DEFAULT_MAX_BREAKING_FORCE:DEFAULT_MAX_BREAKING_FORCE,EXPLOSION_SIZES:EXPLOSION_SIZES,EXPLOSION_STRENGTHS:EXPLOSION_STRENGTHS});var DEFAULT_DESCRIPTION$1 = {
  mass: 1,
  friction: 1,
  quaternion: DEFAULT_QUATERNION,
  position: DEFAULT_POSITION$4
};

var DEFAULT_BOX_DESCRIPTION = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_DESCRIPTION$1), {}, {
  width: 2,
  length: 2,
  height: 2,
  collider: COLLIDER_TYPES$1.BOX
});

var DEFAULT_SPHERE_DESCRIPTION = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_DESCRIPTION$1), {}, {
  radius: 2,
  collider: COLLIDER_TYPES$1.SPHERE
});

var mapColliderTypeToAddEvent$1 = function mapColliderTypeToAddEvent(type) {
  var _COLLIDER_TYPES$BOX$C;

  return (_COLLIDER_TYPES$BOX$C = {}, _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.BOX, PHYSICS_EVENTS.ADD.BOX), _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.VEHICLE, PHYSICS_EVENTS.ADD.VEHICLE), _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.PLAYER, PHYSICS_EVENTS.ADD.PLAYER), _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.SPHERE, PHYSICS_EVENTS.ADD.SPHERE), _COLLIDER_TYPES$BOX$C)[type] || PHYSICS_EVENTS.ADD.BOX;
};
var extractBoundingBox = function extractBoundingBox(body) {
  body.geometry.computeBoundingBox();
  return body.geometry.boundingBox;
};
var extractBiggestBoundingBox = function extractBiggestBoundingBox(body) {
  var boxes = [];
  body.traverse(function (child) {
    if (child.geometry) {
      boxes.push(extractBoundingBox(child));
    }
  }); // sorting by volume

  return boxes.sort(function (boxA, boxB) {
    var vectorA = new Vector3$1();
    var vectorB = new Vector3$1();
    boxA.getSize(vectorA);
    boxB.getSize(vectorB);
    return vectorB.x * vectorB.y * vectorB.z - vectorA.x * vectorA.y * vectorA.z;
  })[0];
};
var extractBoundingSphere = function extractBoundingSphere(body) {
  body.geometry.computeBoundingSphere();
  return body.geometry.boundingSphere;
};
var extractBiggestBoundingSphere = function extractBiggestBoundingSphere(body) {
  var spheres = [];
  body.traverse(function (child) {
    if (child.geometry) {
      spheres.push(extractBoundingBox(child));
    }
  }); // sorting by volume

  return spheres.sort(function (sphereA, sphereB) {
    return getSphereVolume(sphereB.radius) - getSphereVolume(sphereA.radius);
  })[0];
};
var parseBoundingBoxSize = function parseBoundingBoxSize() {
  var boundingBox = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  try {
    var size = new Vector3$1();
    boundingBox.getSize(size);
    var sizeX = size.x,
        sizeY = size.y,
        sizeZ = size.z;
    return {
      x: sizeX,
      y: sizeY,
      z: sizeZ
    };
  } catch (e) {
    console.log(BOUNDINGBOX_NOT_AVAILABLE);
    return {
      x: 1,
      y: 1,
      z: 1
    };
  }
};
var extractPositionAndQuaternion$1 = function extractPositionAndQuaternion(element) {
  var _element$getPosition = element.getPosition(),
      x = _element$getPosition.x,
      y = _element$getPosition.y,
      z = _element$getPosition.z;

  var quaternion = element.getQuaternion();
  return {
    position: {
      x: x,
      y: y,
      z: z
    },
    quaternion: {
      x: quaternion.x,
      y: quaternion.y,
      z: quaternion.z,
      w: quaternion.w
    }
  };
};
var extractBoxDescription = function extractBoxDescription(element) {
  var scale = element.getScale();
  var size = parseBoundingBoxSize(element.boundingBox);
  return _objectSpread2$1({
    width: size.x * scale.x,
    height: size.y * scale.y,
    length: size.z * scale.z,
    size: size
  }, extractPositionAndQuaternion$1(element));
};
var extractSphereDescription = function extractSphereDescription(element) {
  var radius = element.boundingSphere.radius;
  return _objectSpread2$1({
    radius: radius
  }, extractPositionAndQuaternion$1(element));
};
var getBoxDescriptionForElement$1 = function getBoxDescriptionForElement(element) {
  return _objectSpread2$1(_objectSpread2$1({}, DEFAULT_BOX_DESCRIPTION), extractBoxDescription(element));
};
var getSphereDescriptionForElement = function getSphereDescriptionForElement(element) {
  return _objectSpread2$1(_objectSpread2$1({}, DEFAULT_SPHERE_DESCRIPTION), extractSphereDescription(element));
};
var mapColliderTypeToDescription$1 = function mapColliderTypeToDescription() {
  var _COLLIDER_TYPES$BOX$C2;

  var colliderType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : COLLIDER_TYPES$1.BOX;
  return (_COLLIDER_TYPES$BOX$C2 = {}, _defineProperty$1(_COLLIDER_TYPES$BOX$C2, COLLIDER_TYPES$1.BOX, getBoxDescriptionForElement$1), _defineProperty$1(_COLLIDER_TYPES$BOX$C2, COLLIDER_TYPES$1.SPHERE, getSphereDescriptionForElement), _COLLIDER_TYPES$BOX$C2)[colliderType] || getBoxDescriptionForElement$1;
};
var iterateGeometries$1 = function () {
  var inverse = new Matrix4();
  return function (root, _ref, cb) {
    var includeInvisible = _ref.includeInvisible;
    var scale = new Vector3$1();
    inverse.getInverse(root.matrixWorld);
    scale.setFromMatrixScale(root.matrixWorld);
    root.traverse(function (mesh) {
      var transform = new Matrix4();

      if (mesh.isMesh && (includeInvisible || mesh.el && mesh.el.object3D.visible || mesh.visible)) {
        if (mesh === root) {
          transform.identity();
        } else {
          mesh.updateWorldMatrix(true);
          transform.multiplyMatrices(inverse, mesh.matrixWorld);
        } // todo: might want to return null xform if this is the root so that callers can avoid multiplying
        // things by the identity matrix


        cb(mesh.geometry.isBufferGeometry ? mesh.geometry.attributes.position.array : mesh.geometry.vertices, transform.elements, mesh.geometry.index ? mesh.geometry.index.array : null);
      }
    });
  };
}();
var convertAmmoVector = function convertAmmoVector(_ref2) {
  var x = _ref2.x,
      y = _ref2.y,
      z = _ref2.z;
  return {
    x: z,
    y: y,
    z: x
  };
};var utils=/*#__PURE__*/Object.freeze({__proto__:null,DEFAULT_DESCRIPTION:DEFAULT_DESCRIPTION$1,mapColliderTypeToAddEvent:mapColliderTypeToAddEvent$1,extractBoundingBox:extractBoundingBox,extractBiggestBoundingBox:extractBiggestBoundingBox,extractBoundingSphere:extractBoundingSphere,extractBiggestBoundingSphere:extractBiggestBoundingSphere,parseBoundingBoxSize:parseBoundingBoxSize,extractPositionAndQuaternion:extractPositionAndQuaternion$1,extractBoxDescription:extractBoxDescription,extractSphereDescription:extractSphereDescription,getBoxDescriptionForElement:getBoxDescriptionForElement$1,getSphereDescriptionForElement:getSphereDescriptionForElement,mapColliderTypeToDescription:mapColliderTypeToDescription$1,iterateGeometries:iterateGeometries$1,convertAmmoVector:convertAmmoVector});var getHostURL = function getHostURL() {
  return "".concat(document.location.protocol, "//").concat(document.location.host);
};var _excluded$8 = ["uuid"];
var COLLIDER_TYPES = COLLIDER_TYPES$1;
var getBoxDescriptionForElement = getBoxDescriptionForElement$1,
    extractPositionAndQuaternion = extractPositionAndQuaternion$1,
    mapColliderTypeToDescription = mapColliderTypeToDescription$1,
    iterateGeometries = iterateGeometries$1,
    mapColliderTypeToAddEvent = mapColliderTypeToAddEvent$1,
    DEFAULT_DESCRIPTION = DEFAULT_DESCRIPTION$1;
var WORKER_READY_TIMEOUT = 200;
var PHYSICS_STATE_TIMEOUT = 50;
var PHYSICS_STATES = {
  READY: 'READY',
  TERMINATING: 'TERMINATING',
  TERMINATED: 'TERMINATED'
};
var Physics = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Physics, _EventDispatcher);

  var _super = _createSuper(Physics);

  function Physics() {
    var _this;

    _classCallCheck(this, Physics);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "handleWorkerMessages", function (_ref) {
      var data = _ref.data;

      switch (data.event) {
        case PHYSICS_EVENTS.READY:
          _this.workerReady = true;
          break;

        case PHYSICS_EVENTS.ELEMENT.UPDATE:
          _this.handleBodyUpdate(data);

          break;

        case PHYSICS_EVENTS.TERMINATE:
          _this.handleTerminateEvent();

          break;

        case PHYSICS_EVENTS.DISPATCH:
          _this.handleDispatchEvent(data);

          break;

        case PHYSICS_EVENTS.UPDATE:
          _this.handlePhysicsUpdate(data);

          break;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handlePhysicsUpdate", function (_ref2) {
      var dt = _ref2.dt;

      _this.dispatchEvent({
        type: PHYSICS_EVENTS.UPDATE,
        dt: dt
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTerminateEvent", function () {
      _this.worker.terminate();

      _this.state = PHYSICS_STATES.READY;
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleBodyUpdate", function (_ref3) {
      var uuid = _ref3.uuid,
          data = _objectWithoutProperties(_ref3, _excluded$8);

      var element = Universe$1.getByUUID(uuid);

      if (element) {
        if (element.getPhysicsOptions('applyPhysicsUpdate')) {
          element.handlePhysicsUpdate(data);
        } else {
          element.dispatchEvent(_objectSpread2$1({
            type: PHYSICS_EVENTS.ELEMENT.UPDATE
          }, data));
        }
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleDispatchEvent", function (_ref4) {
      var uuid = _ref4.uuid,
          eventData = _ref4.eventData,
          eventName = _ref4.eventName;
      var element = Universe$1.getByUUID(uuid);

      if (element) {
        element.dispatchEvent({
          type: eventName,
          data: eventData
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setLinearVelocity", function (element, velocity) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.SET.LINEAR_VELOCITY,
          uuid: uuid,
          velocity: velocity
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setPosition", function (element, position) {
      _this.setElementPosition(element, position);
    });

    _defineProperty$1(_assertThisInitialized(_this), "setElementPosition", function (element, position) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.SET.POSITION,
          uuid: uuid,
          position: position
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setElementQuaternion", function (element, quaternion) {});

    _defineProperty$1(_assertThisInitialized(_this), "resetElement", function (element, position, quaternion) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.RESET,
          uuid: uuid,
          position: position,
          quaternion: quaternion
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setVehiclePosition", function (vehicle, _ref5) {
      var x = _ref5.x,
          y = _ref5.y,
          z = _ref5.z;

      if (Config$1.physics().enabled) {
        var uuid = vehicle.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.VEHICLE.SET.POSITION,
          uuid: uuid,
          position: {
            x: x,
            y: y,
            z: z
          }
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "setVehicleQuaternion", function (vehicle, _ref6) {
      var x = _ref6.x,
          y = _ref6.y,
          z = _ref6.z,
          w = _ref6.w;

      if (Config$1.physics().enabled) {
        var uuid = vehicle.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.VEHICLE.SET.QUATERNION,
          uuid: uuid,
          quaternion: {
            x: x,
            y: y,
            z: z,
            w: w
          }
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "resetVehicle", function (vehicle, position, quaternion) {
      if (Config$1.physics().enabled) {
        var uuid = vehicle.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.VEHICLE.RESET,
          uuid: uuid,
          quaternion: {
            x: quaternion.x,
            y: quaternion.y,
            z: quaternion.z,
            w: quaternion.w
          },
          position: {
            x: position.x,
            y: position.y,
            z: position.z
          }
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "applyImpulse", function (element, impulse) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.APPLY.IMPULSE,
          uuid: uuid,
          impulse: impulse
        });
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "explosion", function (element, strength, radius) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();

        _this.worker.postMessage({
          event: PHYSICS_EVENTS.EFFECTS.EXPLOSION,
          uuid: uuid,
          strength: strength,
          radius: radius
        });
      }
    });

    _this.elements = [];
    _this.isWorkerReady = false;
    _this.state = PHYSICS_STATES.READY;
    return _this;
  }

  _createClass(Physics, [{
    key: "createWorker",
    value: function createWorker() {
      this.worker = new WorkerFactory();
      this.workerReady = false;
      this.state = PHYSICS_STATES.READY;
      this.worker.onmessage = this.handleWorkerMessages;
    }
  }, {
    key: "isTerminating",
    value: function isTerminating() {
      return this.state === PHYSICS_STATES.TERMINATING;
    }
  }, {
    key: "isTerminated",
    value: function isTerminated() {
      return this.state === PHYSICS_STATES.TERMINATED;
    }
  }, {
    key: "isReady",
    value: function isReady() {
      return this.state === PHYSICS_STATES.READY;
    }
  }, {
    key: "waitForState",
    value: function waitForState(state) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var isStateReached = function isStateReached() {
          return _this2.state === state;
        };

        var check = function check() {
          setTimeout(function () {
            if (isStateReached()) {
              resolve();
            } else {
              check();
            }
          }, PHYSICS_STATE_TIMEOUT);
        };

        check();
      });
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (Config$1.physics().enabled) {
        this.state = PHYSICS_STATES.TERMINATING;
        this.worker.postMessage({
          event: PHYSICS_EVENTS.TERMINATE
        });
        this.elements = [];
      }
    }
  }, {
    key: "hasElement",
    value: function hasElement(element) {
      var uuid = element.uuid();
      return this.elements.includes(uuid);
    }
  }, {
    key: "storeElement",
    value: function storeElement(element, options) {
      if (!this.hasElement(element)) {
        var uuid = element.uuid();
        this.elements.push(uuid);
      } else {
        console.log(PHYSICS_ELEMENT_ALREADY_STORED, element);
      }
    }
  }, {
    key: "removeElement",
    value: function removeElement(element) {
      if (this.hasElement(element)) {
        var uuid = element.uuid();
        this.elements.splice(this.elements.indexOf(uuid), 1);
      } else {
        console.log(PHYSICS_ELEMENT_CANT_BE_REMOVED);
      }
    }
  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      if (Config$1.physics().enabled) {
        this.createWorker();
        this.worker.postMessage(_objectSpread2$1(_objectSpread2$1({
          event: PHYSICS_EVENTS.LOAD.AMMO
        }, Config$1.physics()), {}, {
          host: getHostURL()
        }));
        return new Promise(function (resolve) {
          var isWorkerReady = function isWorkerReady() {
            return _this3.workerReady;
          };

          var check = function check() {
            setTimeout(function () {
              if (isWorkerReady()) {
                resolve();
              } else {
                check();
              }
            }, WORKER_READY_TIMEOUT);
          };

          check();
        });
      }

      return Promise.resolve();
    }
  }, {
    key: "disposeElement",
    value: function disposeElement(element) {
      if (Config$1.physics().enabled && this.hasElement(element)) {
        var uuid = element.uuid();
        this.removeElement(element);
        this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.DISPOSE,
          uuid: uuid
        });
      }
    }
  }, {
    key: "add",
    value: function add(element) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (Config$1.physics().enabled) {
        var _options$colliderType = options.colliderType,
            colliderType = _options$colliderType === void 0 ? COLLIDER_TYPES.BOX : _options$colliderType;
        var uuid = element.uuid();

        var description = _objectSpread2$1(_objectSpread2$1({}, mapColliderTypeToDescription(colliderType)(element)), options);

        this.storeElement(element, options);
        this.worker.postMessage(_objectSpread2$1(_objectSpread2$1({
          event: mapColliderTypeToAddEvent(description.collider)
        }, description), {}, {
          uuid: uuid
        }));
      }
    }
  }, {
    key: "addVehicle",
    value: function addVehicle(element, options) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();
        var description = getBoxDescriptionForElement(element);
        this.storeElement(element, options);
        this.worker.postMessage(_objectSpread2$1(_objectSpread2$1({
          event: PHYSICS_EVENTS.ADD.VEHICLE,
          uuid: uuid
        }, description), options));
      }
    }
  }, {
    key: "addModel",
    value: function addModel(model, options) {
      if (Config$1.physics().enabled) {
        var uuid = model.uuid();
        var vertices = [];
        var matrices = [];
        var indexes = [];
        iterateGeometries(model.getBody(), {}, function (vertexArray, matrixArray, indexArray) {
          vertices.push(vertexArray);
          matrices.push(matrixArray);
          indexes.push(indexArray);
        });
        this.storeElement(model, options);
        this.worker.postMessage(_objectSpread2$1(_objectSpread2$1(_objectSpread2$1({
          event: PHYSICS_EVENTS.ADD.MODEL,
          uuid: uuid,
          vertices: vertices,
          matrices: matrices,
          indexes: indexes
        }, DEFAULT_DESCRIPTION), extractPositionAndQuaternion(model)), options));
      }
    }
  }, {
    key: "updateBodyState",
    value: function updateBodyState(element, state) {
      if (Config$1.physics().enabled) {
        var uuid = element.uuid();
        this.worker.postMessage({
          event: PHYSICS_EVENTS.ELEMENT.UPDATE,
          uuid: uuid,
          state: state
        });
      }
    }
  }]);

  return Physics;
}(EventDispatcher);
var Physics$1 = new Physics();var ENTITY_TYPES = {
  SCENE: 'SCENE',
  CAMERA: 'CAMERA',
  MESH: 'MESH',
  LABEL: 'LABEL',
  LIGHT: {
    DEFAULT: 'LIGHT.DEFAULT',
    AMBIENT: 'LIGHT.AMBIENT',
    SUN: 'LIGHT.SUN',
    HEMISPHERE: 'LIGHT.HEMISPHERE',
    POINT: 'LIGHT.POINT',
    SPOT: 'LIGHT.SPOT'
  },
  AUDIO: {
    DEFAULT: 'AUDIO.DEFAULT',
    AMBIENT: 'AUDIO.AMBIENT',
    DIRECTIONAL: 'AUDIO.DIRECTIONAL',
    BACKGROUND: 'AUDIO.BACKGROUND'
  },
  MODEL: 'MODEL',
  SPRITE: 'SPRITE',
  PARTICLE: 'PARTICLE',
  EFFECT: {
    PARTICLE: 'EFFECT.PARTICLE',
    SCENERY: 'EFFECT.SCENERY'
  },
  HELPER: {
    GRID: 'HELPER.GRID',
    AXES: 'HELPER.AXES'
  },
  UNKNOWN: 'UNKNOWN'
};
var FLAT_ENTITY_TYPES = [ENTITY_TYPES.SCENE, ENTITY_TYPES.CAMERA, ENTITY_TYPES.MESH, ENTITY_TYPES.LABEL, ENTITY_TYPES.LIGHT.DEFAULT, ENTITY_TYPES.LIGHT.AMBIENT, ENTITY_TYPES.LIGHT.SUN, ENTITY_TYPES.LIGHT.HEMISPHERE, ENTITY_TYPES.LIGHT.POINT, ENTITY_TYPES.LIGHT.SPOT, ENTITY_TYPES.AUDIO.DEFAULT, ENTITY_TYPES.AUDIO.AMBIENT, ENTITY_TYPES.AUDIO.DIRECTIONAL, ENTITY_TYPES.AUDIO.BACKGROUND, ENTITY_TYPES.MODEL, ENTITY_TYPES.SPRITE, ENTITY_TYPES.PARTICLE, ENTITY_TYPES.EFFECT.PARTICLE, ENTITY_TYPES.EFFECT.SCENERY, ENTITY_TYPES.HELPER.GRID, ENTITY_TYPES.HELPER.AXES, ENTITY_TYPES.UNKNOWN];
var ENTITY_EVENTS = {
  DISPOSE: 'DISPOSE',
  STATE_MACHINE: {
    CHANGE: 'STATE_MACHINE_CHANGE'
  },
  ANIMATION: {
    LOOP: 'LOOP',
    FINISHED: 'FINISHED'
  }
};
var DEFAULT_TAG = 'all';var Scene = /*#__PURE__*/function () {
  function Scene() {
    var _this = this;

    _classCallCheck(this, Scene);

    _defineProperty$1(this, "setShadowType", function () {
      var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SHADOWTYPE;

      if (Object.keys(SHADOW_TYPES).includes(type)) {
        _this.shadowType = mapShadowTypeToShadowMap(type);

        _this.setRendererShadowMap();
      }
    });

    _defineProperty$1(this, "setRendererOutputEncoding", function () {
      var encoding = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_OUTPUT_ENCODING;

      if (Object.keys(OUTPUT_ENCODINGS).includes(encoding)) {
        _this.renderer.outputEncoding = OUTPUT_ENCODINGS[encoding];
      }
    });

    _defineProperty$1(this, "setBackground", function (texture) {
      _this.scene.background = typeof texture === 'string' ? Images$1.get(texture) : texture;
    });

    _defineProperty$1(this, "setRendererShadowMap", function () {
      _this.renderer.shadowMap.enabled = true;
      _this.renderer.shadowMap.type = _this.shadowType;
      _this.renderer.sortObjects = false;
    });

    _defineProperty$1(this, "onResize", function () {
      if (!_this.camera || !_this.renderer) return;

      var _Config$screen = Config$1.screen(),
          h = _Config$screen.h,
          w = _Config$screen.w;

      _this.resize(w, h);
    });

    _defineProperty$1(this, "onPhysicsUpdate", function (_ref) {
      var dt = _ref.dt;
      Universe$1.onPhysicsUpdate(dt);

      _this.getCamera().onPhysicsUpdate(dt);
    });

    this.clock = new Clock();
    this.rendererElements = {};
    this.elements = [];
    this.clearColor = 0x000000;
    this.alpha = 1.0;
    this.shadowType = mapShadowTypeToShadowMap(DEFAULT_SHADOWTYPE);
  }

  _createClass(Scene, [{
    key: "getEntityType",
    value: function getEntityType() {
      return ENTITY_TYPES.SCENE;
    }
  }, {
    key: "createScene",
    value: function createScene() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : generateRandomName('LevelName');
      var fog = Config$1.fog();
      this.scene = new Scene$2();
      this.scene.name = name; // this.scene.overrideMaterial = null; // should be null by default, but it's not.

      if (fog.enabled) {
        this.fog(fog.color, fog.density);
      }
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return this.scene.uuid;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.scene.name;
    }
  }, {
    key: "getScene",
    value: function getScene() {
      return this.scene;
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.scene.children;
    }
  }, {
    key: "updateChildren",
    value: function updateChildren() {
      for (var i in this.scene.children) {
        if (this.scene.children[i].material) {
          this.scene.children[i].material.needsUpdate = true;
        }
      }
    }
  }, {
    key: "add",
    value: function add(body, element) {
      var addUniverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      this.scene.add(body);

      if (element) {
        this.elements.push(element);
      }

      if (addUniverse) {
        var name = element.getName();
        Universe$1.set(name, element);
        Universe$1.storeUUIDToElementNameReference(body.uuid, name);
      }
    }
  }, {
    key: "getHierarchy",
    value: function getHierarchy() {
      return [{
        element: this,
        children: [this.getCamera().getHierarchy()].concat(_toConsumableArray(this.elements.filter(function (e) {
          return !e.hasParent() && !e.isHelper();
        }).map(function (e) {
          return e.getHierarchy();
        })))
      }];
    }
  }, {
    key: "remove",
    value: function remove(body) {
      this.scene.remove(body);
      Universe$1.remove(body.name);
    }
  }, {
    key: "setClearColor",
    value: function setClearColor(value) {
      var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1.0;

      if (this.renderer) {
        this.clearColor = value;
        this.alpha = alpha;
        this.renderer.setClearColor(value, alpha);
      }
    }
  }, {
    key: "create",
    value: function create(name) {
      this.createScene(name);
      this.createRenderer();
      this.attachListeners();
    }
  }, {
    key: "attachListeners",
    value: function attachListeners() {
      this.listenToResizeEvent();
      this.listenToPhysicsUpdate();
    }
  }, {
    key: "detachListeners",
    value: function detachListeners() {
      this.stopResizeListener();
      this.stopPhysicsUpdateListener();
    }
  }, {
    key: "listenToPhysicsUpdate",
    value: function listenToPhysicsUpdate() {
      Physics$1.addEventListener(PHYSICS_EVENTS.UPDATE, this.onPhysicsUpdate);
    }
  }, {
    key: "stopPhysicsUpdateListener",
    value: function stopPhysicsUpdateListener() {
      Physics$1.removeEventListener(PHYSICS_EVENTS.UPDATE, this.onPhysicsUpdate);
    }
  }, {
    key: "listenToResizeEvent",
    value: function listenToResizeEvent() {
      var win = getWindow();

      if (win) {
        win.addEventListener('resize', this.onResize);
      }
    }
  }, {
    key: "stopResizeListener",
    value: function stopResizeListener() {
      var win = getWindow();

      if (win) {
        win.removeEventListener('resize', this.onResize);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      // destroy renderer
      this.renderer.dispose(); // remove listener to resize

      this.detachListeners();
    }
  }, {
    key: "createCamera",
    value: function createCamera(camera) {
      this.camera = camera;
    }
  }, {
    key: "getDOMElement",
    value: function getDOMElement() {
      if (this.renderer) {
        return this.renderer.domElement;
      }
    }
  }, {
    key: "getCamera",
    value: function getCamera() {
      return this.camera;
    }
  }, {
    key: "getCameraBody",
    value: function getCameraBody() {
      return this.camera.getBody();
    }
  }, {
    key: "getRenderer",
    value: function getRenderer() {
      return this.renderer;
    }
  }, {
    key: "getChildren",
    value: function getChildren() {
      return this.scene.children;
    }
  }, {
    key: "removeExistingRendererElements",
    value: function removeExistingRendererElements() {
      Object.keys(this.rendererElements).forEach(function (k) {
        var element = document.body.querySelector("#".concat(k));

        if (element) {
          element.remove();
        }
      });
    }
  }, {
    key: "storeRenderer",
    value: function storeRenderer(rendererElement) {
      var id = "renderer_".concat(generateUUID());
      this.rendererElements[id] = rendererElement;
      return id;
    }
  }, {
    key: "createRenderer",
    value: function createRenderer() {
      var _Config$lights = Config$1.lights(),
          shadows = _Config$lights.shadows,
          _Config$lights$shadow = _Config$lights.shadowType,
          shadowType = _Config$lights$shadow === void 0 ? DEFAULT_SHADOWTYPE : _Config$lights$shadow;

      var _Config$screen2 = Config$1.screen(),
          _Config$screen2$alpha = _Config$screen2.alpha,
          alpha = _Config$screen2$alpha === void 0 ? true : _Config$screen2$alpha,
          _Config$screen2$antia = _Config$screen2.antialias,
          antialias = _Config$screen2$antia === void 0 ? true : _Config$screen2$antia,
          w = _Config$screen2.w,
          h = _Config$screen2.h;

      var container = Config$1.container();
      this.renderer = new WebGLRenderer({
        alpha: alpha,
        antialias: antialias,
        powerPreference: 'high-performance'
      });

      if (shadows) {
        this.setShadowType(shadowType);
        this.setRendererShadowMap();
      }

      this.renderer.setPixelRatio(window.devicePixelRatio);
      this.renderer.setSize(w, h);
      this.renderer.domElement.id = this.storeRenderer(this.renderer.domElement);
      this.removeExistingRendererElements();

      if (!container) {
        document.body.appendChild(this.renderer.domElement);
      } else {
        container.appendChild(this.renderer.domElement);
      }
    }
  }, {
    key: "setRendererToneMapping",
    value: function setRendererToneMapping() {
      var toneMapping = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LinearToneMapping;
      var toneMappingExposure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      this.renderer.toneMapping = toneMapping;
      this.renderer.toneMappingExposure = toneMappingExposure;
    }
  }, {
    key: "resize",
    value: function resize(width, height) {
      if (!width || !height) return;
      var ratio = width / height;
      this.camera.getBody().aspect = ratio;
      this.camera.getBody().updateProjectionMatrix();
      this.renderer.setSize(width, height);
    }
  }, {
    key: "render",
    value: function render() {
      this.renderer.setClearColor(this.clearColor, this.alpha);
      this.renderer.clear();
      this.renderer.setRenderTarget(null);
      this.renderer.render(this.scene, this.camera.getBody());
    }
  }, {
    key: "setFog",
    value: function setFog(color, density) {
      this.scene.fog = new FogExp2(color, density);
      Config$1.setConfig({
        fog: {
          enabled: true,
          color: color,
          density: density
        }
      });
    }
  }, {
    key: "update",
    value: function update(dt) {
      Universe$1.update(dt);
      this.getCamera().update(dt);
    }
  }]);

  return Scene;
}();
var Scene$1 = new Scene();var MOUSE_DOWN = 'mouseDown';
var MOUSE_UP = 'mouseUp';
var MOUSE_MOVE = 'mouseMove';
var ELEMENT_CLICK = 'elementClick';
var ELEMENT_DESELECT = 'elementDeselect';

var Mouse = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Mouse, _EventDispatcher);

  var _super = _createSuper(Mouse);

  function Mouse() {
    var _this;

    _classCallCheck(this, Mouse);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "parseMouseEvent", function (event) {
      var _this$getRelativeMous = _this.getRelativeMousePosition(event),
          x = _this$getRelativeMous.x,
          y = _this$getRelativeMous.y;

      _this.normalizeMouse(x, y);

      return {
        x: x,
        y: y,
        normalized: _objectSpread2$1({}, _this.mouse)
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();
      _this.mouseMoveEvent.mouse = _this.parseMouseEvent(event);

      _this.dispatchEvent(_this.mouseMoveEvent);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseUp", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();
      _this.mouseUpEvent.mouse = _this.parseMouseEvent(event);

      _this.dispatchEvent(_this.mouseUpEvent);
    });

    _defineProperty$1(_assertThisInitialized(_this), "parseIntersection", function (_ref) {
      var object = _ref.object,
          face = _ref.face,
          point = _ref.point;
      return {
        face: face,
        position: point,
        element: Universe$1.find(object)
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "elementExists", function (_ref2) {
      var element = _ref2.element;
      return !!element;
    });

    _defineProperty$1(_assertThisInitialized(_this), "elementHasTag", function (tag) {
      return function (_ref3) {
        var element = _ref3.element;
        return element.hasTag(tag);
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "getIntersections", function () {
      var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var tag = arguments.length > 1 ? arguments[1] : undefined;

      if (_this.hasRaycaster()) {
        _this.raycaster.setFromCamera(_this.mouse, Scene$1.getCameraBody());

        return _this.raycaster.intersectObjects(Scene$1.getChildren(), recursive) // .filter(this.isIntersectionAMeshOrSprite)
        .map(_this.parseIntersection).filter(_this.elementExists).filter(_this.elementHasTag(tag));
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();

      var mouseEvent = _this.parseMouseEvent(event);

      _this.mouseDownEvent.mouse = mouseEvent;
      _this.elementClickEvent.mouse = mouseEvent;

      _this.dispatchEvent(_this.mouseDownEvent);

      var elements = _this.getIntersections();

      _this.elementClickEvent.elements = elements;

      if (!elements.length) {
        _this.dispatchEvent(_this.elementDeselectEvent);
      } else {
        _this.dispatchEvent(_this.elementClickEvent);
      }
    });

    _this.enabled = false;
    _this.mouseMoveIntersectionEnabled = false;
    _this.mouse = new Vector2();
    _this.mouseDownEvent = {
      type: MOUSE_DOWN
    };
    _this.mouseUpEvent = {
      type: MOUSE_UP
    };
    _this.mouseMoveEvent = {
      type: MOUSE_MOVE
    };
    _this.elementClickEvent = {
      type: ELEMENT_CLICK
    };
    _this.elementDeselectEvent = {
      type: ELEMENT_DESELECT
    };
    return _this;
  }

  _createClass(Mouse, [{
    key: "hasRaycaster",
    value: function hasRaycaster() {
      return Boolean(this.raycaster);
    }
  }, {
    key: "createRayCaster",
    value: function createRayCaster() {
      if (!this.hasRaycaster()) {
        this.raycaster = new Raycaster();
        this.raycaster.setFromCamera(this.mouse, Scene$1.getCameraBody());
      }
    }
  }, {
    key: "enable",
    value: function enable() {
      this.enabled = true;
      this.createRayCaster();
      Scene$1.getDOMElement().addEventListener('mousemove', this.onMouseMove);
      Scene$1.getDOMElement().addEventListener('mousedown', this.onMouseDown);
      document.addEventListener('mouseup', this.onMouseUp);
    }
  }, {
    key: "enableMouseMoveIntersection",
    value: function enableMouseMoveIntersection() {
      this.mouseMoveIntersectionEnabled = true;
    }
  }, {
    key: "disable",
    value: function disable() {
      this.enabled = false;
      this.mouseMoveIntersectionEnabled = false;
      document.removeEventListener('mouseup', this.onMouseUp);
      Scene$1.getDOMElement().removeEventListener('mousemove', this.onMouseMove);
      Scene$1.getDOMElement().removeEventListener('mousedown', this.onMouseDown);
    }
  }, {
    key: "getRelativeMousePosition",
    value: function getRelativeMousePosition(event) {
      var rect = Config$1.container().getBoundingClientRect();
      var x = event.clientX - rect.left;
      var y = event.clientY - rect.top;
      return {
        x: x,
        y: y
      };
    }
  }, {
    key: "normalizeMouse",
    value: function normalizeMouse(x, y) {
      var _Config$screen = Config$1.screen(),
          w = _Config$screen.w,
          h = _Config$screen.h;

      this.mouse.set(x / w * 2 - 1, -(y / h) * 2 + 1);
    }
  }]);

  return Mouse;
}(EventDispatcher);var FEATURES = {
  WEBGL: 'webgl',
  WEBAUDIOAPI: 'webaudioapi',
  WEBWORKER: 'webworker',
  LOCALSTORAGE: 'localStorage',
  AJAX: 'ajax',
  OFFSCREENCANVAS: 'offscreenCanvas',
  GAMEPADAPI: 'gamepadapi',
  MEMORY: 'memory'
};
var Features = /*#__PURE__*/function () {
  function Features() {
    _classCallCheck(this, Features);

    this.tests = [FEATURES.WEBGL, FEATURES.WEBAUDIOAPI, FEATURES.WEBWORKER, FEATURES.LOCALSTORAGE, FEATURES.AJAX];
  }

  _createClass(Features, [{
    key: "setUpPolyfills",
    value: function setUpPolyfills() {
      var frameRate = Config$1.screen().frameRate;

      window.requestNextFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function (callback, element) {
        window.setTimeout(callback, 1000 / frameRate);
      };
    }
  }, {
    key: "isFeatureSupported",
    value: function isFeatureSupported(feature) {
      if (typeof this[feature] === 'function') {
        var _this$feature = this[feature](),
            success = _this$feature.success;

        return success;
      }

      return false;
    }
  }, {
    key: "checkSupportedFeatures",
    value: function checkSupportedFeatures() {
      var _this = this;

      var configTests = Config$1.tests() || [];
      var tests = [].concat(_toConsumableArray(this.tests), _toConsumableArray(configTests));

      if (tests.indexOf(FEATURES.WEBGL) == -1) {
        tests.push(FEATURES.WEBGL);
      }

      var failures = tests.map(function (test) {
        return _this[test] && _this[test]();
      }).reduce(function (acc, result) {
        if (!result.success) {
          acc.push(result.name);
        }

        return acc;
      }, []);
      return failures.length ? Promise.reject(failures) : Promise.resolve();
    }
  }, {
    key: "localStorage",
    value: function localStorage() {
      if (window && window.localStorage && typeof window.localStorage.setItem === 'function' && typeof window.localStorage.getItem === 'function' && typeof window.localStorage.removeItem === 'function' && typeof window.localStorage.clear === 'function') {
        return {
          success: true,
          name: FEATURES.LOCALSTORAGE
        };
      } else {
        return {
          success: false,
          name: FEATURES.LOCALSTORAGE
        };
      }
    }
  }, {
    key: "offscreenCanvas",
    value: function offscreenCanvas() {
      var hasOffscreenCanvas = !!window.OffscreenCanvas;
      return {
        success: hasOffscreenCanvas,
        name: FEATURES.OFFSCREENCANVAS
      };
    }
  }, {
    key: "webgl",
    value: function webgl() {
      try {
        var canvas = document.createElement("canvas");
        var context = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");

        if (context) {
          return {
            success: true,
            name: FEATURES.WEBGL
          };
        } else {
          return {
            success: false,
            name: FEATURES.WEBGL
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.WEBGL
        };
      }
    }
  }, {
    key: "webaudioapi",
    value: function webaudioapi() {
      try {
        var hasWebAudioApi = !!(window.webkitAudioContext || window.AudioContext);

        if (hasWebAudioApi) {
          return {
            success: true,
            name: FEATURES.WEBAUDIOAPI
          };
        } else {
          return {
            success: false,
            name: FEATURES.WEBAUDIOAPI
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.WEBAUDIOAPI
        };
      }
    }
  }, {
    key: "webworker",
    value: function webworker() {
      try {
        var hasWorkers = !!window.Worker;

        if (hasWorkers) {
          return {
            success: true,
            name: FEATURES.WEBWORKER
          };
        } else {
          return {
            success: false,
            name: FEATURES.WEBWORKER
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.WEBWORKER
        };
      }
    }
  }, {
    key: "ajax",
    value: function ajax() {
      try {
        var xhr = null;

        try {
          xhr = new XMLHttpRequest();
        } catch (e) {}

        try {
          xhr = new ActiveXObject("Microsoft.XMLHTTP");
        } catch (e) {}

        try {
          xhr = new ActiveXObject("Msxml2.XMLHTTP");
        } catch (e) {}

        if (xhr) {
          return {
            success: true,
            name: FEATURES.AJAX
          };
        } else {
          return {
            success: false,
            name: FEATURES.AJAX
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.AJAX
        };
      }
    }
  }, {
    key: "gamepadapi",
    value: function gamepadapi() {
      try {
        if (navigator && (navigator.getGamepads || navigator.webkitGetGamepads) && window.Gamepad && window.GamepadButton) {
          return {
            success: true,
            name: FEATURES.GAMEPADAPI
          };
        } else {
          return {
            success: false,
            name: FEATURES.GAMEPADAPI
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.GAMEPADAPI
        };
      }
    }
  }, {
    key: "memory",
    value: function memory() {
      try {
        if (performance && performance.memory && performance.memory.usedJSHeapSize && performance.memory.jsHeapSizeLimit) {
          return {
            success: true,
            name: FEATURES.MEMORY
          };
        } else {
          return {
            success: false,
            name: FEATURES.MEMORY
          };
        }
      } catch (e) {
        return {
          success: false,
          name: FEATURES.MEMORY
        };
      }
    }
  }]);

  return Features;
}();
var Features$1 = new Features();var SAVE_STARTED = 'SAVE_STARTED';
var SAVE_COMPLETED = 'SAVE_COMPLETED';
var SAVE_ERROR = 'SAVE_ERROR';
var LOAD_STARTED = 'LOAD_STARTED';
var LOAD_COMPLETED = 'LOAD_COMPLETED';
var LOAD_ERROR = 'LOAD_ERROR';
var KEYBOARD_ENABLED = 'KEYBOARD_ENABLED';
var MOUSE_ENABLED = 'MOUSE_ENABLED';
var GAMEPAD_ENABLED = 'GAMEPAD_ENABLED';
var INPUT_ENABLED = 'INPUT_ENABLED';
var KEYBOARD_DISABLED = 'KEYBOARD_DISABLED';
var MOUSE_DISABLED = 'MOUSE_DISABLED';
var GAMEPAD_DISABLED = 'GAMEPAD_DISABLED';
var INPUT_DISABLED = 'INPUT_DISABLED';
var GAMEPAD_CONNECTED = 'GAMEPAD_CONNECTED';
var GAMEPAD_DISCONNECTED = 'GAMEPAD_DISCONNECTED';
var NETWORK_CHANGED = 'NETWORK_CHANGED';
var UI_LOADING_SCREEN = 'UI_LOADING_SCREEN';
var LOCATION_PATH_CHANGE = 'LOCATION_PATH_CHANGE';
var RESET = 'RESET';var inputEnabled = function inputEnabled() {
  return {
    type: INPUT_ENABLED
  };
};
var keyboardEnabled = function keyboardEnabled() {
  return {
    type: KEYBOARD_ENABLED
  };
};
var mouseEnabled = function mouseEnabled() {
  return {
    type: MOUSE_ENABLED
  };
};
var gamepadEnabled = function gamepadEnabled() {
  return {
    type: GAMEPAD_ENABLED
  };
};
var inputDisabled = function inputDisabled() {
  return {
    type: INPUT_DISABLED
  };
};
var keyboardDisabled = function keyboardDisabled() {
  return {
    type: KEYBOARD_DISABLED
  };
};
var mouseDisabled = function mouseDisabled() {
  return {
    type: MOUSE_DISABLED
  };
};
var gamepadDisabled = function gamepadDisabled() {
  return {
    type: GAMEPAD_DISABLED
  };
};
var gamepadConnected = function gamepadConnected(gamepads) {
  return {
    type: GAMEPAD_CONNECTED,
    gamepads: gamepads
  };
};
var gamepadDisconnected = function gamepadDisconnected(gamepads) {
  return {
    type: GAMEPAD_DISCONNECTED,
    gamepads: gamepads
  };
};function symbolObservablePonyfill(root) {
	var result;
	var Symbol = root.Symbol;

	if (typeof Symbol === 'function') {
		if (Symbol.observable) {
			result = Symbol.observable;
		} else {
			result = Symbol('observable');
			Symbol.observable = result;
		}
	} else {
		result = '@@observable';
	}

	return result;
}/* global window */

var root;

if (typeof self !== 'undefined') {
  root = self;
} else if (typeof window !== 'undefined') {
  root = window;
} else if (typeof __webpack_require__.g !== 'undefined') {
  root = __webpack_require__.g;
} else if (true) {
  root = module;
} else {}

var result$2 = symbolObservablePonyfill(root);/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * Creates a Redux store that holds the state tree.
 * The only way to change the data in the store is to call `dispatch()` on it.
 *
 * There should only be a single store in your app. To specify how different
 * parts of the state tree respond to actions, you may combine several reducers
 * into a single reducer function by using `combineReducers`.
 *
 * @param {Function} reducer A function that returns the next state tree, given
 * the current state tree and the action to handle.
 *
 * @param {any} [preloadedState] The initial state. You may optionally specify it
 * to hydrate the state from the server in universal apps, or to restore a
 * previously serialized user session.
 * If you use `combineReducers` to produce the root reducer function, this must be
 * an object with the same shape as `combineReducers` keys.
 *
 * @param {Function} [enhancer] The store enhancer. You may optionally specify it
 * to enhance the store with third-party capabilities such as middleware,
 * time travel, persistence, etc. The only store enhancer that ships with Redux
 * is `applyMiddleware()`.
 *
 * @returns {Store} A Redux store that lets you read the state, dispatch actions
 * and subscribe to changes.
 */

function createStore$1(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error('Expected the enhancer to be a function.');
    }

    return enhancer(createStore$1)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error('Expected the reducer to be a function.');
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error('Expected the listener to be a function.');
    }

    if (isDispatching) {
      throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribelistener for more details.');
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
    }

    if (typeof action.type === 'undefined') {
      throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
    }

    if (isDispatching) {
      throw new Error('Reducers may not dispatch actions.');
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error('Expected the nextReducer to be a function.');
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new TypeError('Expected the observer to be an object.');
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[result$2] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[result$2] = observable, _ref2;
}

function getUndefinedStateErrorMessage(key, action) {
  var actionType = action && action.type;
  var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
  return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
}

function assertReducerShape(reducers) {
  Object.keys(reducers).forEach(function (key) {
    var reducer = reducers[key];
    var initialState = reducer(undefined, {
      type: ActionTypes.INIT
    });

    if (typeof initialState === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
    }

    if (typeof reducer(undefined, {
      type: ActionTypes.PROBE_UNKNOWN_ACTION()
    }) === 'undefined') {
      throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
    }
  });
}
/**
 * Turns an object whose values are different reducer functions, into a single
 * reducer function. It will call every child reducer, and gather their results
 * into a single state object, whose keys correspond to the keys of the passed
 * reducer functions.
 *
 * @param {Object} reducers An object whose values correspond to different
 * reducer functions that need to be combined into one. One handy way to obtain
 * it is to use ES6 `import * as reducers` syntax. The reducers may never return
 * undefined for any action. Instead, they should return their initial state
 * if the state passed to them was undefined, and the current state for any
 * unrecognized action.
 *
 * @returns {Function} A reducer function that invokes every reducer inside the
 * passed object, and builds a state object with the same shape.
 */


function combineReducers$1(reducers) {
  var reducerKeys = Object.keys(reducers);
  var finalReducers = {};

  for (var i = 0; i < reducerKeys.length; i++) {
    var key = reducerKeys[i];

    if (typeof reducers[key] === 'function') {
      finalReducers[key] = reducers[key];
    }
  }

  var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same

  var shapeAssertionError;

  try {
    assertReducerShape(finalReducers);
  } catch (e) {
    shapeAssertionError = e;
  }

  return function combination(state, action) {
    if (state === void 0) {
      state = {};
    }

    if (shapeAssertionError) {
      throw shapeAssertionError;
    }

    var hasChanged = false;
    var nextState = {};

    for (var _i = 0; _i < finalReducerKeys.length; _i++) {
      var _key = finalReducerKeys[_i];
      var reducer = finalReducers[_key];
      var previousStateForKey = state[_key];
      var nextStateForKey = reducer(previousStateForKey, action);

      if (typeof nextStateForKey === 'undefined') {
        var errorMessage = getUndefinedStateErrorMessage(_key, action);
        throw new Error(errorMessage);
      }

      nextState[_key] = nextStateForKey;
      hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
    }

    hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
    return hasChanged ? nextState : state;
  };
}

function bindActionCreator(actionCreator, dispatch) {
  return function () {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
/**
 * Turns an object whose values are action creators, into an object with the
 * same keys, but with every function wrapped into a `dispatch` call so they
 * may be invoked directly. This is just a convenience method, as you can call
 * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
 *
 * For convenience, you can also pass an action creator as the first argument,
 * and get a dispatch wrapped function in return.
 *
 * @param {Function|Object} actionCreators An object whose values are action
 * creator functions. One handy way to obtain it is to use ES6 `import * as`
 * syntax. You may also pass a single function.
 *
 * @param {Function} dispatch The `dispatch` function available on your Redux
 * store.
 *
 * @returns {Function|Object} The object mimicking the original object, but with
 * every action creator wrapped into the `dispatch` call. If you passed a
 * function as `actionCreators`, the return value will also be a single
 * function.
 */


function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === 'function') {
    return bindActionCreator(actionCreators, dispatch);
  }

  if (typeof actionCreators !== 'object' || actionCreators === null) {
    throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
  }

  var boundActionCreators = {};

  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];

    if (typeof actionCreator === 'function') {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }

  return boundActionCreators;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    keys.push.apply(keys, Object.getOwnPropertySymbols(object));
  }

  if (enumerableOnly) keys = keys.filter(function (sym) {
    return Object.getOwnPropertyDescriptor(object, sym).enumerable;
  });
  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for
 * the resulting composite function.
 *
 * @param {...Function} funcs The functions to compose.
 * @returns {Function} A function obtained by composing the argument functions
 * from right to left. For example, compose(f, g, h) is identical to doing
 * (...args) => f(g(h(...args))).
 */
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  if (funcs.length === 0) {
    return function (arg) {
      return arg;
    };
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(void 0, arguments));
    };
  });
}

/**
 * Creates a store enhancer that applies middleware to the dispatch method
 * of the Redux store. This is handy for a variety of tasks, such as expressing
 * asynchronous actions in a concise manner, or logging every action payload.
 *
 * See `redux-thunk` package as an example of the Redux middleware.
 *
 * Because middleware is potentially asynchronous, this should be the first
 * store enhancer in the composition chain.
 *
 * Note that each middleware will be given the `dispatch` and `getState` functions
 * as named arguments.
 *
 * @param {...Function} middlewares The middleware chain to be applied.
 * @returns {Function} A store enhancer applying the middleware.
 */

function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }

  return function (createStore) {
    return function () {
      var store = createStore.apply(void 0, arguments);

      var _dispatch = function dispatch() {
        throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
      };

      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function (middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread2({}, store, {
        dispatch: _dispatch
      });
    };
  };
}var redux=/*#__PURE__*/Object.freeze({__proto__:null,__DO_NOT_USE__ActionTypes:ActionTypes,applyMiddleware:applyMiddleware,bindActionCreators:bindActionCreators,combineReducers:combineReducers$1,compose:compose,createStore:createStore$1});function createThunkMiddleware(extraArgument) {
  return function (_ref) {
    var dispatch = _ref.dispatch,
        getState = _ref.getState;
    return function (next) {
      return function (action) {
        if (typeof action === 'function') {
          return action(dispatch, getState, extraArgument);
        }

        return next(action);
      };
    };
  };
}

var thunk = createThunkMiddleware();
thunk.withExtraArgument = createThunkMiddleware;var name = "mage-engine";
var version$1 = "3.19.0";
var description = "A WebGL Javascript Game Engine, built on top of THREE.js and many other libraries.";
var main = "dist/mage.js";
var author$1 = {
	name: "Marco Stagni",
	email: "marco@mage.studio"
};
var scripts = {
	preversion: "npm test",
	version: "npm run build",
	dev: "concurrently 'npm:build:live' 'npm:start'",
	start: "http-server ./ -p 8085",
	"postversion:push": "git push --no-verify && git push --tags --no-verify",
	postversion: "npm run postversion:push && npm publish",
	prebuild: "rimraf dist/mage.js",
	build: "rollup --config config/index.js",
	"build:live": "rollup --config config/index.js --watch",
	test: "echo you should test"
};
var repository = {
	type: "git",
	url: "git://github.com/MageStudio/Mage.git"
};
var license = "BSD-3-Clause";
var keywords = [
	"mage",
	"marco",
	"stagni",
	"three.js",
	"webgl",
	"game",
	"engine",
	"game engine",
	"javascript",
	"browser",
	"shader"
];
var dependencies = {
	"@babel/plugin-transform-classes": "^7.9.5",
	"@babel/plugin-transform-runtime": "7.5.0",
	"@babel/runtime": "7.5.0",
	"between.js": "0.1.2-fix.2",
	"hotkeys-js": "3.7.2",
	"html-to-image": "^1.9.0",
	html2canvas: "^1.4.1",
	inferno: "7.3.2",
	"inferno-create-element": "7.3.3",
	"inferno-redux": "7.4.2",
	"mage-engine.particles": "github:MageStudio/partykals#v2.0.5",
	redux: "4.0.5",
	"redux-thunk": "^2.3.0",
	rxjs: "6.5.3",
	three: "0.126.0",
	"three.proton.js": "0.2.3",
	vivifyjs: "*",
	"whatwg-fetch": "3.0.0",
	xstate: "^4.8.0"
};
var devDependencies = {
	"@babel/cli": "7.17.3",
	"@babel/core": "7.17.5",
	"@babel/node": "7.16.8",
	"@babel/plugin-proposal-class-properties": "7.16.7",
	"@babel/polyfill": "7.12.1",
	"@babel/preset-env": "7.16.11",
	"@babel/register": "7.17.0",
	"@rollup/plugin-babel": "5.3.1",
	"@rollup/plugin-commonjs": "21.0.2",
	"@rollup/plugin-json": "4.1.0",
	"@rollup/plugin-node-resolve": "13.1.3",
	"@rollup/plugin-replace": "^2.3.4",
	"babel-loader": "8.2.3",
	"babel-plugin-inferno": "6.3.0",
	"babel-plugin-syntax-jsx": "^6.18.0",
	concurrently: "^5.3.0",
	"http-server": "^0.12.3",
	madge: "^5.0.1",
	rimraf: "^3.0.0",
	rollup: "2.69.0",
	"rollup-plugin-terser": "7.0.2",
	"rollup-plugin-web-worker-loader": "1.6.1"
};
var packageJSON = {
	name: name,
	version: version$1,
	description: description,
	main: main,
	author: author$1,
	scripts: scripts,
	repository: repository,
	license: license,
	keywords: keywords,
	dependencies: dependencies,
	devDependencies: devDependencies
};var DEFAULT_STATE$5 = {
  mage: packageJSON.version
};
var info = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE$5;
  return state;
});var DEFAULT_STATE$4 = {
  error: false,
  saving: false,
  loading: false,
  errorDetails: '',
  sceneName: '',
  currentPath: '/',
  timestamp: ''
};
var storage$1 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE$4;
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  switch (action.type) {
    case SAVE_STARTED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        saving: true
      });

    case SAVE_COMPLETED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        saving: false,
        error: false,
        sceneName: action.currentScene,
        currentPath: action.currentPath,
        timestamp: action.timestamp
      });

    case SAVE_ERROR:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        saving: false,
        error: true,
        errorDetails: action.errorDetails
      });

    case LOAD_STARTED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        loading: true
      });

    case LOAD_COMPLETED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        loading: false,
        error: false
      });

    case LOAD_ERROR:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        loading: false,
        error: true,
        errorDetails: action.errorDetails
      });

    default:
      return state;
  }
});var DEFAULT_STATE$3 = {
  keyboard: false,
  mouse: false,
  gamepad: false,
  gamepads: {}
};
var input = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE$3;
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  switch (action.type) {
    case INPUT_ENABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        keyboard: true,
        mouse: true,
        gamepad: true
      });

    case KEYBOARD_ENABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        keyboard: true
      });

    case MOUSE_ENABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        mouse: true
      });

    case GAMEPAD_ENABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        gamepad: true
      });

    case INPUT_DISABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        keyboard: false,
        mouse: false,
        gamepad: false
      });

    case KEYBOARD_DISABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        keyboard: false
      });

    case MOUSE_DISABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        mouse: false
      });

    case GAMEPAD_DISABLED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        gamepad: false
      });

    case GAMEPAD_CONNECTED:
    case GAMEPAD_DISCONNECTED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        gamepads: action.gamepads
      });

    default:
      return state;
  }
});var DEFAULT_STATE$2 = {
  isOnline: true
};
var network = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE$2;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case NETWORK_CHANGED:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        isOnline: action.isOnline
      });

    default:
      return state;
  }
});var DEFAULT_STATE$1 = {
  loadingScreenVisible: false
};
var ui = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE$1;
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  switch (action.type) {
    case UI_LOADING_SCREEN:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        loadingScreenVisible: action.loadingScreenVisible
      });

    default:
      return state;
  }
});var DEFAULT_STATE = {
  path: '/'
};
var location$1 = (function () {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE;
  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  switch (action.type) {
    case LOCATION_PATH_CHANGE:
      return _objectSpread2$1(_objectSpread2$1({}, state), {}, {
        path: action.path
      });

    default:
      return state;
  }
});var createRootReducer = function createRootReducer(combinedReducer) {
  return function (state, action) {
    switch (action.type) {
      case RESET:
        if (Object.keys(action.state).length > 0) {
          return _objectSpread2$1(_objectSpread2$1({}, state), action.state);
        } else {
          return state;
        }

      default:
        return combinedReducer(state, action);
    }
  };
};var DEFAULT_REDUCERS=/*#__PURE__*/Object.freeze({__proto__:null,info:info,input:input,storage:storage$1,network:network,ui:ui,location:location$1,'default':createRootReducer});var _this = undefined;

var debounce = function debounce(func, wait, immediate) {
  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : _this;
  var timeout;
  return function () {
    var args = arguments;

    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };

    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};
var NOOP = function NOOP(f) {
  return f;
};var functions=/*#__PURE__*/Object.freeze({__proto__:null,debounce:debounce,NOOP:NOOP});var store, latestAction;
var unsubscribe = NOOP;
var subscribers = [];

var applyMiddlewares = function applyMiddlewares(mdws, debug) {
  if (debug) {
    return compose(applyMiddleware.apply(redux, _toConsumableArray(mdws)), window.__REDUX_DEVTOOLS_EXTENSION__ ? window.__REDUX_DEVTOOLS_EXTENSION__() : function (f) {
      return f;
    });
  }

  return applyMiddleware.apply(redux, _toConsumableArray(mdws));
};

var defaultMiddleware = function defaultMiddleware() {
  return [thunk];
};

var combineReducers = function combineReducers() {
  var reducers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return combineReducers$1(_objectSpread2$1(_objectSpread2$1({}, reducers), DEFAULT_REDUCERS));
};

var getState = function getState() {
  if (store) {
    return store.getState();
  } else {
    console.log(STORE_DOESNT_EXIST);
  }
};
var getStore = function getStore() {
  return store;
};

var handleSubscriptions = function handleSubscriptions() {
  return subscribers.forEach(function (subscriber) {
    if (subscriber.onStateChange) {
      subscriber.onStateChange(getState(), latestAction);
    }
  });
};

var createStore = function createStore(reducers) {
  var initialState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var debug = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var storeReducers = combineReducers(reducers);

  if (!store) {
    store = createStore$1(createRootReducer(storeReducers), initialState, applyMiddlewares(defaultMiddleware(), debug));
    unsubscribe = store.subscribe(handleSubscriptions);
  }
};
var subscribe = function subscribe(subscriber) {
  return subscribers.push(subscriber);
};
var unsubscribeAll = function unsubscribeAll() {
  unsubscribe();
  subscribers = [];
};
var dispatch$8 = function dispatch(action) {
  if (store && action) {
    store.dispatch(action);
    latestAction = action;
  }
};var STANDARD = 'STANDARD';
var GAMEPAD_BUTTON_MAPPINGS = _defineProperty$1({}, STANDARD, ['X', 'B', 'A', 'Y', 'L1', 'R1', null, null, 'SELECT', 'START']);var WINDOW_GAMEPAD_CONNECTED_EVENT = 'gamepadconnected';
var WINDOW_GAMEPAD_DISCONNECTED_EVENT = 'gamepaddisconnected';
var GAMEPAD_CONNECTED_EVENT = 'gamepadConnected';
var GAMEPAD_DISCONNECTED_EVENT = 'gamepadDisconnected';
var AXIS_CHANGE_EVENT = 'axisChange';
var BUTTON_PRESSED_EVENT = 'gamepadButtonPressed';
var BUTTON_RELEASED_EVENT = 'gamepadButtonReleased';
var isValidGamepad = function isValidGamepad(gamepad) {
  return !!gamepad;
};
var getConnectedGamepads = function getConnectedGamepads() {
  var list = navigator.getGamepads ? navigator.getGamepads() : navigator.webkitGetGamepads ? navigator.webkitGetGamepads() : [];
  if (typeof list === 'array') return list;
  var gamepads = [];

  var _iterator = _createForOfIteratorHelper(navigator.getGamepads()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var gamepad = _step.value;

      if (isValidGamepad(gamepad)) {
        gamepads.push(gamepad);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return gamepads;
};
var mapButtonIndexToKey = function mapButtonIndexToKey(gamepad, index) {
  return (GAMEPAD_BUTTON_MAPPINGS[gamepad.id] || GAMEPAD_BUTTON_MAPPINGS[STANDARD])[index];
};
var parseButton = function parseButton(button, index) {
  if (typeof button === 'number') {
    return {
      pressed: button === 1.0,
      value: button,
      index: index,
      key: mapButtonIndexToKey(index)
    };
  }
  return {
    pressed: button.pressed,
    value: button.value,
    index: index,
    key: mapButtonIndexToKey(index)
  };
};

var Gamepad = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Gamepad, _EventDispatcher);

  var _super = _createSuper(Gamepad);

  function Gamepad() {
    var _this;

    _classCallCheck(this, Gamepad);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "transformGamepadsForEvent", function () {
      return Object.keys(_this.gamepads).reduce(function (acc, index) {
        var _this$gamepads$index = _this.gamepads[index],
            gamepadIndex = _this$gamepads$index.index,
            connected = _this$gamepads$index.connected,
            timestamp = _this$gamepads$index.timestamp,
            id = _this$gamepads$index.id,
            mapping = _this$gamepads$index.mapping;
        acc[index] = {
          index: gamepadIndex,
          connected: connected,
          timestamp: timestamp,
          id: id,
          mapping: mapping
        };
        return acc;
      }, {});
    });

    _defineProperty$1(_assertThisInitialized(_this), "onGamepadConnected", function (e) {
      _this.addGamepad(e.gamepad);

      _this.dispatchEvent({
        type: GAMEPAD_CONNECTED_EVENT,
        gamepad: e.gamepad
      });

      dispatch$8(gamepadConnected(_this.transformGamepadsForEvent()));
    });

    _defineProperty$1(_assertThisInitialized(_this), "onGamepadDisconnected", function (e) {
      _this.removeGamepad(e.gamepad);

      _this.dispatchEvent({
        type: GAMEPAD_DISCONNECTED_EVENT,
        gamepad: e.gamepad
      });

      dispatch$8(gamepadDisconnected(_this.transformGamepadsForEvent()));
    });

    _defineProperty$1(_assertThisInitialized(_this), "evaluateGamepads", function (previousGamepads) {
      Object.keys(_this.gamepads).forEach(function (index) {
        var gamepad = _this.gamepads[index];
        var previousButtons = previousGamepads[index].buttons;

        _this.evaluateButtonsChange(previousButtons, gamepad);

        _this.evaluateAxesChange(gamepad);
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "evaluateButtonsChange", function (previousButtons, gamepad) {
      gamepad.buttons.forEach(function (button, index) {
        var current = parseButton(button, index);
        var previous = parseButton(previousButtons[index], index);

        if (current.pressed) {
          _this.dispatchEvent({
            type: BUTTON_PRESSED_EVENT,
            button: current,
            gamepad: gamepad
          });
        } else if (previous.pressed) {
          _this.dispatchEvent({
            type: BUTTON_RELEASED_EVENT,
            button: current,
            gamepad: gamepad
          });
        }
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "evaluateAxesChange", function (gamepad) {
      var toFloat = function toFloat(number, fixed) {
        return parseFloat(number.toFixed(fixed));
      };

      var joystick = 0;
      var axes = gamepad.axes;

      for (var i = 0; i < axes.length; i += 2) {
        var x = toFloat(axes[i], 2);
        var y = toFloat(axes[i + 1], 2);

        _this.dispatchEvent({
          type: AXIS_CHANGE_EVENT,
          value: {
            x: x,
            y: y
          },
          gamepad: gamepad,
          joystick: joystick
        });

        joystick++;
      }
    });

    _this.enabled = false;
    _this.gamepads = {};
    return _this;
  }

  _createClass(Gamepad, [{
    key: "reset",
    value: function reset() {
      this.enabled = false;
      this.gamepads = {};
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.enabled;
    }
  }, {
    key: "enable",
    value: function enable() {
      if (Features$1.isFeatureSupported(FEATURES.GAMEPADAPI)) {
        this.enabled = true;
        window.addEventListener(WINDOW_GAMEPAD_CONNECTED_EVENT, this.onGamepadConnected);
        window.addEventListener(WINDOW_GAMEPAD_DISCONNECTED_EVENT, this.onGamepadDisconnected);
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      this.reset();
      window.removeEventListener(WINDOW_GAMEPAD_CONNECTED_EVENT, this.onGamepadConnected);
      window.removeEventListener(WINDOW_GAMEPAD_DISCONNECTED_EVENT, this.onGamepadDisconnected);
    }
  }, {
    key: "getConnectedGamepads",
    value: function getConnectedGamepads() {
      return this.gamepads;
    }
  }, {
    key: "addGamepad",
    value: function addGamepad(gamepad) {
      this.gamepads[gamepad.index] = gamepad;
    }
  }, {
    key: "removeGamepad",
    value: function removeGamepad(gamepad) {
      delete this.gamepads[gamepad.index];
    }
  }, {
    key: "updateGamepadWithIndex",
    value: function updateGamepadWithIndex(index, gamepad) {
      this.gamepads[index] = gamepad;
    }
  }, {
    key: "hasGamepadWithIndex",
    value: function hasGamepadWithIndex(index) {
      return !!(index in this.gamepads);
    }
  }, {
    key: "updateGamepads",
    value: function updateGamepads() {
      var _this2 = this;

      getConnectedGamepads().filter(isValidGamepad).forEach(function (gamepad) {
        if (!_this2.hasGamepadWithIndex(gamepad.index)) {
          _this2.addGamepad(gamepad);
        } else {
          _this2.updateGamepadWithIndex(gamepad.index, gamepad);
        }
      });
    }
  }, {
    key: "update",
    value: function update() {
      if (this.enabled) {
        var previous = _objectSpread2$1({}, this.gamepads);

        this.updateGamepads();
        this.evaluateGamepads(previous);
      }
    }
  }]);

  return Gamepad;
}(EventDispatcher);var _INPUT_EVENTS;
var INPUT_EVENTS = (_INPUT_EVENTS = {
  KEY_PRESS: KEY_PRESS,
  KEY_DOWN: KEY_DOWN,
  KEY_UP: KEY_UP,
  MOUSE_DOWN: MOUSE_DOWN,
  MOUSE_UP: MOUSE_UP
}, _defineProperty$1(_INPUT_EVENTS, "MOUSE_DOWN", MOUSE_DOWN), _defineProperty$1(_INPUT_EVENTS, "MOUSE_MOVE", MOUSE_MOVE), _defineProperty$1(_INPUT_EVENTS, "ELEMENT_CLICK", ELEMENT_CLICK), _defineProperty$1(_INPUT_EVENTS, "ELEMENT_DESELECT", ELEMENT_DESELECT), _defineProperty$1(_INPUT_EVENTS, "GAMEPAD_CONNECTED_EVENT", GAMEPAD_CONNECTED_EVENT), _defineProperty$1(_INPUT_EVENTS, "GAMEPAD_DISCONNECTED_EVENT", GAMEPAD_DISCONNECTED_EVENT), _defineProperty$1(_INPUT_EVENTS, "BUTTON_PRESSED_EVENT", BUTTON_PRESSED_EVENT), _defineProperty$1(_INPUT_EVENTS, "BUTTON_RELEASED_EVENT", BUTTON_RELEASED_EVENT), _defineProperty$1(_INPUT_EVENTS, "AXIS_CHANGE_EVENT", AXIS_CHANGE_EVENT), _INPUT_EVENTS);
var Input = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Input, _EventDispatcher);

  var _super = _createSuper(Input);

  function Input() {
    var _this;

    _classCallCheck(this, Input);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "propagate", function (event) {
      _this.dispatchEvent(event);
    });

    _this.enabled = false;
    return _this;
  }

  _createClass(Input, [{
    key: "enable",
    value: function enable() {
      if (!this.enabled) {
        dispatch$8(inputEnabled());
        this.mouse = new Mouse();
        this.keyboard = new Keyboard();
        this.gamepad = new Gamepad();
        this.enableGamepad();
        this.enableKeyboard();
        this.enableMouse();
        this.enabled = true;
      }
    }
  }, {
    key: "disable",
    value: function disable() {
      if (this.enabled) {
        dispatch$8(inputDisabled());
        this.disableKeyboard();
        this.disableMouse();
        this.disableGamepad();
        this.enabled = false;
      }
    }
  }, {
    key: "isEnabled",
    value: function isEnabled() {
      return this.enabled;
    }
  }, {
    key: "enableGamepad",
    value: function enableGamepad() {
      dispatch$8(gamepadEnabled());
      this.gamepad.enable();
      this.gamepad.addEventListener(GAMEPAD_CONNECTED_EVENT, this.propagate.bind(this));
      this.gamepad.addEventListener(GAMEPAD_DISCONNECTED_EVENT, this.propagate.bind(this));
      this.gamepad.addEventListener(BUTTON_RELEASED_EVENT, this.propagate.bind(this));
      this.gamepad.addEventListener(BUTTON_PRESSED_EVENT, this.propagate.bind(this));
      this.gamepad.addEventListener(BUTTON_RELEASED_EVENT, this.propagate.bind(this));
      this.gamepad.addEventListener(AXIS_CHANGE_EVENT, this.propagate.bind(this));
    }
  }, {
    key: "enableKeyboard",
    value: function enableKeyboard() {
      dispatch$8(keyboardEnabled());
      this.keyboard.enable();
      this.keyboard.addEventListener(KEY_DOWN, this.propagate.bind(this));
      this.keyboard.addEventListener(KEY_UP, this.propagate.bind(this));
    }
  }, {
    key: "enableMouse",
    value: function enableMouse() {
      dispatch$8(mouseEnabled());
      this.mouse.enable();
      this.mouse.addEventListener(MOUSE_DOWN, this.propagate.bind(this));
      this.mouse.addEventListener(MOUSE_UP, this.propagate.bind(this));
      this.mouse.addEventListener(MOUSE_MOVE, this.propagate.bind(this));
      this.mouse.addEventListener(ELEMENT_CLICK, this.propagate.bind(this));
      this.mouse.addEventListener(ELEMENT_DESELECT, this.propagate.bind(this));
    }
  }, {
    key: "disableKeyboard",
    value: function disableKeyboard() {
      dispatch$8(keyboardDisabled());
      this.keyboard.disable();
      this.keyboard.removeEventListener(KEY_DOWN, this.propagate.bind(this));
      this.keyboard.removeEventListener(KEY_UP, this.propagate.bind(this));
      this.keyboard = undefined;
    }
  }, {
    key: "disableMouse",
    value: function disableMouse() {
      dispatch$8(mouseDisabled());
      this.mouse.disable();
      this.mouse.removeEventListener(MOUSE_DOWN, this.propagate.bind(this));
      this.mouse.removeEventListener(MOUSE_UP, this.propagate.bind(this));
      this.mouse.removeEventListener(MOUSE_MOVE, this.propagate.bind(this));
      this.mouse.removeEventListener(ELEMENT_CLICK, this.propagate.bind(this));
      this.mouse.removeEventListener(ELEMENT_DESELECT, this.propagate.bind(this));
      this.mouse = undefined;
    }
  }, {
    key: "disableGamepad",
    value: function disableGamepad() {
      dispatch$8(gamepadDisabled());
      this.gamepad.disable();
      this.gamepad.removeEventListener(GAMEPAD_CONNECTED_EVENT, this.propagate.bind(this));
      this.gamepad.removeEventListener(GAMEPAD_DISCONNECTED_EVENT, this.propagate.bind(this));
      this.gamepad.removeEventListener(BUTTON_PRESSED_EVENT, this.propagate.bind(this));
      this.gamepad.removeEventListener(BUTTON_RELEASED_EVENT, this.propagate.bind(this));
      this.gamepad.removeEventListener(AXIS_CHANGE_EVENT, this.propagate.bind(this));
      this.gamepad = null;
    }
  }, {
    key: "update",
    value: function update() {
      if (this.isEnabled() && this.gamepad.isEnabled()) {
        this.gamepad.update();
      }
    }
  }, {
    key: "EVENTS",
    get: function get() {
      return INPUT_EVENTS;
    }
  }]);

  return Input;
}(EventDispatcher);
var Input$1 = new Input();var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob:
    'FileReader' in self &&
    'Blob' in self &&
    (function() {
      try {
        new Blob();
        return true
      } catch (e) {
        return false
      }
    })(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj)
}

if (support.arrayBuffer) {
  var viewClasses = [
    '[object Int8Array]',
    '[object Uint8Array]',
    '[object Uint8ClampedArray]',
    '[object Int16Array]',
    '[object Uint16Array]',
    '[object Int32Array]',
    '[object Uint32Array]',
    '[object Float32Array]',
    '[object Float64Array]'
  ];

  var isArrayBufferView =
    ArrayBuffer.isView ||
    function(obj) {
      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
    };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name')
  }
  return name.toLowerCase()
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }
  return value
}

// Build a destructive iterator for the value list
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return {done: value === undefined, value: value}
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator
    };
  }

  return iterator
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function(name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null
};

Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name))
};

Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items)
};

Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items)
};

Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items)
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'))
  }
  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  })
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }
  return chars.join('')
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0)
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function(body) {
    this._bodyInit = body;
    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      // IE 10-11 can't handle a DataView body.
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob)
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]))
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob')
      } else {
        return Promise.resolve(new Blob([this._bodyText]))
      }
    };

    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
      } else {
        return this.blob().then(readBlobAsArrayBuffer)
      }
    };
  }

  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob)
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text')
    } else {
      return Promise.resolve(this._bodyText)
    }
  };

  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode)
    };
  }

  this.json = function() {
    return this.text().then(JSON.parse)
  };

  return this
}

// HTTP methods whose capitalization should be normalized
var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read')
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests')
  }
  this._initBody(body);
}

Request.prototype.clone = function() {
  return new Request(this, {body: this._bodyInit})
};

function decode(body) {
  var form = new FormData();
  body
    .trim()
    .split('&')
    .forEach(function(bytes) {
      if (bytes) {
        var split = bytes.split('=');
        var name = split.shift().replace(/\+/g, ' ');
        var value = split.join('=').replace(/\+/g, ' ');
        form.append(decodeURIComponent(name), decodeURIComponent(value));
      }
    });
  return form
}

function parseHeaders(rawHeaders) {
  var headers = new Headers();
  // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function(line) {
    var parts = line.split(':');
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers
}

Body.call(Request.prototype);

function Response(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';
  this._initBody(bodyInit);
}

Body.call(Response.prototype);

Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  })
};

Response.error = function() {
  var response = new Response(null, {status: 0, statusText: ''});
  response.type = 'error';
  return response
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code')
  }

  return new Response(null, {status: status, headers: {location: url}})
};

var DOMException = self.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch$1(input, init) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'))
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function() {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response(body, options));
    };

    xhr.onerror = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function() {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function() {
      reject(new DOMException('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function(value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function() {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  })
}

fetch$1.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch$1;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
}var _excluded$7 = ["wheels", "accelerationKey", "brakingKey", "rightKey", "leftKey", "debug"];

var BaseCar = /*#__PURE__*/function (_BaseScript) {
  _inherits(BaseCar, _BaseScript);

  var _super = _createSuper(BaseCar);

  function BaseCar() {
    _classCallCheck(this, BaseCar);

    return _super.call(this, 'BaseCar');
  }

  _createClass(BaseCar, [{
    key: "start",
    value: function start(element, options) {
      var wheels = options.wheels,
          _options$acceleration = options.accelerationKey,
          accelerationKey = _options$acceleration === void 0 ? 'w' : _options$acceleration,
          _options$brakingKey = options.brakingKey,
          brakingKey = _options$brakingKey === void 0 ? 's' : _options$brakingKey,
          _options$rightKey = options.rightKey,
          rightKey = _options$rightKey === void 0 ? 'd' : _options$rightKey,
          _options$leftKey = options.leftKey,
          leftKey = _options$leftKey === void 0 ? 'a' : _options$leftKey;
          options.debug;
          var physicsOptions = _objectWithoutProperties(options, _excluded$7);

      this.car = element;
      this.wheels = wheels;
      this.state = {
        acceleration: false,
        braking: false,
        right: false,
        left: false
      };
      this.accelerationKey = accelerationKey;
      this.brakingKey = brakingKey;
      this.rightKey = rightKey;
      this.leftKey = leftKey;
      Input$1.enable();
      Physics$1.addVehicle(this.car, _objectSpread2$1({
        wheels: wheels.map(function (w) {
          return w.uuid();
        })
      }, physicsOptions));
    }
  }, {
    key: "handleInput",
    value: function handleInput() {
      this.state.acceleration = Input$1.keyboard.isPressed(this.accelerationKey);
      this.state.braking = Input$1.keyboard.isPressed(this.brakingKey);
      this.state.right = Input$1.keyboard.isPressed(this.rightKey);
      this.state.left = Input$1.keyboard.isPressed(this.leftKey);
    }
  }, {
    key: "sendCarUpdate",
    value: function sendCarUpdate() {
      Physics$1.updateBodyState(this.car, this.state);
    }
  }, {
    key: "update",
    value: function update(dt) {
      this.handleInput();
      this.sendCarUpdate();
    }
  }]);

  return BaseCar;
}(BaseScript);var DEFAULT_DISTANCE$1 = 5.0;
var DEFAULT_HEIGHT = 3.0;
var DEFAULT_HEIGHT_DAMPING = 2.0;
var DEFAULT_LOOK_AT_HEIGHT = 1;
var DEFAULT_ROTATION_SNAP_TIME = 0.3;
var DEFAULT_DISTANCE_SNAP_TIME = 0.5;
var DEFAULT_DISTANCE_MULTIPLIER = 1;

var SmoothCarFollow = /*#__PURE__*/function (_BaseScript) {
  _inherits(SmoothCarFollow, _BaseScript);

  var _super = _createSuper(SmoothCarFollow);

  function SmoothCarFollow() {
    _classCallCheck(this, SmoothCarFollow);

    return _super.call(this, 'SmoothCarFollow');
  }

  _createClass(SmoothCarFollow, [{
    key: "start",
    value: function start(camera, options) {
      var target = options.target,
          _options$height = options.height,
          height = _options$height === void 0 ? DEFAULT_HEIGHT : _options$height,
          _options$heightDampin = options.heightDamping,
          heightDamping = _options$heightDampin === void 0 ? DEFAULT_HEIGHT_DAMPING : _options$heightDampin,
          _options$lookAtHeight = options.lookAtHeight,
          lookAtHeight = _options$lookAtHeight === void 0 ? DEFAULT_LOOK_AT_HEIGHT : _options$lookAtHeight,
          _options$distance = options.distance,
          distance = _options$distance === void 0 ? DEFAULT_DISTANCE$1 : _options$distance,
          _options$rotationSnap = options.rotationSnapTime,
          rotationSnapTime = _options$rotationSnap === void 0 ? DEFAULT_ROTATION_SNAP_TIME : _options$rotationSnap,
          _options$distanceSnap = options.distanceSnapTime,
          distanceSnapTime = _options$distanceSnap === void 0 ? DEFAULT_DISTANCE_SNAP_TIME : _options$distanceSnap,
          _options$distanceMult = options.distanceMultiplier,
          distanceMultiplier = _options$distanceMult === void 0 ? DEFAULT_DISTANCE_MULTIPLIER : _options$distanceMult;
      this.camera = camera;
      this.target = target;
      this.height = height;
      this.heightDamping = heightDamping;
      this.distance = distance;
      this.rotationSnapTime = rotationSnapTime;
      this.distanceSnapTime = distanceSnapTime;
      this.distanceMultiplier = distanceMultiplier;
      this.lookAtVector = new Vector3$1(0, lookAtHeight, 0);
    }
  }, {
    key: "followCar",
    value: function followCar(dt) {
      var direction = this.target.getPhysicsState('direction');

      if (direction) {
        var x = direction.x,
            y = direction.y,
            z = direction.z;
        var cameraPosition = this.camera.getPosition();
        var targetPosition = this.target.getPosition();
        var vector = new Vector3$1(x, y, z).negate().normalize().multiplyScalar(this.distance);
        vector.y = y + this.height;
        var desiredPosition = targetPosition.add(vector); // const lerpFactor = 1 - Math.pow(0.1, dt);

        cameraPosition.lerpVectors(cameraPosition, desiredPosition, dt);
        this.camera.setPosition(cameraPosition);
        var lookAtTarget = new Vector3$1();
        lookAtTarget.copy(this.target.getPosition().add(this.lookAtVector));
        this.camera.lookAt(lookAtTarget);
      }
    }
  }, {
    key: "update",
    value: function update(dt) {
      this.followCar(dt);
    }
  }]);

  return SmoothCarFollow;
}(BaseScript);var BUILTIN = {
  BASECAR: 'BaseCar',
  TRAILS: 'Trails',
  SMOOTH_CAR_FOLLOW: 'SmoothCarFollow'
};
var Scripts = /*#__PURE__*/function () {
  function Scripts() {
    var _this = this,
        _this$map;

    _classCallCheck(this, Scripts);

    _defineProperty$1(this, "load", function (scripts, level) {
      _this.scripts = scripts;
      var keys = Object.keys(scripts);

      if (!keys.length) {
        return Promise.resolve('scripts');
      }

      return Promise.all(keys.map(function (name) {
        return _this.loadSingleScript(name, level);
      }));
    });

    _defineProperty$1(this, "loadSingleScript", function (name, level) {
      var path = _this.scripts[name];
      return new Promise(function (resolve) {
        fetch$1(path).then(function (response) {
          return response.text();
        }).then(function (text) {
          _this.createFromString(text);

          resolve();
        });
      });
    });

    this.map = (_this$map = {}, _defineProperty$1(_this$map, BUILTIN.BASECAR, BaseCar), _defineProperty$1(_this$map, BUILTIN.SMOOTH_CAR_FOLLOW, SmoothCarFollow), _this$map);
  }

  _createClass(Scripts, [{
    key: "update",
    value: function update() {}
  }, {
    key: "set",
    value: function set(id, ScriptClass) {
      this.map[id] = ScriptClass;
    }
  }, {
    key: "get",
    value: function get(name) {
      var ScriptClass = this.map[name];

      if (ScriptClass) {
        return new ScriptClass(name);
      }

      return false;
    }
  }, {
    key: "parseScript",
    value: function parseScript(content) {
      // does this mean we can send whatever we want down to the script?
      return new Function('Script', 'Input', 'return ' + content + ';')(BaseScript, Input$1);
    }
  }, {
    key: "createFromString",
    value: function createFromString(stringContent) {
      var Script = this.parseScript(stringContent);
      var s = new Script();
      this.set(s.name(), s);
      return s;
    }
  }, {
    key: "create",
    value: function create(name, ScriptClass) {
      console.warn(DEPRECATIONS.SCRIPTS_CREATE);
      this.register(name, ScriptClass);
    }
  }, {
    key: "register",
    value: function register(name, ScriptClass) {
      if (ScriptClass) {
        var script = new ScriptClass();

        if (script.__check && script.__check()) {
          this.set(name, ScriptClass);
        } else {
          console.error('[Mage] Script:', name, 'needs to be an instance of Script.');
        }
      } else {
        console.error('[Mage] Script not provided.');
      }
    }
  }, {
    key: "BUILTIN",
    get: function get() {
      return BUILTIN;
    }
  }]);

  return Scripts;
}();
var Scripts$1 = new Scripts();var inverseProjectionMatrix = new Matrix4();

var Frustum = /*#__PURE__*/function () {
  function Frustum(data) {
    _classCallCheck(this, Frustum);

    data = data || {};
    this.vertices = {
      near: [new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1()],
      far: [new Vector3$1(), new Vector3$1(), new Vector3$1(), new Vector3$1()]
    };

    if (data.projectionMatrix !== undefined) {
      this.setFromProjectionMatrix(data.projectionMatrix, data.maxFar || 10000);
    }
  }

  _createClass(Frustum, [{
    key: "setFromProjectionMatrix",
    value: function setFromProjectionMatrix(projectionMatrix, maxFar) {
      var isOrthographic = projectionMatrix.elements[2 * 4 + 3] === 0;
      inverseProjectionMatrix.copy(projectionMatrix).invert(); // 3 --- 0  vertices.near/far order
      // |     |
      // 2 --- 1
      // clip space spans from [-1, 1]

      this.vertices.near[0].set(1, 1, -1);
      this.vertices.near[1].set(1, -1, -1);
      this.vertices.near[2].set(-1, -1, -1);
      this.vertices.near[3].set(-1, 1, -1);
      this.vertices.near.forEach(function (v) {
        v.applyMatrix4(inverseProjectionMatrix);
      });
      this.vertices.far[0].set(1, 1, 1);
      this.vertices.far[1].set(1, -1, 1);
      this.vertices.far[2].set(-1, -1, 1);
      this.vertices.far[3].set(-1, 1, 1);
      this.vertices.far.forEach(function (v) {
        v.applyMatrix4(inverseProjectionMatrix);
        var absZ = Math.abs(v.z);

        if (isOrthographic) {
          v.z *= Math.min(maxFar / absZ, 1.0);
        } else {
          v.multiplyScalar(Math.min(maxFar / absZ, 1.0));
        }
      });
      return this.vertices;
    }
  }, {
    key: "split",
    value: function split(breaks, target) {
      while (breaks.length > target.length) {
        target.push(new Frustum());
      }

      target.length = breaks.length;

      for (var i = 0; i < breaks.length; i++) {
        var cascade = target[i];

        if (i === 0) {
          for (var j = 0; j < 4; j++) {
            cascade.vertices.near[j].copy(this.vertices.near[j]);
          }
        } else {
          for (var _j = 0; _j < 4; _j++) {
            cascade.vertices.near[_j].lerpVectors(this.vertices.near[_j], this.vertices.far[_j], breaks[i - 1]);
          }
        }

        if (i === breaks - 1) {
          for (var _j2 = 0; _j2 < 4; _j2++) {
            cascade.vertices.far[_j2].copy(this.vertices.far[_j2]);
          }
        } else {
          for (var _j3 = 0; _j3 < 4; _j3++) {
            cascade.vertices.far[_j3].lerpVectors(this.vertices.near[_j3], this.vertices.far[_j3], breaks[i]);
          }
        }
      }
    }
  }, {
    key: "toSpace",
    value: function toSpace(cameraMatrix, target) {
      for (var i = 0; i < 4; i++) {
        target.vertices.near[i].copy(this.vertices.near[i]).applyMatrix4(cameraMatrix);
        target.vertices.far[i].copy(this.vertices.far[i]).applyMatrix4(cameraMatrix);
      }
    }
  }]);

  return Frustum;
}();var Shader$1 = {
  lights_fragment_begin:
  /* glsl */
  "\nGeometricContext geometry;\n\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef CLEARCOAT\n\n    geometry.clearcoatNormal = clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n        pointLight = pointLights[ i ];\n\n        getPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n        pointLightShadow = pointLightShadows[ i ];\n        directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n        #endif\n\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n        spotLight = spotLights[ i ];\n\n        getSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n        spotLightShadow = spotLightShadows[ i ];\n        directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n        #endif\n\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS > 0) && defined( RE_Direct ) && defined( USE_CSM ) && defined( CSM_CASCADES )\n\n    DirectionalLight directionalLight;\n    float linearDepth = (vViewPosition.z) / (shadowFar - cameraNear);\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #if defined( USE_SHADOWMAP ) && defined( CSM_FADE )\n    vec2 cascade;\n    float cascadeCenter;\n    float closestEdge;\n    float margin;\n    float csmx;\n    float csmy;\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n        directionalLight = directionalLights[ i ];\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n        // NOTE: Depth gets larger away from the camera.\n        // cascade.x is closer, cascade.y is further\n        cascade = CSM_cascades[ i ];\n        cascadeCenter = ( cascade.x + cascade.y ) / 2.0;\n        closestEdge = linearDepth < cascadeCenter ? cascade.x : cascade.y;\n        margin = 0.25 * pow( closestEdge, 2.0 );\n        csmx = cascade.x - margin / 2.0;\n        csmy = cascade.y + margin / 2.0;\n        if( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS && linearDepth >= csmx && ( linearDepth < csmy || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 ) ) {\n\n            float dist = min( linearDepth - csmx, csmy - linearDepth );\n            float ratio = clamp( dist / margin, 0.0, 1.0 );\n            if( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS ) {\n\n                vec3 prevColor = directLight.color;\n                directionalLightShadow = directionalLightShadows[ i ];\n                directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n                bool shouldFadeLastCascade = UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth > cascadeCenter;\n                directLight.color = mix( prevColor, directLight.color, shouldFadeLastCascade ? ratio : 1.0 );\n\n            }\n\n            ReflectedLight prevLight = reflectedLight;\n            RE_Direct( directLight, geometry, material, reflectedLight );\n\n            bool shouldBlend = UNROLLED_LOOP_INDEX != CSM_CASCADES - 1 || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1 && linearDepth < cascadeCenter;\n            float blendRatio = shouldBlend ? ratio : 1.0;\n\n            reflectedLight.directDiffuse = mix( prevLight.directDiffuse, reflectedLight.directDiffuse, blendRatio );\n            reflectedLight.directSpecular = mix( prevLight.directSpecular, reflectedLight.directSpecular, blendRatio );\n            reflectedLight.indirectDiffuse = mix( prevLight.indirectDiffuse, reflectedLight.indirectDiffuse, blendRatio );\n            reflectedLight.indirectSpecular = mix( prevLight.indirectSpecular, reflectedLight.indirectSpecular, blendRatio );\n\n        }\n\n    }\n    #pragma unroll_loop_end\n    #else\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n        directionalLight = directionalLights[ i ];\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\n        directionalLightShadow = directionalLightShadows[ i ];\n        if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y) directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\n        #endif\n\n        if(linearDepth >= CSM_cascades[UNROLLED_LOOP_INDEX].x && (linearDepth < CSM_cascades[UNROLLED_LOOP_INDEX].y || UNROLLED_LOOP_INDEX == CSM_CASCADES - 1)) RE_Direct( directLight, geometry, material, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n    #endif\n\n#endif\n\n\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct ) && !defined( USE_CSM ) && !defined( CSM_CASCADES )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n        directionalLight = directionalLights[ i ];\n\n        getDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n        directionalLightShadow = directionalLightShadows[ i ];\n        directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n        #endif\n\n        RE_Direct( directLight, geometry, material, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n    RectAreaLight rectAreaLight;\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n        rectAreaLight = rectAreaLights[ i ];\n        RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n    }\n    #pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    irradiance += getLightProbeIrradiance( lightProbe, geometry );\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n        #pragma unroll_loop_start\n        for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n            irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n        }\n        #pragma unroll_loop_end\n\n    #endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n    vec3 radiance = vec3( 0.0 );\n    vec3 clearcoatRadiance = vec3( 0.0 );\n\n#endif\n",
  lights_pars_begin:
  /* glsl */
  "\n#if defined( USE_CSM ) && defined( CSM_CASCADES )\nuniform vec2 CSM_cascades[CSM_CASCADES];\nuniform float cameraNear;\nuniform float shadowFar;\n#endif\n    " + ShaderChunk.lights_pars_begin
};var _cameraToLightMatrix = new Matrix4();

var _lightSpaceFrustum = new Frustum();

var _center = new Vector3$1();

var _bbox = new Box3();

var _uniformArray = [];
var _logArray = [];
var DEFAULT_MAX_FAR = 100000;
var DEFAULT_MODE = 'practical';
var DEFAULT_SHADOWMAP_SIZE = 2048;
var DEFAULT_CASCADE = 3;
var DEFAULT_BIAS$3 = 0.000001;
var DEFAULT_INTENSITY$5 = 1;
var DEFAULT_NEAR$3 = 1;
var DEFAULT_FAR$3 = 2000;
var DEFAULT_MARGIN = 200;
var CascadeShadowMaps = /*#__PURE__*/function () {
  function CascadeShadowMaps(_ref) {
    var _ref$camera = _ref.camera,
        camera = _ref$camera === void 0 ? Scene$1.getCameraBody() : _ref$camera,
        _ref$parent = _ref.parent,
        parent = _ref$parent === void 0 ? Scene$1.getScene() : _ref$parent,
        _ref$cascades = _ref.cascades,
        cascades = _ref$cascades === void 0 ? DEFAULT_CASCADE : _ref$cascades,
        _ref$maxFar = _ref.maxFar,
        maxFar = _ref$maxFar === void 0 ? DEFAULT_MAX_FAR : _ref$maxFar,
        _ref$mode = _ref.mode,
        mode = _ref$mode === void 0 ? DEFAULT_MODE : _ref$mode,
        _ref$shadowMapSize = _ref.shadowMapSize,
        shadowMapSize = _ref$shadowMapSize === void 0 ? DEFAULT_SHADOWMAP_SIZE : _ref$shadowMapSize,
        _ref$shadowBias = _ref.shadowBias,
        shadowBias = _ref$shadowBias === void 0 ? DEFAULT_BIAS$3 : _ref$shadowBias,
        _ref$lightDirection = _ref.lightDirection,
        lightDirection = _ref$lightDirection === void 0 ? new Vector3$1(1, -1, 1).normalize() : _ref$lightDirection,
        _ref$lightIntensity = _ref.lightIntensity,
        lightIntensity = _ref$lightIntensity === void 0 ? DEFAULT_INTENSITY$5 : _ref$lightIntensity,
        _ref$lightNear = _ref.lightNear,
        lightNear = _ref$lightNear === void 0 ? DEFAULT_NEAR$3 : _ref$lightNear,
        _ref$lightFar = _ref.lightFar,
        lightFar = _ref$lightFar === void 0 ? DEFAULT_FAR$3 : _ref$lightFar,
        _ref$lightMargin = _ref.lightMargin,
        lightMargin = _ref$lightMargin === void 0 ? DEFAULT_MARGIN : _ref$lightMargin,
        customSplitsCallback = _ref.customSplitsCallback;

    _classCallCheck(this, CascadeShadowMaps);

    this.camera = camera;
    this.parent = parent;
    this.cascades = cascades;
    this.maxFar = maxFar;
    this.mode = mode;
    this.shadowMapSize = shadowMapSize;
    this.shadowBias = shadowBias;
    this.lightDirection = lightDirection;
    this.lightIntensity = lightIntensity;
    this.lightNear = lightNear;
    this.lightFar = lightFar;
    this.lightMargin = lightMargin;
    this.customSplitsCallback = customSplitsCallback;
    this.fade = false;
    this.mainFrustum = new Frustum();
    this.frustums = [];
    this.breaks = [];
    this.lights = [];
    this.shaders = new Map();
    this.createLights();
    this.updateFrustums();
    this.injectInclude();
  }

  _createClass(CascadeShadowMaps, [{
    key: "createLights",
    value: function createLights() {
      for (var i = 0; i < this.cascades; i++) {
        var light = new DirectionalLight(0xffffff, this.lightIntensity);
        light.castShadow = true;
        light.shadow.mapSize.width = this.shadowMapSize;
        light.shadow.mapSize.height = this.shadowMapSize;
        light.shadow.camera.near = this.lightNear;
        light.shadow.camera.far = this.lightFar;
        light.shadow.bias = this.shadowBias;
        this.parent.add(light);
        this.parent.add(light.target);
        this.lights.push(light);
      }
    }
  }, {
    key: "initCascades",
    value: function initCascades() {
      var camera = this.camera;
      camera.updateProjectionMatrix();
      this.mainFrustum.setFromProjectionMatrix(camera.projectionMatrix, this.maxFar);
      this.mainFrustum.split(this.breaks, this.frustums);
    }
  }, {
    key: "updateShadowBounds",
    value: function updateShadowBounds() {
      var frustums = this.frustums;

      for (var i = 0; i < frustums.length; i++) {
        var light = this.lights[i];
        var shadowCam = light.shadow.camera;
        var frustum = this.frustums[i]; // Get the two points that represent that furthest points on the frustum assuming
        // that's either the diagonal across the far plane or the diagonal across the whole
        // frustum itself.

        var nearVerts = frustum.vertices.near;
        var farVerts = frustum.vertices.far;
        var point1 = farVerts[0];
        var point2 = void 0;

        if (point1.distanceTo(farVerts[2]) > point1.distanceTo(nearVerts[2])) {
          point2 = farVerts[2];
        } else {
          point2 = nearVerts[2];
        }

        var squaredBBWidth = point1.distanceTo(point2);

        if (this.fade) {
          // expand the shadow extents by the fade margin if fade is enabled.
          var camera = this.camera;
          var far = Math.max(camera.far, this.maxFar);
          var linearDepth = frustum.vertices.far[0].z / (far - camera.near);
          var margin = 0.25 * Math.pow(linearDepth, 2.0) * (far - camera.near);
          squaredBBWidth += margin;
        }

        shadowCam.left = -squaredBBWidth / 2;
        shadowCam.right = squaredBBWidth / 2;
        shadowCam.top = squaredBBWidth / 2;
        shadowCam.bottom = -squaredBBWidth / 2;
        shadowCam.updateProjectionMatrix();
      }
    }
  }, {
    key: "getBreaks",
    value: function getBreaks() {
      var camera = this.camera;
      var far = Math.min(camera.far, this.maxFar);
      this.breaks.length = 0;

      switch (this.mode) {
        case 'uniform':
          uniformSplit(this.cascades, camera.near, far, this.breaks);
          break;

        case 'logarithmic':
          logarithmicSplit(this.cascades, camera.near, far, this.breaks);
          break;

        case 'practical':
          practicalSplit(this.cascades, camera.near, far, 0.5, this.breaks);
          break;

        case 'custom':
          if (this.customSplitsCallback === undefined) console.error('CSM: Custom split scheme callback not defined.');
          this.customSplitsCallback(this.cascades, camera.near, far, this.breaks);
          break;
      }

      function uniformSplit(amount, near, far, target) {
        for (var i = 1; i < amount; i++) {
          target.push((near + (far - near) * i / amount) / far);
        }

        target.push(1);
      }

      function logarithmicSplit(amount, near, far, target) {
        for (var i = 1; i < amount; i++) {
          target.push(near * Math.pow(far / near, i / amount) / far);
        }

        target.push(1);
      }

      function practicalSplit(amount, near, far, lambda, target) {
        _uniformArray.length = 0;
        _logArray.length = 0;
        logarithmicSplit(amount, near, far, _logArray);
        uniformSplit(amount, near, far, _uniformArray);

        for (var i = 1; i < amount; i++) {
          target.push(MathUtils.lerp(_uniformArray[i - 1], _logArray[i - 1], lambda));
        }

        target.push(1);
      }
    }
  }, {
    key: "update",
    value: function update() {
      var camera = this.camera;
      var frustums = this.frustums;

      for (var i = 0; i < frustums.length; i++) {
        var light = this.lights[i];
        var shadowCam = light.shadow.camera;
        var texelWidth = (shadowCam.right - shadowCam.left) / this.shadowMapSize;
        var texelHeight = (shadowCam.top - shadowCam.bottom) / this.shadowMapSize;
        light.shadow.camera.updateMatrixWorld(true);

        _cameraToLightMatrix.multiplyMatrices(light.shadow.camera.matrixWorldInverse, camera.matrixWorld);

        frustums[i].toSpace(_cameraToLightMatrix, _lightSpaceFrustum);
        var nearVerts = _lightSpaceFrustum.vertices.near;
        var farVerts = _lightSpaceFrustum.vertices.far;

        _bbox.makeEmpty();

        for (var j = 0; j < 4; j++) {
          _bbox.expandByPoint(nearVerts[j]);

          _bbox.expandByPoint(farVerts[j]);
        }

        _bbox.getCenter(_center);

        _center.z = _bbox.max.z + this.lightMargin;
        _center.x = Math.floor(_center.x / texelWidth) * texelWidth;
        _center.y = Math.floor(_center.y / texelHeight) * texelHeight;

        _center.applyMatrix4(light.shadow.camera.matrixWorld);

        light.position.copy(_center);
        light.target.position.copy(_center);
        light.target.position.x += this.lightDirection.x;
        light.target.position.y += this.lightDirection.y;
        light.target.position.z += this.lightDirection.z;
      }
    }
  }, {
    key: "injectInclude",
    value: function injectInclude() {
      ShaderChunk.lights_fragment_begin = Shader$1.lights_fragment_begin;
      ShaderChunk.lights_pars_begin = Shader$1.lights_pars_begin;
    }
  }, {
    key: "setupMaterial",
    value: function setupMaterial(material) {
      material.defines = material.defines || {};
      material.defines.USE_CSM = 1;
      material.defines.CSM_CASCADES = this.cascades;

      if (this.fade) {
        material.defines.CSM_FADE = '';
      }

      var breaksVec2 = [];
      var scope = this;
      var shaders = this.shaders;

      material.onBeforeCompile = function (shader) {
        var far = Math.min(scope.camera.far, scope.maxFar);
        scope.getExtendedBreaks(breaksVec2);
        shader.uniforms.CSM_cascades = {
          value: breaksVec2
        };
        shader.uniforms.cameraNear = {
          value: scope.camera.near
        };
        shader.uniforms.shadowFar = {
          value: far
        };
        shaders.set(material, shader);
      };

      shaders.set(material, null);
    }
  }, {
    key: "updateUniforms",
    value: function updateUniforms() {
      var far = Math.min(this.camera.far, this.maxFar);
      var shaders = this.shaders;
      shaders.forEach(function (shader, material) {
        if (shader !== null) {
          var uniforms = shader.uniforms;
          this.getExtendedBreaks(uniforms.CSM_cascades.value);
          uniforms.cameraNear.value = this.camera.near;
          uniforms.shadowFar.value = far;
        }

        if (!this.fade && 'CSM_FADE' in material.defines) {
          delete material.defines.CSM_FADE;
          material.needsUpdate = true;
        } else if (this.fade && !('CSM_FADE' in material.defines)) {
          material.defines.CSM_FADE = '';
          material.needsUpdate = true;
        }
      }, this);
    }
  }, {
    key: "getExtendedBreaks",
    value: function getExtendedBreaks(target) {
      while (target.length < this.breaks.length) {
        target.push(new Vector2());
      }

      target.length = this.breaks.length;

      for (var i = 0; i < this.cascades; i++) {
        var amount = this.breaks[i];
        var prev = this.breaks[i - 1] || 0;
        target[i].x = prev;
        target[i].y = amount;
      }
    }
  }, {
    key: "updateFrustums",
    value: function updateFrustums() {
      this.getBreaks();
      this.initCascades();
      this.updateShadowBounds();
      this.updateUniforms();
    }
  }, {
    key: "remove",
    value: function remove() {
      for (var i = 0; i < this.lights.length; i++) {
        this.parent.remove(this.lights[i]);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var shaders = this.shaders;
      shaders.forEach(function (shader, material) {
        delete material.onBeforeCompile;
        delete material.defines.USE_CSM;
        delete material.defines.CSM_CASCADES;
        delete material.defines.CSM_FADE;

        if (shader !== null) {
          delete shader.uniforms.CSM_cascades;
          delete shader.uniforms.cameraNear;
          delete shader.uniforms.shadowFar;
        }

        material.needsUpdate = true;
      });
      shaders.clear();
    }
  }]);

  return CascadeShadowMaps;
}();var POINTLIGHT = 'pointlight';
var AMBIENTLIGHT = 'ambientlight';
var SUNLIGHT = 'sunlight';
var SPOTLIGHT = 'spotlight';
var HEMISPHERELIGHT = 'hemisphere';
var TIME_TO_UPDATE = 5;
var Lights = /*#__PURE__*/function () {
  function Lights() {
    _classCallCheck(this, Lights);

    this.delayFactor = 0.1;
    this.delayStep = 30;
    this.holderRadius = 0.01;
    this.holderSegments = 1;
    this.numLights = 0;
    this.map = {};
    this.lights = [];
    this.csm = undefined;
  }

  _createClass(Lights, [{
    key: "isUsingCSM",
    value: function isUsingCSM() {
      return !!this.csm;
    }
  }, {
    key: "setUpCSM",
    value: function setUpCSM() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.csm = new CascadeShadowMaps(options);
    }
  }, {
    key: "add",
    value: function add(light) {
      this.lights.push(light);
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (this.isUsingCSM()) {
        this.csm.update();
      }

      var start = new Date();

      for (var index in this.lights) {
        var light = this.lights[index];
        light.update(dt);
        if (+new Date() - start > TIME_TO_UPDATE) break;
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        lights: this.lights.map(function (l) {
          return l.toJSON();
        })
      };
    }
  }]);

  return Lights;
}();
var Lights$1 = new Lights();var ToonShader = {
  uniforms: {
    "uDirLightPos": {
      type: "v3",
      value: new Vector3$1()
    },
    "uDirLightColor": {
      type: "c",
      value: new Color$1(0xffffff)
    },
    "uMaterialColor": {
      type: "c",
      value: new Color$1(0xffffff)
    },
    uKd: {
      type: "f",
      value: 1
    },
    uBorder: {
      type: "f",
      value: 0.4
    }
  },
  vertexShader: ["varying vec3 vNormal;", "varying vec3 vViewPosition;", "void main() {", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "vNormal = normalize( normalMatrix * normal );", "vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", "vViewPosition = -mvPosition.xyz;", "}"].join("\n"),
  fragmentShader: ["uniform vec3 uMaterialColor;", "uniform vec3 uDirLightPos;", "uniform vec3 uDirLightColor;", "uniform float uKd;", "uniform float uBorder;", "varying vec3 vNormal;", "varying vec3 vViewPosition;", "void main() {", // compute direction to light
  "vec4 lDirection = viewMatrix * vec4( uDirLightPos, 0.0 );", "vec3 lVector = normalize( lDirection.xyz );", // diffuse: N * L. Normal must be normalized, since it's interpolated.
  "vec3 normal = normalize( vNormal );", //was: "float diffuse = max( dot( normal, lVector ), 0.0);",
  // solution
  "float diffuse = dot( normal, lVector );", "if ( diffuse > 0.6 ) { diffuse = 1.0; }", "else if ( diffuse > -0.2 ) { diffuse = 0.7; }", "else { diffuse = 0.3; }", "gl_FragColor = vec4( uKd * uMaterialColor * uDirLightColor * diffuse, 1.0 );", "}"].join("\n")
};

var ToonMaterial = /*#__PURE__*/function (_ShaderMaterial) {
  _inherits(ToonMaterial, _ShaderMaterial);

  var _super = _createSuper(ToonMaterial);

  function ToonMaterial(_ref) {
    var _this;

    var _ref$light = _ref.light,
        light = _ref$light === void 0 ? {} : _ref$light,
        color = _ref.color;

    _classCallCheck(this, ToonMaterial);

    var uniforms = UniformsUtils.clone(ToonShader.uniforms);
    var vertexShader = ToonShader.vertexShader,
        fragmentShader = ToonShader.fragmentShader;
    _this = _super.call(this, {
      uniforms: uniforms,
      vertexShader: vertexShader,
      fragmentShader: fragmentShader,
      flatShading: true
    });
    var position = light.position,
        lightColor = light.color;

    if (color) {
      var materialColor = new Color$1(color);

      _this.uniforms.uMaterialColor.value.copy(materialColor);
    }

    _this.uniforms.uDirLightPos.value = position;

    _this.uniforms.uDirLightColor.value.copy(new Color$1(lightColor));

    _this.side = DoubleSide;
    return _this;
  }

  return ToonMaterial;
}(ShaderMaterial);var setUpLightsAndShadows = function setUpLightsAndShadows(mesh) {
  var _Config$lights = Config$1.lights(),
      textureAnisotropy = _Config$lights.textureAnisotropy,
      shadows = _Config$lights.shadows;

  mesh.castShadow = Boolean(shadows);
  mesh.receiveShadow = Boolean(shadows);

  if (hasMaterial(mesh)) {
    var setUpMaterial = function setUpMaterial(material) {
      if (Lights$1.isUsingCSM()) {
        Lights$1.csm.setupMaterial(material);
      }

      if (material.map) {
        material.map.anisotropy = textureAnisotropy;
      }

      return material;
    };

    mesh.material = processMaterial(mesh.material, setUpMaterial);
  }
};
var isScene = function isScene(mesh) {
  return mesh.isScene;
};

var hasMaterial = function hasMaterial(mesh) {
  return Boolean(mesh.material);
};
var hasGeometry = function hasGeometry(mesh) {
  return Boolean(mesh.geometry);
};
var processMaterial = function processMaterial(material, callback) {
  return Array.isArray(material) ? material.map(callback) : callback(material);
};
var changeMaterialByName = function changeMaterialByName(name, mesh, materialOptions) {
  if (!hasMaterial(mesh)) return;

  switch (name) {
    case MATERIALS.LAMBERT:
      return cloneMaterial(MeshLambertMaterial, mesh, materialOptions);

    case MATERIALS.PHONG:
      return cloneMaterial(MeshPhongMaterial, mesh, materialOptions);

    case MATERIALS.DEPTH:
      return cloneMaterial(MeshDepthMaterial, mesh, materialOptions);

    case MATERIALS.STANDARD:
      return cloneMaterial(MeshStandardMaterial, mesh, materialOptions);

    case MATERIALS.TOON:
      return cloneMaterial(ToonMaterial, mesh, materialOptions);

    case MATERIALS.THREE_TOON:
      return cloneMaterial(MeshToonMaterial, mesh, materialOptions);

    case MATERIALS.BASIC:
    default:
      return cloneMaterial(MeshBasicMaterial, mesh, materialOptions);
  }
};

var cloneMaterial = function cloneMaterial(MeshMaterial, mesh) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  var _cloneMaterial = function _cloneMaterial(material) {
    var clone = material.clone();
    var newMaterial = new MeshMaterial(_objectSpread2$1({
      map: clone.map,
      color: clone.color
    }, options));
    newMaterial.skinning = true;
    return newMaterial;
  };

  mesh.material = processMaterial(mesh.material, _cloneMaterial);
  setUpLightsAndShadows(mesh);
};

var disposeTextures = function disposeTextures(mesh) {
  if (hasMaterial(mesh)) {
    var _disposeTexture = function _disposeTexture(material) {
      Object.values(TEXTURES).forEach(function (key) {
        if (material[key]) {
          material[key].dispose();
        }
      });
    };

    processMaterial(mesh.material, _disposeTexture);
  }
};
var disposeMaterial = function disposeMaterial(mesh) {
  if (hasMaterial(mesh)) {
    mesh.material.dispose && mesh.material.dispose();
  }
};
var disposeGeometry = function disposeGeometry(mesh) {
  if (hasGeometry(mesh)) {
    mesh.geometry.dispose && mesh.geometry.dispose();
  }
};
var prepareModel = function prepareModel(model) {
  setUpLightsAndShadows(model);
  model.traverse(function (mesh) {
    setUpLightsAndShadows(mesh);
  });
  return model;
};var Entity = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Entity, _EventDispatcher);

  var _super = _createSuper(Entity);

  function Entity() {
    var _this;

    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$serializable = _ref.serializable,
        serializable = _ref$serializable === void 0 ? true : _ref$serializable,
        _ref$tag = _ref.tag,
        tag = _ref$tag === void 0 ? '' : _ref$tag,
        _ref$tags = _ref.tags,
        tags = _ref$tags === void 0 ? [] : _ref$tags;

    _classCallCheck(this, Entity);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "getBodyByName", function (name) {
      if (name && _this.hasBody()) {
        return _this.getBody().getObjectByName(name);
      }

      console.warn(ELEMENT_NAME_NOT_PROVIDED);
    });

    _defineProperty$1(_assertThisInitialized(_this), "addTag", function (tagName) {
      if (!tagName) return;

      if (!_this.hasTag(tagName)) {
        _this.tags.push(tagName);

        return true;
      } else {
        console.log(TAG_ALREADY_EXISTS, tagName);
        return false;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "hasStateMachine", function () {
      return !!_this.stateMachine;
    });

    _defineProperty$1(_assertThisInitialized(_this), "hasScripts", function () {
      return _this.scripts.length > 0;
    });

    _defineProperty$1(_assertThisInitialized(_this), "parseScripts", function (list, options, enabled) {
      return list.map(function (script, i) {
        return {
          script: script,
          name: script.getName(),
          enabled: enabled,
          options: options[i]
        };
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "isMesh", function () {
      return _this.getEntityType() === ENTITY_TYPES.MESH;
    });

    _defineProperty$1(_assertThisInitialized(_this), "isModel", function () {
      return _this.getEntityType() === ENTITY_TYPES.MODEL;
    });

    _defineProperty$1(_assertThisInitialized(_this), "isSprite", function () {
      return _this.getEntityType() === ENTITY_TYPES.SPRITE;
    });

    _defineProperty$1(_assertThisInitialized(_this), "isLight", function () {
      return Object.values(ENTITY_TYPES.LIGHT).includes(_this.getEntityType());
    });

    _defineProperty$1(_assertThisInitialized(_this), "isHelper", function () {
      return Object.values(ENTITY_TYPES.HELPER).includes(_this.getEntityType());
    });

    _defineProperty$1(_assertThisInitialized(_this), "isEffect", function () {
      return Object.values(ENTITY_TYPES.EFFECT).includes(_this.getEntityType());
    });

    _defineProperty$1(_assertThisInitialized(_this), "setQuaternion", function (_ref2) {
      var x = _ref2.x,
          y = _ref2.y,
          z = _ref2.z,
          w = _ref2.w;

      _this.body.quaternion.set(x, y, z, w);
    });

    _defineProperty$1(_assertThisInitialized(_this), "setUuid", function (uuid) {
      if (uuid) {
        _this.body.uuid = uuid;
      }
    });

    _this.scripts = [];
    _this.tags = [];
    _this.children = [];
    _this.isMage = true;
    _this.parent = false;
    _this.disposed = false;

    _this.addTags([DEFAULT_TAG, tag].concat(_toConsumableArray(tags)));

    _this.serializable = serializable;
    return _this;
  }

  _createClass(Entity, [{
    key: "isSerializable",
    value: function isSerializable() {
      return !!this.serializable;
    }
  }, {
    key: "isDisposed",
    value: function isDisposed() {
      return this.disposed;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.scripts = [];
      this.children = [];
      this.isMage = true;
      this.parent = false;
      this.tags = [DEFAULT_TAG];
    }
  }, {
    key: "waitForBody",
    value: function waitForBody() {
      var _this2 = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 200;
      var maxTries = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return new Promise(function (resolve, reject) {
        var check = function check(tries) {
          setTimeout(function () {
            if (_this2.hasBody()) {
              resolve();
            } else if (tries <= maxTries) {
              check(tries + 1);
            } else {
              reject();
            }
          }, delay);
        };

        check(0);
      });
    }
  }, {
    key: "hasBody",
    value: function hasBody() {
      return !!this.body;
    }
  }, {
    key: "getBody",
    value: function getBody() {
      return this.body;
    }
  }, {
    key: "setBody",
    value: function setBody(body) {
      this.body = body;
    }
  }, {
    key: "hasParent",
    value: function hasParent() {
      return !!this.parent;
    }
  }, {
    key: "getParent",
    value: function getParent() {
      return this.parent;
    }
  }, {
    key: "setParent",
    value: function setParent(parent) {
      this.parent = parent;
    }
  }, {
    key: "add",
    value: function add(child) {
      var _this3 = this;

      var container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getBody();

      var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
          _ref3$waitForBody = _ref3.waitForBody,
          waitForBody = _ref3$waitForBody === void 0 ? 0 : _ref3$waitForBody,
          _ref3$waitForBodyMaxR = _ref3.waitForBodyMaxRetries,
          waitForBodyMaxRetries = _ref3$waitForBodyMaxR === void 0 ? 1 : _ref3$waitForBodyMaxR;

      if (this.hasBody()) {
        var _add = function _add(toAdd) {
          if (toAdd instanceof Entity) {
            return toAdd.waitForBody(waitForBody, waitForBodyMaxRetries).then(function () {
              _this3.children.push(toAdd);

              toAdd.setParent(_this3);
              container.add(toAdd.getBody());
              return toAdd;
            }).catch(console.log);
          } else {
            console.log(ENTITY_CANT_ADD_NOT_ENTITY);
            return Promise.reject(ENTITY_CANT_ADD_NOT_ENTITY);
          }
        };

        if (Array.isArray(child)) {
          return Promise.all(child.map(_add));
        } else {
          return _add(child);
        }
      } else {
        console.log(ENTITY_NOT_SET);
        return Promise.reject(ENTITY_NOT_SET);
      }
    }
  }, {
    key: "isParentOf",
    value: function isParentOf(child) {
      var comparator = function comparator(child) {
        return !!child.getBody().getObjectById(child.id);
      };

      if (child.isMage) {
        comparator = function comparator(child) {
          return child.getBody().getObjectById(child.id());
        };
      }

      return this.children.filter(comparator).length > 0;
    }
  }, {
    key: "has",
    value: function has(child) {
      if (child.isMage) {
        return this.equals(child) || this.isParentOf(child);
      } else {
        return !!this.getBody().getObjectById(child.id);
      }
    }
  }, {
    key: "remove",
    value: function remove(element) {
      if (this.hasBody() && this.has(element)) {
        if (element.isMage) {
          this.body.remove(element.getBody());
          var index = this.children.findIndex(function (m) {
            return m.equals(element);
          });
          if (index) this.children.splice(index, 1);
        } else {
          this.body.remove(element.getBody());
        }
      }
    }
  }, {
    key: "addTo",
    value: function addTo(target, childName) {
      if (target && target.isMage) {
        if (childName) {
          target.add(this, target.getBodyByName(childName));
        } else {
          target.add(this);
        }
      }
    }
  }, {
    key: "hasChildren",
    value: function hasChildren() {
      return this.children.length > 0;
    }
  }, {
    key: "getHierarchy",
    value: function getHierarchy() {
      return {
        element: this,
        children: this.children.map(function (e) {
          return e.getHierarchy();
        })
      };
    }
  }, {
    key: "addTags",
    value: function addTags() {
      var tags = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      tags.forEach(this.addTag);
    }
  }, {
    key: "removeTag",
    value: function removeTag(tagName) {
      if (tagName === DEFAULT_TAG) {
        console.log(TAG_CANT_BE_REMOVED);
        return;
      }

      if (this.hasTag(tagName)) {
        this.tags.splice(this.tags.indexOf(tagName), 1);
      } else {
        console.log(TAG_NOT_EXISTING_REMOVAL);
      }
    }
  }, {
    key: "removeAllTags",
    value: function removeAllTags() {
      this.tags = [DEFAULT_TAG];
    }
  }, {
    key: "hasTag",
    value: function hasTag(tagName) {
      return this.tags.includes(tagName);
    }
  }, {
    key: "getTags",
    value: function getTags() {
      return this.tags;
    }
  }, {
    key: "disposeScripts",
    value: function disposeScripts() {
      if (this.hasScripts()) {
        var length = this.scripts.length;

        for (var i = 0; i < length; i++) {
          var _this$scripts$i = this.scripts[i],
              script = _this$scripts$i.script,
              enabled = _this$scripts$i.enabled;

          if (enabled) {
            script.onDispose();

            script.__setStartedFlag(false);
          }

          delete this.scripts[i];
        }
      }
    }
  }, {
    key: "start",
    value: function start() {
      var _this4 = this;

      if (this.hasScripts()) {
        this.scripts.forEach(function (_ref4) {
          var script = _ref4.script,
              enabled = _ref4.enabled,
              options = _ref4.options;

          if (enabled) {
            script.start(_this4, options);

            script.__setStartedFlag(true);
          }
        });
      }
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (this.hasScripts()) {
        this.scripts.forEach(function (_ref5) {
          var script = _ref5.script,
              enabled = _ref5.enabled;

          if (script && enabled) {
            script.update(dt);
          }
        });
      }
    }
  }, {
    key: "onPhysicsUpdate",
    value: function onPhysicsUpdate(dt) {
      if (this.hasScripts()) {
        this.scripts.forEach(function (_ref6) {
          var script = _ref6.script,
              enabled = _ref6.enabled;

          if (script && enabled) {
            script.physicsUpdate(dt);
          }
        });
      }
    }
  }, {
    key: "disposeBody",
    value: function disposeBody() {
      this.getBody().clear();

      if (this.getBody().dispose && !isScene(this.getBody())) {
        this.getBody().dispose();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.hasChildren()) {
        this.children.forEach(function (child) {
          child.dispose();
        });
      }

      if (this.hasBody()) {
        this.stopStateMachine();
        this.disposeScripts();
        Scene$1.remove(this.getBody());
        this.disposeBody();
      }

      this.dispatchEvent({
        type: ENTITY_EVENTS.DISPOSE
      });
      this.reset();
    }
  }, {
    key: "addStateMachine",
    value: function addStateMachine(description) {
      var _this5 = this;

      this.stateMachine = interpret(createMachine(description)).onTransition(function (state) {
        _this5.dispatchEvent({
          type: ENTITY_EVENTS.STATE_MACHINE.CHANGE,
          state: state
        });
      });

      if (description.autostart) {
        this.startStateMachine();
      }
    }
  }, {
    key: "startStateMachine",
    value: function startStateMachine() {
      if (this.hasStateMachine()) {
        this.stateMachine.start();
      } else {
        console.log(STATE_MACHINE_NOT_AVAILABLE);
      }
    }
  }, {
    key: "stopStateMachine",
    value: function stopStateMachine() {
      if (this.hasStateMachine()) {
        this.stateMachine.stop();
      }
    }
  }, {
    key: "changeState",
    value: function changeState(event) {
      if (this.hasStateMachine()) {
        this.stateMachine.send(event);
      } else {
        console.log(STATE_MACHINE_NOT_AVAILABLE);
      }
    }
  }, {
    key: "getScript",
    value: function getScript(name) {
      var script = this.scripts.filter(function (script) {
        return script.name === name;
      })[0].script;

      if (script) {
        return script;
      } else {
        console.warn(SCRIPT_NOT_FOUND);
      }
    }
  }, {
    key: "addScripts",
    value: function addScripts() {
      var _this6 = this;

      var scripts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var parsedScripts = this.parseScripts(scripts, options, enabled);
      this.scripts = [].concat(_toConsumableArray(this.scripts), [parsedScripts]);

      if (enabled) {
        parsedScripts.forEach(function (parsed) {
          return parsed.start(_this6, parsed.options);
        });
      }
    }
  }, {
    key: "addScript",
    value: function addScript(name) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var script = Scripts$1.get(name);
      var _options$enabled = options.enabled,
          enabled = _options$enabled === void 0 ? true : _options$enabled;

      if (script) {
        this.scripts.push({
          script: script,
          name: name,
          enabled: enabled,
          options: options
        });

        if (enabled) {
          script.start(this, options);
        }
      } else {
        console.log(SCRIPT_NOT_FOUND);
      }

      return script;
    }
  }, {
    key: "enableScripts",
    value: function enableScripts() {
      this.scriptsEnabled = true;
    }
  }, {
    key: "disableScripts",
    value: function disableScripts() {
      this.scriptsEnabled = false;
    }
  }, {
    key: "setEntityType",
    value: function setEntityType(type) {
      if (FLAT_ENTITY_TYPES.includes(type)) {
        this.entityType = type;
      } else {
        console.log(ENTITY_TYPE_NOT_ALLOWED);
        this.entityType = ENTITY_TYPES.UNKNOWN;
      }
    }
  }, {
    key: "getEntityType",
    value: function getEntityType() {
      return this.entityType;
    }
  }, {
    key: "addLight",
    // TODO: sounds should become entities
    // addSound(name, options) {
    //     const { autoplay = false, ...opts } = options;
    //     this.isPlayingSound = autoplay;
    //     this.sound = new Sound(name, {
    //         autoplay,
    //         ...opts
    //     });
    //     this.sound.setTarget(this);
    //     return this.sound;
    // }
    // addDirectionalSound(name, options) {
    //     const { autoplay = false, ...opts } = options;
    //     this.isPlayingSound = autoplay;
    //     this.sound = new DirectionalSound(name, {
    //         autoplay,
    //         ...opts
    //     });
    //     this.sound.setTarget(this);
    //     return this.sound;
    // }
    // addAmbientSound(name, options) {
    //     const { autoplay = false, ...opts } = options;
    //     this.isPlayingSound = autoplay;
    //     this.sound = new AmbientSound(name, {
    //         body: this.body,
    //         autoplay,
    //         ...opts
    //     });
    //     return this.sound;
    // }
    value: function addLight(light) {
      var _this$getPosition = this.getPosition(),
          x = _this$getPosition.x,
          y = _this$getPosition.y,
          z = _this$getPosition.z;

      light.setPosition({
        x: x,
        y: y,
        z: z
      });
      this.light = light;
    }
  }, {
    key: "playSound",
    value: function playSound() {
      if (this.sound && !this.isPlayingSound) {
        this.sound.play();
        this.isPlayingSound = true;
      }
    }
  }, {
    key: "stopSound",
    value: function stopSound() {
      if (this.sound && this.isPlayingSound) {
        this.sound.stop();
        this.isPlayingSound = false;
      }
    }
  }, {
    key: "getScale",
    value: function getScale() {
      return {
        x: this.body.scale.x,
        y: this.body.scale.y,
        z: this.body.scale.z
      };
    }
  }, {
    key: "setScale",
    value: function setScale(howbig) {
      if (this.hasBody()) {
        var scale = _objectSpread2$1(_objectSpread2$1({}, this.getScale()), howbig);

        this.body.scale.set(scale.x, scale.y, scale.z);
      }
    }
  }, {
    key: "getQuaternion",
    value: function getQuaternion() {
      if (this.hasBody()) {
        return this.getBody().quaternion.clone();
      }
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return this.getBody().position.clone();
    }
  }, {
    key: "setPosition",
    value: function setPosition(where) {
      if (this.hasBody()) {
        var _this$getPosition2 = this.getPosition(),
            x = _this$getPosition2.x,
            y = _this$getPosition2.y,
            z = _this$getPosition2.z;

        var position = _objectSpread2$1({
          x: x,
          y: y,
          z: z
        }, where);

        this.body.position.set(position.x, position.y, position.z);
      }
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      return this.getBody().rotation.clone();
    }
  }, {
    key: "setRotation",
    value: function setRotation(how) {
      if (this.hasBody()) {
        var _this$getRotation = this.getRotation(),
            x = _this$getRotation.x,
            y = _this$getRotation.y,
            z = _this$getRotation.z;

        var rotation = _objectSpread2$1({
          x: x,
          y: y,
          z: z
        }, how);

        this.body.rotation.set(rotation.x, rotation.y, rotation.z);
      }
    }
  }, {
    key: "getWorldTransform",
    value: function getWorldTransform() {
      var position = this.getBody().getWorldPosition(new Vector3$1());
      var quaternion = this.getBody().getWorldQuaternion(new Quaternion(0, 0, 0, 1));
      var rotation = new Euler(0, 0, 0, 'XYZ').setFromQuaternion(quaternion, 'XYZ');
      return {
        position: position,
        rotation: rotation,
        quaternion: quaternion
      };
    }
  }, {
    key: "translate",
    value: function translate(_ref7) {
      var _ref7$x = _ref7.x,
          x = _ref7$x === void 0 ? 0 : _ref7$x,
          _ref7$y = _ref7.y,
          y = _ref7$y === void 0 ? 0 : _ref7$y,
          _ref7$z = _ref7.z,
          z = _ref7$z === void 0 ? 0 : _ref7$z;

      if (this.hasBody()) {
        this.body.translateX(x);
        this.body.translateY(y);
        this.body.translateZ(z);
      }
    }
  }, {
    key: "rotateTo",
    value: function rotateTo() {
      var _this7 = this;

      var rotation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getRotation();
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
      var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Between.Easing.Linear.None;

      var _this$getRotation2 = this.getRotation(),
          x = _this$getRotation2.x,
          y = _this$getRotation2.y,
          z = _this$getRotation2.z;

      return new Promise(function (resolve) {
        return new Between({
          x: x,
          y: y,
          z: z
        }, rotation).time(time).easing(easing).on('update', function (value) {
          return !_this7.isDisposed() && _this7.setRotation(value);
        }).on('complete', resolve);
      });
    }
  }, {
    key: "goTo",
    value: function goTo() {
      var _this8 = this;

      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getPosition();
      var time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 250;
      var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Between.Easing.Linear.None;

      var _this$getPosition3 = this.getPosition(),
          x = _this$getPosition3.x,
          y = _this$getPosition3.y,
          z = _this$getPosition3.z;

      return new Promise(function (resolve) {
        return new Between({
          x: x,
          y: y,
          z: z
        }, position).time(time).easing(easing).on('update', function (value) {
          return !_this8.isDisposed() && _this8.setPosition(value);
        }).on('complete', resolve);
      });
    }
  }, {
    key: "uuid",
    value: function uuid() {
      return this.body.uuid;
    }
  }, {
    key: "setId",
    value: function setId() {
      return this.body.id;
    }
  }, {
    key: "id",
    value: function id() {
      return this.body.id;
    }
  }, {
    key: "setVisible",
    value: function setVisible() {
      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.getBody().visible = flag;
    }
  }, {
    key: "equals",
    value: function equals(entity) {
      try {
        return entity.uuid ? this.uuid() === entity.uuid() : false;
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "setName",
    value: function setName(name) {
      this.name = name;
    }
  }, {
    key: "getName",
    value: function getName() {
      return this.name;
    }
  }, {
    key: "setData",
    value: function setData(key, value) {
      if (this.getBody().userData) {
        if (key && value) {
          this.getBody().userData[key] = value;
        } else {
          console.log(KEY_VALUE_IS_MISSING);
        }
      } else {
        console.log(USER_DATA_IS_MISSING);
      }
    }
  }, {
    key: "getData",
    value: function getData(key) {
      if (this.getBody().userData) {
        if (key) {
          return this.getBody().userData[key];
        } else {
          console.log(KEY_IS_MISSING);
        }
      } else {
        console.log(USER_DATA_IS_MISSING);
      }
    }
  }, {
    key: "mapScriptsToJSON",
    value: function mapScriptsToJSON() {
      this.scripts.reduce(function (acc, _ref8) {
        var name = _ref8.name,
            _ref8$options = _ref8.options,
            options = _ref8$options === void 0 ? {} : _ref8$options;
        acc.names.push(name);
        acc.options.push(options);
        return acc;
      }, {
        names: [],
        options: []
      });
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (this.isSerializable()) {
        return {
          position: this.getPosition(),
          rotation: this.getRotation(),
          scale: this.getScale(),
          entityType: this.getEntityType(),
          scripts: this.mapScriptsToJSON(),
          tags: this.getTags()
        };
      }
    }
  }], [{
    key: "create",
    value: function create() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return new this(options);
    }
  }]);

  return Entity;
}(EventDispatcher);var AnimationHandler = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(AnimationHandler, _EventDispatcher);

  var _super = _createSuper(AnimationHandler);

  function AnimationHandler(mesh) {
    var _this;

    var animations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, AnimationHandler);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "getAnimationEventHandler", function (type) {
      return function (_ref) {
        var action = _ref.action,
            direction = _ref.direction;

        _this.dispatchEvent({
          type: type,
          action: action,
          direction: direction
        });
      };
    });

    _this.mixer = new AnimationMixer(mesh);
    _this.animations = animations;
    _this.isPlaying = false;

    _this.addEventsListeners();

    return _this;
  }

  _createClass(AnimationHandler, [{
    key: "addEventsListeners",
    value: function addEventsListeners() {
      this.mixer.addEventListener('loop', this.getAnimationEventHandler(ENTITY_EVENTS.ANIMATION.LOOP));
      this.mixer.addEventListener('finished', this.getAnimationEventHandler(ENTITY_EVENTS.ANIMATION.FINISHED));
    }
  }, {
    key: "getAction",
    value: function getAction(id) {
      var action;

      if (typeof id === 'number') {
        action = this.animations[id];
      } else if (typeof id === 'string') {
        action = AnimationClip.findByName(this.animations, id);
      }

      return action;
    }
  }, {
    key: "getAvailableAnimations",
    value: function getAvailableAnimations() {
      return this.animations.map(function (_ref2) {
        var name = _ref2.name;
        return name;
      });
    }
  }, {
    key: "stopAll",
    value: function stopAll() {
      this.mixer.stopAllAction();
      this.isPlaying = false;
    }
  }, {
    key: "stopCurrentAnimation",
    value: function stopCurrentAnimation() {
      if (this.currentAction) {
        this.currentAction.stop();
      }

      this.isPlaying = false;
    }
  }, {
    key: "playAnimation",
    value: function playAnimation(id, options) {
      var action = this.getAction(id);
      var _options$loop = options.loop,
          loop = _options$loop === void 0 ? LoopRepeat : _options$loop;
      this.isPlaying = true;

      if (this.currentAction) {
        this.fadeToAnimation(action, options);
      } else if (action) {
        this.currentAction = this.mixer.clipAction(action).setLoop(loop).play();
      } else {
        console.warn(ANIMATION_NOT_FOUND);
      }
    }
  }, {
    key: "fadeToAnimation",
    value: function fadeToAnimation(action) {
      var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref3$duration = _ref3.duration,
          duration = _ref3$duration === void 0 ? 0.2 : _ref3$duration,
          _ref3$loop = _ref3.loop,
          loop = _ref3$loop === void 0 ? LoopRepeat : _ref3$loop;

      var previousAction = this.currentAction;
      this.currentAction = this.mixer.clipAction(action);

      if (previousAction !== this.currentAction) {
        previousAction.fadeOut(duration);
      }

      this.currentAction.reset().setEffectiveTimeScale(1).setEffectiveWeight(1).fadeIn(duration).setLoop(loop).play();
    }
  }, {
    key: "update",
    value: function update(dt) {
      this.mixer.update(dt);
    }
  }]);

  return AnimationHandler;
}(EventDispatcher);var _MATERIAL_TEXTURE_MAP;
var MATERIAL_TEXTURE_MAP = (_MATERIAL_TEXTURE_MAP = {}, _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.BASIC, [TEXTURES.ALPHA, TEXTURES.AO, TEXTURES.ENV, TEXTURES.LIGHT, TEXTURES.MAP, TEXTURES.SPECULAR]), _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.LAMBERT, [TEXTURES.ALPHA, TEXTURES.AO, TEXTURES.ENV, TEXTURES.LIGHT, TEXTURES.MAP, TEXTURES.SPECULAR, TEXTURES.EMISSIVE]), _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.PHONG, [TEXTURES.ALPHA, TEXTURES.AO, TEXTURES.ENV, TEXTURES.LIGHT, TEXTURES.MAP, TEXTURES.SPECULAR, TEXTURES.EMISSIVE, TEXTURES.BUMP, TEXTURES.DISPLACEMENT, TEXTURES.NORMAL]), _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.DEPTH, [TEXTURES.ALPHA, TEXTURES.MAP, TEXTURES.DISPLACEMENT]), _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.STANDARD, [TEXTURES.ALPHA, TEXTURES.AO, TEXTURES.ENV, TEXTURES.LIGHT, TEXTURES.MAP, TEXTURES.EMISSIVE, TEXTURES.BUMP, TEXTURES.DISPLACEMENT, TEXTURES.NORMAL, TEXTURES.METALNESS, TEXTURES.ROUGHNESS]), _defineProperty$1(_MATERIAL_TEXTURE_MAP, MATERIALS.THREE_TOON, [TEXTURES.ALPHA, TEXTURES.AO, TEXTURES.BUMP, TEXTURES.DISPLACEMENT, TEXTURES.EMISSIVE, TEXTURES.GRADIENT, TEXTURES.LIGHT, TEXTURES.MAP, TEXTURES.NORMAL]), _MATERIAL_TEXTURE_MAP);
var isTextureMapAllowedForMaterial = function isTextureMapAllowedForMaterial(materialType, textureType) {
  return MATERIAL_TEXTURE_MAP[materialType] && MATERIAL_TEXTURE_MAP[materialType].includes(textureType);
};var _excluded$6 = ["position", "quaternion"],
    _excluded2 = ["applyPhysicsUpdate"],
    _excluded3 = ["dt", "event"];
var COLLIDER_TAG = 'collider';
var DEFAULT_COLLIDER_OFFSET = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_PHYSICS_OPTIONS = {
  applyPhysicsUpdate: true
};

var Element$1 = /*#__PURE__*/function (_Entity) {
  _inherits(Element, _Entity);

  var _super = _createSuper(Element);

  function Element() {
    var _this;

    var _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Element);

    _this = _super.call(this, _options);

    _defineProperty$1(_assertThisInitialized(_this), "handleAnimationHandlerEvents", function (e) {
      _this.dispatchEvent(e);
    });

    _defineProperty$1(_assertThisInitialized(_this), "hasRayColliders", function () {
      return _this.colliders.length > 0;
    });

    _defineProperty$1(_assertThisInitialized(_this), "areCollisionsEnabled", function () {
      return _this.collisionsEnabled;
    });

    _defineProperty$1(_assertThisInitialized(_this), "enableCollisions", function () {
      return _this.collisionsEnabled = true;
    });

    _defineProperty$1(_assertThisInitialized(_this), "disableCollisions", function () {
      return _this.collisionsEnabled = false;
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateRayColliders", function () {
      _this.colliders.forEach(function (_ref) {
        var ray = _ref.ray,
            helper = _ref.helper,
            _ref$offset = _ref.offset,
            offset = _ref$offset === void 0 ? DEFAULT_COLLIDER_OFFSET : _ref$offset;

        var position = _this.body.position.clone().add(new Vector3$1(offset.x, offset.y, offset.z));

        if (helper) {
          helper.updatePoints(_this.getPointsFromRayCollider(ray, position));
        }

        ray.ray.origin.copy(position);
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "getPointsFromRayCollider", function (ray, position) {
      var origin = position.clone();
      var end = origin.clone().add(ray.ray.direction.clone().multiplyScalar(ray.far)); //ray.ray.direction.clone().multiplyScalar(ray.far);

      return [origin, end];
    });

    _defineProperty$1(_assertThisInitialized(_this), "createRayColliderFromVector", function (_ref2, near, far, offset, debug) {
      var type = _ref2.type,
          vector = _ref2.vector;

      var parsedOffset = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_COLLIDER_OFFSET), offset);

      var position = _this.body.position.clone().add(new Vector3$1(parsedOffset.x, parsedOffset.y, parsedOffset.z));

      var ray = new Raycaster(position, vector, near, far);
      var helper; // if (debug) {
      //     const points = this.getPointsFromRayCollider(ray, position);
      //     helper = new Line(points);
      //     helper.addTag(COLLIDER_TAG);
      //     helper.setColor(COLLIDER_COLOR);
      //     helper.setThickness(4);
      // }

      if (_this.getEntityType() === ENTITY_TYPES.SPRITE) {
        ray.setFromCamera(position, Scene$1.getCameraBody());
      }

      return {
        type: type,
        ray: ray,
        helper: helper,
        offset: parsedOffset
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "setColliders", function () {
      var vectors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var colliders = vectors.map(function (vector, i) {
        var _options$i = options[i],
            _options$i$near = _options$i.near,
            near = _options$i$near === void 0 ? 0 : _options$i$near,
            _options$i$far = _options$i.far,
            far = _options$i$far === void 0 ? 10 : _options$i$far,
            _options$i$debug = _options$i.debug,
            debug = _options$i$debug === void 0 ? false : _options$i$debug,
            _options$i$offset = _options$i.offset,
            offset = _options$i$offset === void 0 ? DEFAULT_COLLIDER_OFFSET : _options$i$offset;
        return _this.createRayColliderFromVector(vector, near, far, offset, debug);
      });
      _this.colliders = [].concat(_toConsumableArray(_this.colliders), _toConsumableArray(colliders));
    });

    _defineProperty$1(_assertThisInitialized(_this), "checkRayCollider", function (_ref3) {
      var ray = _ref3.ray,
          type = _ref3.type;

      var mapCollision = function mapCollision(collision) {
        var distance = collision.distance,
            object = collision.object;
        var uuid = object.uuid;
        return {
          distance: distance,
          body: Universe$1.getByUUID(uuid)
        };
      };

      var collisions = ray.intersectObjects(Scene$1.scene.children).filter(function (collision) {
        return collision.object.uuid !== _this.uuid();
      }).map(mapCollision).filter(function (_ref4) {
        var body = _ref4.body;
        return !body.hasTag(COLLIDER_TAG);
      });
      return {
        collisions: collisions,
        type: type
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "checkCollisions", function () {
      var collisions = [];

      _this.colliders.forEach(function (collider) {
        var collision = _this.checkRayCollider(collider);

        if (collision) {
          collisions.push(collision);
        }
      });

      if (collisions.length) {
        _this.dispatchEvent({
          type: COLLISION_EVENT,
          collisions: collisions
        });
      }

      return collisions;
    });

    _defineProperty$1(_assertThisInitialized(_this), "setTextureMap", function (textureId) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      console.warn(DEPRECATIONS.ELEMENT_SET_TEXTURE_MAP);
      return _this.setTexture(textureId, TEXTURES.MAP, options);
    });

    _defineProperty$1(_assertThisInitialized(_this), "lookAt", function () {
      var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref5$x = _ref5.x,
          x = _ref5$x === void 0 ? 0 : _ref5$x,
          _ref5$y = _ref5.y,
          y = _ref5$y === void 0 ? 0 : _ref5$y,
          _ref5$z = _ref5.z,
          z = _ref5$z === void 0 ? 0 : _ref5$z;

      var body = _this.getBody();

      if (body.lookAt) {
        body.lookAt(x, y, z);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handlePhysicsUpdate", function (_ref6) {
      var position = _ref6.position,
          quaternion = _ref6.quaternion,
          data = _objectWithoutProperties(_ref6, _excluded$6);

      _this.setPosition(position);

      _this.setQuaternion(quaternion);

      _this.setPhysicsState(data);
    });

    _defineProperty$1(_assertThisInitialized(_this), "equals", function (object) {
      return _this.name === object.name && _this.body.uuid === object.body.uuid;
    });

    _defineProperty$1(_assertThisInitialized(_this), "traverse", function (cb) {
      _this.body.traverse(cb);
    });

    var _options$name = _options.name,
        name = _options$name === void 0 ? generateRandomName(_this.constructor.name) : _options$name,
        geometry = _options.geometry,
        material = _options.material,
        _body = _options.body;
    _this.textures = {};
    _this.opacity = 1;
    _this.options = _objectSpread2$1(_objectSpread2$1({}, _options), {}, {
      name: name
    });
    _this.physicsOptions = DEFAULT_PHYSICS_OPTIONS;
    _this.physicsState = {};

    _this.setBody({
      geometry: geometry,
      material: material,
      body: _body
    });

    _this.colliders = [];
    _this.collisionsEnabled = true;
    _this.animationHandler = undefined;
    _this.animations = [];

    _this.setMaterialType();

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  _createClass(Element, [{
    key: "getMaterialType",
    value: function getMaterialType() {
      return this.materialType;
    }
  }, {
    key: "setMaterialType",
    value: function setMaterialType() {
      var materialType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : MATERIALS.BASIC;
      this.materialType = materialType;
    }
  }, {
    key: "addTag",
    value: function addTag(tag) {
      _get(_getPrototypeOf(Element.prototype), "addTag", this).call(this, tag);

      var existingTags = this.getBody().userData.tags || [];
      this.getBody().userData.tags = [].concat(_toConsumableArray(existingTags), [tag]);
    }
  }, {
    key: "setBody",
    value: function setBody(_ref7) {
      var body = _ref7.body,
          geometry = _ref7.geometry,
          material = _ref7.material;

      if (body) {
        this.body = body;
      } else if (geometry && material) {
        this.geometry = geometry;
        this.material = material;
        this.body = new Mesh(this.geometry, this.material);
      }

      if (this.hasBody()) {
        this.postBodyCreation();
        this.addToScene();
      }
    }
  }, {
    key: "evaluateBoundingBox",
    value: function evaluateBoundingBox() {
      if (hasGeometry(this.getBody())) {
        this.boundingBox = extractBoundingBox(this.getBody());
      } else {
        this.boundingBox = extractBiggestBoundingBox(this.getBody());
      }
    }
  }, {
    key: "evaluateBoundingSphere",
    value: function evaluateBoundingSphere() {
      if (hasGeometry(this.getBody())) {
        this.boundingSphere = extractBoundingSphere(this.getBody());
      } else {
        this.boundingSphere = extractBiggestBoundingSphere(this.getBody());
      }
    }
  }, {
    key: "postBodyCreation",
    value: function postBodyCreation() {
      var _this$options = this.options,
          name = _this$options.name,
          _this$options$shadows = _this$options.shadowsEnabled,
          shadowsEnabled = _this$options$shadows === void 0 ? true : _this$options$shadows;
      this.evaluateBoundingBox();
      this.evaluateBoundingSphere();
      this.setName(name);

      if (shadowsEnabled) {
        setUpLightsAndShadows(this.getBody());
      }
    }
  }, {
    key: "addToScene",
    value: function addToScene() {
      var _this$options$addUniv = this.options.addUniverse,
          addUniverse = _this$options$addUniv === void 0 ? true : _this$options$addUniv;

      if (this.hasBody()) {
        Scene$1.add(this.getBody(), this, addUniverse);
      } else {
        console.warn(ELEMENT_NOT_SET$1);
      }
    }
  }, {
    key: "setName",
    value: function setName(name) {
      var _ref8 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref8$replace = _ref8.replace,
          replace = _ref8$replace === void 0 ? false : _ref8$replace;

      _get(_getPrototypeOf(Element.prototype), "setName", this).call(this, name);

      if (this.hasBody()) {
        if (replace) this.dispose();
        this.body.name = name;
        if (replace) this.addToScene();
      }
    }
  }, {
    key: "toggleShadows",
    value: function toggleShadows() {
      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (this.isModel()) {
        this.getBody().castShadow = flag;
        this.getBody().receiveShadow = flag;
        this.getBody().traverse(function (child) {
          child.castShadow = flag;
          child.receiveShadow = flag;
        });
      }
    }
  }, {
    key: "setArmature",
    value: function setArmature(armature) {
      this.armature = armature;
      Scene$1.add(this.armature, null, false);
    }
  }, {
    key: "addAnimationHandler",
    value: function addAnimationHandler() {
      var animations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.animations = animations;
      this.animationHandler = new AnimationHandler(this.getBody(), animations);
      this.addAnimationHandlerListeners();
    }
  }, {
    key: "addAnimationHandlerListeners",
    value: function addAnimationHandlerListeners() {
      this.animationHandler.addEventListener(ENTITY_EVENTS.ANIMATION.LOOP, this.handleAnimationHandlerEvents);
      this.animationHandler.addEventListener(ENTITY_EVENTS.ANIMATION.FINISHED, this.handleAnimationHandlerEvents);
    }
  }, {
    key: "removeAnimationHandlerListeners",
    value: function removeAnimationHandlerListeners() {
      this.animationHandler.removeEventListener(ENTITY_EVENTS.ANIMATION.LOOP, this.handleAnimationHandlerEvents);
      this.animationHandler.removeEventListener(ENTITY_EVENTS.ANIMATION.FINISHED, this.handleAnimationHandlerEvents);
    }
  }, {
    key: "hasAnimationHandler",
    value: function hasAnimationHandler() {
      return !!this.animationHandler;
    }
  }, {
    key: "hasAnimations",
    value: function hasAnimations() {
      return !!this.animations.length;
    }
  }, {
    key: "playAnimation",
    value: function playAnimation(id) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!this.hasAnimations()) return;

      if (this.hasAnimationHandler()) {
        this.animationHandler.playAnimation(id, options);
      } else {
        console.warn(ANIMATION_HANDLER_NOT_FOUND);
      }
    }
  }, {
    key: "stopAllAnimations",
    value: function stopAllAnimations() {
      if (!this.hasAnimations()) return;

      if (this.hasAnimationHandler()) {
        this.animationHandler.stopAll();
      } else {
        console.warn(ANIMATION_HANDLER_NOT_FOUND);
      }
    }
  }, {
    key: "stopAnimation",
    value: function stopAnimation() {
      if (!this.hasAnimations()) return;

      if (this.hasAnimationHandler()) {
        this.animationHandler.stopCurrentAnimation();
      } else {
        console.warn(ANIMATION_HANDLER_NOT_FOUND);
      }
    }
  }, {
    key: "getAvailableAnimations",
    value: function getAvailableAnimations() {
      if (!this.hasAnimations()) return [];

      if (this.hasAnimationHandler()) {
        return this.animationHandler.getAvailableAnimations();
      } else {
        console.warn(ANIMATION_HANDLER_NOT_FOUND);
      }

      return [];
    }
  }, {
    key: "setPhysicsOptions",
    value: function setPhysicsOptions() {
      var _ref9 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_PHYSICS_OPTIONS,
          _ref9$applyPhysicsUpd = _ref9.applyPhysicsUpdate,
          applyPhysicsUpdate = _ref9$applyPhysicsUpd === void 0 ? true : _ref9$applyPhysicsUpd,
          rest = _objectWithoutProperties(_ref9, _excluded2);

      var parsedOptions = _objectSpread2$1({
        applyPhysicsUpdate: applyPhysicsUpdate
      }, rest);

      this.physicsOptions = parsedOptions;
    }
  }, {
    key: "getPhysicsOptions",
    value: function getPhysicsOptions(option) {
      return option ? this.physicsOptions[option] : this.physicsOptions;
    }
  }, {
    key: "setPhysicsState",
    value: function setPhysicsState() {
      var _ref10 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          _ref10.dt;
          _ref10.event;
          var data = _objectWithoutProperties(_ref10, _excluded3);

      var physicsState = _objectSpread2$1(_objectSpread2$1({}, this.physicsState), data);

      this.physicsState = physicsState;
    }
  }, {
    key: "getPhysicsState",
    value: function getPhysicsState(key) {
      return key ? this.physicsState[key] : this.physicsState;
    }
  }, {
    key: "enablePhysics",
    value: function enablePhysics() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var mass = options.mass;
      this.setPhysicsOptions(options);

      if (Config$1.physics().enabled) {
        if (this.isModel() && mass === 0) {
          Physics$1.addModel(this, options);
        } else {
          Physics$1.add(this, options);
        }
      }
    }
  }, {
    key: "getAngularVelocity",
    value: function getAngularVelocity() {
      return this.angularVelocity || DEFAULT_ANGULAR_VELOCITY;
    }
  }, {
    key: "setAngularVelocity",
    value: function setAngularVelocity(velocity) {
      this.angularVelocity = velocity;
      Physics$1.updateAngularVelocity(this.uuid(), velocity);
    }
  }, {
    key: "getLinearVelocity",
    value: function getLinearVelocity() {
      return this.linearVelocity || DEFAULT_LINEAR_VELOCITY;
    }
  }, {
    key: "setLinearVelocity",
    value: function setLinearVelocity(velocity) {
      this.linearVelocity = velocity;
      Physics$1.updateLinearVelocity(this.uuid(), velocity);
    }
  }, {
    key: "isCollidingOnDirection",
    value: function isCollidingOnDirection(direction) {
      var collider = this.colliders.filter(function (_ref11) {
        var type = _ref11.type;
        return type === direction;
      })[0];
      var emptyCollision = {
        collisions: [],
        type: direction
      };
      return collider ? this.checkRayCollider(collider) : emptyCollision;
    }
  }, {
    key: "setGeometryRotation",
    value: function setGeometryRotation() {
      var rotation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _rotation$x = rotation.x,
          x = _rotation$x === void 0 ? 0 : _rotation$x,
          _rotation$y = rotation.y,
          y = _rotation$y === void 0 ? 0 : _rotation$y,
          _rotation$z = rotation.z,
          z = _rotation$z === void 0 ? 0 : _rotation$z;

      if (x !== 0) {
        this.getBody().geometry.rotateX(x);
      }

      if (y !== 0) {
        this.getBody().geometry.rotateY(y);
      }

      if (z !== 0) {
        this.getBody().geometry.rotateZ(z);
      }
    }
  }, {
    key: "setColor",
    value: function setColor(color) {
      var _this2 = this;

      if (color) {
        if (hasMaterial(this.getBody())) {
          this.body.material.color = new Color$1(color);
        } else {
          this.body.traverse(function (child) {
            if (hasMaterial(child) && !_this2.isParentOf(child)) {
              child.material.color = new Color$1(color);
            }
          });
        }
      } else {
        console.warn(ELEMENT_SET_COLOR_MISSING_COLOR);
      }
    }
  }, {
    key: "getColor",
    value: function getColor() {
      if (hasMaterial(this.getBody())) {
        return this.body.material.color;
      } else {
        var found;
        this.body.traverse(function (child) {
          if (hasMaterial(child) && !found) {
            found = child.material.color;
          }
        });
        return found;
      }
    }
  }, {
    key: "recordTexture",
    value: function recordTexture(textureId, textureType) {
      this.textures[textureType] = textureId;
    }
  }, {
    key: "setTexture",
    value: function setTexture(textureId) {
      var textureType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXTURES.MAP;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!isTextureMapAllowedForMaterial(this.getMaterialType(), textureType)) {
        console.log(ELEMENT_MATERIAL_NO_SUPPORT_FOR_TEXTURE, textureType, this.getMaterialType());
        return;
      }

      if (textureId) {
        var _options$repeat = options.repeat,
            repeat = _options$repeat === void 0 ? {
          x: 1,
          y: 1
        } : _options$repeat,
            _options$wrap = options.wrap,
            wrap = _options$wrap === void 0 ? RepeatWrapping$1 : _options$wrap;
        this.recordTexture(textureId, textureType);

        var applyTextureTo = function applyTextureTo(element) {
          var texture = Images$1.get(textureId);
          texture.wrapS = wrap;
          texture.wrapT = wrap;
          texture.repeat.set(repeat.x, repeat.y);
          element.material[textureType] = texture;
        };

        if (hasMaterial(this.getBody())) {
          applyTextureTo(this.getBody());
        } else {
          this.getBody().traverse(function (child) {
            if (hasMaterial(child)) {
              applyTextureTo(child);
            }
          });
        }
      }
    }
  }, {
    key: "setMaterialFromName",
    value: function setMaterialFromName(materialName) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.setMaterialType(materialName);

      if (hasMaterial(this.getBody())) {
        changeMaterialByName(materialName, this.getBody(), options);
      } else {
        this.getBody().traverse(function (child) {
          if (hasMaterial(child)) {
            changeMaterialByName(materialName, child, options);
          }
        });
      }
    }
  }, {
    key: "setOpacity",
    value: function setOpacity() {
      var _this3 = this;

      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1.0;
      var opacity = clamp(value, 0, 1);
      this.opacity = opacity;

      if (hasMaterial(this.getBody())) {
        this.body.material.transparent = true;
        this.body.material.opacity = opacity;
      } else {
        this.body.traverse(function (child) {
          if (hasMaterial(child) && !_this3.isParentOf(child)) {
            child.material.transparent = true;
            child.material.opacity = opacity;
          }
        });
      }
    }
  }, {
    key: "fadeTo",
    value: function fadeTo(opacity, time) {
      var _this4 = this;

      return new Promise(function (resolve) {
        return new Between(_this4.opacity, opacity).time(time).on('update', function (value) {
          return !_this4.isDisposed() && _this4.setOpacity(value);
        }).on('complete', resolve);
      });
    }
  }, {
    key: "setWireframe",
    value: function setWireframe() {
      var flag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      if (hasMaterial(this.getBody())) {
        this.body.material.wireframe = flag;
      } else {
        this.body.traverse(function (child) {
          if (hasMaterial(child)) {
            child.material.wireframe = flag;
          }
        });
      }
    }
  }, {
    key: "setWireframeLineWidth",
    value: function setWireframeLineWidth() {
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      if (hasMaterial(this.getBody())) {
        this.body.material.wireframeLinewidth = width;
      } else {
        this.body.traverse(function (child) {
          if (hasMaterial(child)) {
            child.material.wireframeLinewidth = width;
          }
        });
      }
    }
  }, {
    key: "disposeBody",
    value: function disposeBody() {
      _get(_getPrototypeOf(Element.prototype), "disposeBody", this).call(this);

      if (hasMaterial(this.getBody())) {
        disposeTextures(this.getBody());
        disposeMaterial(this.getBody());
        disposeGeometry(this.getBody());
      }

      this.getBody().traverse(function (child) {
        if (hasMaterial(child)) {
          disposeTextures(child);
          disposeMaterial(child);
          disposeGeometry(child);
        }
      });
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(Element.prototype), "update", this).call(this, dt);

      if (this.hasRayColliders() && this.areCollisionsEnabled()) {
        this.updateRayColliders();
        this.checkCollisions();
      }

      if (this.hasAnimationHandler() && this.animationHandler.isPlaying) {
        this.animationHandler.update(dt);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(Element.prototype), "dispose", this).call(this);

      if (this.hasAnimationHandler()) {
        this.removeAnimationHandlerListeners();
      }

      Physics$1.disposeElement(this);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      if (this.isSerializable()) {
        return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(Element.prototype), "toJSON", this).call(this)), {}, {
          body: this.body.toJSON(),
          textures: this.textures
        }, this.options);
      }
    }
  }]);

  return Element;
}(Entity);var Camera = /*#__PURE__*/function (_Entity) {
  _inherits(Camera, _Entity);

  var _super = _createSuper(Camera);

  function Camera() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Camera);

    var _options$name = options.name,
        name = _options$name === void 0 ? 'camera' : _options$name,
        _options$fov = options.fov,
        fov = _options$fov === void 0 ? Config$1.camera().fov : _options$fov,
        _options$ratio = options.ratio,
        ratio = _options$ratio === void 0 ? Config$1.screen().ratio : _options$ratio,
        _options$near = options.near,
        near = _options$near === void 0 ? Config$1.camera().near : _options$near,
        _options$far = options.far,
        far = _options$far === void 0 ? Config$1.camera().far : _options$far;
    _this = _super.call(this, {
      name: name
    });
    _this.options = options;

    _this.setBody(new PerspectiveCamera(fov, ratio, near, far));

    _this.setEntityType(ENTITY_TYPES.CAMERA);

    _this.setName(name);

    return _this;
  }

  _createClass(Camera, [{
    key: "getPosition",
    value: function getPosition() {
      return this.body.position;
    }
  }, {
    key: "getDirection",
    value: function getDirection() {
      var vector = new Vector3$1();

      var _this$getBody$getWorl = this.getBody().getWorldDirection(vector),
          x = _this$getBody$getWorl.x,
          y = _this$getBody$getWorl.y,
          z = _this$getBody$getWorl.z;

      return {
        x: x,
        y: y,
        z: z
      };
    }
  }, {
    key: "lookAt",
    value: function lookAt() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _position$x = position.x,
          x = _position$x === void 0 ? 0 : _position$x,
          _position$y = position.y,
          y = _position$y === void 0 ? 0 : _position$y,
          _position$z = position.z,
          z = _position$z === void 0 ? 0 : _position$z;
      this.body.lookAt(x, y, z);
    }
  }]);

  return Camera;
}(Entity);var Grid = /*#__PURE__*/function (_Element) {
  _inherits(Grid, _Element);

  var _super = _createSuper(Grid);

  function Grid(size, division, color1, color2) {
    var _this;

    _classCallCheck(this, Grid);

    var options = {
      size: size,
      division: division,
      color1: color1,
      color2: color2,
      name: generateRandomName('GridHelper')
    };
    _this = _super.call(this, options);
    var body = new GridHelper(size, division, color1, color2);

    _this.setBody({
      body: body
    });

    _this.setEntityType(ENTITY_TYPES.HELPER.GRID);

    return _this;
  }

  _createClass(Grid, [{
    key: "update",
    value: function update() {}
  }]);

  return Grid;
}(Element$1);var AxesHelper = /*#__PURE__*/function (_LineSegments) {
  _inherits(AxesHelper, _LineSegments);

  var _super = _createSuper(AxesHelper);

  function AxesHelper() {
    var _this;

    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var thickness = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    _classCallCheck(this, AxesHelper);

    var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
    var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
    var geometry = new BufferGeometry();
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
    var material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
      linewidth: thickness
    });
    _this = _super.call(this, geometry, material);
    _this.type = 'AxesHelper';
    return _this;
  }

  _createClass(AxesHelper, [{
    key: "setColors",
    value: function setColors(xAxisColor, yAxisColor, zAxisColor) {
      var color = new Color$1();
      var array = this.geometry.attributes.color.array;
      color.set(xAxisColor);
      color.toArray(array, 0);
      color.toArray(array, 3);
      color.set(yAxisColor);
      color.toArray(array, 6);
      color.toArray(array, 9);
      color.set(zAxisColor);
      color.toArray(array, 12);
      color.toArray(array, 15);
      this.geometry.attributes.color.needsUpdate = true;
      return this;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.geometry.dispose();
      this.material.dispose();
    }
  }]);

  return AxesHelper;
}(LineSegments);

var Axes = /*#__PURE__*/function (_Element) {
  _inherits(Axes, _Element);

  var _super2 = _createSuper(Axes);

  function Axes(size, thickness) {
    var _this2;

    _classCallCheck(this, Axes);

    var options = {
      size: size,
      thickness: thickness,
      name: generateRandomName('AxesHelper')
    };
    _this2 = _super2.call(this, options);
    var body = new AxesHelper(size, thickness);

    _this2.setBody({
      body: body
    });

    _this2.setEntityType(ENTITY_TYPES.HELPER.AXES);

    return _this2;
  }

  _createClass(Axes, [{
    key: "update",
    value: function update() {}
  }]);

  return Axes;
}(Element$1);var Cube = /*#__PURE__*/function (_Element) {
  _inherits(Cube, _Element);

  var _super = _createSuper(Cube);

  function Cube() {
    var _this;

    var side = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var color = arguments.length > 1 ? arguments[1] : undefined;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Cube);

    _this = _super.call(this, options);
    var geometry = new BoxGeometry(side, side, side);
    var material = new MeshBasicMaterial(_objectSpread2$1({
      color: color,
      wireframe: false
    }, options));

    _this.setBody({
      geometry: geometry,
      material: material
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  return Cube;
}(Element$1);var Sphere = /*#__PURE__*/function (_Element) {
  _inherits(Sphere, _Element);

  var _super = _createSuper(Sphere);

  function Sphere() {
    var _this;

    var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var color = arguments.length > 1 ? arguments[1] : undefined;
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Sphere);

    _this = _super.call(this, options);
    var segments = 32;
    var geometry = new SphereGeometry(radius, segments, segments);
    var material = new MeshBasicMaterial(_objectSpread2$1({
      color: color,
      wireframe: false
    }, options));

    _this.setBody({
      geometry: geometry,
      material: material
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  return Sphere;
}(Element$1);var Cylinder = /*#__PURE__*/function (_Element) {
  _inherits(Cylinder, _Element);

  var _super = _createSuper(Cylinder);

  function Cylinder() {
    var _this;

    var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var height = arguments.length > 2 ? arguments[2] : undefined;
    var color = arguments.length > 3 ? arguments[3] : undefined;
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, Cylinder);

    _this = _super.call(this, options);
    var segments = 32;
    var geometry = new CylinderGeometry(radiusTop, radiusBottom, height, segments);
    var material = new MeshBasicMaterial(_objectSpread2$1({
      color: color,
      wireframe: false
    }, options));

    _this.setBody({
      geometry: geometry,
      material: material
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  return Cylinder;
}(Element$1);var DEFAULT_LINE_COLOR = 0xffffff;
var DEFAULT_LINE_THICKNESS = 2;

var Line = /*#__PURE__*/function (_Element) {
  _inherits(Line, _Element);

  var _super = _createSuper(Line);

  function Line() {
    var _this;

    var _points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Line);

    _this = _super.call(this, options);

    _defineProperty$1(_assertThisInitialized(_this), "updatePoints", function (points) {
      var vectors = points.map(function (_ref) {
        var x = _ref.x,
            y = _ref.y,
            z = _ref.z;
        return new Vector3$1(x, y, z);
      });
      _this.body.geometry.vertices = vectors;
      _this.body.geometry.verticesNeedUpdate = true;
    });

    _this.points = _points;

    var material = _this.getMaterial();

    var geometry = _this.getGeometryFromPoints();

    var body = new Line$1(geometry, material);

    _this.setBody({
      body: body
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  _createClass(Line, [{
    key: "postBodyCreation",
    value: function postBodyCreation() {
      _get(_getPrototypeOf(Line.prototype), "postBodyCreation", this).call(this);

      var _this$options$dashed = this.options.dashed,
          dashed = _this$options$dashed === void 0 ? false : _this$options$dashed;

      if (dashed) {
        this.body.computeLineDistances();
      }
    }
  }, {
    key: "getMaterial",
    value: function getMaterial() {
      var _this$options = this.options,
          _this$options$color = _this$options.color,
          color = _this$options$color === void 0 ? DEFAULT_LINE_COLOR : _this$options$color,
          _this$options$dashed2 = _this$options.dashed,
          dashed = _this$options$dashed2 === void 0 ? false : _this$options$dashed2,
          _this$options$thickne = _this$options.thickness,
          thickness = _this$options$thickne === void 0 ? DEFAULT_LINE_THICKNESS : _this$options$thickne;
      return dashed ? new LineDashedMaterial({
        color: color,
        linewidth: thickness
      }) : new LineBasicMaterial({
        color: color,
        linewidth: thickness
      });
    }
  }, {
    key: "getGeometryFromPoints",
    value: function getGeometryFromPoints() {
      var vectors = this.points.map(function (_ref2) {
        var _ref2$x = _ref2.x,
            x = _ref2$x === void 0 ? 0 : _ref2$x,
            _ref2$y = _ref2.y,
            y = _ref2$y === void 0 ? 0 : _ref2$y,
            _ref2$z = _ref2.z,
            z = _ref2$z === void 0 ? 0 : _ref2$z;
        return new Vector3$1(x, y, z);
      });
      return new BufferGeometry().setFromPoints(vectors);
    }
  }, {
    key: "setThickness",
    value: function setThickness() {
      var thickness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_LINE_THICKNESS;
      this.body.material.linewidth = thickness;
    }
  }]);

  return Line;
}(Element$1);var DEFAULT_CURVE_LINE_DIVISIONS = 20;

var CurveLine = /*#__PURE__*/function (_Line) {
  _inherits(CurveLine, _Line);

  var _super = _createSuper(CurveLine);

  function CurveLine() {
    var _this;

    var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CurveLine);

    var _options$divisions = options.divisions,
        divisions = _options$divisions === void 0 ? DEFAULT_CURVE_LINE_DIVISIONS : _options$divisions;
    var curve = CurveLine.genereateCurve(points, divisions);
    _this = _super.call(this, curve, options);
    _this.curve = curve;
    return _this;
  }

  _createClass(CurveLine, null, [{
    key: "genereateCurve",
    value: function genereateCurve(points, divisions) {
      return new CatmullRomCurve3(points.map(function (_ref) {
        var x = _ref.x,
            y = _ref.y,
            z = _ref.z;
        return new Vector3$1(x, y, z);
      })).getPoints(divisions);
    }
  }]);

  return CurveLine;
}(Line);var UP = new Vector3$1(0, 1, 0);
var DOWN = new Vector3$1(0, -1, 0);

var Plane = /*#__PURE__*/function (_Element) {
  _inherits(Plane, _Element);

  var _super = _createSuper(Plane);

  function Plane(height, width) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, Plane);

    _this = _super.call(this, options);
    var _options$color = options.color,
        color = _options$color === void 0 ? 0xfffffff : _options$color,
        _options$transparent = options.transparent,
        transparent = _options$transparent === void 0 ? false : _options$transparent,
        _options$opacity = options.opacity,
        opacity = _options$opacity === void 0 ? 1 : _options$opacity;
    material = new MeshBasicMaterial({
      color: color,
      side: DoubleSide,
      transparent: transparent,
      opacity: opacity
    });
    geometry = new PlaneGeometry(width, height);

    _this.setBody({
      geometry: geometry,
      material: material
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  _createClass(Plane, [{
    key: "face",
    value: function face(direction) {
      var vector = new Vector3$1(direction.x, direction.y, direction.z);
      this.body.lookAt(vector);
    }
  }], [{
    key: "UP",
    get: function get() {
      return UP;
    }
  }, {
    key: "DOWN",
    get: function get() {
      return DOWN;
    }
  }]);

  return Plane;
}(Element$1);var Box = /*#__PURE__*/function (_Element) {
  _inherits(Box, _Element);

  var _super = _createSuper(Box);

  function Box() {
    var _this;

    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
    var color = arguments.length > 3 ? arguments[3] : undefined;
    var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};

    _classCallCheck(this, Box);

    _this = _super.call(this, options);
    var geometry = new BoxGeometry(width, height, depth);
    var material = new MeshBasicMaterial(_objectSpread2$1({
      color: color,
      wireframe: false
    }, options));

    _this.setBody({
      geometry: geometry,
      material: material
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    return _this;
  }

  return Box;
}(Element$1);var _excluded$5 = ["anisotropy"];

var validateAnisotropy = function validateAnisotropy(anisotropy) {
  var max = Scene$1.getRenderer().capabilities.getMaxAnisotropy();
  return anisotropy > max ? max : anisotropy;
};

var Sprite = /*#__PURE__*/function (_Element) {
  _inherits(Sprite, _Element);

  var _super = _createSuper(Sprite);

  function Sprite() {
    var _this;

    var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 20;
    var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;
    var spriteTexture = arguments.length > 2 ? arguments[2] : undefined;
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, Sprite);

    _this = _super.call(this, options);

    var _options$anisotropy = options.anisotropy,
        anisotropy = _options$anisotropy === void 0 ? 1 : _options$anisotropy,
        rest = _objectWithoutProperties(options, _excluded$5);

    var texture = Images$1.get(spriteTexture);
    texture.anisotropy = validateAnisotropy(anisotropy);
    var material = new SpriteMaterial(_objectSpread2$1({
      map: texture
    }, rest));
    var body = new Sprite$1(material);
    body.scale.x = width;
    body.scale.y = height;

    _this.setBody({
      body: body
    });

    _this.setEntityType(ENTITY_TYPES.SPRITE);

    return _this;
  }

  _createClass(Sprite, [{
    key: "getRotation",
    value: function getRotation() {
      return this.body.material.rotation;
    }
  }, {
    key: "setRotation",
    value: function setRotation() {
      var rotation = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getRotation();
      this.body.material.rotation = rotation;
    }
  }]);

  return Sprite;
}(Element$1);var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const WOFF = 'application/font-woff';
const JPEG = 'image/jpeg';
const mimes = {
    woff: WOFF,
    woff2: WOFF,
    ttf: 'application/font-truetype',
    eot: 'application/vnd.ms-fontobject',
    png: 'image/png',
    jpg: JPEG,
    jpeg: JPEG,
    gif: 'image/gif',
    tiff: 'image/tiff',
    svg: 'image/svg+xml',
};
function getExtension(url) {
    const match = /\.([^./]*?)$/g.exec(url);
    return match ? match[1] : '';
}
function getMimeType(url) {
    const extension = getExtension(url).toLowerCase();
    return mimes[extension] || '';
}
function resolveUrl(url, baseUrl) {
    // url is absolute already
    if (url.match(/^[a-z]+:\/\//i)) {
        return url;
    }
    // url is absolute already, without protocol
    if (url.match(/^\/\//)) {
        return window.location.protocol + url;
    }
    // dataURI, mailto:, tel:, etc.
    if (url.match(/^[a-z]+:/i)) {
        return url;
    }
    const doc = document.implementation.createHTMLDocument();
    const base = doc.createElement('base');
    const a = doc.createElement('a');
    doc.head.appendChild(base);
    doc.body.appendChild(a);
    if (baseUrl) {
        base.href = baseUrl;
    }
    a.href = url;
    return a.href;
}
function isDataUrl(url) {
    return url.search(/^(data:)/) !== -1;
}
function makeDataUrl(content, mimeType) {
    return `data:${mimeType};base64,${content}`;
}
function parseDataUrlContent(dataURL) {
    return dataURL.split(/,/)[1];
}
const uuid = (function uuid() {
    // generate uuid for className of pseudo elements.
    // We should not use GUIDs, otherwise pseudo elements sometimes cannot be captured.
    let counter = 0;
    // ref: http://stackoverflow.com/a/6248722/2519373
    const random = () => 
    // eslint-disable-next-line no-bitwise
    `0000${((Math.random() * Math.pow(36, 4)) << 0).toString(36)}`.slice(-4);
    return () => {
        counter += 1;
        return `u${random()}${counter}`;
    };
})();
function toArray(arrayLike) {
    const arr = [];
    for (let i = 0, l = arrayLike.length; i < l; i += 1) {
        arr.push(arrayLike[i]);
    }
    return arr;
}
function px(node, styleProperty) {
    const val = window.getComputedStyle(node).getPropertyValue(styleProperty);
    return parseFloat(val.replace('px', ''));
}
function getNodeWidth(node) {
    const leftBorder = px(node, 'border-left-width');
    const rightBorder = px(node, 'border-right-width');
    return node.clientWidth + leftBorder + rightBorder;
}
function getNodeHeight(node) {
    const topBorder = px(node, 'border-top-width');
    const bottomBorder = px(node, 'border-bottom-width');
    return node.clientHeight + topBorder + bottomBorder;
}
function getPixelRatio() {
    let ratio;
    let FINAL_PROCESS;
    try {
        FINAL_PROCESS = process;
    }
    catch (e) {
        // pass
    }
    const val = FINAL_PROCESS && FINAL_PROCESS.env
        ? FINAL_PROCESS.env.devicePixelRatio
        : null;
    if (val) {
        ratio = parseInt(val, 10);
        if (Number.isNaN(ratio)) {
            ratio = 1;
        }
    }
    return ratio || window.devicePixelRatio || 1;
}
function createImage(url) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.crossOrigin = 'anonymous';
        img.decoding = 'sync';
        img.src = url;
    });
}
function svgToDataURL(svg) {
    return __awaiter$5(this, void 0, void 0, function* () {
        return Promise.resolve()
            .then(() => new XMLSerializer().serializeToString(svg))
            .then(encodeURIComponent)
            .then((html) => `data:image/svg+xml;charset=utf-8,${html}`);
    });
}
function nodeToDataURL(node, width, height) {
    return __awaiter$5(this, void 0, void 0, function* () {
        const xmlns = 'http://www.w3.org/2000/svg';
        const svg = document.createElementNS(xmlns, 'svg');
        const foreignObject = document.createElementNS(xmlns, 'foreignObject');
        svg.setAttribute('width', `${width}`);
        svg.setAttribute('height', `${height}`);
        svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
        foreignObject.setAttribute('width', '100%');
        foreignObject.setAttribute('height', '100%');
        foreignObject.setAttribute('x', '0');
        foreignObject.setAttribute('y', '0');
        foreignObject.setAttribute('externalResourcesRequired', 'true');
        svg.appendChild(foreignObject);
        foreignObject.appendChild(node);
        return svgToDataURL(svg);
    });
}const cache = {};
function getCacheKey(url) {
    let key = url.replace(/\?.*/, '');
    // font resourse
    if (/ttf|otf|eot|woff2?/i.test(key)) {
        key = key.replace(/.*\//, '');
    }
    return key;
}
function getBlobFromURL(url, options) {
    const cacheKey = getCacheKey(url);
    if (cache[cacheKey] != null) {
        return cache[cacheKey];
    }
    // cache bypass so we dont have CORS issues with cached images
    // ref: https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest#Bypassing_the_cache
    if (options.cacheBust) {
        // eslint-disable-next-line no-param-reassign
        url += (/\?/.test(url) ? '&' : '?') + new Date().getTime();
    }
    const failed = (reason) => {
        let placeholder = '';
        if (options.imagePlaceholder) {
            const parts = options.imagePlaceholder.split(/,/);
            if (parts && parts[1]) {
                placeholder = parts[1];
            }
        }
        let msg = `Failed to fetch resource: ${url}`;
        if (reason) {
            msg = typeof reason === 'string' ? reason : reason.message;
        }
        if (msg) {
            console.error(msg);
        }
        return {
            blob: placeholder,
            contentType: '',
        };
    };
    const deferred = window
        .fetch(url)
        .then((res) => 
    // eslint-disable-next-line promise/no-nesting
    res.blob().then((blob) => ({
        blob,
        contentType: res.headers.get('Content-Type') || '',
    })))
        .then(({ blob, contentType }) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve({
            contentType,
            blob: reader.result,
        });
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    }))
        .then(({ blob, contentType }) => ({
        contentType,
        blob: parseDataUrlContent(blob),
    }))
        // on failed
        .catch(failed);
    // cache result
    cache[cacheKey] = deferred;
    return deferred;
}function formatCSSText(style) {
    const content = style.getPropertyValue('content');
    return `${style.cssText} content: '${content.replace(/'|"/g, '')}';`;
}
function formatCSSProperties(style) {
    return toArray(style)
        .map((name) => {
        const value = style.getPropertyValue(name);
        const priority = style.getPropertyPriority(name);
        return `${name}: ${value}${priority ? ' !important' : ''};`;
    })
        .join(' ');
}
function getPseudoElementStyle(className, pseudo, style) {
    const selector = `.${className}:${pseudo}`;
    const cssText = style.cssText
        ? formatCSSText(style)
        : formatCSSProperties(style);
    return document.createTextNode(`${selector}{${cssText}}`);
}
function clonePseudoElement(nativeNode, clonedNode, pseudo) {
    const style = window.getComputedStyle(nativeNode, pseudo);
    const content = style.getPropertyValue('content');
    if (content === '' || content === 'none') {
        return;
    }
    const className = uuid();
    try {
        clonedNode.className = `${clonedNode.className} ${className}`;
    }
    catch (err) {
        return;
    }
    const styleElement = document.createElement('style');
    styleElement.appendChild(getPseudoElementStyle(className, pseudo, style));
    clonedNode.appendChild(styleElement);
}
function clonePseudoElements(nativeNode, clonedNode) {
    clonePseudoElement(nativeNode, clonedNode, ':before');
    clonePseudoElement(nativeNode, clonedNode, ':after');
}var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function cloneCanvasElement(node) {
    return __awaiter$4(this, void 0, void 0, function* () {
        const dataURL = node.toDataURL();
        if (dataURL === 'data:,') {
            return Promise.resolve(node.cloneNode(false));
        }
        return createImage(dataURL);
    });
}
function cloneVideoElement(node, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
        return Promise.resolve(node.poster)
            .then((url) => getBlobFromURL(url, options))
            .then((data) => makeDataUrl(data.blob, getMimeType(node.poster) || data.contentType))
            .then((dataURL) => createImage(dataURL));
    });
}
function cloneSingleNode(node, options) {
    return __awaiter$4(this, void 0, void 0, function* () {
        if (node instanceof HTMLCanvasElement) {
            return cloneCanvasElement(node);
        }
        if (node instanceof HTMLVideoElement && node.poster) {
            return cloneVideoElement(node, options);
        }
        return Promise.resolve(node.cloneNode(false));
    });
}
const isSlotElement = (node) => node.tagName != null && node.tagName.toUpperCase() === 'SLOT';
function cloneChildren(nativeNode, clonedNode, options) {
    var _a;
    return __awaiter$4(this, void 0, void 0, function* () {
        const children = isSlotElement(nativeNode) && nativeNode.assignedNodes
            ? toArray(nativeNode.assignedNodes())
            : toArray(((_a = nativeNode.shadowRoot) !== null && _a !== void 0 ? _a : nativeNode).childNodes);
        if (children.length === 0 || nativeNode instanceof HTMLVideoElement) {
            return Promise.resolve(clonedNode);
        }
        return children
            .reduce((deferred, child) => deferred
            // eslint-disable-next-line no-use-before-define
            .then(() => cloneNode(child, options))
            .then((clonedChild) => {
            // eslint-disable-next-line promise/always-return
            if (clonedChild) {
                clonedNode.appendChild(clonedChild);
            }
        }), Promise.resolve())
            .then(() => clonedNode);
    });
}
function cloneCSSStyle(nativeNode, clonedNode) {
    const source = window.getComputedStyle(nativeNode);
    const target = clonedNode.style;
    if (!target) {
        return;
    }
    if (source.cssText) {
        target.cssText = source.cssText;
    }
    else {
        toArray(source).forEach((name) => {
            target.setProperty(name, source.getPropertyValue(name), source.getPropertyPriority(name));
        });
    }
}
function cloneInputValue(nativeNode, clonedNode) {
    if (nativeNode instanceof HTMLTextAreaElement) {
        clonedNode.innerHTML = nativeNode.value;
    }
    if (nativeNode instanceof HTMLInputElement) {
        clonedNode.setAttribute('value', nativeNode.value);
    }
}
function decorate(nativeNode, clonedNode) {
    return __awaiter$4(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof Element)) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve()
            .then(() => cloneCSSStyle(nativeNode, clonedNode))
            .then(() => clonePseudoElements(nativeNode, clonedNode))
            .then(() => cloneInputValue(nativeNode, clonedNode))
            .then(() => clonedNode);
    });
}
function cloneNode(node, options, isRoot) {
    return __awaiter$4(this, void 0, void 0, function* () {
        if (!isRoot && options.filter && !options.filter(node)) {
            return Promise.resolve(null);
        }
        return Promise.resolve(node)
            .then((clonedNode) => cloneSingleNode(clonedNode, options))
            .then((clonedNode) => cloneChildren(node, clonedNode, options))
            .then((clonedNode) => decorate(node, clonedNode));
    });
}var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const URL_REGEX = /url\((['"]?)([^'"]+?)\1\)/g;
const URL_WITH_FORMAT_REGEX = /url\([^)]+\)\s*format\((["'])([^"']+)\1\)/g;
const FONT_SRC_REGEX = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function toRegex(url) {
    // eslint-disable-next-line no-useless-escape
    const escaped = url.replace(/([.*+?^${}()|\[\]\/\\])/g, '\\$1');
    return new RegExp(`(url\\(['"]?)(${escaped})(['"]?\\))`, 'g');
}
function parseURLs(cssText) {
    const result = [];
    cssText.replace(URL_REGEX, (raw, quotation, url) => {
        result.push(url);
        return raw;
    });
    return result.filter((url) => !isDataUrl(url));
}
function embed(cssText, resourceURL, baseURL, options, get) {
    const resolvedURL = baseURL ? resolveUrl(resourceURL, baseURL) : resourceURL;
    return Promise.resolve(resolvedURL)
        .then((url) => get ? get(url) : getBlobFromURL(url, options))
        .then((data) => {
        if (typeof data === 'string') {
            return makeDataUrl(data, getMimeType(resourceURL));
        }
        return makeDataUrl(data.blob, getMimeType(resourceURL) || data.contentType);
    })
        .then((dataURL) => cssText.replace(toRegex(resourceURL), `$1${dataURL}$3`))
        .then((content) => content, () => resolvedURL);
}
function filterPreferredFontFormat(str, { preferredFontFormat }) {
    return !preferredFontFormat
        ? str
        : str.replace(FONT_SRC_REGEX, (match) => {
            // eslint-disable-next-line no-constant-condition
            while (true) {
                const [src, , format] = URL_WITH_FORMAT_REGEX.exec(match) || [];
                if (!format) {
                    return '';
                }
                if (format === preferredFontFormat) {
                    return `src: ${src};`;
                }
            }
        });
}
function shouldEmbed(url) {
    return url.search(URL_REGEX) !== -1;
}
function embedResources(cssText, baseUrl, options) {
    return __awaiter$3(this, void 0, void 0, function* () {
        if (!shouldEmbed(cssText)) {
            return Promise.resolve(cssText);
        }
        const filteredCSSText = filterPreferredFontFormat(cssText, options);
        return Promise.resolve(filteredCSSText)
            .then(parseURLs)
            .then((urls) => urls.reduce((deferred, url) => 
        // eslint-disable-next-line promise/no-nesting
        deferred.then((css) => embed(css, url, baseUrl, options)), Promise.resolve(filteredCSSText)));
    });
}var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function embedBackground(clonedNode, options) {
    var _a;
    return __awaiter$2(this, void 0, void 0, function* () {
        const background = (_a = clonedNode.style) === null || _a === void 0 ? void 0 : _a.getPropertyValue('background');
        if (!background) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve(background)
            .then((cssString) => embedResources(cssString, null, options))
            .then((cssString) => {
            clonedNode.style.setProperty('background', cssString, clonedNode.style.getPropertyPriority('background'));
            return clonedNode;
        });
    });
}
function embedImageNode(clonedNode, options) {
    return __awaiter$2(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof HTMLImageElement && !isDataUrl(clonedNode.src)) &&
            !(clonedNode instanceof SVGImageElement &&
                !isDataUrl(clonedNode.href.baseVal))) {
            return Promise.resolve(clonedNode);
        }
        const src = clonedNode instanceof HTMLImageElement
            ? clonedNode.src
            : clonedNode.href.baseVal;
        return Promise.resolve(src)
            .then((url) => getBlobFromURL(url, options))
            .then((data) => makeDataUrl(data.blob, getMimeType(src) || data.contentType))
            .then((dataURL) => new Promise((resolve, reject) => {
            clonedNode.onload = resolve;
            clonedNode.onerror = reject;
            if (clonedNode instanceof HTMLImageElement) {
                clonedNode.srcset = '';
                clonedNode.src = dataURL;
            }
            else {
                clonedNode.href.baseVal = dataURL;
            }
        }))
            .then(() => clonedNode, () => clonedNode);
    });
}
function embedChildren(clonedNode, options) {
    return __awaiter$2(this, void 0, void 0, function* () {
        const children = toArray(clonedNode.childNodes);
        // eslint-disable-next-line no-use-before-define
        const deferreds = children.map((child) => embedImages(child, options));
        return Promise.all(deferreds).then(() => clonedNode);
    });
}
function embedImages(clonedNode, options) {
    return __awaiter$2(this, void 0, void 0, function* () {
        if (!(clonedNode instanceof Element)) {
            return Promise.resolve(clonedNode);
        }
        return Promise.resolve(clonedNode)
            .then((node) => embedBackground(node, options))
            .then((node) => embedImageNode(node, options))
            .then((node) => embedChildren(node, options));
    });
}function applyStyleWithOptions(node, options) {
    const { style } = node;
    if (options.backgroundColor) {
        style.backgroundColor = options.backgroundColor;
    }
    if (options.width) {
        style.width = `${options.width}px`;
    }
    if (options.height) {
        style.height = `${options.height}px`;
    }
    const manual = options.style;
    if (manual != null) {
        Object.keys(manual).forEach((key) => {
            style[key] = manual[key];
        });
    }
    return node;
}var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const cssFetchCache = {};
function fetchCSS(url) {
    const cache = cssFetchCache[url];
    if (cache != null) {
        return cache;
    }
    const deferred = window.fetch(url).then((res) => ({
        url,
        cssText: res.text(),
    }));
    cssFetchCache[url] = deferred;
    return deferred;
}
function embedFonts(meta) {
    return __awaiter$1(this, void 0, void 0, function* () {
        return meta.cssText.then((raw) => {
            let cssText = raw;
            const regexUrl = /url\(["']?([^"')]+)["']?\)/g;
            const fontLocs = cssText.match(/url\([^)]+\)/g) || [];
            const loadFonts = fontLocs.map((location) => {
                let url = location.replace(regexUrl, '$1');
                if (!url.startsWith('https://')) {
                    url = new URL(url, meta.url).href;
                }
                // eslint-disable-next-line promise/no-nesting
                return window
                    .fetch(url)
                    .then((res) => res.blob())
                    .then((blob) => new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                        // Side Effect
                        cssText = cssText.replace(location, `url(${reader.result})`);
                        resolve([location, reader.result]);
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(blob);
                }));
            });
            // eslint-disable-next-line promise/no-nesting
            return Promise.all(loadFonts).then(() => cssText);
        });
    });
}
function parseCSS(source) {
    if (source == null) {
        return [];
    }
    const result = [];
    const commentsRegex = /(\/\*[\s\S]*?\*\/)/gi;
    // strip out comments
    let cssText = source.replace(commentsRegex, '');
    const keyframesRegex = new RegExp('((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})', 'gi');
    // eslint-disable-next-line no-constant-condition
    while (true) {
        const matches = keyframesRegex.exec(cssText);
        if (matches === null) {
            break;
        }
        result.push(matches[0]);
    }
    cssText = cssText.replace(keyframesRegex, '');
    const importRegex = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi;
    // to match css & media queries together
    const combinedCSSRegex = '((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]' +
        '*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})';
    // unified regex
    const unifiedRegex = new RegExp(combinedCSSRegex, 'gi');
    // eslint-disable-next-line no-constant-condition
    while (true) {
        let matches = importRegex.exec(cssText);
        if (matches === null) {
            matches = unifiedRegex.exec(cssText);
            if (matches === null) {
                break;
            }
            else {
                importRegex.lastIndex = unifiedRegex.lastIndex;
            }
        }
        else {
            unifiedRegex.lastIndex = importRegex.lastIndex;
        }
        result.push(matches[0]);
    }
    return result;
}
function getCSSRules(styleSheets) {
    return __awaiter$1(this, void 0, void 0, function* () {
        const ret = [];
        const deferreds = [];
        // First loop inlines imports
        styleSheets.forEach((sheet) => {
            if ('cssRules' in sheet) {
                try {
                    toArray(sheet.cssRules).forEach((item, index) => {
                        if (item.type === CSSRule.IMPORT_RULE) {
                            let importIndex = index + 1;
                            const url = item.href;
                            const deferred = fetchCSS(url)
                                .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                                .then((cssText) => parseCSS(cssText).forEach((rule) => {
                                try {
                                    sheet.insertRule(rule, rule.startsWith('@import')
                                        ? (importIndex += 1)
                                        : sheet.cssRules.length);
                                }
                                catch (error) {
                                    console.error('Error inserting rule from remote css', {
                                        rule,
                                        error,
                                    });
                                }
                            }))
                                .catch((e) => {
                                console.error('Error loading remote css', e.toString());
                            });
                            deferreds.push(deferred);
                        }
                    });
                }
                catch (e) {
                    const inline = styleSheets.find((a) => a.href == null) || document.styleSheets[0];
                    if (sheet.href != null) {
                        deferreds.push(fetchCSS(sheet.href)
                            .then((metadata) => (metadata ? embedFonts(metadata) : ''))
                            .then((cssText) => parseCSS(cssText).forEach((rule) => {
                            inline.insertRule(rule, sheet.cssRules.length);
                        }))
                            .catch((err) => {
                            console.error('Error loading remote stylesheet', err.toString());
                        }));
                    }
                    console.error('Error inlining remote css file', e.toString());
                }
            }
        });
        return Promise.all(deferreds).then(() => {
            // Second loop parses rules
            styleSheets.forEach((sheet) => {
                if ('cssRules' in sheet) {
                    try {
                        toArray(sheet.cssRules).forEach((item) => {
                            ret.push(item);
                        });
                    }
                    catch (e) {
                        console.error(`Error while reading CSS rules from ${sheet.href}`, e.toString());
                    }
                }
            });
            return ret;
        });
    });
}
function getWebFontRules(cssRules) {
    return cssRules
        .filter((rule) => rule.type === CSSRule.FONT_FACE_RULE)
        .filter((rule) => shouldEmbed(rule.style.getPropertyValue('src')));
}
function parseWebFontRules(node) {
    return __awaiter$1(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => {
            if (node.ownerDocument == null) {
                reject(new Error('Provided element is not within a Document'));
            }
            resolve(toArray(node.ownerDocument.styleSheets));
        })
            .then((styleSheets) => getCSSRules(styleSheets))
            .then(getWebFontRules);
    });
}
function getWebFontCSS(node, options) {
    return __awaiter$1(this, void 0, void 0, function* () {
        return parseWebFontRules(node)
            .then((rules) => Promise.all(rules.map((rule) => {
            const baseUrl = rule.parentStyleSheet
                ? rule.parentStyleSheet.href
                : null;
            return embedResources(rule.cssText, baseUrl, options);
        })))
            .then((cssTexts) => cssTexts.join('\n'));
    });
}
function embedWebFonts(clonedNode, options) {
    return __awaiter$1(this, void 0, void 0, function* () {
        return (options.fontEmbedCSS != null
            ? Promise.resolve(options.fontEmbedCSS)
            : getWebFontCSS(clonedNode, options)).then((cssText) => {
            const styleNode = document.createElement('style');
            const sytleContent = document.createTextNode(cssText);
            styleNode.appendChild(sytleContent);
            if (clonedNode.firstChild) {
                clonedNode.insertBefore(styleNode, clonedNode.firstChild);
            }
            else {
                clonedNode.appendChild(styleNode);
            }
            return clonedNode;
        });
    });
}var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getImageSize(node, options = {}) {
    const width = options.width || getNodeWidth(node);
    const height = options.height || getNodeHeight(node);
    return { width, height };
}
function toSvg(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const { width, height } = getImageSize(node, options);
        return Promise.resolve(node)
            .then((nativeNode) => cloneNode(nativeNode, options, true))
            .then((clonedNode) => embedWebFonts(clonedNode, options))
            .then((clonedNode) => embedImages(clonedNode, options))
            .then((clonedNode) => applyStyleWithOptions(clonedNode, options))
            .then((clonedNode) => nodeToDataURL(clonedNode, width, height));
    });
}
const dimensionCanvasLimit = 16384; // as per https://developer.mozilla.org/en-US/docs/Web/HTML/Element/canvas#maximum_canvas_size
function checkCanvasDimensions(canvas) {
    if (canvas.width > dimensionCanvasLimit ||
        canvas.height > dimensionCanvasLimit) {
        if (canvas.width > dimensionCanvasLimit &&
            canvas.height > dimensionCanvasLimit) {
            if (canvas.width > canvas.height) {
                canvas.height *= dimensionCanvasLimit / canvas.width;
                canvas.width = dimensionCanvasLimit;
            }
            else {
                canvas.width *= dimensionCanvasLimit / canvas.height;
                canvas.height = dimensionCanvasLimit;
            }
        }
        else if (canvas.width > dimensionCanvasLimit) {
            canvas.height *= dimensionCanvasLimit / canvas.width;
            canvas.width = dimensionCanvasLimit;
        }
        else {
            canvas.width *= dimensionCanvasLimit / canvas.height;
            canvas.height = dimensionCanvasLimit;
        }
    }
}
function toCanvas(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toSvg(node, options)
            .then(createImage)
            .then((img) => {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const ratio = options.pixelRatio || getPixelRatio();
            const { width, height } = getImageSize(node, options);
            const canvasWidth = options.canvasWidth || width;
            const canvasHeight = options.canvasHeight || height;
            canvas.width = canvasWidth * ratio;
            canvas.height = canvasHeight * ratio;
            if (!options.skipAutoScale) {
                checkCanvasDimensions(canvas);
            }
            canvas.style.width = `${canvasWidth}`;
            canvas.style.height = `${canvasHeight}`;
            if (options.backgroundColor) {
                context.fillStyle = options.backgroundColor;
                context.fillRect(0, 0, canvas.width, canvas.height);
            }
            context.drawImage(img, 0, 0, canvas.width, canvas.height);
            return canvas;
        });
    });
}
function toPng(node, options = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return toCanvas(node, options).then((canvas) => canvas.toDataURL());
    });
}var isArray$3 = Array.isArray;
function isStringOrNumber$2(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef$3(o) {
    return o === void 0 || o === null;
}
function isInvalid$2(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction$3(o) {
    return typeof o === 'function';
}
function isString$3(o) {
    return typeof o === 'string';
}
function isNumber$2(o) {
    return typeof o === 'number';
}
function isNull$2(o) {
    return o === null;
}
function isUndefined$3(o) {
    return o === void 0;
}
function combineFrom$3(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

/**
 * Links given data to event as first parameter
 * @param {*} data data to be linked, it will be available in function as first parameter
 * @param {Function} event Function to be called when event occurs
 * @returns {{data: *, event: Function}}
 */
function linkEvent(data, event) {
    if (isFunction$3(event)) {
        return { data: data, event: event };
    }
    return null; // Return null when event is invalid, to avoid creating unnecessary event handlers
}
// object.event should always be function, otherwise its badly created object.
function isLinkEventObject$1(o) {
    return !isNull$2(o) && typeof o === 'object';
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ$2 = {};
var Fragment$1 = '$F';
function normalizeEventName$1(name) {
    return name.substr(2).toLowerCase();
}
function appendChild$1(parentDOM, dom) {
    parentDOM.appendChild(dom);
}
function insertOrAppend$1(parentDOM, newNode, nextNode) {
    if (isNull$2(nextNode)) {
        appendChild$1(parentDOM, newNode);
    }
    else {
        parentDOM.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement$1(tag, isSVG) {
    if (isSVG) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    return document.createElement(tag);
}
function replaceChild$1(parentDOM, newDom, lastDom) {
    parentDOM.replaceChild(newDom, lastDom);
}
function removeChild$1(parentDOM, childNode) {
    parentDOM.removeChild(childNode);
}
function callAll$1(arrayFn) {
    var listener;
    while ((listener = arrayFn.shift()) !== undefined) {
        listener();
    }
}
function findChildVNode$1(vNode, startEdge, flags) {
    var children = vNode.children;
    if (flags & 4 /* ComponentClass */) {
        return children.$LI;
    }
    if (flags & 8192 /* Fragment */) {
        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];
    }
    return children;
}
function findDOMfromVNode$1(vNode, startEdge) {
    var flags;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        vNode = findChildVNode$1(vNode, startEdge, flags);
    }
    return null;
}
function removeVNodeDOM$1(vNode, parentDOM) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            removeChild$1(parentDOM, vNode.dom);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    removeVNodeDOM$1(children[i], parentDOM);
                }
                return;
            }
        }
    } while (vNode);
}
function moveVNodeDOM$1(vNode, parentDOM, nextNode) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            insertOrAppend$1(parentDOM, vNode.dom, nextNode);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    moveVNodeDOM$1(children[i], parentDOM, nextNode);
                }
                return;
            }
        }
    } while (vNode);
}
function createDerivedState$1(instance, nextProps, state) {
    if (instance.constructor.getDerivedStateFromProps) {
        return combineFrom$3(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
    }
    return state;
}
var renderCheck$1 = {
    v: false
};
var options$1 = {
    componentComparator: null,
    createVNode: null,
    renderComplete: null
};
function setTextContent$1(dom, children) {
    dom.textContent = children;
}
// Calling this function assumes, nextValue is linkEvent
function isLastValueSameLinkEvent$1(lastValue, nextValue) {
    return (isLinkEventObject$1(lastValue) &&
        lastValue.event === nextValue.event &&
        lastValue.data === nextValue.data);
}
function mergeUnsetProperties$2(to, from) {
    for (var propName in from) {
        if (isUndefined$3(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}
function safeCall1$1(method, arg1) {
    return !!isFunction$3(method) && (method(arg1), true);
}

var keyPrefix$2 = '$';
function V$2(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode$2(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V$2(childFlag, children, className, flags, key, props, ref, type);
    if (options$1.createVNode) {
        options$1.createVNode(vNode);
    }
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren$2(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks$2(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef$3(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef$3(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties$2(ref, defaultHooks);
}
function mergeDefaultProps$2(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef$3(defaultProps)) {
        return props;
    }
    if (isNullOrUndef$3(props)) {
        return combineFrom$3(defaultProps, null);
    }
    return mergeUnsetProperties$2(props, defaultProps);
}
function resolveComponentFlags$2(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode$2(flags, type, props, key, ref) {
    flags = resolveComponentFlags$2(flags, type);
    var vNode = new V$2(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps$2(flags, type, props), mergeDefaultHooks$2(flags, type, ref), type);
    if (options$1.createVNode) {
        options$1.createVNode(vNode);
    }
    return vNode;
}
function createTextVNode$2(text, key) {
    return new V$2(1 /* HasInvalidChildren */, isNullOrUndef$3(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment$2(children, childFlags, key) {
    var fragment = createVNode$2(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode$2();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode$2(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
function normalizeProps$1(vNode) {
    var props = vNode.props;
    if (props) {
        var flags = vNode.flags;
        if (flags & 481 /* Element */) {
            if (props.children !== void 0 && isNullOrUndef$3(vNode.children)) {
                normalizeChildren$2(vNode, props.children);
            }
            if (props.className !== void 0) {
                vNode.className = props.className || null;
                props.className = undefined;
            }
        }
        if (props.key !== void 0) {
            vNode.key = props.key;
            props.key = undefined;
        }
        if (props.ref !== void 0) {
            if (flags & 8 /* ComponentFunction */) {
                vNode.ref = combineFrom$3(vNode.ref, props.ref);
            }
            else {
                vNode.ref = props.ref;
            }
            props.ref = undefined;
        }
    }
    return vNode;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment$2(vNodeToClone) {
    var clonedChildren;
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    if (childFlags === 2 /* HasVNodeChildren */) {
        clonedChildren = directClone$2(oldChildren);
    }
    else if (childFlags & 12 /* MultipleChildren */) {
        clonedChildren = [];
        for (var i = 0, len = oldChildren.length; i < len; ++i) {
            clonedChildren.push(directClone$2(oldChildren[i]));
        }
    }
    return createFragment$2(clonedChildren, childFlags, vNodeToClone.key);
}
function directClone$2(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull$2(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V$2(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment$2(vNodeToClone);
}
function createVoidVNode$2() {
    return createTextVNode$2('', null);
}
function createPortal(children, container) {
    var normalizedRoot = normalizeRoot$1(children);
    return createVNode$2(1024 /* Portal */, 1024 /* Portal */, null, normalizedRoot, 0 /* UnknownChildren */, null, normalizedRoot.key, container);
}
function _normalizeVNodes$2(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid$2(n)) {
            var newKey = currentKey + keyPrefix$2 + index;
            if (isArray$3(n)) {
                _normalizeVNodes$2(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber$2(n)) {
                    n = createTextVNode$2(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString$3(oldKey) && oldKey[0] === keyPrefix$2;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone$2(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull$2(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function getFlagsForElementVnode$1(type) {
    switch (type) {
        case 'svg':
            return 32 /* SvgElement */;
        case 'input':
            return 64 /* InputElement */;
        case 'select':
            return 256 /* SelectElement */;
        case 'textarea':
            return 128 /* TextareaElement */;
        case Fragment$1:
            return 8192 /* Fragment */;
        default:
            return 1 /* HtmlElement */;
    }
}
function normalizeChildren$2(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid$2(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber$2(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray$3(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid$2(n) || isArray$3(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes$2(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber$2(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode$2(n, keyPrefix$2 + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull$2(key);
                var isPrefixed = isString$3(key) && key[0] === keyPrefix$2;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone$2(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix$2 + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone$2(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}
function normalizeRoot$1(input) {
    if (isInvalid$2(input) || isStringOrNumber$2(input)) {
        return createTextVNode$2(input, null);
    }
    if (isArray$3(input)) {
        return createFragment$2(input, 0 /* UnknownChildren */, null);
    }
    return input.flags & 16384 /* InUse */ ? directClone$2(input) : input;
}

var xlinkNS$1 = 'http://www.w3.org/1999/xlink';
var xmlNS$1 = 'http://www.w3.org/XML/1998/namespace';
var namespaces$1 = {
    'xlink:actuate': xlinkNS$1,
    'xlink:arcrole': xlinkNS$1,
    'xlink:href': xlinkNS$1,
    'xlink:role': xlinkNS$1,
    'xlink:show': xlinkNS$1,
    'xlink:title': xlinkNS$1,
    'xlink:type': xlinkNS$1,
    'xml:base': xmlNS$1,
    'xml:lang': xmlNS$1,
    'xml:space': xmlNS$1
};

function getDelegatedEventObject$1(v) {
    return {
        onClick: v,
        onDblClick: v,
        onFocusIn: v,
        onFocusOut: v,
        onKeyDown: v,
        onKeyPress: v,
        onKeyUp: v,
        onMouseDown: v,
        onMouseMove: v,
        onMouseUp: v,
        onTouchEnd: v,
        onTouchMove: v,
        onTouchStart: v
    };
}
var attachedEventCounts$1 = getDelegatedEventObject$1(0);
var attachedEvents$1 = getDelegatedEventObject$1(null);
var syntheticEvents$1 = getDelegatedEventObject$1(true);
function updateOrAddSyntheticEvent$1(name, dom) {
    var eventsObject = dom.$EV;
    if (!eventsObject) {
        eventsObject = dom.$EV = getDelegatedEventObject$1(null);
    }
    if (!eventsObject[name]) {
        if (++attachedEventCounts$1[name] === 1) {
            attachedEvents$1[name] = attachEventToDocument$1(name);
        }
    }
    return eventsObject;
}
function unmountSyntheticEvent$1(name, dom) {
    var eventsObject = dom.$EV;
    if (eventsObject && eventsObject[name]) {
        if (--attachedEventCounts$1[name] === 0) {
            document.removeEventListener(normalizeEventName$1(name), attachedEvents$1[name]);
            attachedEvents$1[name] = null;
        }
        eventsObject[name] = null;
    }
}
function handleSyntheticEvent$1(name, lastEvent, nextEvent, dom) {
    if (isFunction$3(nextEvent)) {
        updateOrAddSyntheticEvent$1(name, dom)[name] = nextEvent;
    }
    else if (isLinkEventObject$1(nextEvent)) {
        if (isLastValueSameLinkEvent$1(lastEvent, nextEvent)) {
            return;
        }
        updateOrAddSyntheticEvent$1(name, dom)[name] = nextEvent;
    }
    else {
        unmountSyntheticEvent$1(name, dom);
    }
}
// When browsers fully support event.composedPath we could loop it through instead of using parentNode property
function getTargetNode$1(event) {
    return isFunction$3(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents$1(event, isClick, name, eventData) {
    var dom = getTargetNode$1(event);
    do {
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (isClick && dom.disabled) {
            return;
        }
        var eventsObject = dom.$EV;
        if (eventsObject) {
            var currentEvent = eventsObject[name];
            if (currentEvent) {
                // linkEvent object
                eventData.dom = dom;
                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }
        dom = dom.parentNode;
    } while (!isNull$2(dom));
}
function stopPropagation$1() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
        this.stopImmediatePropagation();
    }
}
function isDefaultPrevented$1() {
    return this.defaultPrevented;
}
function isPropagationStopped$1() {
    return this.cancelBubble;
}
function extendEventProperties$1(event) {
    // Event data needs to be object to save reference to currentTarget getter
    var eventData = {
        dom: document
    };
    event.isDefaultPrevented = isDefaultPrevented$1;
    event.isPropagationStopped = isPropagationStopped$1;
    event.stopPropagation = stopPropagation$1;
    Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
            return eventData.dom;
        }
    });
    return eventData;
}
function rootClickEvent$1(name) {
    return function (event) {
        if (event.button !== 0) {
            // Firefox incorrectly triggers click event for mid/right mouse buttons.
            // This bug has been active for 17 years.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
            event.stopPropagation();
            return;
        }
        dispatchEvents$1(event, true, name, extendEventProperties$1(event));
    };
}
function rootEvent$1(name) {
    return function (event) {
        dispatchEvents$1(event, false, name, extendEventProperties$1(event));
    };
}
function attachEventToDocument$1(name) {
    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent$1(name) : rootEvent$1(name);
    document.addEventListener(normalizeEventName$1(name), attachedEvent);
    return attachedEvent;
}

function isSameInnerHTML$1(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}

function triggerEventListener$2(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction$2(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ$2;
        var dom = vNode.dom;
        if (isString$3(methodName)) {
            triggerEventListener$2(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener$2(props, methodName[i], e);
            }
        }
        if (isFunction$3(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ$2;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function attachEvent$1(dom, eventName, handler) {
    var previousKey = "$" + eventName;
    var previousArgs = dom[previousKey];
    if (previousArgs) {
        if (previousArgs[1].wrapped) {
            return;
        }
        dom.removeEventListener(previousArgs[0], previousArgs[1]);
        dom[previousKey] = null;
    }
    if (isFunction$3(handler)) {
        dom.addEventListener(eventName, handler);
        dom[previousKey] = [eventName, handler];
    }
}

function isCheckedType$2(type) {
    return type === 'checkbox' || type === 'radio';
}
var onTextInputChange$1 = createWrappedFunction$2('onInput', applyValueInput$2);
var wrappedOnChange$2 = createWrappedFunction$2(['onClick', 'onChange'], applyValueInput$2);
/* tslint:disable-next-line:no-empty */
function emptywrapper$1(event) {
    event.stopPropagation();
}
emptywrapper$1.wrapped = true;
function inputEvents$1(dom, nextPropsOrEmpty) {
    if (isCheckedType$2(nextPropsOrEmpty.type)) {
        attachEvent$1(dom, 'change', wrappedOnChange$2);
        attachEvent$1(dom, 'click', emptywrapper$1);
    }
    else {
        attachEvent$1(dom, 'input', onTextInputChange$1);
    }
}
function applyValueInput$2(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef$3(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef$3(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef$3(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType$2(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef$3(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef$3(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions$2(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption$2(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions$2(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions$2(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions$2(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions$2(children[i], value);
            }
        }
    }
}
function updateChildOption$2(vNode, value) {
    var props = vNode.props || EMPTY_OBJ$2;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray$3(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef$3(value) || !isNullOrUndef$3(props.selected)) {
        dom.selected = props.selected || false;
    }
}
var onSelectChange$1 = createWrappedFunction$2('onChange', applyValueSelect$2);
function selectEvents$1(dom) {
    attachEvent$1(dom, 'change', onSelectChange$1);
}
function applyValueSelect$2(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef$3(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber$2(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef$3(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions$2(vNode, value);
    }
}

var onTextareaInputChange$1 = createWrappedFunction$2('onInput', applyValueTextArea$2);
var wrappedOnChange$1$1 = createWrappedFunction$2('onChange');
function textAreaEvents$1(dom, nextPropsOrEmpty) {
    attachEvent$1(dom, 'input', onTextareaInputChange$1);
    if (nextPropsOrEmpty.onChange) {
        attachEvent$1(dom, 'change', wrappedOnChange$1$1);
    }
}
function applyValueTextArea$2(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef$3(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef$3(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

/**
 * There is currently no support for switching same input between controlled and nonControlled
 * If that ever becomes a real issue, then re design controlled elements
 * Currently user must choose either controlled or non-controlled and stick with that
 */
function processElement$1(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
        applyValueInput$2(nextPropsOrEmpty, dom);
    }
    else if (flags & 256 /* SelectElement */) {
        applyValueSelect$2(nextPropsOrEmpty, dom, mounting, vNode);
    }
    else if (flags & 128 /* TextareaElement */) {
        applyValueTextArea$2(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
        dom.$V = vNode;
    }
}
function addFormElementEventHandlers$1(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
        inputEvents$1(dom, nextPropsOrEmpty);
    }
    else if (flags & 256 /* SelectElement */) {
        selectEvents$1(dom);
    }
    else if (flags & 128 /* TextareaElement */) {
        textAreaEvents$1(dom, nextPropsOrEmpty);
    }
}
function isControlledFormElement$1(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType$2(nextPropsOrEmpty.type) ? !isNullOrUndef$3(nextPropsOrEmpty.checked) : !isNullOrUndef$3(nextPropsOrEmpty.value);
}

function createRef() {
    return {
        current: null
    };
}
function forwardRef(render) {
    return {
        render: render
    };
}
function unmountRef$1(ref) {
    if (ref) {
        if (!safeCall1$1(ref, null) && ref.current) {
            ref.current = null;
        }
    }
}
function mountRef$1(ref, value, lifecycle) {
    if (ref && (isFunction$3(ref) || ref.current !== void 0)) {
        lifecycle.push(function () {
            if (!safeCall1$1(ref, value) && ref.current !== void 0) {
                ref.current = value;
            }
        });
    }
}

function remove$1(vNode, parentDOM) {
    unmount$2(vNode);
    removeVNodeDOM$1(vNode, parentDOM);
}
function unmount$2(vNode) {
    var flags = vNode.flags;
    var children = vNode.children;
    var ref;
    if (flags & 481 /* Element */) {
        ref = vNode.ref;
        var props = vNode.props;
        unmountRef$1(ref);
        var childFlags = vNode.childFlags;
        if (!isNull$2(props)) {
            var keys = Object.keys(props);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                if (syntheticEvents$1[key]) {
                    unmountSyntheticEvent$1(key, vNode.dom);
                }
            }
        }
        if (childFlags & 12 /* MultipleChildren */) {
            unmountAllChildren$1(children);
        }
        else if (childFlags === 2 /* HasVNodeChildren */) {
            unmount$2(children);
        }
    }
    else if (children) {
        if (flags & 4 /* ComponentClass */) {
            if (isFunction$3(children.componentWillUnmount)) {
                children.componentWillUnmount();
            }
            unmountRef$1(vNode.ref);
            children.$UN = true;
            unmount$2(children.$LI);
        }
        else if (flags & 8 /* ComponentFunction */) {
            ref = vNode.ref;
            if (!isNullOrUndef$3(ref) && isFunction$3(ref.onComponentWillUnmount)) {
                ref.onComponentWillUnmount(findDOMfromVNode$1(vNode, true), vNode.props || EMPTY_OBJ$2);
            }
            unmount$2(children);
        }
        else if (flags & 1024 /* Portal */) {
            remove$1(children, vNode.ref);
        }
        else if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren$1(children);
            }
        }
    }
}
function unmountAllChildren$1(children) {
    for (var i = 0, len = children.length; i < len; ++i) {
        unmount$2(children[i]);
    }
}
function clearDOM$1(dom) {
    // Optimization for clearing dom
    dom.textContent = '';
}
function removeAllChildren$1(dom, vNode, children) {
    unmountAllChildren$1(children);
    if (vNode.flags & 8192 /* Fragment */) {
        removeVNodeDOM$1(vNode, dom);
    }
    else {
        clearDOM$1(dom);
    }
}

function wrapLinkEvent$1(nextValue) {
    // This variable makes sure there is no "this" context in callback
    var ev = nextValue.event;
    return function (e) {
        ev(nextValue.data, e);
    };
}
function patchEvent$1(name, lastValue, nextValue, dom) {
    if (isLinkEventObject$1(nextValue)) {
        if (isLastValueSameLinkEvent$1(lastValue, nextValue)) {
            return;
        }
        nextValue = wrapLinkEvent$1(nextValue);
    }
    attachEvent$1(dom, normalizeEventName$1(name), nextValue);
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle$1(lastAttrValue, nextAttrValue, dom) {
    if (isNullOrUndef$3(nextAttrValue)) {
        dom.removeAttribute('style');
        return;
    }
    var domStyle = dom.style;
    var style;
    var value;
    if (isString$3(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef$3(lastAttrValue) && !isString$3(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle.setProperty(style, value);
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef$3(nextAttrValue[style])) {
                domStyle.removeProperty(style);
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle.setProperty(style, value);
        }
    }
}
function patchDangerInnerHTML$1(lastValue, nextValue, lastVNode, dom) {
    var lastHtml = (lastValue && lastValue.__html) || '';
    var nextHtml = (nextValue && nextValue.__html) || '';
    if (lastHtml !== nextHtml) {
        if (!isNullOrUndef$3(nextHtml) && !isSameInnerHTML$1(dom, nextHtml)) {
            if (!isNull$2(lastVNode)) {
                if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                    unmountAllChildren$1(lastVNode.children);
                }
                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                    unmount$2(lastVNode.children);
                }
                lastVNode.children = null;
                lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }
            dom.innerHTML = nextHtml;
        }
    }
}
function patchProp$1(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
        case 'children':
        case 'childrenType':
        case 'className':
        case 'defaultValue':
        case 'key':
        case 'multiple':
        case 'ref':
        case 'selectedIndex':
            break;
        case 'autoFocus':
            dom.autofocus = !!nextValue;
            break;
        case 'allowfullscreen':
        case 'autoplay':
        case 'capture':
        case 'checked':
        case 'controls':
        case 'default':
        case 'disabled':
        case 'hidden':
        case 'indeterminate':
        case 'loop':
        case 'muted':
        case 'novalidate':
        case 'open':
        case 'readOnly':
        case 'required':
        case 'reversed':
        case 'scoped':
        case 'seamless':
        case 'selected':
            dom[prop] = !!nextValue;
            break;
        case 'defaultChecked':
        case 'value':
        case 'volume':
            if (hasControlledValue && prop === 'value') {
                break;
            }
            var value = isNullOrUndef$3(nextValue) ? '' : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
            break;
        case 'style':
            patchStyle$1(lastValue, nextValue, dom);
            break;
        case 'dangerouslySetInnerHTML':
            patchDangerInnerHTML$1(lastValue, nextValue, lastVNode, dom);
            break;
        default:
            if (syntheticEvents$1[prop]) {
                handleSyntheticEvent$1(prop, lastValue, nextValue, dom);
            }
            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
                patchEvent$1(prop, lastValue, nextValue, dom);
            }
            else if (isNullOrUndef$3(nextValue)) {
                dom.removeAttribute(prop);
            }
            else if (isSVG && namespaces$1[prop]) {
                // We optimize for isSVG being false
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces$1[prop], prop, nextValue);
            }
            else {
                dom.setAttribute(prop, nextValue);
            }
            break;
    }
}
function mountProps$1(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
        hasControlledValue = isControlledFormElement$1(props);
        if (hasControlledValue) {
            addFormElementEventHandlers$1(flags, dom, props);
        }
    }
    for (var prop in props) {
        // do not add a hasOwnProperty check here, it affects performance
        patchProp$1(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
        processElement$1(flags, vNode, dom, props, true, hasControlledValue);
    }
}

function renderNewInput$1(instance, props, context) {
    var nextInput = normalizeRoot$1(instance.render(props, instance.state, context));
    var childContext = context;
    if (isFunction$3(instance.getChildContext)) {
        childContext = combineFrom$3(context, instance.getChildContext());
    }
    instance.$CX = childContext;
    return nextInput;
}
function createClassComponentInstance$1(vNode, Component, props, context, isSVG, lifecycle) {
    var instance = new Component(props, context);
    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));
    instance.$SVG = isSVG;
    instance.$L = lifecycle;
    vNode.children = instance;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ$2) {
        instance.props = props;
    }
    if (!usesNewAPI) {
        if (isFunction$3(instance.componentWillMount)) {
            instance.$BR = true;
            instance.componentWillMount();
            var pending = instance.$PS;
            if (!isNull$2(pending)) {
                var state = instance.state;
                if (isNull$2(state)) {
                    instance.state = pending;
                }
                else {
                    for (var key in pending) {
                        state[key] = pending[key];
                    }
                }
                instance.$PS = null;
            }
            instance.$BR = false;
        }
    }
    else {
        instance.state = createDerivedState$1(instance, props, instance.state);
    }
    instance.$LI = renderNewInput$1(instance, props, context);
    return instance;
}

function mount$2(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 481 /* Element */) {
        mountElement$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 4 /* ComponentClass */) {
        mountClassComponent$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 8 /* ComponentFunction */) {
        mountFunctionalComponent$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
        mountFunctionalComponentCallbacks$1(vNode, lifecycle);
    }
    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {
        mountText$1(vNode, parentDOM, nextNode);
    }
    else if (flags & 8192 /* Fragment */) {
        mountFragment$1(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
    }
    else if (flags & 1024 /* Portal */) {
        mountPortal$1(vNode, context, parentDOM, nextNode, lifecycle);
    }
}
function mountPortal$1(vNode, context, parentDOM, nextNode, lifecycle) {
    mount$2(vNode.children, vNode.ref, context, false, null, lifecycle);
    var placeHolderVNode = createVoidVNode$2();
    mountText$1(placeHolderVNode, parentDOM, nextNode);
    vNode.dom = placeHolderVNode.dom;
}
function mountFragment$1(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {
        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;
        children = vNode.children = createVoidVNode$2();
    }
    if (childFlags === 2 /* HasVNodeChildren */) {
        mount$2(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);
    }
    else {
        mountArrayChildren$1(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
}
function mountText$1(vNode, parentDOM, nextNode) {
    var dom = (vNode.dom = document.createTextNode(vNode.children));
    if (!isNull$2(parentDOM)) {
        insertOrAppend$1(parentDOM, dom, nextNode);
    }
}
function mountElement$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = vNode.flags;
    var props = vNode.props;
    var className = vNode.className;
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    var dom = (vNode.dom = documentCreateElement$1(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));
    if (!isNullOrUndef$3(className) && className !== '') {
        if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
    }
    if (childFlags === 16 /* HasTextChildren */) {
        setTextContent$1(dom, children);
    }
    else if (childFlags !== 1 /* HasInvalidChildren */) {
        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (children.flags & 16384 /* InUse */) {
                vNode.children = children = directClone$2(children);
            }
            mount$2(children, dom, context, childrenIsSVG, null, lifecycle);
        }
        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {
            mountArrayChildren$1(children, dom, context, childrenIsSVG, null, lifecycle);
        }
    }
    if (!isNull$2(parentDOM)) {
        insertOrAppend$1(parentDOM, dom, nextNode);
    }
    if (!isNull$2(props)) {
        mountProps$1(vNode, flags, props, dom, isSVG);
    }
    mountRef$1(vNode.ref, dom, lifecycle);
}
function mountArrayChildren$1(children, dom, context, isSVG, nextNode, lifecycle) {
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child.flags & 16384 /* InUse */) {
            children[i] = child = directClone$2(child);
        }
        mount$2(child, dom, context, isSVG, nextNode, lifecycle);
    }
}
function mountClassComponent$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = createClassComponentInstance$1(vNode, vNode.type, vNode.props || EMPTY_OBJ$2, context, isSVG, lifecycle);
    mount$2(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    mountClassComponentCallbacks$1(vNode.ref, instance, lifecycle);
}
function renderFunctionalComponent$1(vNode, context) {
    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(vNode.props || EMPTY_OBJ$2, vNode.ref, context) : vNode.type(vNode.props || EMPTY_OBJ$2, context);
}
function mountFunctionalComponent$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    mount$2((vNode.children = normalizeRoot$1(renderFunctionalComponent$1(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback$1(instance) {
    return function () {
        instance.componentDidMount();
    };
}
function mountClassComponentCallbacks$1(ref, instance, lifecycle) {
    mountRef$1(ref, instance, lifecycle);
    if (isFunction$3(instance.componentDidMount)) {
        lifecycle.push(createClassMountCallback$1(instance));
    }
}
function createOnMountCallback$1(ref, vNode) {
    return function () {
        ref.onComponentDidMount(findDOMfromVNode$1(vNode, true), vNode.props || EMPTY_OBJ$2);
    };
}
function mountFunctionalComponentCallbacks$1(vNode, lifecycle) {
    var ref = vNode.ref;
    if (!isNullOrUndef$3(ref)) {
        safeCall1$1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ$2);
        if (isFunction$3(ref.onComponentDidMount)) {
            lifecycle.push(createOnMountCallback$1(ref, vNode));
        }
    }
}

function replaceWithNewNode$1(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    unmount$2(lastVNode);
    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {
        mount$2(nextVNode, null, context, isSVG, null, lifecycle);
        // Single DOM operation, when we have dom references available
        replaceChild$1(parentDOM, nextVNode.dom, lastVNode.dom);
    }
    else {
        mount$2(nextVNode, parentDOM, context, isSVG, findDOMfromVNode$1(lastVNode, true), lifecycle);
        removeVNodeDOM$1(lastVNode, parentDOM);
    }
}
function patch$1(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);
    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {
        if (lastVNode.flags & 16384 /* InUse */) {
            replaceWithNewNode$1(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
        }
        else {
            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one
            mount$2(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (nextFlags & 481 /* Element */) {
        patchElement$1(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
    }
    else if (nextFlags & 4 /* ComponentClass */) {
        patchClassComponent$1(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 8 /* ComponentFunction */) {
        patchFunctionalComponent$1(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 16 /* Text */) {
        patchText$1(lastVNode, nextVNode);
    }
    else if (nextFlags & 512 /* Void */) {
        nextVNode.dom = lastVNode.dom;
    }
    else if (nextFlags & 8192 /* Fragment */) {
        patchFragment$1(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    }
    else {
        patchPortal$1(lastVNode, nextVNode, context, lifecycle);
    }
}
function patchSingleTextChild$1(lastChildren, nextChildren, parentDOM) {
    if (lastChildren !== nextChildren) {
        if (lastChildren !== '') {
            parentDOM.firstChild.nodeValue = nextChildren;
        }
        else {
            setTextContent$1(parentDOM, nextChildren);
        }
    }
}
function patchContentEditableChildren$1(dom, nextChildren) {
    if (dom.textContent !== nextChildren) {
        dom.textContent = nextChildren;
    }
}
function patchFragment$1(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastChildFlags = lastVNode.childFlags;
    var nextChildFlags = nextVNode.childFlags;
    var nextNode = null;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {
        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;
        nextChildren = nextVNode.children = createVoidVNode$2();
    }
    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;
    if (lastChildFlags & 12 /* MultipleChildren */) {
        var lastLen = lastChildren.length;
        // We need to know Fragment's edge node when
        if (
        // It uses keyed algorithm
        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||
            // It transforms from many to single
            nextIsSingle ||
            // It will append more nodes
            (!nextIsSingle && nextChildren.length > lastLen)) {
            // When fragment has multiple children there is always at least one vNode
            nextNode = findDOMfromVNode$1(lastChildren[lastLen - 1], false).nextSibling;
        }
    }
    patchChildren$1(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal$1(lastVNode, nextVNode, context, lifecycle) {
    var lastContainer = lastVNode.ref;
    var nextContainer = nextVNode.ref;
    var nextChildren = nextVNode.children;
    patchChildren$1(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid$2(nextChildren)) {
        var node = nextChildren.dom;
        removeChild$1(lastContainer, node);
        appendChild$1(nextContainer, node);
    }
}
function patchElement$1(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
    var dom = (nextVNode.dom = lastVNode.dom);
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var isFormElement = false;
    var hasControlledValue = false;
    var nextPropsOrEmpty;
    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
    // inlined patchProps  -- starts --
    if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ$2;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ$2;
        if (nextPropsOrEmpty !== EMPTY_OBJ$2) {
            isFormElement = (nextFlags & 448 /* FormElement */) > 0;
            if (isFormElement) {
                hasControlledValue = isControlledFormElement$1(nextPropsOrEmpty);
            }
            for (var prop in nextPropsOrEmpty) {
                var lastValue = lastPropsOrEmpty[prop];
                var nextValue = nextPropsOrEmpty[prop];
                if (lastValue !== nextValue) {
                    patchProp$1(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ$2) {
            for (var prop$1 in lastPropsOrEmpty) {
                if (isNullOrUndef$3(nextPropsOrEmpty[prop$1]) && !isNullOrUndef$3(lastPropsOrEmpty[prop$1])) {
                    patchProp$1(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
    }
    var nextChildren = nextVNode.children;
    var nextClassName = nextVNode.className;
    // inlined patchProps  -- ends --
    if (lastVNode.className !== nextClassName) {
        if (isNullOrUndef$3(nextClassName)) {
            dom.removeAttribute('class');
        }
        else if (isSVG) {
            dom.setAttribute('class', nextClassName);
        }
        else {
            dom.className = nextClassName;
        }
    }
    if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren$1(dom, nextChildren);
    }
    else {
        patchChildren$1(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);
    }
    if (isFormElement) {
        processElement$1(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
    }
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    if (lastRef !== nextRef) {
        unmountRef$1(lastRef);
        mountRef$1(nextRef, dom, lifecycle);
    }
}
function replaceOneVNodeWithMultipleVNodes$1(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
    unmount$2(lastChildren);
    mountArrayChildren$1(nextChildren, parentDOM, context, isSVG, findDOMfromVNode$1(lastChildren, true), lifecycle);
    removeVNodeDOM$1(lastChildren, parentDOM);
}
function patchChildren$1(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
    switch (lastChildFlags) {
        case 2 /* HasVNodeChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    patch$1(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    remove$1(lastChildren, parentDOM);
                    break;
                case 16 /* HasTextChildren */:
                    unmount$2(lastChildren);
                    setTextContent$1(parentDOM, nextChildren);
                    break;
                default:
                    replaceOneVNodeWithMultipleVNodes$1(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
                    break;
            }
            break;
        case 1 /* HasInvalidChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    mount$2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    break;
                case 16 /* HasTextChildren */:
                    setTextContent$1(parentDOM, nextChildren);
                    break;
                default:
                    mountArrayChildren$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        case 16 /* HasTextChildren */:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    patchSingleTextChild$1(lastChildren, nextChildren, parentDOM);
                    break;
                case 2 /* HasVNodeChildren */:
                    clearDOM$1(parentDOM);
                    mount$2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    clearDOM$1(parentDOM);
                    break;
                default:
                    clearDOM$1(parentDOM);
                    mountArrayChildren$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        default:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    unmountAllChildren$1(lastChildren);
                    setTextContent$1(parentDOM, nextChildren);
                    break;
                case 2 /* HasVNodeChildren */:
                    removeAllChildren$1(parentDOM, parentVNode, lastChildren);
                    mount$2(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    removeAllChildren$1(parentDOM, parentVNode, lastChildren);
                    break;
                default:
                    var lastLength = lastChildren.length | 0;
                    var nextLength = nextChildren.length | 0;
                    // Fast path's for both algorithms
                    if (lastLength === 0) {
                        if (nextLength > 0) {
                            mountArrayChildren$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                        }
                    }
                    else if (nextLength === 0) {
                        removeAllChildren$1(parentDOM, parentVNode, lastChildren);
                    }
                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                        patchKeyedChildren$1(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
                    }
                    else {
                        patchNonKeyedChildren$1(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
                    }
                    break;
            }
            break;
    }
}
function createDidUpdate$1(instance, lastProps, lastState, snapshot, lifecycle) {
    lifecycle.push(function () {
        instance.componentDidUpdate(lastProps, lastState, snapshot);
    });
}
function updateClassComponent$1(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
    var lastState = instance.state;
    var lastProps = instance.props;
    var usesNewAPI = Boolean(instance.$N);
    var hasSCU = isFunction$3(instance.shouldComponentUpdate);
    if (usesNewAPI) {
        nextState = createDerivedState$1(instance, nextProps, nextState !== lastState ? combineFrom$3(lastState, nextState) : nextState);
    }
    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {
        if (!usesNewAPI && isFunction$3(instance.componentWillUpdate)) {
            instance.componentWillUpdate(nextProps, nextState, context);
        }
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
        var snapshot = null;
        var nextInput = renderNewInput$1(instance, nextProps, context);
        if (usesNewAPI && isFunction$3(instance.getSnapshotBeforeUpdate)) {
            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
        }
        patch$1(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
        // Dont update Last input, until patch has been succesfully executed
        instance.$LI = nextInput;
        if (isFunction$3(instance.componentDidUpdate)) {
            createDidUpdate$1(instance, lastProps, lastState, snapshot, lifecycle);
        }
    }
    else {
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
    }
}
function patchClassComponent$1(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = (nextVNode.children = lastVNode.children);
    // If Component has crashed, ignore it to stay functional
    if (isNull$2(instance)) {
        return;
    }
    instance.$L = lifecycle;
    var nextProps = nextVNode.props || EMPTY_OBJ$2;
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    var nextState = instance.state;
    if (!instance.$N) {
        if (isFunction$3(instance.componentWillReceiveProps)) {
            instance.$BR = true;
            instance.componentWillReceiveProps(nextProps, context);
            // If instance component was removed during its own update do nothing.
            if (instance.$UN) {
                return;
            }
            instance.$BR = false;
        }
        if (!isNull$2(instance.$PS)) {
            nextState = combineFrom$3(nextState, instance.$PS);
            instance.$PS = null;
        }
    }
    updateClassComponent$1(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
    if (lastRef !== nextRef) {
        unmountRef$1(lastRef);
        mountRef$1(nextRef, instance, lifecycle);
    }
}
function patchFunctionalComponent$1(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var shouldUpdate = true;
    var nextProps = nextVNode.props || EMPTY_OBJ$2;
    var nextRef = nextVNode.ref;
    var lastProps = lastVNode.props;
    var nextHooksDefined = !isNullOrUndef$3(nextRef);
    var lastInput = lastVNode.children;
    if (nextHooksDefined && isFunction$3(nextRef.onComponentShouldUpdate)) {
        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
    }
    if (shouldUpdate !== false) {
        if (nextHooksDefined && isFunction$3(nextRef.onComponentWillUpdate)) {
            nextRef.onComponentWillUpdate(lastProps, nextProps);
        }
        var type = nextVNode.type;
        var nextInput = normalizeRoot$1(nextVNode.flags & 32768 /* ForwardRef */ ? type.render(nextProps, nextRef, context) : type(nextProps, context));
        patch$1(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
        nextVNode.children = nextInput;
        if (nextHooksDefined && isFunction$3(nextRef.onComponentDidUpdate)) {
            nextRef.onComponentDidUpdate(lastProps, nextProps);
        }
    }
    else {
        nextVNode.children = lastInput;
    }
}
function patchText$1(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = (nextVNode.dom = lastVNode.dom);
    if (nextText !== lastVNode.children) {
        dom.nodeValue = nextText;
    }
}
function patchNonKeyedChildren$1(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; ++i) {
        nextChild = nextChildren[i];
        lastChild = lastChildren[i];
        if (nextChild.flags & 16384 /* InUse */) {
            nextChild = nextChildren[i] = directClone$2(nextChild);
        }
        patch$1(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
        lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; ++i) {
            nextChild = nextChildren[i];
            if (nextChild.flags & 16384 /* InUse */) {
                nextChild = nextChildren[i] = directClone$2(nextChild);
            }
            mount$2(nextChild, dom, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; ++i) {
            remove$1(lastChildren[i], dom);
        }
    }
}
function patchKeyedChildren$1(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    var nextNode;
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[j] = bNode = directClone$2(bNode);
            }
            patch$1(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[j] = bNode;
            ++j;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[j];
            bNode = b[j];
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
        // Sync nodes with the same key at the end.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[bEnd] = bNode = directClone$2(bNode);
            }
            patch$1(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[aEnd] = bNode;
            aEnd--;
            bEnd--;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[aEnd];
            bNode = b[bEnd];
        }
    }
    if (j > aEnd) {
        if (j <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? findDOMfromVNode$1(b[nextPos], true) : outerEdge;
            while (j <= bEnd) {
                bNode = b[j];
                if (bNode.flags & 16384 /* InUse */) {
                    b[j] = bNode = directClone$2(bNode);
                }
                ++j;
                mount$2(bNode, dom, context, isSVG, nextNode, lifecycle);
            }
        }
    }
    else if (j > bEnd) {
        while (j <= aEnd) {
            remove$1(a[j++], dom);
        }
    }
    else {
        patchKeyedChildrenComplex$1(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
    }
}
function patchKeyedChildrenComplex$1(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
    var aNode;
    var bNode;
    var nextPos;
    var i = 0;
    var aStart = j;
    var bStart = j;
    var aLeft = aEnd - j + 1;
    var bLeft = bEnd - j + 1;
    var sources = new Int32Array(bLeft + 1);
    // Keep track if its possible to remove whole DOM using textContent = '';
    var canRemoveWholeContent = aLeft === aLength;
    var moved = false;
    var pos = 0;
    var patched = 0;
    // When sizes are small, just loop them through
    if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                for (j = bStart; j <= bEnd; j++) {
                    bNode = b[j];
                    if (aNode.key === bNode.key) {
                        sources[j - bStart] = i + 1;
                        if (canRemoveWholeContent) {
                            canRemoveWholeContent = false;
                            while (aStart < i) {
                                remove$1(a[aStart++], dom);
                            }
                        }
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        if (bNode.flags & 16384 /* InUse */) {
                            b[j] = bNode = directClone$2(bNode);
                        }
                        patch$1(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                        ++patched;
                        break;
                    }
                }
                if (!canRemoveWholeContent && j > bEnd) {
                    remove$1(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove$1(aNode, dom);
            }
        }
    }
    else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; ++i) {
            keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                j = keyIndex[aNode.key];
                if (j !== void 0) {
                    if (canRemoveWholeContent) {
                        canRemoveWholeContent = false;
                        while (i > aStart) {
                            remove$1(a[aStart++], dom);
                        }
                    }
                    sources[j - bStart] = i + 1;
                    if (pos > j) {
                        moved = true;
                    }
                    else {
                        pos = j;
                    }
                    bNode = b[j];
                    if (bNode.flags & 16384 /* InUse */) {
                        b[j] = bNode = directClone$2(bNode);
                    }
                    patch$1(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                    ++patched;
                }
                else if (!canRemoveWholeContent) {
                    remove$1(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove$1(aNode, dom);
            }
        }
    }
    // fast-path: if nothing patched remove all old and add all new
    if (canRemoveWholeContent) {
        removeAllChildren$1(dom, parentVNode, a);
        mountArrayChildren$1(b, dom, context, isSVG, outerEdge, lifecycle);
    }
    else if (moved) {
        var seq = lis_algorithm$1(sources);
        j = seq.length - 1;
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone$2(bNode);
                }
                nextPos = pos + 1;
                mount$2(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode$1(b[nextPos], true) : outerEdge, lifecycle);
            }
            else if (j < 0 || i !== seq[j]) {
                pos = i + bStart;
                bNode = b[pos];
                nextPos = pos + 1;
                moveVNodeDOM$1(bNode, dom, nextPos < bLength ? findDOMfromVNode$1(b[nextPos], true) : outerEdge);
            }
            else {
                j--;
            }
        }
    }
    else if (patched !== bLeft) {
        // when patched count doesn't match b length we need to insert those new ones
        // loop backwards so we can use insertBefore
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone$2(bNode);
                }
                nextPos = pos + 1;
                mount$2(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode$1(b[nextPos], true) : outerEdge, lifecycle);
            }
        }
    }
}
var result$1;
var p$2;
var maxLen$1 = 0;
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm$1(arr) {
    var arrI = 0;
    var i = 0;
    var j = 0;
    var k = 0;
    var u = 0;
    var v = 0;
    var c = 0;
    var len = arr.length;
    if (len > maxLen$1) {
        maxLen$1 = len;
        result$1 = new Int32Array(len);
        p$2 = new Int32Array(len);
    }
    for (; i < len; ++i) {
        arrI = arr[i];
        if (arrI !== 0) {
            j = result$1[k];
            if (arr[j] < arrI) {
                p$2[i] = j;
                result$1[++k] = i;
                continue;
            }
            u = 0;
            v = k;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result$1[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result$1[u]]) {
                if (u > 0) {
                    p$2[i] = result$1[u - 1];
                }
                result$1[u] = i;
            }
        }
    }
    u = k + 1;
    var seq = new Int32Array(u);
    v = result$1[u - 1];
    while (u-- > 0) {
        seq[u] = v;
        v = p$2[v];
        result$1[u] = 0;
    }
    return seq;
}

var hasDocumentAvailable$2 = typeof document !== 'undefined';
if (hasDocumentAvailable$2) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}
function __render(input, parentDOM, callback, context) {
    var lifecycle = [];
    var rootInput = parentDOM.$V;
    renderCheck$1.v = true;
    if (isNullOrUndef$3(rootInput)) {
        if (!isNullOrUndef$3(input)) {
            if (input.flags & 16384 /* InUse */) {
                input = directClone$2(input);
            }
            mount$2(input, parentDOM, context, false, null, lifecycle);
            parentDOM.$V = input;
            rootInput = input;
        }
    }
    else {
        if (isNullOrUndef$3(input)) {
            remove$1(rootInput, parentDOM);
            parentDOM.$V = null;
        }
        else {
            if (input.flags & 16384 /* InUse */) {
                input = directClone$2(input);
            }
            patch$1(rootInput, input, parentDOM, context, false, null, lifecycle);
            rootInput = parentDOM.$V = input;
        }
    }
    if (lifecycle.length > 0) {
        callAll$1(lifecycle);
    }
    renderCheck$1.v = false;
    if (isFunction$3(callback)) {
        callback();
    }
    if (isFunction$3(options$1.renderComplete)) {
        options$1.renderComplete(rootInput, parentDOM);
    }
}
function render(input, parentDOM, callback, context) {
    if ( callback === void 0 ) callback = null;
    if ( context === void 0 ) context = EMPTY_OBJ$2;

    __render(input, parentDOM, callback, context);
}
function createRenderer(parentDOM) {
    return function renderer(lastInput, nextInput, callback, context) {
        if (!parentDOM) {
            parentDOM = lastInput;
        }
        render(nextInput, parentDOM, callback, context);
    };
}

var QUEUE$1 = [];
var nextTick$1 = typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };
var microTaskPending$1 = false;
function queueStateChanges$1(component, newState, callback, force) {
    var pending = component.$PS;
    if (isFunction$3(newState)) {
        newState = newState(pending ? combineFrom$3(component.state, pending) : component.state, component.props, component.context);
    }
    if (isNullOrUndef$3(pending)) {
        component.$PS = newState;
    }
    else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component.$BR) {
        if (!renderCheck$1.v) {
            if (QUEUE$1.length === 0) {
                applyState$1(component, force, callback);
                return;
            }
        }
        if (QUEUE$1.indexOf(component) === -1) {
            QUEUE$1.push(component);
        }
        if (!microTaskPending$1) {
            microTaskPending$1 = true;
            nextTick$1(rerender$1);
        }
        if (isFunction$3(callback)) {
            var QU = component.$QU;
            if (!QU) {
                QU = component.$QU = [];
            }
            QU.push(callback);
        }
    }
    else if (isFunction$3(callback)) {
        component.$L.push(callback.bind(component));
    }
}
function callSetStateCallbacks$1(component) {
    var queue = component.$QU;
    for (var i = 0, len = queue.length; i < len; ++i) {
        queue[i].call(component);
    }
    component.$QU = null;
}
function rerender$1() {
    var component;
    microTaskPending$1 = false;
    while ((component = QUEUE$1.pop())) {
        var queue = component.$QU;
        applyState$1(component, false, queue ? callSetStateCallbacks$1.bind(null, component) : null);
    }
}
function applyState$1(component, force, callback) {
    if (component.$UN) {
        return;
    }
    if (force || !component.$BR) {
        var pendingState = component.$PS;
        component.$PS = null;
        var lifecycle = [];
        renderCheck$1.v = true;
        updateClassComponent$1(component, combineFrom$3(component.state, pendingState), component.props, findDOMfromVNode$1(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
        if (lifecycle.length > 0) {
            callAll$1(lifecycle);
        }
        renderCheck$1.v = false;
    }
    else {
        component.state = component.$PS;
        component.$PS = null;
    }
    if (isFunction$3(callback)) {
        callback.call(component);
    }
}
var Component$1 = function Component(props, context) {
    // Public
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$QU = null; // QUEUE
    this.$N = false; // Uses new lifecycle API Flag
    this.$L = null; // Current lifecycle of this component
    this.$SVG = false; // Flag to keep track if component is inside SVG tree
    this.props = props || EMPTY_OBJ$2;
    this.context = context || EMPTY_OBJ$2; // context should not be mutable
};
Component$1.prototype.forceUpdate = function forceUpdate (callback) {
    if (this.$UN) {
        return;
    }
    // Do not allow double render during force update
    queueStateChanges$1(this, {}, callback, true);
};
Component$1.prototype.setState = function setState (newState, callback) {
    if (this.$UN) {
        return;
    }
    if (!this.$BS) {
        queueStateChanges$1(this, newState, callback, false);
    }
};
Component$1.prototype.render = function render (_nextProps, _nextState, _nextContext) {
    return null;
};

var version = "7.3.2";var index_esm=/*#__PURE__*/Object.freeze({__proto__:null,Component:Component$1,EMPTY_OBJ:EMPTY_OBJ$2,Fragment:Fragment$1,_CI:createClassComponentInstance$1,_HI:normalizeRoot$1,_M:mount$2,_MCCC:mountClassComponentCallbacks$1,_ME:mountElement$1,_MFCC:mountFunctionalComponentCallbacks$1,_MP:mountProps$1,_MR:mountRef$1,__render:__render,createComponentVNode:createComponentVNode$2,createFragment:createFragment$2,createPortal:createPortal,createRef:createRef,createRenderer:createRenderer,createTextVNode:createTextVNode$2,createVNode:createVNode$2,directClone:directClone$2,findDOMfromVNode:findDOMfromVNode$1,forwardRef:forwardRef,getFlagsForElementVnode:getFlagsForElementVnode$1,linkEvent:linkEvent,normalizeProps:normalizeProps$1,options:options$1,render:render,rerender:rerender$1,version:version});var isArray$2 = Array.isArray;
function isStringOrNumber$1(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef$2(o) {
    return o === void 0 || o === null;
}
function isInvalid$1(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction$2(o) {
    return typeof o === 'function';
}
function isString$2(o) {
    return typeof o === 'string';
}
function isNumber$1(o) {
    return typeof o === 'number';
}
function isNull$1(o) {
    return o === null;
}
function isUndefined$2(o) {
    return o === void 0;
}
function combineFrom$2(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ$1 = {};
var Fragment = '$F';
function mergeUnsetProperties$1(to, from) {
    for (var propName in from) {
        if (isUndefined$2(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}

var keyPrefix$1 = '$';
function V$1(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode$1(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V$1(childFlag, children, className, flags, key, props, ref, type);
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren$1(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks$1(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef$2(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef$2(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties$1(ref, defaultHooks);
}
function mergeDefaultProps$1(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef$2(defaultProps)) {
        return props;
    }
    if (isNullOrUndef$2(props)) {
        return combineFrom$2(defaultProps, null);
    }
    return mergeUnsetProperties$1(props, defaultProps);
}
function resolveComponentFlags$1(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode$1(flags, type, props, key, ref) {
    flags = resolveComponentFlags$1(flags, type);
    var vNode = new V$1(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps$1(flags, type, props), mergeDefaultHooks$1(flags, type, ref), type);
    return vNode;
}
function createTextVNode$1(text, key) {
    return new V$1(1 /* HasInvalidChildren */, isNullOrUndef$2(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment$1(children, childFlags, key) {
    var fragment = createVNode$1(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode$1();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode$1(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment$1(vNodeToClone) {
    var clonedChildren;
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    if (childFlags === 2 /* HasVNodeChildren */) {
        clonedChildren = directClone$1(oldChildren);
    }
    else if (childFlags & 12 /* MultipleChildren */) {
        clonedChildren = [];
        for (var i = 0, len = oldChildren.length; i < len; ++i) {
            clonedChildren.push(directClone$1(oldChildren[i]));
        }
    }
    return createFragment$1(clonedChildren, childFlags, vNodeToClone.key);
}
function directClone$1(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull$1(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V$1(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment$1(vNodeToClone);
}
function createVoidVNode$1() {
    return createTextVNode$1('', null);
}
function _normalizeVNodes$1(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid$1(n)) {
            var newKey = currentKey + keyPrefix$1 + index;
            if (isArray$2(n)) {
                _normalizeVNodes$1(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber$1(n)) {
                    n = createTextVNode$1(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString$2(oldKey) && oldKey[0] === keyPrefix$1;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone$1(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull$1(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function getFlagsForElementVnode(type) {
    switch (type) {
        case 'svg':
            return 32 /* SvgElement */;
        case 'input':
            return 64 /* InputElement */;
        case 'select':
            return 256 /* SelectElement */;
        case 'textarea':
            return 128 /* TextareaElement */;
        case Fragment:
            return 8192 /* Fragment */;
        default:
            return 1 /* HtmlElement */;
    }
}
function normalizeChildren$1(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid$1(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber$1(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray$2(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid$1(n) || isArray$2(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes$1(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber$1(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode$1(n, keyPrefix$1 + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull$1(key);
                var isPrefixed = isString$2(key) && key[0] === keyPrefix$1;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone$1(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix$1 + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone$1(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}

function triggerEventListener$1(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction$1(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ$1;
        var dom = vNode.dom;
        if (isString$2(methodName)) {
            triggerEventListener$1(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener$1(props, methodName[i], e);
            }
        }
        if (isFunction$2(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ$1;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function isCheckedType$1(type) {
    return type === 'checkbox' || type === 'radio';
}
createWrappedFunction$1('onInput', applyValueInput$1);
createWrappedFunction$1(['onClick', 'onChange'], applyValueInput$1);
function applyValueInput$1(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef$2(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef$2(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef$2(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType$1(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef$2(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef$2(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions$1(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption$1(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions$1(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions$1(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions$1(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions$1(children[i], value);
            }
        }
    }
}
function updateChildOption$1(vNode, value) {
    var props = vNode.props || EMPTY_OBJ$1;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray$2(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef$2(value) || !isNullOrUndef$2(props.selected)) {
        dom.selected = props.selected || false;
    }
}
createWrappedFunction$1('onChange', applyValueSelect$1);
function applyValueSelect$1(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef$2(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber$1(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef$2(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions$1(vNode, value);
    }
}

createWrappedFunction$1('onInput', applyValueTextArea$1);
createWrappedFunction$1('onChange');
function applyValueTextArea$1(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef$2(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef$2(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

var hasDocumentAvailable$1 = typeof document !== 'undefined';
if (hasDocumentAvailable$1) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}
typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };function isNullOrUndef$1(o) {
    return o === void 0 || o === null;
}
function isString$1(o) {
    return typeof o === 'string';
}
function isUndefined$1(o) {
    return o === void 0;
}

var componentHooks = {
    onComponentDidMount: 1,
    onComponentDidUpdate: 1,
    onComponentShouldUpdate: 1,
    onComponentWillMount: 1,
    onComponentWillUnmount: 1,
    onComponentWillUpdate: 1
};
function createElement(type, props, _children) {
    var arguments$1 = arguments;
    var children;
    var ref = null;
    var key = null;
    var className = null;
    var flags = 0;
    var newProps;
    var childLen = arguments.length - 2;
    if (childLen === 1) {
        children = _children;
    }
    else if (childLen > 1) {
        children = [];
        while (childLen-- > 0) {
            children[childLen] = arguments$1[childLen + 2];
        }
    }
    if (isString$1(type)) {
        flags = getFlagsForElementVnode(type);
        if (!isNullOrUndef$1(props)) {
            newProps = {};
            for (var prop in props) {
                if (prop === 'className' || prop === 'class') {
                    className = props[prop];
                }
                else if (prop === 'key') {
                    key = props.key;
                }
                else if (prop === 'children' && isUndefined$1(children)) {
                    children = props.children; // always favour children args over props
                }
                else if (prop === 'ref') {
                    ref = props.ref;
                }
                else {
                    if (prop === 'contenteditable') {
                        flags |= 4096 /* ContentEditable */;
                    }
                    newProps[prop] = props[prop];
                }
            }
        }
    }
    else {
        flags = 2 /* ComponentUnknown */;
        if (!isUndefined$1(children)) {
            if (!props) {
                props = {};
            }
            props.children = children;
        }
        if (!isNullOrUndef$1(props)) {
            newProps = {};
            for (var prop$1 in props) {
                if (prop$1 === 'key') {
                    key = props.key;
                }
                else if (prop$1 === 'ref') {
                    ref = props.ref;
                }
                else if (componentHooks[prop$1] === 1) {
                    if (!ref) {
                        ref = {};
                    }
                    ref[prop$1] = props[prop$1];
                }
                else {
                    newProps[prop$1] = props[prop$1];
                }
            }
        }
        return createComponentVNode$1(flags, type, newProps, key, ref);
    }
    if (flags & 8192 /* Fragment */) {
        return createFragment$1(childLen === 1 ? [children] : children, 0 /* UnknownChildren */, key);
    }
    return createVNode$1(flags, type, className, children, 0 /* UnknownChildren */, newProps, key, ref);
}var hoistNonInfernoStatics = {exports: {}};(function (module) {

var INFERNO_STATICS = {
    childContextTypes: true,
    contextTypes: true,
    defaultProps: true,
    displayName: true,
    getDefaultProps: true,
    propTypes: true,
    type: true
};

var KNOWN_STATICS = {
    name: true,
    length: true,
    prototype: true,
    caller: true,
    arguments: true,
    arity: true
};

var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';

function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
    if (typeof sourceComponent !== 'string') { // don't hoist over string (html) components
        var keys = Object.getOwnPropertyNames(sourceComponent);

        /* istanbul ignore else */
        if (isGetOwnPropertySymbolsAvailable) {
            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
        }

        for (var i = 0; i < keys.length; ++i) {
            if (!INFERNO_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
                try {
                    targetComponent[keys[i]] = sourceComponent[keys[i]];
                } catch (error) {

                }
            }
        }
    }

    return targetComponent;
}
module.exports = hoistNonReactStatics;
module.exports.default = module.exports;
}(hoistNonInfernoStatics));

var hoistNonReactStatics = hoistNonInfernoStatics.exports;var isArray$1 = Array.isArray;
function isStringOrNumber(o) {
    var type = typeof o;
    return type === 'string' || type === 'number';
}
function isNullOrUndef(o) {
    return o === void 0 || o === null;
}
function isInvalid(o) {
    return o === null || o === false || o === true || o === void 0;
}
function isFunction$1(o) {
    return typeof o === 'function';
}
function isString(o) {
    return typeof o === 'string';
}
function isNumber(o) {
    return typeof o === 'number';
}
function isNull(o) {
    return o === null;
}
function isUndefined(o) {
    return o === void 0;
}
function combineFrom$1(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}
// object.event should always be function, otherwise its badly created object.
function isLinkEventObject(o) {
    return !isNull(o) && typeof o === 'object';
}

// We need EMPTY_OBJ defined in one place.
// Its used for comparison so we cant inline it into shared
var EMPTY_OBJ = {};
function normalizeEventName(name) {
    return name.substr(2).toLowerCase();
}
function appendChild(parentDOM, dom) {
    parentDOM.appendChild(dom);
}
function insertOrAppend(parentDOM, newNode, nextNode) {
    if (isNull(nextNode)) {
        appendChild(parentDOM, newNode);
    }
    else {
        parentDOM.insertBefore(newNode, nextNode);
    }
}
function documentCreateElement(tag, isSVG) {
    if (isSVG) {
        return document.createElementNS('http://www.w3.org/2000/svg', tag);
    }
    return document.createElement(tag);
}
function replaceChild(parentDOM, newDom, lastDom) {
    parentDOM.replaceChild(newDom, lastDom);
}
function removeChild(parentDOM, childNode) {
    parentDOM.removeChild(childNode);
}
function callAll(arrayFn) {
    for (var i = 0; i < arrayFn.length; i++) {
        arrayFn[i]();
    }
}
function findChildVNode(vNode, startEdge, flags) {
    var children = vNode.children;
    if (flags & 4 /* ComponentClass */) {
        return children.$LI;
    }
    if (flags & 8192 /* Fragment */) {
        return vNode.childFlags === 2 /* HasVNodeChildren */ ? children : children[startEdge ? 0 : children.length - 1];
    }
    return children;
}
function findDOMfromVNode(vNode, startEdge) {
    var flags;
    while (vNode) {
        flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            return vNode.dom;
        }
        vNode = findChildVNode(vNode, startEdge, flags);
    }
    return null;
}
function removeVNodeDOM(vNode, parentDOM) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            removeChild(parentDOM, vNode.dom);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    removeVNodeDOM(children[i], parentDOM);
                }
                return;
            }
        }
    } while (vNode);
}
function moveVNodeDOM(vNode, parentDOM, nextNode) {
    do {
        var flags = vNode.flags;
        if (flags & 2033 /* DOMRef */) {
            insertOrAppend(parentDOM, vNode.dom, nextNode);
            return;
        }
        var children = vNode.children;
        if (flags & 4 /* ComponentClass */) {
            vNode = children.$LI;
        }
        if (flags & 8 /* ComponentFunction */) {
            vNode = children;
        }
        if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags === 2 /* HasVNodeChildren */) {
                vNode = children;
            }
            else {
                for (var i = 0, len = children.length; i < len; ++i) {
                    moveVNodeDOM(children[i], parentDOM, nextNode);
                }
                return;
            }
        }
    } while (vNode);
}
function createDerivedState(instance, nextProps, state) {
    if (instance.constructor.getDerivedStateFromProps) {
        return combineFrom$1(state, instance.constructor.getDerivedStateFromProps(nextProps, state));
    }
    return state;
}
var renderCheck = {
    v: false
};
function setTextContent(dom, children) {
    dom.textContent = children;
}
// Calling this function assumes, nextValue is linkEvent
function isLastValueSameLinkEvent(lastValue, nextValue) {
    return (isLinkEventObject(lastValue) &&
        lastValue.event === nextValue.event &&
        lastValue.data === nextValue.data);
}
function mergeUnsetProperties(to, from) {
    for (var propName in from) {
        if (isUndefined(to[propName])) {
            to[propName] = from[propName];
        }
    }
    return to;
}
function safeCall1(method, arg1) {
    return !!isFunction$1(method) && (method(arg1), true);
}

var keyPrefix = '$';
function V(childFlags, children, className, flags, key, props, ref, type) {
    this.childFlags = childFlags;
    this.children = children;
    this.className = className;
    this.dom = null;
    this.flags = flags;
    this.key = key === void 0 ? null : key;
    this.props = props === void 0 ? null : props;
    this.ref = ref === void 0 ? null : ref;
    this.type = type;
}
function createVNode(flags, type, className, children, childFlags, props, key, ref) {
    var childFlag = childFlags === void 0 ? 1 /* HasInvalidChildren */ : childFlags;
    var vNode = new V(childFlag, children, className, flags, key, props, ref, type);
    if (childFlag === 0 /* UnknownChildren */) {
        normalizeChildren(vNode, vNode.children);
    }
    return vNode;
}
function mergeDefaultHooks(flags, type, ref) {
    if (flags & 4 /* ComponentClass */) {
        return ref;
    }
    var defaultHooks = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultHooks;
    if (isNullOrUndef(defaultHooks)) {
        return ref;
    }
    if (isNullOrUndef(ref)) {
        return defaultHooks;
    }
    return mergeUnsetProperties(ref, defaultHooks);
}
function mergeDefaultProps(flags, type, props) {
    // set default props
    var defaultProps = (flags & 32768 /* ForwardRef */ ? type.render : type).defaultProps;
    if (isNullOrUndef(defaultProps)) {
        return props;
    }
    if (isNullOrUndef(props)) {
        return combineFrom$1(defaultProps, null);
    }
    return mergeUnsetProperties(props, defaultProps);
}
function resolveComponentFlags(flags, type) {
    if (flags & 12 /* ComponentKnown */) {
        return flags;
    }
    if (type.prototype && type.prototype.render) {
        return 4 /* ComponentClass */;
    }
    if (type.render) {
        return 32776 /* ForwardRefComponent */;
    }
    return 8 /* ComponentFunction */;
}
function createComponentVNode(flags, type, props, key, ref) {
    flags = resolveComponentFlags(flags, type);
    var vNode = new V(1 /* HasInvalidChildren */, null, null, flags, key, mergeDefaultProps(flags, type, props), mergeDefaultHooks(flags, type, ref), type);
    return vNode;
}
function createTextVNode(text, key) {
    return new V(1 /* HasInvalidChildren */, isNullOrUndef(text) || text === true || text === false ? '' : text, null, 16 /* Text */, key, null, null, null);
}
function createFragment(children, childFlags, key) {
    var fragment = createVNode(8192 /* Fragment */, 8192 /* Fragment */, null, children, childFlags, null, key, null);
    switch (fragment.childFlags) {
        case 1 /* HasInvalidChildren */:
            fragment.children = createVoidVNode();
            fragment.childFlags = 2 /* HasVNodeChildren */;
            break;
        case 16 /* HasTextChildren */:
            fragment.children = [createTextVNode(children)];
            fragment.childFlags = 4 /* HasNonKeyedChildren */;
            break;
    }
    return fragment;
}
function normalizeProps(vNode) {
    var props = vNode.props;
    if (props) {
        var flags = vNode.flags;
        if (flags & 481 /* Element */) {
            if (props.children !== void 0 && isNullOrUndef(vNode.children)) {
                normalizeChildren(vNode, props.children);
            }
            if (props.className !== void 0) {
                vNode.className = props.className || null;
                props.className = undefined;
            }
        }
        if (props.key !== void 0) {
            vNode.key = props.key;
            props.key = undefined;
        }
        if (props.ref !== void 0) {
            if (flags & 8 /* ComponentFunction */) {
                vNode.ref = combineFrom$1(vNode.ref, props.ref);
            }
            else {
                vNode.ref = props.ref;
            }
            props.ref = undefined;
        }
    }
    return vNode;
}
/*
 * Fragment is different than normal vNode,
 * because when it needs to be cloned we need to clone its children too
 * But not normalize, because otherwise those possibly get KEY and re-mount
 */
function cloneFragment(vNodeToClone) {
    var clonedChildren;
    var oldChildren = vNodeToClone.children;
    var childFlags = vNodeToClone.childFlags;
    if (childFlags === 2 /* HasVNodeChildren */) {
        clonedChildren = directClone(oldChildren);
    }
    else if (childFlags & 12 /* MultipleChildren */) {
        clonedChildren = [];
        for (var i = 0, len = oldChildren.length; i < len; ++i) {
            clonedChildren.push(directClone(oldChildren[i]));
        }
    }
    return createFragment(clonedChildren, childFlags, vNodeToClone.key);
}
function directClone(vNodeToClone) {
    var flags = vNodeToClone.flags & -16385 /* ClearInUse */;
    var props = vNodeToClone.props;
    if (flags & 14 /* Component */) {
        if (!isNull(props)) {
            var propsToClone = props;
            props = {};
            for (var key in propsToClone) {
                props[key] = propsToClone[key];
            }
        }
    }
    if ((flags & 8192 /* Fragment */) === 0) {
        return new V(vNodeToClone.childFlags, vNodeToClone.children, vNodeToClone.className, flags, vNodeToClone.key, props, vNodeToClone.ref, vNodeToClone.type);
    }
    return cloneFragment(vNodeToClone);
}
function createVoidVNode() {
    return createTextVNode('', null);
}
function _normalizeVNodes(nodes, result, index, currentKey) {
    for (var len = nodes.length; index < len; index++) {
        var n = nodes[index];
        if (!isInvalid(n)) {
            var newKey = currentKey + keyPrefix + index;
            if (isArray$1(n)) {
                _normalizeVNodes(n, result, 0, newKey);
            }
            else {
                if (isStringOrNumber(n)) {
                    n = createTextVNode(n, newKey);
                }
                else {
                    var oldKey = n.key;
                    var isPrefixedKey = isString(oldKey) && oldKey[0] === keyPrefix;
                    if (n.flags & 81920 /* InUseOrNormalized */ || isPrefixedKey) {
                        n = directClone(n);
                    }
                    n.flags |= 65536 /* Normalized */;
                    if (!isPrefixedKey) {
                        if (isNull(oldKey)) {
                            n.key = newKey;
                        }
                        else {
                            n.key = currentKey + oldKey;
                        }
                    }
                    else if (oldKey.substring(0, currentKey.length) !== currentKey) {
                        n.key = currentKey + oldKey;
                    }
                }
                result.push(n);
            }
        }
    }
}
function normalizeChildren(vNode, children) {
    var newChildren;
    var newChildFlags = 1 /* HasInvalidChildren */;
    // Don't change children to match strict equal (===) true in patching
    if (isInvalid(children)) {
        newChildren = children;
    }
    else if (isStringOrNumber(children)) {
        newChildFlags = 16 /* HasTextChildren */;
        newChildren = children;
    }
    else if (isArray$1(children)) {
        var len = children.length;
        for (var i = 0; i < len; ++i) {
            var n = children[i];
            if (isInvalid(n) || isArray$1(n)) {
                newChildren = newChildren || children.slice(0, i);
                _normalizeVNodes(children, newChildren, i, '');
                break;
            }
            else if (isStringOrNumber(n)) {
                newChildren = newChildren || children.slice(0, i);
                newChildren.push(createTextVNode(n, keyPrefix + i));
            }
            else {
                var key = n.key;
                var needsCloning = (n.flags & 81920 /* InUseOrNormalized */) > 0;
                var isNullKey = isNull(key);
                var isPrefixed = isString(key) && key[0] === keyPrefix;
                if (needsCloning || isNullKey || isPrefixed) {
                    newChildren = newChildren || children.slice(0, i);
                    if (needsCloning || isPrefixed) {
                        n = directClone(n);
                    }
                    if (isNullKey || isPrefixed) {
                        n.key = keyPrefix + i;
                    }
                    newChildren.push(n);
                }
                else if (newChildren) {
                    newChildren.push(n);
                }
                n.flags |= 65536 /* Normalized */;
            }
        }
        newChildren = newChildren || children;
        if (newChildren.length === 0) {
            newChildFlags = 1 /* HasInvalidChildren */;
        }
        else {
            newChildFlags = 8 /* HasKeyedChildren */;
        }
    }
    else {
        newChildren = children;
        newChildren.flags |= 65536 /* Normalized */;
        if (children.flags & 81920 /* InUseOrNormalized */) {
            newChildren = directClone(children);
        }
        newChildFlags = 2 /* HasVNodeChildren */;
    }
    vNode.children = newChildren;
    vNode.childFlags = newChildFlags;
    return vNode;
}
function normalizeRoot(input) {
    if (isInvalid(input) || isStringOrNumber(input)) {
        return createTextVNode(input, null);
    }
    if (isArray$1(input)) {
        return createFragment(input, 0 /* UnknownChildren */, null);
    }
    return input.flags & 16384 /* InUse */ ? directClone(input) : input;
}

var xlinkNS = 'http://www.w3.org/1999/xlink';
var xmlNS = 'http://www.w3.org/XML/1998/namespace';
var namespaces = {
    'xlink:actuate': xlinkNS,
    'xlink:arcrole': xlinkNS,
    'xlink:href': xlinkNS,
    'xlink:role': xlinkNS,
    'xlink:show': xlinkNS,
    'xlink:title': xlinkNS,
    'xlink:type': xlinkNS,
    'xml:base': xmlNS,
    'xml:lang': xmlNS,
    'xml:space': xmlNS
};

function getDelegatedEventObject(v) {
    return {
        onClick: v,
        onDblClick: v,
        onFocusIn: v,
        onFocusOut: v,
        onKeyDown: v,
        onKeyPress: v,
        onKeyUp: v,
        onMouseDown: v,
        onMouseMove: v,
        onMouseUp: v,
        onTouchEnd: v,
        onTouchMove: v,
        onTouchStart: v
    };
}
var attachedEventCounts = getDelegatedEventObject(0);
var attachedEvents = getDelegatedEventObject(null);
var syntheticEvents = getDelegatedEventObject(true);
function updateOrAddSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (!eventsObject) {
        eventsObject = dom.$EV = getDelegatedEventObject(null);
    }
    if (!eventsObject[name]) {
        if (++attachedEventCounts[name] === 1) {
            attachedEvents[name] = attachEventToDocument(name);
        }
    }
    return eventsObject;
}
function unmountSyntheticEvent(name, dom) {
    var eventsObject = dom.$EV;
    if (eventsObject && eventsObject[name]) {
        if (--attachedEventCounts[name] === 0) {
            document.removeEventListener(normalizeEventName(name), attachedEvents[name]);
            attachedEvents[name] = null;
        }
        eventsObject[name] = null;
    }
}
function handleSyntheticEvent(name, lastEvent, nextEvent, dom) {
    if (isFunction$1(nextEvent)) {
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else if (isLinkEventObject(nextEvent)) {
        if (isLastValueSameLinkEvent(lastEvent, nextEvent)) {
            return;
        }
        updateOrAddSyntheticEvent(name, dom)[name] = nextEvent;
    }
    else {
        unmountSyntheticEvent(name, dom);
    }
}
// When browsers fully support event.composedPath we could loop it through instead of using parentNode property
function getTargetNode(event) {
    return isFunction$1(event.composedPath) ? event.composedPath()[0] : event.target;
}
function dispatchEvents(event, isClick, name, eventData) {
    var dom = getTargetNode(event);
    do {
        // Html Nodes can be nested fe: span inside button in that scenario browser does not handle disabled attribute on parent,
        // because the event listener is on document.body
        // Don't process clicks on disabled elements
        if (isClick && dom.disabled) {
            return;
        }
        var eventsObject = dom.$EV;
        if (eventsObject) {
            var currentEvent = eventsObject[name];
            if (currentEvent) {
                // linkEvent object
                eventData.dom = dom;
                currentEvent.event ? currentEvent.event(currentEvent.data, event) : currentEvent(event);
                if (event.cancelBubble) {
                    return;
                }
            }
        }
        dom = dom.parentNode;
    } while (!isNull(dom));
}
function stopPropagation() {
    this.cancelBubble = true;
    if (!this.immediatePropagationStopped) {
        this.stopImmediatePropagation();
    }
}
function isDefaultPrevented() {
    return this.defaultPrevented;
}
function isPropagationStopped() {
    return this.cancelBubble;
}
function extendEventProperties(event) {
    // Event data needs to be object to save reference to currentTarget getter
    var eventData = {
        dom: document
    };
    event.isDefaultPrevented = isDefaultPrevented;
    event.isPropagationStopped = isPropagationStopped;
    event.stopPropagation = stopPropagation;
    Object.defineProperty(event, 'currentTarget', {
        configurable: true,
        get: function get() {
            return eventData.dom;
        }
    });
    return eventData;
}
function rootClickEvent(name) {
    return function (event) {
        if (event.button !== 0) {
            // Firefox incorrectly triggers click event for mid/right mouse buttons.
            // This bug has been active for 17 years.
            // https://bugzilla.mozilla.org/show_bug.cgi?id=184051
            event.stopPropagation();
            return;
        }
        dispatchEvents(event, true, name, extendEventProperties(event));
    };
}
function rootEvent(name) {
    return function (event) {
        dispatchEvents(event, false, name, extendEventProperties(event));
    };
}
function attachEventToDocument(name) {
    var attachedEvent = name === 'onClick' || name === 'onDblClick' ? rootClickEvent(name) : rootEvent(name);
    document.addEventListener(normalizeEventName(name), attachedEvent);
    return attachedEvent;
}

function isSameInnerHTML(dom, innerHTML) {
    var tempdom = document.createElement('i');
    tempdom.innerHTML = innerHTML;
    return tempdom.innerHTML === dom.innerHTML;
}

function triggerEventListener(props, methodName, e) {
    if (props[methodName]) {
        var listener = props[methodName];
        if (listener.event) {
            listener.event(listener.data, e);
        }
        else {
            listener(e);
        }
    }
    else {
        var nativeListenerName = methodName.toLowerCase();
        if (props[nativeListenerName]) {
            props[nativeListenerName](e);
        }
    }
}
function createWrappedFunction(methodName, applyValue) {
    var fnMethod = function (e) {
        var vNode = this.$V;
        // If vNode is gone by the time event fires, no-op
        if (!vNode) {
            return;
        }
        var props = vNode.props || EMPTY_OBJ;
        var dom = vNode.dom;
        if (isString(methodName)) {
            triggerEventListener(props, methodName, e);
        }
        else {
            for (var i = 0; i < methodName.length; ++i) {
                triggerEventListener(props, methodName[i], e);
            }
        }
        if (isFunction$1(applyValue)) {
            var newVNode = this.$V;
            var newProps = newVNode.props || EMPTY_OBJ;
            applyValue(newProps, dom, false, newVNode);
        }
    };
    Object.defineProperty(fnMethod, 'wrapped', {
        configurable: false,
        enumerable: false,
        value: true,
        writable: false
    });
    return fnMethod;
}

function attachEvent(dom, eventName, handler) {
    var previousKey = "$" + eventName;
    var previousArgs = dom[previousKey];
    if (previousArgs) {
        if (previousArgs[1].wrapped) {
            return;
        }
        dom.removeEventListener(previousArgs[0], previousArgs[1]);
        dom[previousKey] = null;
    }
    if (isFunction$1(handler)) {
        dom.addEventListener(eventName, handler);
        dom[previousKey] = [eventName, handler];
    }
}

function isCheckedType(type) {
    return type === 'checkbox' || type === 'radio';
}
var onTextInputChange = createWrappedFunction('onInput', applyValueInput);
var wrappedOnChange = createWrappedFunction(['onClick', 'onChange'], applyValueInput);
/* tslint:disable-next-line:no-empty */
function emptywrapper(event) {
    event.stopPropagation();
}
emptywrapper.wrapped = true;
function inputEvents(dom, nextPropsOrEmpty) {
    if (isCheckedType(nextPropsOrEmpty.type)) {
        attachEvent(dom, 'change', wrappedOnChange);
        attachEvent(dom, 'click', emptywrapper);
    }
    else {
        attachEvent(dom, 'input', onTextInputChange);
    }
}
function applyValueInput(nextPropsOrEmpty, dom) {
    var type = nextPropsOrEmpty.type;
    var value = nextPropsOrEmpty.value;
    var checked = nextPropsOrEmpty.checked;
    var multiple = nextPropsOrEmpty.multiple;
    var defaultValue = nextPropsOrEmpty.defaultValue;
    var hasValue = !isNullOrUndef(value);
    if (type && type !== dom.type) {
        dom.setAttribute('type', type);
    }
    if (!isNullOrUndef(multiple) && multiple !== dom.multiple) {
        dom.multiple = multiple;
    }
    if (!isNullOrUndef(defaultValue) && !hasValue) {
        dom.defaultValue = defaultValue + '';
    }
    if (isCheckedType(type)) {
        if (hasValue) {
            dom.value = value;
        }
        if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
    else {
        if (hasValue && dom.value !== value) {
            dom.defaultValue = value;
            dom.value = value;
        }
        else if (!isNullOrUndef(checked)) {
            dom.checked = checked;
        }
    }
}

function updateChildOptions(vNode, value) {
    if (vNode.type === 'option') {
        updateChildOption(vNode, value);
    }
    else {
        var children = vNode.children;
        var flags = vNode.flags;
        if (flags & 4 /* ComponentClass */) {
            updateChildOptions(children.$LI, value);
        }
        else if (flags & 8 /* ComponentFunction */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags === 2 /* HasVNodeChildren */) {
            updateChildOptions(children, value);
        }
        else if (vNode.childFlags & 12 /* MultipleChildren */) {
            for (var i = 0, len = children.length; i < len; ++i) {
                updateChildOptions(children[i], value);
            }
        }
    }
}
function updateChildOption(vNode, value) {
    var props = vNode.props || EMPTY_OBJ;
    var dom = vNode.dom;
    // we do this as multiple may have changed
    dom.value = props.value;
    if (props.value === value || (isArray$1(value) && value.indexOf(props.value) !== -1)) {
        dom.selected = true;
    }
    else if (!isNullOrUndef(value) || !isNullOrUndef(props.selected)) {
        dom.selected = props.selected || false;
    }
}
var onSelectChange = createWrappedFunction('onChange', applyValueSelect);
function selectEvents(dom) {
    attachEvent(dom, 'change', onSelectChange);
}
function applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode) {
    var multiplePropInBoolean = Boolean(nextPropsOrEmpty.multiple);
    if (!isNullOrUndef(nextPropsOrEmpty.multiple) && multiplePropInBoolean !== dom.multiple) {
        dom.multiple = multiplePropInBoolean;
    }
    var index = nextPropsOrEmpty.selectedIndex;
    if (index === -1) {
        dom.selectedIndex = -1;
    }
    var childFlags = vNode.childFlags;
    if (childFlags !== 1 /* HasInvalidChildren */) {
        var value = nextPropsOrEmpty.value;
        if (isNumber(index) && index > -1 && dom.options[index]) {
            value = dom.options[index].value;
        }
        if (mounting && isNullOrUndef(value)) {
            value = nextPropsOrEmpty.defaultValue;
        }
        updateChildOptions(vNode, value);
    }
}

var onTextareaInputChange = createWrappedFunction('onInput', applyValueTextArea);
var wrappedOnChange$1 = createWrappedFunction('onChange');
function textAreaEvents(dom, nextPropsOrEmpty) {
    attachEvent(dom, 'input', onTextareaInputChange);
    if (nextPropsOrEmpty.onChange) {
        attachEvent(dom, 'change', wrappedOnChange$1);
    }
}
function applyValueTextArea(nextPropsOrEmpty, dom, mounting) {
    var value = nextPropsOrEmpty.value;
    var domValue = dom.value;
    if (isNullOrUndef(value)) {
        if (mounting) {
            var defaultValue = nextPropsOrEmpty.defaultValue;
            if (!isNullOrUndef(defaultValue) && defaultValue !== domValue) {
                dom.defaultValue = defaultValue;
                dom.value = defaultValue;
            }
        }
    }
    else if (domValue !== value) {
        /* There is value so keep it controlled */
        dom.defaultValue = value;
        dom.value = value;
    }
}

/**
 * There is currently no support for switching same input between controlled and nonControlled
 * If that ever becomes a real issue, then re design controlled elements
 * Currently user must choose either controlled or non-controlled and stick with that
 */
function processElement(flags, vNode, dom, nextPropsOrEmpty, mounting, isControlled) {
    if (flags & 64 /* InputElement */) {
        applyValueInput(nextPropsOrEmpty, dom);
    }
    else if (flags & 256 /* SelectElement */) {
        applyValueSelect(nextPropsOrEmpty, dom, mounting, vNode);
    }
    else if (flags & 128 /* TextareaElement */) {
        applyValueTextArea(nextPropsOrEmpty, dom, mounting);
    }
    if (isControlled) {
        dom.$V = vNode;
    }
}
function addFormElementEventHandlers(flags, dom, nextPropsOrEmpty) {
    if (flags & 64 /* InputElement */) {
        inputEvents(dom, nextPropsOrEmpty);
    }
    else if (flags & 256 /* SelectElement */) {
        selectEvents(dom);
    }
    else if (flags & 128 /* TextareaElement */) {
        textAreaEvents(dom, nextPropsOrEmpty);
    }
}
function isControlledFormElement(nextPropsOrEmpty) {
    return nextPropsOrEmpty.type && isCheckedType(nextPropsOrEmpty.type) ? !isNullOrUndef(nextPropsOrEmpty.checked) : !isNullOrUndef(nextPropsOrEmpty.value);
}
function unmountRef(ref) {
    if (ref) {
        if (!safeCall1(ref, null) && ref.current) {
            ref.current = null;
        }
    }
}
function mountRef(ref, value, lifecycle) {
    if (ref && (isFunction$1(ref) || ref.current !== void 0)) {
        lifecycle.push(function () {
            if (!safeCall1(ref, value) && ref.current !== void 0) {
                ref.current = value;
            }
        });
    }
}

function remove(vNode, parentDOM) {
    unmount$1(vNode);
    removeVNodeDOM(vNode, parentDOM);
}
function unmount$1(vNode) {
    var flags = vNode.flags;
    var children = vNode.children;
    var ref;
    if (flags & 481 /* Element */) {
        ref = vNode.ref;
        var props = vNode.props;
        unmountRef(ref);
        var childFlags = vNode.childFlags;
        if (!isNull(props)) {
            var keys = Object.keys(props);
            for (var i = 0, len = keys.length; i < len; i++) {
                var key = keys[i];
                if (syntheticEvents[key]) {
                    unmountSyntheticEvent(key, vNode.dom);
                }
            }
        }
        if (childFlags & 12 /* MultipleChildren */) {
            unmountAllChildren(children);
        }
        else if (childFlags === 2 /* HasVNodeChildren */) {
            unmount$1(children);
        }
    }
    else if (children) {
        if (flags & 4 /* ComponentClass */) {
            if (isFunction$1(children.componentWillUnmount)) {
                children.componentWillUnmount();
            }
            unmountRef(vNode.ref);
            children.$UN = true;
            unmount$1(children.$LI);
        }
        else if (flags & 8 /* ComponentFunction */) {
            ref = vNode.ref;
            if (!isNullOrUndef(ref) && isFunction$1(ref.onComponentWillUnmount)) {
                ref.onComponentWillUnmount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
            }
            unmount$1(children);
        }
        else if (flags & 1024 /* Portal */) {
            remove(children, vNode.ref);
        }
        else if (flags & 8192 /* Fragment */) {
            if (vNode.childFlags & 12 /* MultipleChildren */) {
                unmountAllChildren(children);
            }
        }
    }
}
function unmountAllChildren(children) {
    for (var i = 0, len = children.length; i < len; ++i) {
        unmount$1(children[i]);
    }
}
function clearDOM(dom) {
    // Optimization for clearing dom
    dom.textContent = '';
}
function removeAllChildren(dom, vNode, children) {
    unmountAllChildren(children);
    if (vNode.flags & 8192 /* Fragment */) {
        removeVNodeDOM(vNode, dom);
    }
    else {
        clearDOM(dom);
    }
}

function wrapLinkEvent(nextValue) {
    // This variable makes sure there is no "this" context in callback
    var ev = nextValue.event;
    return function (e) {
        ev(nextValue.data, e);
    };
}
function patchEvent(name, lastValue, nextValue, dom) {
    if (isLinkEventObject(nextValue)) {
        if (isLastValueSameLinkEvent(lastValue, nextValue)) {
            return;
        }
        nextValue = wrapLinkEvent(nextValue);
    }
    attachEvent(dom, normalizeEventName(name), nextValue);
}
// We are assuming here that we come from patchProp routine
// -nextAttrValue cannot be null or undefined
function patchStyle(lastAttrValue, nextAttrValue, dom) {
    if (isNullOrUndef(nextAttrValue)) {
        dom.removeAttribute('style');
        return;
    }
    var domStyle = dom.style;
    var style;
    var value;
    if (isString(nextAttrValue)) {
        domStyle.cssText = nextAttrValue;
        return;
    }
    if (!isNullOrUndef(lastAttrValue) && !isString(lastAttrValue)) {
        for (style in nextAttrValue) {
            // do not add a hasOwnProperty check here, it affects performance
            value = nextAttrValue[style];
            if (value !== lastAttrValue[style]) {
                domStyle.setProperty(style, value);
            }
        }
        for (style in lastAttrValue) {
            if (isNullOrUndef(nextAttrValue[style])) {
                domStyle.removeProperty(style);
            }
        }
    }
    else {
        for (style in nextAttrValue) {
            value = nextAttrValue[style];
            domStyle.setProperty(style, value);
        }
    }
}
function patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom) {
    var lastHtml = (lastValue && lastValue.__html) || '';
    var nextHtml = (nextValue && nextValue.__html) || '';
    if (lastHtml !== nextHtml) {
        if (!isNullOrUndef(nextHtml) && !isSameInnerHTML(dom, nextHtml)) {
            if (!isNull(lastVNode)) {
                if (lastVNode.childFlags & 12 /* MultipleChildren */) {
                    unmountAllChildren(lastVNode.children);
                }
                else if (lastVNode.childFlags === 2 /* HasVNodeChildren */) {
                    unmount$1(lastVNode.children);
                }
                lastVNode.children = null;
                lastVNode.childFlags = 1 /* HasInvalidChildren */;
            }
            dom.innerHTML = nextHtml;
        }
    }
}
function patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode) {
    switch (prop) {
        case 'children':
        case 'childrenType':
        case 'className':
        case 'defaultValue':
        case 'key':
        case 'multiple':
        case 'ref':
        case 'selectedIndex':
            break;
        case 'autoFocus':
            dom.autofocus = !!nextValue;
            break;
        case 'allowfullscreen':
        case 'autoplay':
        case 'capture':
        case 'checked':
        case 'controls':
        case 'default':
        case 'disabled':
        case 'hidden':
        case 'indeterminate':
        case 'loop':
        case 'muted':
        case 'novalidate':
        case 'open':
        case 'readOnly':
        case 'required':
        case 'reversed':
        case 'scoped':
        case 'seamless':
        case 'selected':
            dom[prop] = !!nextValue;
            break;
        case 'defaultChecked':
        case 'value':
        case 'volume':
            if (hasControlledValue && prop === 'value') {
                break;
            }
            var value = isNullOrUndef(nextValue) ? '' : nextValue;
            if (dom[prop] !== value) {
                dom[prop] = value;
            }
            break;
        case 'style':
            patchStyle(lastValue, nextValue, dom);
            break;
        case 'dangerouslySetInnerHTML':
            patchDangerInnerHTML(lastValue, nextValue, lastVNode, dom);
            break;
        default:
            if (syntheticEvents[prop]) {
                handleSyntheticEvent(prop, lastValue, nextValue, dom);
            }
            else if (prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110) {
                patchEvent(prop, lastValue, nextValue, dom);
            }
            else if (isNullOrUndef(nextValue)) {
                dom.removeAttribute(prop);
            }
            else if (isSVG && namespaces[prop]) {
                // We optimize for isSVG being false
                // If we end up in this path we can read property again
                dom.setAttributeNS(namespaces[prop], prop, nextValue);
            }
            else {
                dom.setAttribute(prop, nextValue);
            }
            break;
    }
}
function mountProps(vNode, flags, props, dom, isSVG) {
    var hasControlledValue = false;
    var isFormElement = (flags & 448 /* FormElement */) > 0;
    if (isFormElement) {
        hasControlledValue = isControlledFormElement(props);
        if (hasControlledValue) {
            addFormElementEventHandlers(flags, dom, props);
        }
    }
    for (var prop in props) {
        // do not add a hasOwnProperty check here, it affects performance
        patchProp(prop, null, props[prop], dom, isSVG, hasControlledValue, null);
    }
    if (isFormElement) {
        processElement(flags, vNode, dom, props, true, hasControlledValue);
    }
}

function renderNewInput(instance, props, context) {
    var nextInput = normalizeRoot(instance.render(props, instance.state, context));
    var childContext = context;
    if (isFunction$1(instance.getChildContext)) {
        childContext = combineFrom$1(context, instance.getChildContext());
    }
    instance.$CX = childContext;
    return nextInput;
}
function createClassComponentInstance(vNode, Component, props, context, isSVG, lifecycle) {
    var instance = new Component(props, context);
    var usesNewAPI = (instance.$N = Boolean(Component.getDerivedStateFromProps || instance.getSnapshotBeforeUpdate));
    instance.$SVG = isSVG;
    instance.$L = lifecycle;
    vNode.children = instance;
    instance.$BS = false;
    instance.context = context;
    if (instance.props === EMPTY_OBJ) {
        instance.props = props;
    }
    if (!usesNewAPI) {
        if (isFunction$1(instance.componentWillMount)) {
            instance.$BR = true;
            instance.componentWillMount();
            var pending = instance.$PS;
            if (!isNull(pending)) {
                var state = instance.state;
                if (isNull(state)) {
                    instance.state = pending;
                }
                else {
                    for (var key in pending) {
                        state[key] = pending[key];
                    }
                }
                instance.$PS = null;
            }
            instance.$BR = false;
        }
    }
    else {
        instance.state = createDerivedState(instance, props, instance.state);
    }
    instance.$LI = renderNewInput(instance, props, context);
    return instance;
}

function mount$1(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = (vNode.flags |= 16384 /* InUse */);
    if (flags & 481 /* Element */) {
        mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 4 /* ComponentClass */) {
        mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (flags & 8 /* ComponentFunction */) {
        mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle);
        mountFunctionalComponentCallbacks(vNode, lifecycle);
    }
    else if (flags & 512 /* Void */ || flags & 16 /* Text */) {
        mountText(vNode, parentDOM, nextNode);
    }
    else if (flags & 8192 /* Fragment */) {
        mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle);
    }
    else if (flags & 1024 /* Portal */) {
        mountPortal(vNode, context, parentDOM, nextNode, lifecycle);
    }
}
function mountPortal(vNode, context, parentDOM, nextNode, lifecycle) {
    mount$1(vNode.children, vNode.ref, context, false, null, lifecycle);
    var placeHolderVNode = createVoidVNode();
    mountText(placeHolderVNode, parentDOM, nextNode);
    vNode.dom = placeHolderVNode.dom;
}
function mountFragment(vNode, context, parentDOM, isSVG, nextNode, lifecycle) {
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (childFlags & 12 /* MultipleChildren */ && children.length === 0) {
        childFlags = vNode.childFlags = 2 /* HasVNodeChildren */;
        children = vNode.children = createVoidVNode();
    }
    if (childFlags === 2 /* HasVNodeChildren */) {
        mount$1(children, parentDOM, nextNode, isSVG, nextNode, lifecycle);
    }
    else {
        mountArrayChildren(children, parentDOM, context, isSVG, nextNode, lifecycle);
    }
}
function mountText(vNode, parentDOM, nextNode) {
    var dom = (vNode.dom = document.createTextNode(vNode.children));
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
}
function mountElement(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var flags = vNode.flags;
    var props = vNode.props;
    var className = vNode.className;
    var children = vNode.children;
    var childFlags = vNode.childFlags;
    var dom = (vNode.dom = documentCreateElement(vNode.type, (isSVG = isSVG || (flags & 32 /* SvgElement */) > 0)));
    if (!isNullOrUndef(className) && className !== '') {
        if (isSVG) {
            dom.setAttribute('class', className);
        }
        else {
            dom.className = className;
        }
    }
    if (childFlags === 16 /* HasTextChildren */) {
        setTextContent(dom, children);
    }
    else if (childFlags !== 1 /* HasInvalidChildren */) {
        var childrenIsSVG = isSVG && vNode.type !== 'foreignObject';
        if (childFlags === 2 /* HasVNodeChildren */) {
            if (children.flags & 16384 /* InUse */) {
                vNode.children = children = directClone(children);
            }
            mount$1(children, dom, context, childrenIsSVG, null, lifecycle);
        }
        else if (childFlags === 8 /* HasKeyedChildren */ || childFlags === 4 /* HasNonKeyedChildren */) {
            mountArrayChildren(children, dom, context, childrenIsSVG, null, lifecycle);
        }
    }
    if (!isNull(parentDOM)) {
        insertOrAppend(parentDOM, dom, nextNode);
    }
    if (!isNull(props)) {
        mountProps(vNode, flags, props, dom, isSVG);
    }
    mountRef(vNode.ref, dom, lifecycle);
}
function mountArrayChildren(children, dom, context, isSVG, nextNode, lifecycle) {
    for (var i = 0; i < children.length; ++i) {
        var child = children[i];
        if (child.flags & 16384 /* InUse */) {
            children[i] = child = directClone(child);
        }
        mount$1(child, dom, context, isSVG, nextNode, lifecycle);
    }
}
function mountClassComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = createClassComponentInstance(vNode, vNode.type, vNode.props || EMPTY_OBJ, context, isSVG, lifecycle);
    mount$1(instance.$LI, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
    mountClassComponentCallbacks(vNode.ref, instance, lifecycle);
}
function renderFunctionalComponent(vNode, context) {
    return vNode.flags & 32768 /* ForwardRef */ ? vNode.type.render(vNode.props || EMPTY_OBJ, vNode.ref, context) : vNode.type(vNode.props || EMPTY_OBJ, context);
}
function mountFunctionalComponent(vNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    mount$1((vNode.children = normalizeRoot(renderFunctionalComponent(vNode, context))), parentDOM, context, isSVG, nextNode, lifecycle);
}
function createClassMountCallback(instance) {
    return function () {
        instance.componentDidMount();
    };
}
function mountClassComponentCallbacks(ref, instance, lifecycle) {
    mountRef(ref, instance, lifecycle);
    if (isFunction$1(instance.componentDidMount)) {
        lifecycle.push(createClassMountCallback(instance));
    }
}
function createOnMountCallback(ref, vNode) {
    return function () {
        ref.onComponentDidMount(findDOMfromVNode(vNode, true), vNode.props || EMPTY_OBJ);
    };
}
function mountFunctionalComponentCallbacks(vNode, lifecycle) {
    var ref = vNode.ref;
    if (!isNullOrUndef(ref)) {
        safeCall1(ref.onComponentWillMount, vNode.props || EMPTY_OBJ);
        if (isFunction$1(ref.onComponentDidMount)) {
            lifecycle.push(createOnMountCallback(ref, vNode));
        }
    }
}

function replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    unmount$1(lastVNode);
    if ((nextVNode.flags & lastVNode.flags & 2033 /* DOMRef */) !== 0) {
        mount$1(nextVNode, null, context, isSVG, null, lifecycle);
        // Single DOM operation, when we have dom references available
        replaceChild(parentDOM, nextVNode.dom, lastVNode.dom);
    }
    else {
        mount$1(nextVNode, parentDOM, context, isSVG, findDOMfromVNode(lastVNode, true), lifecycle);
        removeVNodeDOM(lastVNode, parentDOM);
    }
}
function patch(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var nextFlags = (nextVNode.flags |= 16384 /* InUse */);
    if (lastVNode.flags !== nextFlags || lastVNode.type !== nextVNode.type || lastVNode.key !== nextVNode.key || nextFlags & 2048 /* ReCreate */) {
        if (lastVNode.flags & 16384 /* InUse */) {
            replaceWithNewNode(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
        }
        else {
            // Last vNode is not in use, it has crashed at application level. Just mount nextVNode and ignore last one
            mount$1(nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (nextFlags & 481 /* Element */) {
        patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle);
    }
    else if (nextFlags & 4 /* ComponentClass */) {
        patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 8 /* ComponentFunction */) {
        patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle);
    }
    else if (nextFlags & 16 /* Text */) {
        patchText(lastVNode, nextVNode);
    }
    else if (nextFlags & 512 /* Void */) {
        nextVNode.dom = lastVNode.dom;
    }
    else if (nextFlags & 8192 /* Fragment */) {
        patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle);
    }
    else {
        patchPortal(lastVNode, nextVNode, context, lifecycle);
    }
}
function patchSingleTextChild(lastChildren, nextChildren, parentDOM) {
    if (lastChildren !== nextChildren) {
        if (lastChildren !== '') {
            parentDOM.firstChild.nodeValue = nextChildren;
        }
        else {
            setTextContent(parentDOM, nextChildren);
        }
    }
}
function patchContentEditableChildren(dom, nextChildren) {
    if (dom.textContent !== nextChildren) {
        dom.textContent = nextChildren;
    }
}
function patchFragment(lastVNode, nextVNode, parentDOM, context, isSVG, lifecycle) {
    var lastChildren = lastVNode.children;
    var nextChildren = nextVNode.children;
    var lastChildFlags = lastVNode.childFlags;
    var nextChildFlags = nextVNode.childFlags;
    var nextNode = null;
    // When fragment is optimized for multiple children, check if there is no children and change flag to invalid
    // This is the only normalization always done, to keep optimization flags API same for fragments and regular elements
    if (nextChildFlags & 12 /* MultipleChildren */ && nextChildren.length === 0) {
        nextChildFlags = nextVNode.childFlags = 2 /* HasVNodeChildren */;
        nextChildren = nextVNode.children = createVoidVNode();
    }
    var nextIsSingle = (nextChildFlags & 2 /* HasVNodeChildren */) !== 0;
    if (lastChildFlags & 12 /* MultipleChildren */) {
        var lastLen = lastChildren.length;
        // We need to know Fragment's edge node when
        if (
        // It uses keyed algorithm
        (lastChildFlags & 8 /* HasKeyedChildren */ && nextChildFlags & 8 /* HasKeyedChildren */) ||
            // It transforms from many to single
            nextIsSingle ||
            // It will append more nodes
            (!nextIsSingle && nextChildren.length > lastLen)) {
            // When fragment has multiple children there is always at least one vNode
            nextNode = findDOMfromVNode(lastChildren[lastLen - 1], false).nextSibling;
        }
    }
    patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lastVNode, lifecycle);
}
function patchPortal(lastVNode, nextVNode, context, lifecycle) {
    var lastContainer = lastVNode.ref;
    var nextContainer = nextVNode.ref;
    var nextChildren = nextVNode.children;
    patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, lastContainer, context, false, null, lastVNode, lifecycle);
    nextVNode.dom = lastVNode.dom;
    if (lastContainer !== nextContainer && !isInvalid(nextChildren)) {
        var node = nextChildren.dom;
        removeChild(lastContainer, node);
        appendChild(nextContainer, node);
    }
}
function patchElement(lastVNode, nextVNode, context, isSVG, nextFlags, lifecycle) {
    var dom = (nextVNode.dom = lastVNode.dom);
    var lastProps = lastVNode.props;
    var nextProps = nextVNode.props;
    var isFormElement = false;
    var hasControlledValue = false;
    var nextPropsOrEmpty;
    isSVG = isSVG || (nextFlags & 32 /* SvgElement */) > 0;
    // inlined patchProps  -- starts --
    if (lastProps !== nextProps) {
        var lastPropsOrEmpty = lastProps || EMPTY_OBJ;
        nextPropsOrEmpty = nextProps || EMPTY_OBJ;
        if (nextPropsOrEmpty !== EMPTY_OBJ) {
            isFormElement = (nextFlags & 448 /* FormElement */) > 0;
            if (isFormElement) {
                hasControlledValue = isControlledFormElement(nextPropsOrEmpty);
            }
            for (var prop in nextPropsOrEmpty) {
                var lastValue = lastPropsOrEmpty[prop];
                var nextValue = nextPropsOrEmpty[prop];
                if (lastValue !== nextValue) {
                    patchProp(prop, lastValue, nextValue, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
        if (lastPropsOrEmpty !== EMPTY_OBJ) {
            for (var prop$1 in lastPropsOrEmpty) {
                if (isNullOrUndef(nextPropsOrEmpty[prop$1]) && !isNullOrUndef(lastPropsOrEmpty[prop$1])) {
                    patchProp(prop$1, lastPropsOrEmpty[prop$1], null, dom, isSVG, hasControlledValue, lastVNode);
                }
            }
        }
    }
    var nextChildren = nextVNode.children;
    var nextClassName = nextVNode.className;
    // inlined patchProps  -- ends --
    if (lastVNode.className !== nextClassName) {
        if (isNullOrUndef(nextClassName)) {
            dom.removeAttribute('class');
        }
        else if (isSVG) {
            dom.setAttribute('class', nextClassName);
        }
        else {
            dom.className = nextClassName;
        }
    }
    if (nextFlags & 4096 /* ContentEditable */) {
        patchContentEditableChildren(dom, nextChildren);
    }
    else {
        patchChildren(lastVNode.childFlags, nextVNode.childFlags, lastVNode.children, nextChildren, dom, context, isSVG && nextVNode.type !== 'foreignObject', null, lastVNode, lifecycle);
    }
    if (isFormElement) {
        processElement(nextFlags, nextVNode, dom, nextPropsOrEmpty, false, hasControlledValue);
    }
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, dom, lifecycle);
    }
}
function replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle) {
    unmount$1(lastChildren);
    mountArrayChildren(nextChildren, parentDOM, context, isSVG, findDOMfromVNode(lastChildren, true), lifecycle);
    removeVNodeDOM(lastChildren, parentDOM);
}
function patchChildren(lastChildFlags, nextChildFlags, lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, parentVNode, lifecycle) {
    switch (lastChildFlags) {
        case 2 /* HasVNodeChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    patch(lastChildren, nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    remove(lastChildren, parentDOM);
                    break;
                case 16 /* HasTextChildren */:
                    unmount$1(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    replaceOneVNodeWithMultipleVNodes(lastChildren, nextChildren, parentDOM, context, isSVG, lifecycle);
                    break;
            }
            break;
        case 1 /* HasInvalidChildren */:
            switch (nextChildFlags) {
                case 2 /* HasVNodeChildren */:
                    mount$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    break;
                case 16 /* HasTextChildren */:
                    setTextContent(parentDOM, nextChildren);
                    break;
                default:
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        case 16 /* HasTextChildren */:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    patchSingleTextChild(lastChildren, nextChildren, parentDOM);
                    break;
                case 2 /* HasVNodeChildren */:
                    clearDOM(parentDOM);
                    mount$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    clearDOM(parentDOM);
                    break;
                default:
                    clearDOM(parentDOM);
                    mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
            }
            break;
        default:
            switch (nextChildFlags) {
                case 16 /* HasTextChildren */:
                    unmountAllChildren(lastChildren);
                    setTextContent(parentDOM, nextChildren);
                    break;
                case 2 /* HasVNodeChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    mount$1(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                    break;
                case 1 /* HasInvalidChildren */:
                    removeAllChildren(parentDOM, parentVNode, lastChildren);
                    break;
                default:
                    var lastLength = lastChildren.length | 0;
                    var nextLength = nextChildren.length | 0;
                    // Fast path's for both algorithms
                    if (lastLength === 0) {
                        if (nextLength > 0) {
                            mountArrayChildren(nextChildren, parentDOM, context, isSVG, nextNode, lifecycle);
                        }
                    }
                    else if (nextLength === 0) {
                        removeAllChildren(parentDOM, parentVNode, lastChildren);
                    }
                    else if (nextChildFlags === 8 /* HasKeyedChildren */ && lastChildFlags === 8 /* HasKeyedChildren */) {
                        patchKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, parentVNode, lifecycle);
                    }
                    else {
                        patchNonKeyedChildren(lastChildren, nextChildren, parentDOM, context, isSVG, lastLength, nextLength, nextNode, lifecycle);
                    }
                    break;
            }
            break;
    }
}
function createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle) {
    lifecycle.push(function () {
        instance.componentDidUpdate(lastProps, lastState, snapshot);
    });
}
function updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, force, nextNode, lifecycle) {
    var lastState = instance.state;
    var lastProps = instance.props;
    var usesNewAPI = Boolean(instance.$N);
    var hasSCU = isFunction$1(instance.shouldComponentUpdate);
    if (usesNewAPI) {
        nextState = createDerivedState(instance, nextProps, nextState !== lastState ? combineFrom$1(lastState, nextState) : nextState);
    }
    if (force || !hasSCU || (hasSCU && instance.shouldComponentUpdate(nextProps, nextState, context))) {
        if (!usesNewAPI && isFunction$1(instance.componentWillUpdate)) {
            instance.componentWillUpdate(nextProps, nextState, context);
        }
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
        var snapshot = null;
        var nextInput = renderNewInput(instance, nextProps, context);
        if (usesNewAPI && isFunction$1(instance.getSnapshotBeforeUpdate)) {
            snapshot = instance.getSnapshotBeforeUpdate(lastProps, lastState);
        }
        patch(instance.$LI, nextInput, parentDOM, instance.$CX, isSVG, nextNode, lifecycle);
        // Dont update Last input, until patch has been succesfully executed
        instance.$LI = nextInput;
        if (isFunction$1(instance.componentDidUpdate)) {
            createDidUpdate(instance, lastProps, lastState, snapshot, lifecycle);
        }
    }
    else {
        instance.props = nextProps;
        instance.state = nextState;
        instance.context = context;
    }
}
function patchClassComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var instance = (nextVNode.children = lastVNode.children);
    // If Component has crashed, ignore it to stay functional
    if (isNull(instance)) {
        return;
    }
    instance.$L = lifecycle;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastRef = lastVNode.ref;
    var nextState = instance.state;
    if (!instance.$N) {
        if (isFunction$1(instance.componentWillReceiveProps)) {
            instance.$BR = true;
            instance.componentWillReceiveProps(nextProps, context);
            // If instance component was removed during its own update do nothing.
            if (instance.$UN) {
                return;
            }
            instance.$BR = false;
        }
        if (!isNull(instance.$PS)) {
            nextState = combineFrom$1(nextState, instance.$PS);
            instance.$PS = null;
        }
    }
    updateClassComponent(instance, nextState, nextProps, parentDOM, context, isSVG, false, nextNode, lifecycle);
    if (lastRef !== nextRef) {
        unmountRef(lastRef);
        mountRef(nextRef, instance, lifecycle);
    }
}
function patchFunctionalComponent(lastVNode, nextVNode, parentDOM, context, isSVG, nextNode, lifecycle) {
    var shouldUpdate = true;
    var nextProps = nextVNode.props || EMPTY_OBJ;
    var nextRef = nextVNode.ref;
    var lastProps = lastVNode.props;
    var nextHooksDefined = !isNullOrUndef(nextRef);
    var lastInput = lastVNode.children;
    if (nextHooksDefined && isFunction$1(nextRef.onComponentShouldUpdate)) {
        shouldUpdate = nextRef.onComponentShouldUpdate(lastProps, nextProps);
    }
    if (shouldUpdate !== false) {
        if (nextHooksDefined && isFunction$1(nextRef.onComponentWillUpdate)) {
            nextRef.onComponentWillUpdate(lastProps, nextProps);
        }
        var type = nextVNode.type;
        var nextInput = normalizeRoot(nextVNode.flags & 32768 /* ForwardRef */ ? type.render(nextProps, nextRef, context) : type(nextProps, context));
        patch(lastInput, nextInput, parentDOM, context, isSVG, nextNode, lifecycle);
        nextVNode.children = nextInput;
        if (nextHooksDefined && isFunction$1(nextRef.onComponentDidUpdate)) {
            nextRef.onComponentDidUpdate(lastProps, nextProps);
        }
    }
    else {
        nextVNode.children = lastInput;
    }
}
function patchText(lastVNode, nextVNode) {
    var nextText = nextVNode.children;
    var dom = (nextVNode.dom = lastVNode.dom);
    if (nextText !== lastVNode.children) {
        dom.nodeValue = nextText;
    }
}
function patchNonKeyedChildren(lastChildren, nextChildren, dom, context, isSVG, lastChildrenLength, nextChildrenLength, nextNode, lifecycle) {
    var commonLength = lastChildrenLength > nextChildrenLength ? nextChildrenLength : lastChildrenLength;
    var i = 0;
    var nextChild;
    var lastChild;
    for (; i < commonLength; ++i) {
        nextChild = nextChildren[i];
        lastChild = lastChildren[i];
        if (nextChild.flags & 16384 /* InUse */) {
            nextChild = nextChildren[i] = directClone(nextChild);
        }
        patch(lastChild, nextChild, dom, context, isSVG, nextNode, lifecycle);
        lastChildren[i] = nextChild;
    }
    if (lastChildrenLength < nextChildrenLength) {
        for (i = commonLength; i < nextChildrenLength; ++i) {
            nextChild = nextChildren[i];
            if (nextChild.flags & 16384 /* InUse */) {
                nextChild = nextChildren[i] = directClone(nextChild);
            }
            mount$1(nextChild, dom, context, isSVG, nextNode, lifecycle);
        }
    }
    else if (lastChildrenLength > nextChildrenLength) {
        for (i = commonLength; i < lastChildrenLength; ++i) {
            remove(lastChildren[i], dom);
        }
    }
}
function patchKeyedChildren(a, b, dom, context, isSVG, aLength, bLength, outerEdge, parentVNode, lifecycle) {
    var aEnd = aLength - 1;
    var bEnd = bLength - 1;
    var j = 0;
    var aNode = a[j];
    var bNode = b[j];
    var nextPos;
    var nextNode;
    // Step 1
    // tslint:disable-next-line
    outer: {
        // Sync nodes with the same key at the beginning.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[j] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[j] = bNode;
            ++j;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[j];
            bNode = b[j];
        }
        aNode = a[aEnd];
        bNode = b[bEnd];
        // Sync nodes with the same key at the end.
        while (aNode.key === bNode.key) {
            if (bNode.flags & 16384 /* InUse */) {
                b[bEnd] = bNode = directClone(bNode);
            }
            patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
            a[aEnd] = bNode;
            aEnd--;
            bEnd--;
            if (j > aEnd || j > bEnd) {
                break outer;
            }
            aNode = a[aEnd];
            bNode = b[bEnd];
        }
    }
    if (j > aEnd) {
        if (j <= bEnd) {
            nextPos = bEnd + 1;
            nextNode = nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge;
            while (j <= bEnd) {
                bNode = b[j];
                if (bNode.flags & 16384 /* InUse */) {
                    b[j] = bNode = directClone(bNode);
                }
                ++j;
                mount$1(bNode, dom, context, isSVG, nextNode, lifecycle);
            }
        }
    }
    else if (j > bEnd) {
        while (j <= aEnd) {
            remove(a[j++], dom);
        }
    }
    else {
        patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle);
    }
}
function patchKeyedChildrenComplex(a, b, context, aLength, bLength, aEnd, bEnd, j, dom, isSVG, outerEdge, parentVNode, lifecycle) {
    var aNode;
    var bNode;
    var nextPos;
    var i = 0;
    var aStart = j;
    var bStart = j;
    var aLeft = aEnd - j + 1;
    var bLeft = bEnd - j + 1;
    var sources = new Int32Array(bLeft + 1);
    // Keep track if its possible to remove whole DOM using textContent = '';
    var canRemoveWholeContent = aLeft === aLength;
    var moved = false;
    var pos = 0;
    var patched = 0;
    // When sizes are small, just loop them through
    if (bLength < 4 || (aLeft | bLeft) < 32) {
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                for (j = bStart; j <= bEnd; j++) {
                    bNode = b[j];
                    if (aNode.key === bNode.key) {
                        sources[j - bStart] = i + 1;
                        if (canRemoveWholeContent) {
                            canRemoveWholeContent = false;
                            while (aStart < i) {
                                remove(a[aStart++], dom);
                            }
                        }
                        if (pos > j) {
                            moved = true;
                        }
                        else {
                            pos = j;
                        }
                        if (bNode.flags & 16384 /* InUse */) {
                            b[j] = bNode = directClone(bNode);
                        }
                        patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                        ++patched;
                        break;
                    }
                }
                if (!canRemoveWholeContent && j > bEnd) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    else {
        var keyIndex = {};
        // Map keys by their index
        for (i = bStart; i <= bEnd; ++i) {
            keyIndex[b[i].key] = i;
        }
        // Try to patch same keys
        for (i = aStart; i <= aEnd; ++i) {
            aNode = a[i];
            if (patched < bLeft) {
                j = keyIndex[aNode.key];
                if (j !== void 0) {
                    if (canRemoveWholeContent) {
                        canRemoveWholeContent = false;
                        while (i > aStart) {
                            remove(a[aStart++], dom);
                        }
                    }
                    sources[j - bStart] = i + 1;
                    if (pos > j) {
                        moved = true;
                    }
                    else {
                        pos = j;
                    }
                    bNode = b[j];
                    if (bNode.flags & 16384 /* InUse */) {
                        b[j] = bNode = directClone(bNode);
                    }
                    patch(aNode, bNode, dom, context, isSVG, outerEdge, lifecycle);
                    ++patched;
                }
                else if (!canRemoveWholeContent) {
                    remove(aNode, dom);
                }
            }
            else if (!canRemoveWholeContent) {
                remove(aNode, dom);
            }
        }
    }
    // fast-path: if nothing patched remove all old and add all new
    if (canRemoveWholeContent) {
        removeAllChildren(dom, parentVNode, a);
        mountArrayChildren(b, dom, context, isSVG, outerEdge, lifecycle);
    }
    else if (moved) {
        var seq = lis_algorithm(sources);
        j = seq.length - 1;
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount$1(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
            else if (j < 0 || i !== seq[j]) {
                pos = i + bStart;
                bNode = b[pos];
                nextPos = pos + 1;
                moveVNodeDOM(bNode, dom, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge);
            }
            else {
                j--;
            }
        }
    }
    else if (patched !== bLeft) {
        // when patched count doesn't match b length we need to insert those new ones
        // loop backwards so we can use insertBefore
        for (i = bLeft - 1; i >= 0; i--) {
            if (sources[i] === 0) {
                pos = i + bStart;
                bNode = b[pos];
                if (bNode.flags & 16384 /* InUse */) {
                    b[pos] = bNode = directClone(bNode);
                }
                nextPos = pos + 1;
                mount$1(bNode, dom, context, isSVG, nextPos < bLength ? findDOMfromVNode(b[nextPos], true) : outerEdge, lifecycle);
            }
        }
    }
}
var result;
var p$1;
var maxLen = 0;
// https://en.wikipedia.org/wiki/Longest_increasing_subsequence
function lis_algorithm(arr) {
    var arrI = 0;
    var i = 0;
    var j = 0;
    var k = 0;
    var u = 0;
    var v = 0;
    var c = 0;
    var len = arr.length;
    if (len > maxLen) {
        maxLen = len;
        result = new Int32Array(len);
        p$1 = new Int32Array(len);
    }
    for (; i < len; ++i) {
        arrI = arr[i];
        if (arrI !== 0) {
            j = result[k];
            if (arr[j] < arrI) {
                p$1[i] = j;
                result[++k] = i;
                continue;
            }
            u = 0;
            v = k;
            while (u < v) {
                c = (u + v) >> 1;
                if (arr[result[c]] < arrI) {
                    u = c + 1;
                }
                else {
                    v = c;
                }
            }
            if (arrI < arr[result[u]]) {
                if (u > 0) {
                    p$1[i] = result[u - 1];
                }
                result[u] = i;
            }
        }
    }
    u = k + 1;
    var seq = new Int32Array(u);
    v = result[u - 1];
    while (u-- > 0) {
        seq[u] = v;
        v = p$1[v];
        result[u] = 0;
    }
    return seq;
}

var hasDocumentAvailable = typeof document !== 'undefined';
if (hasDocumentAvailable) {
    /*
     * Defining $EV and $V properties on Node.prototype
     * fixes v8 "wrong map" de-optimization
     */
    if (window.Node) {
        Node.prototype.$EV = null;
        Node.prototype.$V = null;
    }
}

var QUEUE = [];
var nextTick = typeof Promise !== 'undefined'
    ? Promise.resolve().then.bind(Promise.resolve())
    : function (a) {
        window.setTimeout(a, 0);
    };
var microTaskPending = false;
function queueStateChanges(component, newState, callback, force) {
    var pending = component.$PS;
    if (isFunction$1(newState)) {
        newState = newState(pending ? combineFrom$1(component.state, pending) : component.state, component.props, component.context);
    }
    if (isNullOrUndef(pending)) {
        component.$PS = newState;
    }
    else {
        for (var stateKey in newState) {
            pending[stateKey] = newState[stateKey];
        }
    }
    if (!component.$BR) {
        if (!renderCheck.v) {
            if (QUEUE.length === 0) {
                applyState(component, force);
                if (isFunction$1(callback)) {
                    callback.call(component);
                }
                return;
            }
        }
        if (QUEUE.indexOf(component) === -1) {
            QUEUE.push(component);
        }
        if (!microTaskPending) {
            microTaskPending = true;
            nextTick(rerender);
        }
        if (isFunction$1(callback)) {
            var QU = component.$QU;
            if (!QU) {
                QU = component.$QU = [];
            }
            QU.push(callback);
        }
    }
    else if (isFunction$1(callback)) {
        component.$L.push(callback.bind(component));
    }
}
function callSetStateCallbacks(component) {
    var queue = component.$QU;
    for (var i = 0; i < queue.length; ++i) {
        queue[i].call(component);
    }
    component.$QU = null;
}
function rerender() {
    var component;
    microTaskPending = false;
    while ((component = QUEUE.shift())) {
        if (!component.$UN) {
            applyState(component, false);
            if (component.$QU) {
                callSetStateCallbacks(component);
            }
        }
    }
}
function applyState(component, force) {
    if (force || !component.$BR) {
        var pendingState = component.$PS;
        component.$PS = null;
        var lifecycle = [];
        renderCheck.v = true;
        updateClassComponent(component, combineFrom$1(component.state, pendingState), component.props, findDOMfromVNode(component.$LI, true).parentNode, component.context, component.$SVG, force, null, lifecycle);
        callAll(lifecycle);
        renderCheck.v = false;
    }
    else {
        component.state = component.$PS;
        component.$PS = null;
    }
}
var Component = function Component(props, context) {
    // Public
    this.state = null;
    // Internal properties
    this.$BR = false; // BLOCK RENDER
    this.$BS = true; // BLOCK STATE
    this.$PS = null; // PENDING STATE (PARTIAL or FULL)
    this.$LI = null; // LAST INPUT
    this.$UN = false; // UNMOUNTED
    this.$CX = null; // CHILDCONTEXT
    this.$QU = null; // QUEUE
    this.$N = false; // Uses new lifecycle API Flag
    this.$L = null; // Current lifecycle of this component
    this.$SVG = false; // Flag to keep track if component is inside SVG tree
    this.props = props || EMPTY_OBJ;
    this.context = context || EMPTY_OBJ; // context should not be mutable
};
Component.prototype.forceUpdate = function forceUpdate (callback) {
    if (this.$UN) {
        return;
    }
    // Do not allow double render during force update
    queueStateChanges(this, {}, callback, true);
};
Component.prototype.setState = function setState (newState, callback) {
    if (this.$UN) {
        return;
    }
    if (!this.$BS) {
        queueStateChanges(this, newState, callback, false);
    }
};
Component.prototype.render = function render (_nextProps, _nextState, _nextContext) {
    return null;
};var CLEARED = null;
// tslint:disable-next-line:no-empty
var nullSubscriptionHandler = function () { };
var nullListenerCollection = {
    // tslint:disable-next-line:no-empty
    clear: function () { },
    // tslint:disable-next-line:no-empty
    notify: function () { },
    subscribe: function (_) { return nullSubscriptionHandler; }
};
var createListenerCollection = function () {
    // the current/next pattern is copied from redux's createStore code.
    var current = [];
    var next = [];
    return {
        clear: function () {
            next = CLEARED;
            current = CLEARED;
        },
        notify: function () {
            var listeners = (current = next);
            for (var i = 0; i < listeners.length; ++i) {
                listeners[i]();
            }
        },
        subscribe: function (listener) {
            var isSubscribed = true;
            if (next === current) {
                next = current.slice();
            }
            next.push(listener);
            return function () {
                if (!isSubscribed || current === null) {
                    return;
                }
                isSubscribed = false;
                if (next === current) {
                    next = current.slice();
                }
                next.splice(next.indexOf(listener), 1);
            };
        }
    };
};
var Subscription$1 = function Subscription(store, parentSub, onStateChange) {
    this.store = store;
    this.parentSub = parentSub;
    this.onStateChange = onStateChange;
    this.unsubscribe = null;
    this.listeners = nullListenerCollection;
};
Subscription$1.prototype.addNestedSub = function addNestedSub (listener) {
    this.trySubscribe();
    return this.listeners.subscribe(listener);
};
Subscription$1.prototype.notifyNestedSubs = function notifyNestedSubs () {
    this.listeners.notify();
};
Subscription$1.prototype.isSubscribed = function isSubscribed () {
    return Boolean(this.unsubscribe);
};
Subscription$1.prototype.trySubscribe = function trySubscribe () {
    if (!this.unsubscribe) {
        this.unsubscribe = this.parentSub ? this.parentSub.addNestedSub(this.onStateChange) : this.store.subscribe(this.onStateChange);
        this.listeners = createListenerCollection();
    }
};
Subscription$1.prototype.tryUnsubscribe = function tryUnsubscribe () {
    if (this.unsubscribe) {
        this.unsubscribe();
        this.unsubscribe = null;
        this.listeners.clear();
        this.listeners = nullListenerCollection;
    }
};

function combineFrom(first, second) {
    var out = {};
    if (first) {
        for (var key in first) {
            out[key] = first[key];
        }
    }
    if (second) {
        for (var key$1 in second) {
            out[key$1] = second[key$1];
        }
    }
    return out;
}

function objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var hotReloadingVersion = 0;
var dummyState = {};
// tslint:disable-next-line:no-empty
var noop$1 = function () { };
var makeSelectorStateful = function (sourceSelector, store) {
    // wrap the selector in an object that tracks its results between runs.
    var selector = {
        error: null,
        props: {},
        run: function runComponentSelector(props) {
            try {
                var nextProps = sourceSelector(store.getState(), props);
                if (nextProps !== selector.props || selector.error) {
                    selector.shouldComponentUpdate = true;
                    selector.props = nextProps;
                    selector.error = null;
                }
            }
            catch (e) {
                selector.shouldComponentUpdate = true;
                selector.error = e;
            }
        },
        shouldComponentUpdate: false
    };
    return selector;
};
// TODO: Move
var invariant = function (test, error) {
    if (!test) {
        throw new Error(error);
    }
};
function getDefaultName(name) {
    return ("ConnectAdvanced(" + name + ")");
}
function connectAdvanced(selectorFactory, ref) {
    var getDisplayName = ref.getDisplayName; if ( getDisplayName === void 0 ) getDisplayName = getDefaultName;
    var methodName = ref.methodName; if ( methodName === void 0 ) methodName = 'connectAdvanced';
    var renderCountProp = ref.renderCountProp; if ( renderCountProp === void 0 ) renderCountProp = null;
    var shouldHandleStateChanges = ref.shouldHandleStateChanges; if ( shouldHandleStateChanges === void 0 ) shouldHandleStateChanges = true;
    var storeKey = ref.storeKey; if ( storeKey === void 0 ) storeKey = 'store';
    var withRef = ref.withRef; if ( withRef === void 0 ) withRef = false;
    var rest = objectWithoutProperties( ref, ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef"] );
    var connectOptions = rest;

    var subscriptionKey = storeKey + 'Subscription';
    var version = hotReloadingVersion++;
    var wrapWithConnect = function (WrappedComponent) {
        invariant(typeof WrappedComponent === 'function', "You must pass a component to the function returned by " + "connect. Instead received " + WrappedComponent);
        var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
        var displayName = getDisplayName(wrappedComponentName);
        var selectorFactoryOptions = combineFrom(connectOptions, {
            WrappedComponent: WrappedComponent,
            displayName: displayName,
            getDisplayName: getDisplayName,
            methodName: methodName,
            renderCountProp: renderCountProp,
            shouldHandleStateChanges: shouldHandleStateChanges,
            storeKey: storeKey,
            withRef: withRef,
            wrappedComponentName: wrappedComponentName
        });
        var Connect = /*@__PURE__*/(function (Component) {
            function Connect(props, context) {
                Component.call(this, props, context);
                this.version = version;
                this.state = {};
                this.renderCount = 0;
                this.store = this.props[storeKey] || this.context[storeKey];
                this.propsMode = Boolean(props[storeKey]);
                this.setWrappedInstance = this.setWrappedInstance.bind(this);
                invariant(!!this.store, "Could not find \"" + storeKey + "\" in either the context or " +
                    "props of \"" + displayName + "\". " +
                    "Either wrap the root component in a <Provider>, " +
                    "or explicitly pass \"" + storeKey + "\" as a prop to \"" + displayName + "\".");
                this.initSelector();
                this.initSubscription();
            }

            if ( Component ) Connect.__proto__ = Component;
            Connect.prototype = Object.create( Component && Component.prototype );
            Connect.prototype.constructor = Connect;
            Connect.prototype.getChildContext = function getChildContext () {
                var obj;

                // If this component received store from props, its subscription should be transparent
                // to any descendants receiving store+subscription from context; it passes along
                // subscription passed to it. Otherwise, it shadows the parent subscription, which allows
                // Connect to control ordering of notifications to flow top-down.
                var subscription = this.propsMode ? null : this.subscription;
                return ( obj = {}, obj[subscriptionKey] = subscription || this.context[subscriptionKey], obj );
            };
            Connect.prototype.componentWillMount = function componentWillMount () {
                if (!shouldHandleStateChanges || this.$SSR) {
                    return;
                }
                this.subscription.trySubscribe();
                this.selector.run(this.props);
            };
            Connect.prototype.componentWillReceiveProps = function componentWillReceiveProps (nextProps) {
                this.selector.run(nextProps);
            };
            Connect.prototype.shouldComponentUpdate = function shouldComponentUpdate () {
                return this.selector.shouldComponentUpdate;
            };
            Connect.prototype.componentWillUnmount = function componentWillUnmount () {
                if (this.subscription) {
                    this.subscription.tryUnsubscribe();
                }
                // these are just to guard against extra memory leakage if a parent element doesn't
                // dereference this instance properly, such as an async callback that never finishes
                this.subscription = null;
                this.notifyNestedSubs = noop$1;
                this.store = null;
                this.selector.run = noop$1;
                this.selector.shouldComponentUpdate = false;
            };
            Connect.prototype.getWrappedInstance = function getWrappedInstance () {
                invariant(withRef, "To access the wrapped instance, you need to specify " + "{ withRef: true } in the options argument of the " + methodName + "() call.");
                return this.wrappedInstance;
            };
            Connect.prototype.setWrappedInstance = function setWrappedInstance (ref) {
                this.wrappedInstance = ref;
            };
            Connect.prototype.initSelector = function initSelector () {
                var sourceSelector = selectorFactory(this.store.dispatch, selectorFactoryOptions);
                this.selector = makeSelectorStateful(sourceSelector, this.store);
                this.selector.run(this.props);
            };
            Connect.prototype.initSubscription = function initSubscription () {
                if (!shouldHandleStateChanges) {
                    return;
                }
                // parentSub's source should match where store came from: props vs. context. A component
                // connected to the store via props shouldn't use subscription from context, or vice versa.
                var parentSub = (this.propsMode ? this.props : this.context)[subscriptionKey];
                this.subscription = new Subscription$1(this.store, parentSub, this.onStateChange.bind(this));
                // `notifyNestedSubs` is duplicated to handle the case where the component is  unmounted in
                // the middle of the notification loop, where `this.subscription` will then be null. An
                // extra null check every change can be avoided by copying the method onto `this` and then
                // replacing it with a no-op on unmount. This can probably be avoided if Subscription's
                // listeners logic is changed to not call listeners that have been unsubscribed in the
                // middle of the notification loop.
                this.notifyNestedSubs = this.subscription.notifyNestedSubs.bind(this.subscription);
            };
            Connect.prototype.onStateChange = function onStateChange () {
                this.selector.run(this.props);
                if (!this.selector.shouldComponentUpdate) {
                    this.notifyNestedSubs();
                }
                else {
                    this.componentDidUpdate = this.notifyNestedSubsOnComponentDidUpdate;
                    this.setState(dummyState);
                }
            };
            Connect.prototype.notifyNestedSubsOnComponentDidUpdate = function notifyNestedSubsOnComponentDidUpdate () {
                // `componentDidUpdate` is conditionally implemented when `onStateChange` determines it
                // needs to notify nested subs. Once called, it unimplements itself until further state
                // changes occur. Doing it this way vs having a permanent `componentDidMount` that does
                // a boolean check every time avoids an extra method call most of the time, resulting
                // in some perf boost.
                this.componentDidUpdate = undefined;
                this.notifyNestedSubs();
            };
            Connect.prototype.isSubscribed = function isSubscribed () {
                return Boolean(this.subscription && this.subscription.isSubscribed());
            };
            Connect.prototype.addExtraProps = function addExtraProps (props) {
                if (!renderCountProp) {
                    return props;
                }
                // make a shallow copy so that fields added don't leak to the original selector.
                // this is especially important for 'ref' since that's a reference back to the component
                // instance. a singleton memoized selector would then be holding a reference to the
                // instance, preventing the instance from being garbage collected, and that would be bad
                var withExtras = combineFrom(props, null);
                if (renderCountProp) {
                    withExtras[renderCountProp] = this.renderCount++;
                }
                if (this.propsMode && this.subscription) {
                    withExtras[subscriptionKey] = this.subscription;
                }
                return withExtras;
            };
            Connect.prototype.render = function render () {
                var selector = this.selector;
                selector.shouldComponentUpdate = false;
                if (selector.error) {
                    throw selector.error;
                }
                else {
                    return normalizeProps(createComponentVNode(2 /* ComponentUnknown */, WrappedComponent, this.addExtraProps(selector.props), null, withRef ? this.setWrappedInstance : null));
                }
            };

            return Connect;
        }(Component));
        Connect.displayName = displayName;
        Connect.WrappedComponent = WrappedComponent;
        return hoistNonReactStatics(Connect, WrappedComponent);
    };
    return wrapWithConnect;
}

var Provider = /*@__PURE__*/(function (Component) {
    function Provider(props, context) {
        Component.call(this, props, context);
        this.store = props.store;
    }

    if ( Component ) Provider.__proto__ = Component;
    Provider.prototype = Object.create( Component && Component.prototype );
    Provider.prototype.constructor = Provider;
    Provider.prototype.getChildContext = function getChildContext () {
        return { store: this.store, storeSubscription: null };
    };
    // Don't infer the return type. It may be expanded and cause reference errors
    // in the output.
    Provider.prototype.render = function render () {
        return this.props.children;
    };

    return Provider;
}(Component));
Provider.displayName = 'Provider';

var hasOwn = Object.prototype.hasOwnProperty;
var shallowEqual = function (a, b) {
    if (a === b) {
        return true;
    }
    var countA = 0;
    var countB = 0;
    for (var key in a) {
        if (hasOwn.call(a, key) && a[key] !== b[key]) {
            return false;
        }
        countA++;
    }
    for (var key$1 in b) {
        if (hasOwn.call(b, key$1)) {
            countB++;
        }
    }
    return countA === countB;
};

// TODO: Type
var wrapMapToPropsConstant = function (getConstant) {
    return function (dispatch, options) {
        var constant = getConstant(dispatch, options);
        var constantSelector = function () { return constant; };
        constantSelector.dependsOnOwnProps = false;
        return constantSelector;
    };
};
// dependsOnOwnProps is used by createMapToPropsProxy to determine whether to pass props as args
// to the mapToProps function being wrapped. It is also used by makePurePropsSelector to determine
// whether mapToProps needs to be invoked when props have changed.
//
// A length of one signals that mapToProps does not depend on props from the parent component.
// A length of zero is assumed to mean mapToProps is getting args via arguments or ...args and
// therefore not reporting its length accurately..
var getDependsOnOwnProps = function (mapToProps) { return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== undefined ? !!mapToProps.dependsOnOwnProps : mapToProps.length !== 1; };
// Used by whenMapStateToPropsIsFunction and whenMapDispatchToPropsIsFunction,
// this function wraps mapToProps in a proxy function which does several things:
//
//  * Detects whether the mapToProps function being called depends on props, which
//    is used by selectorFactory to decide if it should reinvoke on props changes.
//
//  * On first call, handles mapToProps if returns another function, and treats that
//    new function as the true mapToProps for subsequent calls.
//
//  * On first call, verifies the first result is a plain object, in order to warn
//    the developer that their mapToProps function is not returning a valid result.
//
var wrapMapToPropsFunc = function (mapToProps, methodName) {
    return function (_dispatch, ref) {
        ref.displayName;

        var proxy = function (stateOrDispatch, ownProps) { return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch); };
        proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
        proxy.mapToProps = function (stateOrDispatch, ownProps) {
            proxy.mapToProps = mapToProps;
            var props = proxy(stateOrDispatch, ownProps);
            if (typeof props === 'function') {
                proxy.mapToProps = props;
                proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
                props = proxy(stateOrDispatch, ownProps);
            }
            return props;
        };
        return proxy;
    };
};

var whenMapDispatchToPropsIsFunction = function (mapDispatchToProps) { return typeof mapDispatchToProps === 'function' ? wrapMapToPropsFunc(mapDispatchToProps) : undefined; };
var whenMapDispatchToPropsIsMissing = function (mapDispatchToProps) { return (!mapDispatchToProps ? wrapMapToPropsConstant(function (dispatch) { return ({ dispatch: dispatch }); }) : undefined); };
var whenMapDispatchToPropsIsObject = function (mapDispatchToProps) { return mapDispatchToProps && typeof mapDispatchToProps === 'object'
    ? wrapMapToPropsConstant(function (dispatch) { return bindActionCreators(mapDispatchToProps, dispatch); })
    : undefined; };
var defaultMapDispatchToPropsFactories = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

var whenMapStateToPropsIsFunction = function (mapStateToProps) { return typeof mapStateToProps === 'function' ? wrapMapToPropsFunc(mapStateToProps) : undefined; };
var whenMapStateToPropsIsMissing = function (mapStateToProps) { return (!mapStateToProps ? wrapMapToPropsConstant(function () { return ({}); }) : undefined); };
var defaultMapStateToPropsFactories = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

var defaultMergeProps = function (stateProps, dispatchProps, ownProps) {
    var merged = combineFrom(ownProps, stateProps);
    if (dispatchProps) {
        for (var key in dispatchProps) {
            merged[key] = dispatchProps[key];
        }
    }
    return merged;
};
var wrapMergePropsFunc = function (mergeProps) {
    return function (_dispatch, ref) {
        ref.displayName;
        var pure = ref.pure;
        var areMergedPropsEqual = ref.areMergedPropsEqual;

        var hasRunOnce = false;
        var mergedProps;
        return function (stateProps, dispatchProps, ownProps) {
            var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
            if (hasRunOnce) {
                if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps)) {
                    mergedProps = nextMergedProps;
                }
            }
            else {
                hasRunOnce = true;
                mergedProps = nextMergedProps;
            }
            return mergedProps;
        };
    };
};
var whenMergePropsIsFunction = function (mergeProps) { return (typeof mergeProps === 'function' ? wrapMergePropsFunc(mergeProps) : undefined); };
var whenMergePropsIsOmitted = function (mergeProps) { return (!mergeProps ? function () { return defaultMergeProps; } : undefined); };
var defaultMergePropsFactories = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

function objectWithoutProperties$1 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var impureFinalPropsSelectorFactory = function (mapStateToProps, mapDispatchToProps, mergeProps, dispatch) {
    return function (state, ownProps) {
        return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps(dispatch, ownProps), ownProps);
    };
};
var pureFinalPropsSelectorFactory = function (mapStateToProps, mapDispatchToProps, mergeProps, dispatch, ref) {
    var areStatesEqual = ref.areStatesEqual;
    var areOwnPropsEqual = ref.areOwnPropsEqual;
    var areStatePropsEqual = ref.areStatePropsEqual;

    var hasRunAtLeastOnce = false;
    var state;
    var ownProps;
    var stateProps;
    var dispatchProps;
    var mergedProps;
    var handleFirstCall = function (firstState, firstOwnProps) {
        state = firstState;
        ownProps = firstOwnProps;
        stateProps = mapStateToProps(state, ownProps);
        dispatchProps = mapDispatchToProps(dispatch, ownProps);
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        hasRunAtLeastOnce = true;
        return mergedProps;
    };
    var handleNewPropsAndNewState = function () {
        stateProps = mapStateToProps(state, ownProps);
        if (mapDispatchToProps.dependsOnOwnProps) {
            dispatchProps = mapDispatchToProps(dispatch, ownProps);
        }
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    };
    var handleNewProps = function () {
        if (mapStateToProps.dependsOnOwnProps) {
            stateProps = mapStateToProps(state, ownProps);
        }
        if (mapDispatchToProps.dependsOnOwnProps) {
            dispatchProps = mapDispatchToProps(dispatch, ownProps);
        }
        mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        return mergedProps;
    };
    var handleNewState = function () {
        var nextStateProps = mapStateToProps(state, ownProps);
        var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
        stateProps = nextStateProps;
        if (statePropsChanged) {
            mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
        }
        return mergedProps;
    };
    var handleSubsequentCalls = function (nextState, nextOwnProps) {
        var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
        var stateChanged = !areStatesEqual(nextState, state);
        state = nextState;
        ownProps = nextOwnProps;
        if (propsChanged && stateChanged) {
            return handleNewPropsAndNewState();
        }
        if (propsChanged) {
            return handleNewProps();
        }
        if (stateChanged) {
            return handleNewState();
        }
        return mergedProps;
    };
    var pureFinalPropsSelector = function (nextState, nextOwnProps) { return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps); };
    return pureFinalPropsSelector;
};
// If pure is true, the selector returned by selectorFactory will memoize its results,
// allowing connectAdvanced's shouldComponentUpdate to return false if final
// props have not changed. If false, the selector will always return a new
// object and shouldComponentUpdate will always return true.
var defaultSelectorFactory = function (dispatch, ref) {
    var initMapStateToProps = ref.initMapStateToProps;
    var initMapDispatchToProps = ref.initMapDispatchToProps;
    var initMergeProps = ref.initMergeProps;
    var rest = objectWithoutProperties$1( ref, ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"] );
    var opts = rest;

    var options = opts; // trick typescript
    var mapStateToProps = initMapStateToProps(dispatch, options);
    var mapDispatchToProps = initMapDispatchToProps(dispatch, options);
    var mergeProps = initMergeProps(dispatch, options);
    var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
    return selectorFactory(mapStateToProps, mapDispatchToProps, mergeProps, dispatch, options);
};

function objectWithoutProperties$2 (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }
var match = function (arg, factories, name) {
    for (var i = factories.length - 1; i >= 0; i--) {
        var result = factories[i](arg);
        if (result) {
            return result;
        }
    }
    return function (_dispatch, options) {
        throw new Error(("Invalid value of type " + (typeof arg) + " for " + name + " argument when connecting component " + (options.wrappedComponentName) + "."));
    };
};
var strictEqual = function (a, b) { return a === b; };
// createConnect with default args builds the 'official' connect behavior. Calling it with
// different options opens up some testing and extensibility scenarios
var createConnect = function (ref) {
    if ( ref === void 0 ) ref = {};
    var connectHOC = ref.connectHOC; if ( connectHOC === void 0 ) connectHOC = connectAdvanced;
    var mapStateToPropsFactories = ref.mapStateToPropsFactories; if ( mapStateToPropsFactories === void 0 ) mapStateToPropsFactories = defaultMapStateToPropsFactories;
    var mapDispatchToPropsFactories = ref.mapDispatchToPropsFactories; if ( mapDispatchToPropsFactories === void 0 ) mapDispatchToPropsFactories = defaultMapDispatchToPropsFactories;
    var mergePropsFactories = ref.mergePropsFactories; if ( mergePropsFactories === void 0 ) mergePropsFactories = defaultMergePropsFactories;
    var selectorFactory = ref.selectorFactory; if ( selectorFactory === void 0 ) selectorFactory = defaultSelectorFactory;

    return function (mapStateToProps, mapDispatchToProps, mergeProps, ref) {
    if ( ref === void 0 ) ref = {};
    var pure = ref.pure; if ( pure === void 0 ) pure = true;
    var areStatesEqual = ref.areStatesEqual; if ( areStatesEqual === void 0 ) areStatesEqual = strictEqual;
    var areOwnPropsEqual = ref.areOwnPropsEqual; if ( areOwnPropsEqual === void 0 ) areOwnPropsEqual = shallowEqual;
    var areStatePropsEqual = ref.areStatePropsEqual; if ( areStatePropsEqual === void 0 ) areStatePropsEqual = shallowEqual;
    var areMergedPropsEqual = ref.areMergedPropsEqual; if ( areMergedPropsEqual === void 0 ) areMergedPropsEqual = shallowEqual;
    var rest = objectWithoutProperties$2( ref, ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"] );
    var extraOptions = rest;

    var initMapStateToProps = match(mapStateToProps, mapStateToPropsFactories, 'mapStateToProps');
    var initMapDispatchToProps = match(mapDispatchToProps, mapDispatchToPropsFactories, 'mapDispatchToProps');
    var initMergeProps = match(mergeProps, mergePropsFactories, 'mergeProps');
    return connectHOC(selectorFactory, combineFrom({
        // used in error messages
        methodName: 'connect',
        // used to compute Connect's displayName from the wrapped component's displayName.
        // tslint:disable-next-line:object-literal-sort-keys
        getDisplayName: function (name) { return ("Connect(" + name + ")"); },
        // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
        shouldHandleStateChanges: !!mapStateToProps,
        // passed through to selectorFactory
        areMergedPropsEqual: areMergedPropsEqual,
        areOwnPropsEqual: areOwnPropsEqual,
        areStatePropsEqual: areStatePropsEqual,
        areStatesEqual: areStatesEqual,
        initMapDispatchToProps: initMapDispatchToProps,
        initMapStateToProps: initMapStateToProps,
        initMergeProps: initMergeProps,
        pure: pure
    }, extraOptions /* any extra options args can override defaults of connect or connectAdvanced */));
};
};
var connect = createConnect();var BaseUI = function BaseUI() {
  return null;
};var TIME_FOR_UPDATE = 5;
var VOLUME = 2;
var AUDIO_EVENTS = {
  ENDED: 'ended'
};
var AUDIO_RAMPS = {
  LINEAR: 'LINEAR',
  EXPONENTIAL: 'EXPONENTIAL'
};
var Audio = /*#__PURE__*/function () {
  function Audio() {
    var _this = this;

    _classCallCheck(this, Audio);

    _defineProperty$1(this, "setCurrentLevel", function (level) {
      _this.currentLevel = level;
    });

    _defineProperty$1(this, "load", function () {
      var audio = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var level = arguments.length > 1 ? arguments[1] : undefined;
      _this.audio = audio;

      _this.createAudioContext();

      if (Object.keys(_this.audio).length === 0) {
        return Promise.resolve();
      }

      return Promise.all(Object.keys(_this.audio).map(function (id) {
        return _this.loadSingleFile(id, level);
      })).catch(function (e) {
        console.log(ASSETS_AUDIO_LOAD_FAIL);
        console.log(e);
        return Promise.resolve();
      });
    });

    _defineProperty$1(this, "loadSingleFile", function (name, level) {
      var path = _this.audio[name];
      var request = new XMLHttpRequest();
      var id = buildAssetId(name, level);
      return new Promise(function (resolve) {
        request.open("GET", path, true);
        request.responseType = "arraybuffer";

        request.onreadystatechange = function (e) {
          if (request.readyState === 4 && request.status === 200) {
            _this.context.decodeAudioData(request.response, function (buffer) {
              _this.map[id] = buffer;
              resolve();
            }, function () {
              _this.map[id] = null;
              resolve();
            });
          }
        };

        request.send();
      });
    });

    this.masterVolumeNode = null;
    this.context = null;
    this.sounds = [];
    this.map = {};
    this.currentLevel = ROOT;
  }

  _createClass(Audio, [{
    key: "reset",
    value: function reset() {
      this.sounds = [];
    }
  }, {
    key: "hasContext",
    value: function hasContext() {
      return !!this.context;
    }
  }, {
    key: "createAudioContext",
    value: function createAudioContext() {
      var AudioContext = window.AudioContext || window.webkitAudioContext || null;

      if (!this.hasContext()) {
        if (AudioContext) {
          this.context = new AudioContext();
          this.createMasterVolumeNode();
        } else {
          console.error(AUDIO_CONTEXT_NOT_AVAILABLE);
        }
      }
    }
  }, {
    key: "createMasterVolumeNode",
    value: function createMasterVolumeNode() {
      this.masterVolumeNode = this.context.createGain();
      this.setVolume(VOLUME);
      this.masterVolumeNode.connect(this.getDestination());
    }
  }, {
    key: "getDestination",
    value: function getDestination() {
      if (this.context) {
        return this.context.destination;
      }
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      if (this.masterVolumeNode) {
        return this.masterVolumeNode.gain.value;
      }
    }
  }, {
    key: "getMasterVolumeNode",
    value: function getMasterVolumeNode() {
      return this.masterVolumeNode;
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.masterVolumeNode.gain.setValueAtTime(value, this.context.currentTime);
    }
  }, {
    key: "get",
    value: function get(id) {
      return this.map[id] || this.map[buildAssetId(id, this.currentLevel)] || false;
    }
  }, {
    key: "add",
    value: function add(sound) {
      this.sounds.push(sound);
    }
  }, {
    key: "updateListenerPosition",
    value: function updateListenerPosition() {
      //now handling listener
      Scene$1.getCameraBody().updateMatrixWorld();
      var p = new Vector3$1();
      p.setFromMatrixPosition(Scene$1.getCameraBody().matrixWorld); //setting audio engine context listener position on camera position

      this.context.listener.setPosition(p.x, p.y, p.z);
    }
  }, {
    key: "updatelistenerOrientation",
    value: function updatelistenerOrientation() {
      //this is to add up and down vector to our camera
      // The camera's world matrix is named "matrix".
      var m = Scene$1.getCameraBody().matrix;
      var mx = m.elements[12],
          my = m.elements[13],
          mz = m.elements[14];
      m.elements[12] = m.elements[13] = m.elements[14] = 0; // Multiply the orientation vector by the world matrix of the camera.

      var vec = new Vector3$1(0, 0, 1);
      vec.applyMatrix4(m);
      vec.normalize(); // Multiply the up vector by the world matrix.

      var up = new Vector3$1(0, -1, 0);
      up.applyMatrix4(m);
      up.normalize(); // Set the orientation and the up-vector for the listener.

      this.context.listener.setOrientation(vec.x, vec.y, vec.z, up.x, up.y, up.z);
      m.elements[12] = mx;
      m.elements[13] = my;
      m.elements[14] = mz;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      for (var index in this.sounds) {
        var sound = this.sounds[index];
        sound.dispose();
      }

      this.reset();
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (!this.hasContext()) return;
      var start = new Date();

      for (var index in this.sounds) {
        var sound = this.sounds[index];
        sound.update(dt);
        this.updateListenerPosition();
        this.updatelistenerOrientation();
        if (+new Date() - start > TIME_FOR_UPDATE) break;
      }
    }
  }]);

  return Audio;
}();
var Audio$1 = new Audio();var Video = /*#__PURE__*/function () {
  function Video() {
    _classCallCheck(this, Video);
  }

  _createClass(Video, [{
    key: "load",
    value: function load() {
      return Promise.resolve();
    }
  }]);

  return Video;
}();

var engine = new Video();var GLTFLoader = function () {
  function GLTFLoader(manager) {
    Loader$1.call(this, manager);
    this.dracoLoader = null;
    this.ddsLoader = null;
  }

  GLTFLoader.prototype = Object.assign(Object.create(Loader$1.prototype), {
    constructor: GLTFLoader,
    load: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var resourcePath;

      if (this.resourcePath !== '') {
        resourcePath = this.resourcePath;
      } else if (this.path !== '') {
        resourcePath = this.path;
      } else {
        resourcePath = LoaderUtils.extractUrlBase(url);
      } // Tells the LoadingManager to track an extra item, which resolves after
      // the model is fully loaded. This means the count of items loaded will
      // be incorrect, but ensures manager.onLoad() does not fire early.


      scope.manager.itemStart(url);

      var _onError = function _onError(e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }

        scope.manager.itemError(url);
        scope.manager.itemEnd(url);
      };

      var loader = new FileLoader(scope.manager);
      loader.setPath(this.path);
      loader.setResponseType('arraybuffer');

      if (scope.crossOrigin === 'use-credentials') {
        loader.setWithCredentials(true);
      }

      loader.load(url, function (data) {
        try {
          scope.parse(data, resourcePath, function (gltf) {
            onLoad(gltf);
            scope.manager.itemEnd(url);
          }, _onError);
        } catch (e) {
          _onError(e);
        }
      }, onProgress, _onError);
    },
    setDRACOLoader: function setDRACOLoader(dracoLoader) {
      this.dracoLoader = dracoLoader;
      return this;
    },
    setDDSLoader: function setDDSLoader(ddsLoader) {
      this.ddsLoader = ddsLoader;
      return this;
    },
    parse: function parse(data, path, onLoad, onError) {
      var content;
      var extensions = {};

      if (typeof data === 'string') {
        content = data;
      } else {
        var magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4));

        if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
          try {
            extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data);
          } catch (error) {
            if (onError) onError(error);
            return;
          }

          content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content;
        } else {
          content = LoaderUtils.decodeText(new Uint8Array(data));
        }
      }

      var json = JSON.parse(content);

      if (json.asset === undefined || json.asset.version[0] < 2) {
        if (onError) onError(new Error('THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.'));
        return;
      }

      if (json.extensionsUsed) {
        for (var i = 0; i < json.extensionsUsed.length; ++i) {
          var extensionName = json.extensionsUsed[i];
          var extensionsRequired = json.extensionsRequired || [];

          switch (extensionName) {
            case EXTENSIONS.KHR_LIGHTS_PUNCTUAL:
              extensions[extensionName] = new GLTFLightsExtension(json);
              break;

            case EXTENSIONS.KHR_MATERIALS_UNLIT:
              extensions[extensionName] = new GLTFMaterialsUnlitExtension();
              break;

            case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
              extensions[extensionName] = new GLTFMaterialsPbrSpecularGlossinessExtension();
              break;

            case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
              extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
              break;

            case EXTENSIONS.MSFT_TEXTURE_DDS:
              extensions[extensionName] = new GLTFTextureDDSExtension(this.ddsLoader);
              break;

            case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
              extensions[extensionName] = new GLTFTextureTransformExtension();
              break;

            case EXTENSIONS.KHR_MESH_QUANTIZATION:
              extensions[extensionName] = new GLTFMeshQuantizationExtension();
              break;

            default:
              if (extensionsRequired.indexOf(extensionName) >= 0) {
                console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
              }

          }
        }
      }

      var parser = new GLTFParser(json, extensions, {
        path: path || this.resourcePath || '',
        crossOrigin: this.crossOrigin,
        manager: this.manager
      });
      parser.parse(onLoad, onError);
    }
  });
  /* GLTFREGISTRY */

  function GLTFRegistry() {
    var objects = {};
    return {
      get: function get(key) {
        return objects[key];
      },
      add: function add(key, object) {
        objects[key] = object;
      },
      remove: function remove(key) {
        delete objects[key];
      },
      removeAll: function removeAll() {
        objects = {};
      }
    };
  }
  /*********************************/

  /********** EXTENSIONS ***********/

  /*********************************/


  var EXTENSIONS = {
    KHR_BINARY_GLTF: 'KHR_binary_glTF',
    KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
    KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
    KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
    KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
    KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
    KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
    MSFT_TEXTURE_DDS: 'MSFT_texture_dds'
  };
  /**
   * DDS Texture Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/MSFT_texture_dds
   *
   */

  function GLTFTextureDDSExtension(ddsLoader) {
    if (!ddsLoader) {
      throw new Error('THREE.GLTFLoader: Attempting to load .dds texture without importing DDSLoader');
    }

    this.name = EXTENSIONS.MSFT_TEXTURE_DDS;
    this.ddsLoader = ddsLoader;
  }
  /**
   * Punctual Lights Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual
   */


  function GLTFLightsExtension(json) {
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    var extension = json.extensions && json.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] || {};
    this.lightDefs = extension.lights || [];
  }

  GLTFLightsExtension.prototype.loadLight = function (lightIndex) {
    var lightDef = this.lightDefs[lightIndex];
    var lightNode;
    var color = new Color$1(0xffffff);
    if (lightDef.color !== undefined) color.fromArray(lightDef.color);
    var range = lightDef.range !== undefined ? lightDef.range : 0;

    switch (lightDef.type) {
      case 'directional':
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;

      case 'point':
        lightNode = new PointLight$1(color);
        lightNode.distance = range;
        break;

      case 'spot':
        lightNode = new SpotLight$1(color);
        lightNode.distance = range; // Handle spotlight properties.

        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== undefined ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== undefined ? lightDef.spot.outerConeAngle : Math.PI / 4.0;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1.0 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;

      default:
        throw new Error('THREE.GLTFLoader: Unexpected light type, "' + lightDef.type + '".');
    } // Some lights (e.g. spot) default to a position other than the origin. Reset the position
    // here, because node-level parsing will only override position if explicitly specified.


    lightNode.position.set(0, 0, 0);
    lightNode.decay = 2;
    if (lightDef.intensity !== undefined) lightNode.intensity = lightDef.intensity;
    lightNode.name = lightDef.name || 'light_' + lightIndex;
    return Promise.resolve(lightNode);
  };
  /**
   * Unlit Materials Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit
   */


  function GLTFMaterialsUnlitExtension() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }

  GLTFMaterialsUnlitExtension.prototype.getMaterialType = function () {
    return MeshBasicMaterial;
  };

  GLTFMaterialsUnlitExtension.prototype.extendParams = function (materialParams, materialDef, parser) {
    var pending = [];
    materialParams.color = new Color$1(1.0, 1.0, 1.0);
    materialParams.opacity = 1.0;
    var metallicRoughness = materialDef.pbrMetallicRoughness;

    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
      }
    }

    return Promise.all(pending);
  };
  /* BINARY EXTENSION */


  var BINARY_EXTENSION_HEADER_MAGIC = 'glTF';
  var BINARY_EXTENSION_HEADER_LENGTH = 12;
  var BINARY_EXTENSION_CHUNK_TYPES = {
    JSON: 0x4E4F534A,
    BIN: 0x004E4942
  };

  function GLTFBinaryExtension(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    var headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH);
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };

    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.');
    } else if (this.header.version < 2.0) {
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.');
    }

    var chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH);
    var chunkIndex = 0;

    while (chunkIndex < chunkView.byteLength) {
      var chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      var chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;

      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        var contentArray = new Uint8Array(data, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = LoaderUtils.decodeText(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        var byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data.slice(byteOffset, byteOffset + chunkLength);
      } // Clients must ignore chunks with unknown types.


      chunkIndex += chunkLength;
    }

    if (this.content === null) {
      throw new Error('THREE.GLTFLoader: JSON content not found.');
    }
  }
  /**
   * DRACO Mesh Compression Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_draco_mesh_compression
   */


  function GLTFDracoMeshCompressionExtension(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.');
    }

    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }

  GLTFDracoMeshCompressionExtension.prototype.decodePrimitive = function (primitive, parser) {
    var json = this.json;
    var dracoLoader = this.dracoLoader;
    var bufferViewIndex = primitive.extensions[this.name].bufferView;
    var gltfAttributeMap = primitive.extensions[this.name].attributes;
    var threeAttributeMap = {};
    var attributeNormalizedMap = {};
    var attributeTypeMap = {};

    for (var attributeName in gltfAttributeMap) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }

    for (attributeName in primitive.attributes) {
      var threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();

      if (gltfAttributeMap[attributeName] !== undefined) {
        var accessorDef = json.accessors[primitive.attributes[attributeName]];
        var componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }

    return parser.getDependency('bufferView', bufferViewIndex).then(function (bufferView) {
      return new Promise(function (resolve) {
        dracoLoader.decodeDracoFile(bufferView, function (geometry) {
          for (var attributeName in geometry.attributes) {
            var attribute = geometry.attributes[attributeName];
            var normalized = attributeNormalizedMap[attributeName];
            if (normalized !== undefined) attribute.normalized = normalized;
          }

          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap);
      });
    });
  };
  /**
   * Texture Transform Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_texture_transform
   */


  function GLTFTextureTransformExtension() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }

  GLTFTextureTransformExtension.prototype.extendTexture = function (texture, transform) {
    texture = texture.clone();

    if (transform.offset !== undefined) {
      texture.offset.fromArray(transform.offset);
    }

    if (transform.rotation !== undefined) {
      texture.rotation = transform.rotation;
    }

    if (transform.scale !== undefined) {
      texture.repeat.fromArray(transform.scale);
    }

    if (transform.texCoord !== undefined) {
      console.warn('THREE.GLTFLoader: Custom UV sets in "' + this.name + '" extension not yet supported.');
    }

    texture.needsUpdate = true;
    return texture;
  };
  /**
   * Specular-Glossiness Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_pbrSpecularGlossiness
   */


  function GLTFMaterialsPbrSpecularGlossinessExtension() {
    return {
      name: EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS,
      specularGlossinessParams: ['color', 'map', 'lightMap', 'lightMapIntensity', 'aoMap', 'aoMapIntensity', 'emissive', 'emissiveIntensity', 'emissiveMap', 'bumpMap', 'bumpScale', 'normalMap', 'displacementMap', 'displacementScale', 'displacementBias', 'specularMap', 'specular', 'glossinessMap', 'glossiness', 'alphaMap', 'envMap', 'envMapIntensity', 'refractionRatio'],
      getMaterialType: function getMaterialType() {
        return ShaderMaterial;
      },
      extendParams: function extendParams(materialParams, materialDef, parser) {
        var pbrSpecularGlossiness = materialDef.extensions[this.name];
        var shader = ShaderLib['standard'];
        var uniforms = UniformsUtils.clone(shader.uniforms);
        var specularMapParsFragmentChunk = ['#ifdef USE_SPECULARMAP', '	uniform sampler2D specularMap;', '#endif'].join('\n');
        var glossinessMapParsFragmentChunk = ['#ifdef USE_GLOSSINESSMAP', '	uniform sampler2D glossinessMap;', '#endif'].join('\n');
        var specularMapFragmentChunk = ['vec3 specularFactor = specular;', '#ifdef USE_SPECULARMAP', '	vec4 texelSpecular = texture2D( specularMap, vUv );', '	texelSpecular = sRGBToLinear( texelSpecular );', '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture', '	specularFactor *= texelSpecular.rgb;', '#endif'].join('\n');
        var glossinessMapFragmentChunk = ['float glossinessFactor = glossiness;', '#ifdef USE_GLOSSINESSMAP', '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );', '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture', '	glossinessFactor *= texelGlossiness.a;', '#endif'].join('\n');
        var lightPhysicalFragmentChunk = ['PhysicalMaterial material;', 'material.diffuseColor = diffuseColor.rgb;', 'material.specularRoughness = clamp( 1.0 - glossinessFactor, 0.04, 1.0 );', 'material.specularColor = specularFactor.rgb;'].join('\n');
        var fragmentShader = shader.fragmentShader.replace('uniform float roughness;', 'uniform vec3 specular;').replace('uniform float metalness;', 'uniform float glossiness;').replace('#include <roughnessmap_pars_fragment>', specularMapParsFragmentChunk).replace('#include <metalnessmap_pars_fragment>', glossinessMapParsFragmentChunk).replace('#include <roughnessmap_fragment>', specularMapFragmentChunk).replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk).replace('#include <lights_physical_fragment>', lightPhysicalFragmentChunk);
        delete uniforms.roughness;
        delete uniforms.metalness;
        delete uniforms.roughnessMap;
        delete uniforms.metalnessMap;
        uniforms.specular = {
          value: new Color$1().setHex(0x111111)
        };
        uniforms.glossiness = {
          value: 0.5
        };
        uniforms.specularMap = {
          value: null
        };
        uniforms.glossinessMap = {
          value: null
        };
        materialParams.vertexShader = shader.vertexShader;
        materialParams.fragmentShader = fragmentShader;
        materialParams.uniforms = uniforms;
        materialParams.defines = {
          'STANDARD': ''
        };
        materialParams.color = new Color$1(1.0, 1.0, 1.0);
        materialParams.opacity = 1.0;
        var pending = [];

        if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
          var array = pbrSpecularGlossiness.diffuseFactor;
          materialParams.color.fromArray(array);
          materialParams.opacity = array[3];
        }

        if (pbrSpecularGlossiness.diffuseTexture !== undefined) {
          pending.push(parser.assignTexture(materialParams, 'map', pbrSpecularGlossiness.diffuseTexture));
        }

        materialParams.emissive = new Color$1(0.0, 0.0, 0.0);
        materialParams.glossiness = pbrSpecularGlossiness.glossinessFactor !== undefined ? pbrSpecularGlossiness.glossinessFactor : 1.0;
        materialParams.specular = new Color$1(1.0, 1.0, 1.0);

        if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
          materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor);
        }

        if (pbrSpecularGlossiness.specularGlossinessTexture !== undefined) {
          var specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture;
          pending.push(parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef));
          pending.push(parser.assignTexture(materialParams, 'specularMap', specGlossMapDef));
        }

        return Promise.all(pending);
      },
      createMaterial: function createMaterial(params) {
        // setup material properties based on MeshStandardMaterial for Specular-Glossiness
        var material = new ShaderMaterial({
          defines: params.defines,
          vertexShader: params.vertexShader,
          fragmentShader: params.fragmentShader,
          uniforms: params.uniforms,
          fog: true,
          lights: true,
          opacity: params.opacity,
          transparent: params.transparent
        });
        material.isGLTFSpecularGlossinessMaterial = true;
        material.color = params.color;
        material.map = params.map === undefined ? null : params.map;
        material.lightMap = null;
        material.lightMapIntensity = 1.0;
        material.aoMap = params.aoMap === undefined ? null : params.aoMap;
        material.aoMapIntensity = 1.0;
        material.emissive = params.emissive;
        material.emissiveIntensity = 1.0;
        material.emissiveMap = params.emissiveMap === undefined ? null : params.emissiveMap;
        material.bumpMap = params.bumpMap === undefined ? null : params.bumpMap;
        material.bumpScale = 1;
        material.normalMap = params.normalMap === undefined ? null : params.normalMap;
        if (params.normalScale) material.normalScale = params.normalScale;
        material.displacementMap = null;
        material.displacementScale = 1;
        material.displacementBias = 0;
        material.specularMap = params.specularMap === undefined ? null : params.specularMap;
        material.specular = params.specular;
        material.glossinessMap = params.glossinessMap === undefined ? null : params.glossinessMap;
        material.glossiness = params.glossiness;
        material.alphaMap = null;
        material.envMap = params.envMap === undefined ? null : params.envMap;
        material.envMapIntensity = 1.0;
        material.refractionRatio = 0.98;
        material.extensions.derivatives = true;
        return material;
      },

      /**
       * Clones a GLTFSpecularGlossinessMaterial instance. The ShaderMaterial.copy() method can
       * copy only properties it knows about or inherits, and misses many properties that would
       * normally be defined by MeshStandardMaterial.
       *
       * This method allows GLTFSpecularGlossinessMaterials to be cloned in the process of
       * loading a glTF model, but cloning later (e.g. by the user) would require these changes
       * AND also updating `.onBeforeRender` on the parent mesh.
       *
       * @param  {ShaderMaterial} source
       * @return {ShaderMaterial}
       */
      cloneMaterial: function cloneMaterial(source) {
        var target = source.clone();
        target.isGLTFSpecularGlossinessMaterial = true;
        var params = this.specularGlossinessParams;

        for (var i = 0, il = params.length; i < il; i++) {
          var value = source[params[i]];
          target[params[i]] = value && value.isColor ? value.clone() : value;
        }

        return target;
      },
      // Here's based on refreshUniformsCommon() and refreshUniformsStandard() in WebGLRenderer.
      refreshUniforms: function refreshUniforms(renderer, scene, camera, geometry, material) {
        if (material.isGLTFSpecularGlossinessMaterial !== true) {
          return;
        }

        var uniforms = material.uniforms;
        var defines = material.defines;
        uniforms.opacity.value = material.opacity;
        uniforms.diffuse.value.copy(material.color);
        uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
        uniforms.map.value = material.map;
        uniforms.specularMap.value = material.specularMap;
        uniforms.alphaMap.value = material.alphaMap;
        uniforms.lightMap.value = material.lightMap;
        uniforms.lightMapIntensity.value = material.lightMapIntensity;
        uniforms.aoMap.value = material.aoMap;
        uniforms.aoMapIntensity.value = material.aoMapIntensity; // uv repeat and offset setting priorities
        // 1. color map
        // 2. specular map
        // 3. normal map
        // 4. bump map
        // 5. alpha map
        // 6. emissive map

        var uvScaleMap;

        if (material.map) {
          uvScaleMap = material.map;
        } else if (material.specularMap) {
          uvScaleMap = material.specularMap;
        } else if (material.displacementMap) {
          uvScaleMap = material.displacementMap;
        } else if (material.normalMap) {
          uvScaleMap = material.normalMap;
        } else if (material.bumpMap) {
          uvScaleMap = material.bumpMap;
        } else if (material.glossinessMap) {
          uvScaleMap = material.glossinessMap;
        } else if (material.alphaMap) {
          uvScaleMap = material.alphaMap;
        } else if (material.emissiveMap) {
          uvScaleMap = material.emissiveMap;
        }

        if (uvScaleMap !== undefined) {
          // backwards compatibility
          if (uvScaleMap.isWebGLRenderTarget) {
            uvScaleMap = uvScaleMap.texture;
          }

          if (uvScaleMap.matrixAutoUpdate === true) {
            uvScaleMap.updateMatrix();
          }

          uniforms.uvTransform.value.copy(uvScaleMap.matrix);
        }

        if (material.envMap) {
          uniforms.envMap.value = material.envMap;
          uniforms.envMapIntensity.value = material.envMapIntensity; // don't flip CubeTexture envMaps, flip everything else:
          //  WebGLRenderTargetCube will be flipped for backwards compatibility
          //  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
          // this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future

          uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? -1 : 1;
          uniforms.reflectivity.value = material.reflectivity;
          uniforms.refractionRatio.value = material.refractionRatio;
          uniforms.maxMipLevel.value = renderer.properties.get(material.envMap).__maxMipLevel;
        }

        uniforms.specular.value.copy(material.specular);
        uniforms.glossiness.value = material.glossiness;
        uniforms.glossinessMap.value = material.glossinessMap;
        uniforms.emissiveMap.value = material.emissiveMap;
        uniforms.bumpMap.value = material.bumpMap;
        uniforms.normalMap.value = material.normalMap;
        uniforms.displacementMap.value = material.displacementMap;
        uniforms.displacementScale.value = material.displacementScale;
        uniforms.displacementBias.value = material.displacementBias;

        if (uniforms.glossinessMap.value !== null && defines.USE_GLOSSINESSMAP === undefined) {
          defines.USE_GLOSSINESSMAP = ''; // set USE_ROUGHNESSMAP to enable vUv

          defines.USE_ROUGHNESSMAP = '';
        }

        if (uniforms.glossinessMap.value === null && defines.USE_GLOSSINESSMAP !== undefined) {
          delete defines.USE_GLOSSINESSMAP;
          delete defines.USE_ROUGHNESSMAP;
        }
      }
    };
  }
  /**
   * Mesh Quantization Extension
   *
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_mesh_quantization
   */


  function GLTFMeshQuantizationExtension() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
  /*********************************/

  /********** INTERPOLATION ********/

  /*********************************/
  // Spline Interpolation
  // Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#appendix-c-spline-interpolation


  function GLTFCubicSplineInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    Interpolant.call(this, parameterPositions, sampleValues, sampleSize, resultBuffer);
  }

  GLTFCubicSplineInterpolant.prototype = Object.create(Interpolant.prototype);
  GLTFCubicSplineInterpolant.prototype.constructor = GLTFCubicSplineInterpolant;

  GLTFCubicSplineInterpolant.prototype.copySampleValue_ = function (index) {
    // Copies a sample value to the result buffer. See description of glTF
    // CUBICSPLINE values layout in interpolate_() function below.
    var result = this.resultBuffer,
        values = this.sampleValues,
        valueSize = this.valueSize,
        offset = index * valueSize * 3 + valueSize;

    for (var i = 0; i !== valueSize; i++) {
      result[i] = values[offset + i];
    }

    return result;
  };

  GLTFCubicSplineInterpolant.prototype.beforeStart_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;
  GLTFCubicSplineInterpolant.prototype.afterEnd_ = GLTFCubicSplineInterpolant.prototype.copySampleValue_;

  GLTFCubicSplineInterpolant.prototype.interpolate_ = function (i1, t0, t, t1) {
    var result = this.resultBuffer;
    var values = this.sampleValues;
    var stride = this.valueSize;
    var stride2 = stride * 2;
    var stride3 = stride * 3;
    var td = t1 - t0;
    var p = (t - t0) / td;
    var pp = p * p;
    var ppp = pp * p;
    var offset1 = i1 * stride3;
    var offset0 = offset1 - stride3;
    var s2 = -2 * ppp + 3 * pp;
    var s3 = ppp - pp;
    var s0 = 1 - s2;
    var s1 = s3 - pp + p; // Layout of keyframe output values for CUBICSPLINE animations:
    //   [ inTangent_1, splineVertex_1, outTangent_1, inTangent_2, splineVertex_2, ... ]

    for (var i = 0; i !== stride; i++) {
      var p0 = values[offset0 + i + stride]; // splineVertex_k

      var m0 = values[offset0 + i + stride2] * td; // outTangent_k * (t_k+1 - t_k)

      var p1 = values[offset1 + i + stride]; // splineVertex_k+1

      var m1 = values[offset1 + i] * td; // inTangent_k+1 * (t_k+1 - t_k)

      result[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }

    return result;
  };
  /*********************************/

  /********** INTERNALS ************/

  /*********************************/

  /* CONSTANTS */


  var WEBGL_CONSTANTS = {
    FLOAT: 5126,
    //FLOAT_MAT2: 35674,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
  };
  var WEBGL_COMPONENT_TYPES = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
  };
  var WEBGL_FILTERS = {
    9728: NearestFilter,
    9729: LinearFilter,
    9984: NearestMipmapNearestFilter,
    9985: LinearMipmapNearestFilter,
    9986: NearestMipmapLinearFilter,
    9987: LinearMipmapLinearFilter
  };
  var WEBGL_WRAPPINGS = {
    33071: ClampToEdgeWrapping,
    33648: MirroredRepeatWrapping,
    10497: RepeatWrapping$1
  };
  var WEBGL_TYPE_SIZES = {
    'SCALAR': 1,
    'VEC2': 2,
    'VEC3': 3,
    'VEC4': 4,
    'MAT2': 4,
    'MAT3': 9,
    'MAT4': 16
  };
  var ATTRIBUTES = {
    POSITION: 'position',
    NORMAL: 'normal',
    TANGENT: 'tangent',
    TEXCOORD_0: 'uv',
    TEXCOORD_1: 'uv2',
    COLOR_0: 'color',
    WEIGHTS_0: 'skinWeight',
    JOINTS_0: 'skinIndex'
  };
  var PATH_PROPERTIES = {
    scale: 'scale',
    translation: 'position',
    rotation: 'quaternion',
    weights: 'morphTargetInfluences'
  };
  var INTERPOLATION = {
    CUBICSPLINE: undefined,
    // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
    // keyframe track will be initialized with a default interpolation type, then modified.
    LINEAR: InterpolateLinear,
    STEP: InterpolateDiscrete
  };
  var ALPHA_MODES = {
    OPAQUE: 'OPAQUE',
    MASK: 'MASK',
    BLEND: 'BLEND'
  };
  var MIME_TYPE_FORMATS = {
    'image/png': RGBAFormat,
    'image/jpeg': RGBFormat
  };
  /* UTILITY FUNCTIONS */

  function resolveURL(url, path) {
    // Invalid URL
    if (typeof url !== 'string' || url === '') return ''; // Host Relative URL

    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
    } // Absolute URL http://,https://,//


    if (/^(https?:)?\/\//i.test(url)) return url; // Data URI

    if (/^data:.*,.*$/i.test(url)) return url; // Blob URL

    if (/^blob:.*$/i.test(url)) return url; // Relative URL

    return path + url;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#default-material
   */


  function createDefaultMaterial(cache) {
    if (cache['DefaultMaterial'] === undefined) {
      cache['DefaultMaterial'] = new MeshStandardMaterial({
        color: 0xFFFFFF,
        emissive: 0x000000,
        metalness: 1,
        roughness: 1,
        transparent: false,
        depthTest: true,
        side: FrontSide
      });
    }

    return cache['DefaultMaterial'];
  }

  function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
    // Add unknown glTF extensions to an object's userData.
    for (var name in objectDef.extensions) {
      if (knownExtensions[name] === undefined) {
        object.userData.gltfExtensions = object.userData.gltfExtensions || {};
        object.userData.gltfExtensions[name] = objectDef.extensions[name];
      }
    }
  }
  /**
   * @param {Object3D|Material|BufferGeometry} object
   * @param {GLTF.definition} gltfDef
   */


  function assignExtrasToUserData(object, gltfDef) {
    if (gltfDef.extras !== undefined) {
      if (_typeof$1(gltfDef.extras) === 'object') {
        Object.assign(object.userData, gltfDef.extras);
      } else {
        console.warn('THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras);
      }
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#morph-targets
   *
   * @param {BufferGeometry} geometry
   * @param {Array<GLTF.Target>} targets
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addMorphTargets(geometry, targets, parser) {
    var hasMorphPosition = false;
    var hasMorphNormal = false;

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];
      if (target.POSITION !== undefined) hasMorphPosition = true;
      if (target.NORMAL !== undefined) hasMorphNormal = true;
      if (hasMorphPosition && hasMorphNormal) break;
    }

    if (!hasMorphPosition && !hasMorphNormal) return Promise.resolve(geometry);
    var pendingPositionAccessors = [];
    var pendingNormalAccessors = [];

    for (var i = 0, il = targets.length; i < il; i++) {
      var target = targets[i];

      if (hasMorphPosition) {
        var pendingAccessor = target.POSITION !== undefined ? parser.getDependency('accessor', target.POSITION) : geometry.attributes.position;
        pendingPositionAccessors.push(pendingAccessor);
      }

      if (hasMorphNormal) {
        var pendingAccessor = target.NORMAL !== undefined ? parser.getDependency('accessor', target.NORMAL) : geometry.attributes.normal;
        pendingNormalAccessors.push(pendingAccessor);
      }
    }

    return Promise.all([Promise.all(pendingPositionAccessors), Promise.all(pendingNormalAccessors)]).then(function (accessors) {
      var morphPositions = accessors[0];
      var morphNormals = accessors[1];
      if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
      if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
      geometry.morphTargetsRelative = true;
      return geometry;
    });
  }
  /**
   * @param {Mesh} mesh
   * @param {GLTF.Mesh} meshDef
   */


  function updateMorphTargets(mesh, meshDef) {
    mesh.updateMorphTargets();

    if (meshDef.weights !== undefined) {
      for (var i = 0, il = meshDef.weights.length; i < il; i++) {
        mesh.morphTargetInfluences[i] = meshDef.weights[i];
      }
    } // .extras has user-defined data, so check that .extras.targetNames is an array.


    if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
      var targetNames = meshDef.extras.targetNames;

      if (mesh.morphTargetInfluences.length === targetNames.length) {
        mesh.morphTargetDictionary = {};

        for (var i = 0, il = targetNames.length; i < il; i++) {
          mesh.morphTargetDictionary[targetNames[i]] = i;
        }
      } else {
        console.warn('THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.');
      }
    }
  }

  function createPrimitiveKey(primitiveDef) {
    var dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
    var geometryKey;

    if (dracoExtension) {
      geometryKey = 'draco:' + dracoExtension.bufferView + ':' + dracoExtension.indices + ':' + createAttributesKey(dracoExtension.attributes);
    } else {
      geometryKey = primitiveDef.indices + ':' + createAttributesKey(primitiveDef.attributes) + ':' + primitiveDef.mode;
    }

    return geometryKey;
  }

  function createAttributesKey(attributes) {
    var attributesKey = '';
    var keys = Object.keys(attributes).sort();

    for (var i = 0, il = keys.length; i < il; i++) {
      attributesKey += keys[i] + ':' + attributes[keys[i]] + ';';
    }

    return attributesKey;
  }
  /* GLTF PARSER */


  function GLTFParser(json, extensions, options) {
    this.json = json || {};
    this.extensions = extensions || {};
    this.options = options || {}; // loader object cache

    this.cache = new GLTFRegistry(); // BufferGeometry caching

    this.primitiveCache = {};
    this.textureLoader = new TextureLoader(this.options.manager);
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType('arraybuffer');

    if (this.options.crossOrigin === 'use-credentials') {
      this.fileLoader.setWithCredentials(true);
    }
  }

  GLTFParser.prototype.parse = function (onLoad, onError) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions; // Clear the loader cache

    this.cache.removeAll(); // Mark the special nodes/meshes in json for efficient parse

    this.markDefs();
    Promise.all([this.getDependencies('scene'), this.getDependencies('animation'), this.getDependencies('camera')]).then(function (dependencies) {
      var result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser: parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      onLoad(result);
    }).catch(onError);
  };
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   */


  GLTFParser.prototype.markDefs = function () {
    var nodeDefs = this.json.nodes || [];
    var skinDefs = this.json.skins || [];
    var meshDefs = this.json.meshes || [];
    var meshReferences = {};
    var meshUses = {}; // Nothing in the node definition indicates whether it is a Bone or an
    // Object3D. Use the skins' joint references to mark bones.

    for (var skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      var joints = skinDefs[skinIndex].joints;

      for (var i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true;
      }
    } // Meshes can (and should) be reused by multiple nodes in a glTF asset. To
    // avoid having more than one Mesh with the same name, count
    // references and rename instances below.
    //
    // Example: CesiumMilkTruck sample model reuses "Wheel" meshes.


    for (var nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      var nodeDef = nodeDefs[nodeIndex];

      if (nodeDef.mesh !== undefined) {
        if (meshReferences[nodeDef.mesh] === undefined) {
          meshReferences[nodeDef.mesh] = meshUses[nodeDef.mesh] = 0;
        }

        meshReferences[nodeDef.mesh]++; // Nothing in the mesh definition indicates whether it is
        // a SkinnedMesh or Mesh. Use the node's mesh reference
        // to mark SkinnedMesh if node has skin.

        if (nodeDef.skin !== undefined) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
    }

    this.json.meshReferences = meshReferences;
    this.json.meshUses = meshUses;
  };
  /**
   * Requests the specified dependency asynchronously, with caching.
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|THREE.Texture|AnimationClip|ArrayBuffer|Object>}
   */


  GLTFParser.prototype.getDependency = function (type, index) {
    var cacheKey = type + ':' + index;
    var dependency = this.cache.get(cacheKey);

    if (!dependency) {
      switch (type) {
        case 'scene':
          dependency = this.loadScene(index);
          break;

        case 'node':
          dependency = this.loadNode(index);
          break;

        case 'mesh':
          dependency = this.loadMesh(index);
          break;

        case 'accessor':
          dependency = this.loadAccessor(index);
          break;

        case 'bufferView':
          dependency = this.loadBufferView(index);
          break;

        case 'buffer':
          dependency = this.loadBuffer(index);
          break;

        case 'material':
          dependency = this.loadMaterial(index);
          break;

        case 'texture':
          dependency = this.loadTexture(index);
          break;

        case 'skin':
          dependency = this.loadSkin(index);
          break;

        case 'animation':
          dependency = this.loadAnimation(index);
          break;

        case 'camera':
          dependency = this.loadCamera(index);
          break;

        case 'light':
          dependency = this.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].loadLight(index);
          break;

        default:
          throw new Error('Unknown type: ' + type);
      }

      this.cache.add(cacheKey, dependency);
    }

    return dependency;
  };
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */


  GLTFParser.prototype.getDependencies = function (type) {
    var dependencies = this.cache.get(type);

    if (!dependencies) {
      var parser = this;
      var defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || [];
      dependencies = Promise.all(defs.map(function (def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }

    return dependencies;
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBuffer = function (bufferIndex) {
    var bufferDef = this.json.buffers[bufferIndex];
    var loader = this.fileLoader;

    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
      throw new Error('THREE.GLTFLoader: ' + bufferDef.type + ' buffer type is not supported.');
    } // If present, GLB container is required to be the first buffer.


    if (bufferDef.uri === undefined && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }

    var options = this.options;
    return new Promise(function (resolve, reject) {
      loader.load(resolveURL(bufferDef.uri, options.path), resolve, undefined, function () {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */


  GLTFParser.prototype.loadBufferView = function (bufferViewIndex) {
    var bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency('buffer', bufferViewDef.buffer).then(function (buffer) {
      var byteLength = bufferViewDef.byteLength || 0;
      var byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */


  GLTFParser.prototype.loadAccessor = function (accessorIndex) {
    var parser = this;
    var json = this.json;
    var accessorDef = this.json.accessors[accessorIndex];

    if (accessorDef.bufferView === undefined && accessorDef.sparse === undefined) {
      // Ignore empty accessors, which may be used to declare runtime
      // information about attributes coming from another source (e.g. Draco
      // compression extension).
      return Promise.resolve(null);
    }

    var pendingBufferViews = [];

    if (accessorDef.bufferView !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }

    if (accessorDef.sparse !== undefined) {
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency('bufferView', accessorDef.sparse.values.bufferView));
    }

    return Promise.all(pendingBufferViews).then(function (bufferViews) {
      var bufferView = bufferViews[0];
      var itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      var TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.

      var elementBytes = TypedArray.BYTES_PER_ELEMENT;
      var itemBytes = elementBytes * itemSize;
      var byteOffset = accessorDef.byteOffset || 0;
      var byteStride = accessorDef.bufferView !== undefined ? json.bufferViews[accessorDef.bufferView].byteStride : undefined;
      var normalized = accessorDef.normalized === true;
      var array, bufferAttribute; // The buffer is not interleaved if the stride is the item size in bytes.

      if (byteStride && byteStride !== itemBytes) {
        // Each "slice" of the buffer, as defined by 'count' elements of 'byteStride' bytes, gets its own InterleavedBuffer
        // This makes sure that IBA.count reflects accessor.count properly
        var ibSlice = Math.floor(byteOffset / byteStride);
        var ibCacheKey = 'InterleavedBuffer:' + accessorDef.bufferView + ':' + accessorDef.componentType + ':' + ibSlice + ':' + accessorDef.count;
        var ib = parser.cache.get(ibCacheKey);

        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes); // Integer parameters to IB/IBA are in array elements, not bytes.

          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }

        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }

        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      } // https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#sparse-accessors


      if (accessorDef.sparse !== undefined) {
        var itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        var TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        var byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        var byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        var sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        var sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);

        if (bufferView !== null) {
          // Avoid modifying the original ArrayBuffer, if the bufferView wasn't initialized with zeroes.
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }

        for (var i = 0, il = sparseIndices.length; i < il; i++) {
          var index = sparseIndices[i];
          bufferAttribute.setX(index, sparseValues[i * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i * itemSize + 3]);
          if (itemSize >= 5) throw new Error('THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.');
        }
      }

      return bufferAttribute;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   * @param {number} textureIndex
   * @return {Promise<THREE.Texture>}
   */


  GLTFParser.prototype.loadTexture = function (textureIndex) {
    var parser = this;
    var json = this.json;
    var options = this.options;
    var textureLoader = this.textureLoader;
    var URL = window.URL || window.webkitURL;
    var textureDef = json.textures[textureIndex];
    var textureExtensions = textureDef.extensions || {};
    var source;

    if (textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS]) {
      source = json.images[textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS].source];
    } else {
      source = json.images[textureDef.source];
    }

    var sourceURI = source.uri;
    var isObjectURL = false;

    if (source.bufferView !== undefined) {
      // Load binary image data from bufferView, if provided.
      sourceURI = parser.getDependency('bufferView', source.bufferView).then(function (bufferView) {
        isObjectURL = true;
        var blob = new Blob([bufferView], {
          type: source.mimeType
        });
        sourceURI = URL.createObjectURL(blob);
        return sourceURI;
      });
    }

    return Promise.resolve(sourceURI).then(function (sourceURI) {
      // Load Texture resource.
      var loader = options.manager.getHandler(sourceURI);

      if (!loader) {
        loader = textureExtensions[EXTENSIONS.MSFT_TEXTURE_DDS] ? parser.extensions[EXTENSIONS.MSFT_TEXTURE_DDS].ddsLoader : textureLoader;
      }

      return new Promise(function (resolve, reject) {
        loader.load(resolveURL(sourceURI, options.path), resolve, undefined, reject);
      });
    }).then(function (texture) {
      // Clean up resources and configure Texture.
      if (isObjectURL === true) {
        URL.revokeObjectURL(sourceURI);
      }

      texture.flipY = false;
      if (textureDef.name !== undefined) texture.name = textureDef.name; // Ignore unknown mime types, like DDS files.

      if (source.mimeType in MIME_TYPE_FORMATS) {
        texture.format = MIME_TYPE_FORMATS[source.mimeType];
      }

      var samplers = json.samplers || {};
      var sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping$1;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping$1;
      return texture;
    });
  };
  /**
   * Asynchronously assigns a texture to the given material parameters.
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @return {Promise}
   */


  GLTFParser.prototype.assignTexture = function (materialParams, mapName, mapDef) {
    var parser = this;
    return this.getDependency('texture', mapDef.index).then(function (texture) {
      if (!texture.isCompressedTexture) {
        switch (mapName) {
          case 'aoMap':
          case 'emissiveMap':
          case 'metalnessMap':
          case 'normalMap':
          case 'roughnessMap':
            texture.format = RGBFormat;
            break;
        }
      } // Materials sample aoMap from UV set 1 and other maps from UV set 0 - this can't be configured
      // However, we will copy UV set 0 to UV set 1 on demand for aoMap


      if (mapDef.texCoord !== undefined && mapDef.texCoord != 0 && !(mapName === 'aoMap' && mapDef.texCoord == 1)) {
        console.warn('THREE.GLTFLoader: Custom UV set ' + mapDef.texCoord + ' for texture ' + mapName + ' not yet supported.');
      }

      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        var transform = mapDef.extensions !== undefined ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : undefined;

        if (transform) {
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
        }
      }

      materialParams[mapName] = texture;
    });
  };
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accomodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   * @param  {Object3D} mesh Mesh, Line, or Points instance.
   */


  GLTFParser.prototype.assignFinalMaterial = function (mesh) {
    var geometry = mesh.geometry;
    var material = mesh.material;
    var extensions = this.extensions;
    var useVertexTangents = geometry.attributes.tangent !== undefined;
    var useVertexColors = geometry.attributes.color !== undefined;
    var useFlatShading = geometry.attributes.normal === undefined;
    var useSkinning = mesh.isSkinnedMesh === true;
    var useMorphTargets = Object.keys(geometry.morphAttributes).length > 0;
    var useMorphNormals = useMorphTargets && geometry.morphAttributes.normal !== undefined;

    if (mesh.isPoints) {
      var cacheKey = 'PointsMaterial:' + material.uuid;
      var pointsMaterial = this.cache.get(cacheKey);

      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false; // glTF spec says points should be 1px

        this.cache.add(cacheKey, pointsMaterial);
      }

      material = pointsMaterial;
    } else if (mesh.isLine) {
      var cacheKey = 'LineBasicMaterial:' + material.uuid;
      var lineMaterial = this.cache.get(cacheKey);

      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        this.cache.add(cacheKey, lineMaterial);
      }

      material = lineMaterial;
    } // Clone the material if it will be modified


    if (useVertexTangents || useVertexColors || useFlatShading || useSkinning || useMorphTargets) {
      var cacheKey = 'ClonedMaterial:' + material.uuid + ':';
      if (material.isGLTFSpecularGlossinessMaterial) cacheKey += 'specular-glossiness:';
      if (useSkinning) cacheKey += 'skinning:';
      if (useVertexTangents) cacheKey += 'vertex-tangents:';
      if (useVertexColors) cacheKey += 'vertex-colors:';
      if (useFlatShading) cacheKey += 'flat-shading:';
      if (useMorphTargets) cacheKey += 'morph-targets:';
      if (useMorphNormals) cacheKey += 'morph-normals:';
      var cachedMaterial = this.cache.get(cacheKey);

      if (!cachedMaterial) {
        cachedMaterial = material.isGLTFSpecularGlossinessMaterial ? extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].cloneMaterial(material) : material.clone();
        if (useSkinning) cachedMaterial.skinning = true;
        if (useVertexTangents) cachedMaterial.vertexTangents = true;
        if (useVertexColors) cachedMaterial.vertexColors = VertexColors;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useMorphTargets) cachedMaterial.morphTargets = true;
        if (useMorphNormals) cachedMaterial.morphNormals = true;
        this.cache.add(cacheKey, cachedMaterial);
      }

      material = cachedMaterial;
    } // workarounds for mesh and geometry


    if (material.aoMap && geometry.attributes.uv2 === undefined && geometry.attributes.uv !== undefined) {
      geometry.setAttribute('uv2', new BufferAttribute(geometry.attributes.uv.array, 2));
    }

    if (material.isGLTFSpecularGlossinessMaterial) {
      // for GLTFSpecularGlossinessMaterial(ShaderMaterial) uniforms runtime update
      mesh.onBeforeRender = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].refreshUniforms;
    } // https://github.com/mrdoob/three.js/issues/11438#issuecomment-507003995


    if (material.normalScale && !useVertexTangents) {
      material.normalScale.y = -material.normalScale.y;
    }

    mesh.material = material;
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */


  GLTFParser.prototype.loadMaterial = function (materialIndex) {
    var parser = this;
    var json = this.json;
    var extensions = this.extensions;
    var materialDef = json.materials[materialIndex];
    var materialType;
    var materialParams = {};
    var materialExtensions = materialDef.extensions || {};
    var pending = [];

    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      var sgExtension = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS];
      materialType = sgExtension.getMaterialType();
      pending.push(sgExtension.extendParams(materialParams, materialDef, parser));
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      var kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      // Specification:
      // https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#metallic-roughness-material
      materialType = MeshStandardMaterial;
      var metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color$1(1.0, 1.0, 1.0);
      materialParams.opacity = 1.0;

      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        var array = metallicRoughness.baseColorFactor;
        materialParams.color.fromArray(array);
        materialParams.opacity = array[3];
      }

      if (metallicRoughness.baseColorTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'map', metallicRoughness.baseColorTexture));
      }

      materialParams.metalness = metallicRoughness.metallicFactor !== undefined ? metallicRoughness.metallicFactor : 1.0;
      materialParams.roughness = metallicRoughness.roughnessFactor !== undefined ? metallicRoughness.roughnessFactor : 1.0;

      if (metallicRoughness.metallicRoughnessTexture !== undefined) {
        pending.push(parser.assignTexture(materialParams, 'metalnessMap', metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, 'roughnessMap', metallicRoughness.metallicRoughnessTexture));
      }
    }

    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }

    var alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;

    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
    } else {
      materialParams.transparent = false;

      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== undefined ? materialDef.alphaCutoff : 0.5;
      }
    }

    if (materialDef.normalTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'normalMap', materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);

      if (materialDef.normalTexture.scale !== undefined) {
        materialParams.normalScale.set(materialDef.normalTexture.scale, materialDef.normalTexture.scale);
      }
    }

    if (materialDef.occlusionTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'aoMap', materialDef.occlusionTexture));

      if (materialDef.occlusionTexture.strength !== undefined) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }

    if (materialDef.emissiveFactor !== undefined && materialType !== MeshBasicMaterial) {
      materialParams.emissive = new Color$1().fromArray(materialDef.emissiveFactor);
    }

    if (materialDef.emissiveTexture !== undefined && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, 'emissiveMap', materialDef.emissiveTexture));
    }

    return Promise.all(pending).then(function () {
      var material;

      if (materialType === ShaderMaterial) {
        material = extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS].createMaterial(materialParams);
      } else {
        material = new materialType(materialParams);
      }

      if (materialDef.name !== undefined) material.name = materialDef.name; // baseColorTexture, emissiveTexture, and specularGlossinessTexture use sRGB encoding.

      if (material.map) material.map.encoding = sRGBEncoding;
      if (material.emissiveMap) material.emissiveMap.encoding = sRGBEncoding;
      if (material.specularMap) material.specularMap.encoding = sRGBEncoding;
      assignExtrasToUserData(material, materialDef);
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  };
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   */


  function computeBounds(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var box = new Box3();

    if (attributes.POSITION !== undefined) {
      var accessor = parser.json.accessors[attributes.POSITION];
      var min = accessor.min;
      var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

      if (min !== undefined && max !== undefined) {
        box.set(new Vector3$1(min[0], min[1], min[2]), new Vector3$1(max[0], max[1], max[2]));
      } else {
        console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
        return;
      }
    } else {
      return;
    }

    var targets = primitiveDef.targets;

    if (targets !== undefined) {
      var vector = new Vector3$1();

      for (var i = 0, il = targets.length; i < il; i++) {
        var target = targets[i];

        if (target.POSITION !== undefined) {
          var accessor = parser.json.accessors[target.POSITION];
          var min = accessor.min;
          var max = accessor.max; // glTF requires 'min' and 'max', but VRM (which extends glTF) currently ignores that requirement.

          if (min !== undefined && max !== undefined) {
            // we need to get max of absolute components because target weight is [-1,1]
            vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
            vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
            vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
            box.expandByVector(vector);
          } else {
            console.warn('THREE.GLTFLoader: Missing min/max properties for accessor POSITION.');
          }
        }
      }
    }

    geometry.boundingBox = box;
    var sphere = new Sphere$1();
    box.getCenter(sphere.center);
    sphere.radius = box.min.distanceTo(box.max) / 2;
    geometry.boundingSphere = sphere;
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {GLTF.Primitive} primitiveDef
   * @param {GLTFParser} parser
   * @return {Promise<BufferGeometry>}
   */


  function addPrimitiveAttributes(geometry, primitiveDef, parser) {
    var attributes = primitiveDef.attributes;
    var pending = [];

    function assignAttributeAccessor(accessorIndex, attributeName) {
      return parser.getDependency('accessor', accessorIndex).then(function (accessor) {
        geometry.setAttribute(attributeName, accessor);
      });
    }

    for (var gltfAttributeName in attributes) {
      var threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase(); // Skip attributes already provided by e.g. Draco extension.

      if (threeAttributeName in geometry.attributes) continue;
      pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
    }

    if (primitiveDef.indices !== undefined && !geometry.index) {
      var accessor = parser.getDependency('accessor', primitiveDef.indices).then(function (accessor) {
        geometry.setIndex(accessor);
      });
      pending.push(accessor);
    }

    assignExtrasToUserData(geometry, primitiveDef);
    computeBounds(geometry, primitiveDef, parser);
    return Promise.all(pending).then(function () {
      return primitiveDef.targets !== undefined ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
    });
  }
  /**
   * @param {BufferGeometry} geometry
   * @param {Number} drawMode
   * @return {BufferGeometry}
   */


  function toTrianglesDrawMode(geometry, drawMode) {
    var index = geometry.getIndex(); // generate index if not present

    if (index === null) {
      var indices = [];
      var position = geometry.getAttribute('position');

      if (position !== undefined) {
        for (var i = 0; i < position.count; i++) {
          indices.push(i);
        }

        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
        return geometry;
      }
    } //


    var numberOfTriangles = index.count - 2;
    var newIndices = [];

    if (drawMode === TriangleFanDrawMode) {
      // gl.TRIANGLE_FAN
      for (var i = 1; i <= numberOfTriangles; i++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i));
        newIndices.push(index.getX(i + 1));
      }
    } else {
      // gl.TRIANGLE_STRIP
      for (var i = 0; i < numberOfTriangles; i++) {
        if (i % 2 === 0) {
          newIndices.push(index.getX(i));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i + 2));
        } else {
          newIndices.push(index.getX(i + 2));
          newIndices.push(index.getX(i + 1));
          newIndices.push(index.getX(i));
        }
      }
    }

    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error('THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
    } // build final geometry


    var newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    return newGeometry;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */


  GLTFParser.prototype.loadGeometries = function (primitives) {
    var parser = this;
    var extensions = this.extensions;
    var cache = this.primitiveCache;

    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function (geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }

    var pending = [];

    for (var i = 0, il = primitives.length; i < il; i++) {
      var primitive = primitives[i];
      var cacheKey = createPrimitiveKey(primitive); // See if we've already created this geometry

      var cached = cache[cacheKey];

      if (cached) {
        // Use the cached geometry if it exists
        pending.push(cached.promise);
      } else {
        var geometryPromise;

        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          // Use DRACO geometry if available
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          // Otherwise create a new geometry
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        } // Cache this geometry


        cache[cacheKey] = {
          primitive: primitive,
          promise: geometryPromise
        };
        pending.push(geometryPromise);
      }
    }

    return Promise.all(pending);
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh>}
   */


  GLTFParser.prototype.loadMesh = function (meshIndex) {
    var parser = this;
    var json = this.json;
    var meshDef = json.meshes[meshIndex];
    var primitives = meshDef.primitives;
    var pending = [];

    for (var i = 0, il = primitives.length; i < il; i++) {
      var material = primitives[i].material === undefined ? createDefaultMaterial(this.cache) : this.getDependency('material', primitives[i].material);
      pending.push(material);
    }

    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function (results) {
      var materials = results.slice(0, results.length - 1);
      var geometries = results[results.length - 1];
      var meshes = [];

      for (var i = 0, il = geometries.length; i < il; i++) {
        var geometry = geometries[i];
        var primitive = primitives[i]; // 1. create Mesh

        var mesh;
        var material = materials[i];

        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === undefined) {
          // .isSkinnedMesh isn't in glTF spec. See .markDefs()
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);

          if (mesh.isSkinnedMesh === true && !mesh.geometry.attributes.skinWeight.normalized) {
            // we normalize floating point skin weight array to fix malformed assets (see #15319)
            // it's important to skip this for non-float32 data since normalizeSkinWeights assumes non-normalized inputs
            mesh.normalizeSkinWeights();
          }

          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line$1(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error('THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode);
        }

        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }

        mesh.name = meshDef.name || 'mesh_' + meshIndex;
        if (geometries.length > 1) mesh.name += '_' + i;
        assignExtrasToUserData(mesh, meshDef);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }

      if (meshes.length === 1) {
        return meshes[0];
      }

      var group = new Group();

      for (var i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i]);
      }

      return group;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   * @param {number} cameraIndex
   * @return {Promise<THREE.Camera>}
   */


  GLTFParser.prototype.loadCamera = function (cameraIndex) {
    var camera;
    var cameraDef = this.json.cameras[cameraIndex];
    var params = cameraDef[cameraDef.type];

    if (!params) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.');
      return;
    }

    if (cameraDef.type === 'perspective') {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === 'orthographic') {
      camera = new OrthographicCamera(params.xmag / -2, params.xmag / 2, params.ymag / 2, params.ymag / -2, params.znear, params.zfar);
    }

    if (cameraDef.name !== undefined) camera.name = cameraDef.name;
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   * @param {number} skinIndex
   * @return {Promise<Object>}
   */


  GLTFParser.prototype.loadSkin = function (skinIndex) {
    var skinDef = this.json.skins[skinIndex];
    var skinEntry = {
      joints: skinDef.joints
    };

    if (skinDef.inverseBindMatrices === undefined) {
      return Promise.resolve(skinEntry);
    }

    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(function (accessor) {
      skinEntry.inverseBindMatrices = accessor;
      return skinEntry;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */


  GLTFParser.prototype.loadAnimation = function (animationIndex) {
    var json = this.json;
    var animationDef = json.animations[animationIndex];
    var pendingNodes = [];
    var pendingInputAccessors = [];
    var pendingOutputAccessors = [];
    var pendingSamplers = [];
    var pendingTargets = [];

    for (var i = 0, il = animationDef.channels.length; i < il; i++) {
      var channel = animationDef.channels[i];
      var sampler = animationDef.samplers[channel.sampler];
      var target = channel.target;
      var name = target.node !== undefined ? target.node : target.id; // NOTE: target.id is deprecated.

      var input = animationDef.parameters !== undefined ? animationDef.parameters[sampler.input] : sampler.input;
      var output = animationDef.parameters !== undefined ? animationDef.parameters[sampler.output] : sampler.output;
      pendingNodes.push(this.getDependency('node', name));
      pendingInputAccessors.push(this.getDependency('accessor', input));
      pendingOutputAccessors.push(this.getDependency('accessor', output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }

    return Promise.all([Promise.all(pendingNodes), Promise.all(pendingInputAccessors), Promise.all(pendingOutputAccessors), Promise.all(pendingSamplers), Promise.all(pendingTargets)]).then(function (dependencies) {
      var nodes = dependencies[0];
      var inputAccessors = dependencies[1];
      var outputAccessors = dependencies[2];
      var samplers = dependencies[3];
      var targets = dependencies[4];
      var tracks = [];

      for (var i = 0, il = nodes.length; i < il; i++) {
        var node = nodes[i];
        var inputAccessor = inputAccessors[i];
        var outputAccessor = outputAccessors[i];
        var sampler = samplers[i];
        var target = targets[i];
        if (node === undefined) continue;
        node.updateMatrix();
        node.matrixAutoUpdate = true;
        var TypedKeyframeTrack;

        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;

          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack;
            break;

          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }

        var targetName = node.name ? node.name : node.uuid;
        var interpolation = sampler.interpolation !== undefined ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
        var targetNames = [];

        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          // Node may be a Group (glTF mesh with several primitives) or a Mesh.
          node.traverse(function (object) {
            if (object.isMesh === true && object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid);
            }
          });
        } else {
          targetNames.push(targetName);
        }

        var outputArray = outputAccessor.array;

        if (outputAccessor.normalized) {
          var scale;

          if (outputArray.constructor === Int8Array) {
            scale = 1 / 127;
          } else if (outputArray.constructor === Uint8Array) {
            scale = 1 / 255;
          } else if (outputArray.constructor == Int16Array) {
            scale = 1 / 32767;
          } else if (outputArray.constructor === Uint16Array) {
            scale = 1 / 65535;
          } else {
            throw new Error('THREE.GLTFLoader: Unsupported output accessor component type.');
          }

          var scaled = new Float32Array(outputArray.length);

          for (var j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale;
          }

          outputArray = scaled;
        }

        for (var j = 0, jl = targetNames.length; j < jl; j++) {
          var track = new TypedKeyframeTrack(targetNames[j] + '.' + PATH_PROPERTIES[target.path], inputAccessor.array, outputArray, interpolation); // Override interpolation with custom factory method.

          if (sampler.interpolation === 'CUBICSPLINE') {
            track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
              // A CUBICSPLINE keyframe in glTF has three output values for each input value,
              // representing inTangent, splineVertex, and outTangent. As a result, track.getValueSize()
              // must be divided by three to get the interpolant's sampleSize argument.
              return new GLTFCubicSplineInterpolant(this.times, this.values, this.getValueSize() / 3, result);
            }; // Mark as CUBICSPLINE. `track.getInterpolation()` doesn't support custom interpolants.


            track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
          }

          tracks.push(track);
        }
      }

      var name = animationDef.name !== undefined ? animationDef.name : 'animation_' + animationIndex;
      return new AnimationClip(name, undefined, tracks);
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */


  GLTFParser.prototype.loadNode = function (nodeIndex) {
    var json = this.json;
    var extensions = this.extensions;
    var parser = this;
    var meshReferences = json.meshReferences;
    var meshUses = json.meshUses;
    var nodeDef = json.nodes[nodeIndex];
    return function () {
      var pending = [];

      if (nodeDef.mesh !== undefined) {
        pending.push(parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
          var node;

          if (meshReferences[nodeDef.mesh] > 1) {
            var instanceNum = meshUses[nodeDef.mesh]++;
            node = mesh.clone();
            node.name += '_instance_' + instanceNum; // onBeforeRender copy for Specular-Glossiness

            node.onBeforeRender = mesh.onBeforeRender;

            for (var i = 0, il = node.children.length; i < il; i++) {
              node.children[i].name += '_instance_' + instanceNum;
              node.children[i].onBeforeRender = mesh.children[i].onBeforeRender;
            }
          } else {
            node = mesh;
          } // if weights are provided on the node, override weights on the mesh.


          if (nodeDef.weights !== undefined) {
            node.traverse(function (o) {
              if (!o.isMesh) return;

              for (var i = 0, il = nodeDef.weights.length; i < il; i++) {
                o.morphTargetInfluences[i] = nodeDef.weights[i];
              }
            });
          }

          return node;
        }));
      }

      if (nodeDef.camera !== undefined) {
        pending.push(parser.getDependency('camera', nodeDef.camera));
      }

      if (nodeDef.extensions && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL] && nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light !== undefined) {
        pending.push(parser.getDependency('light', nodeDef.extensions[EXTENSIONS.KHR_LIGHTS_PUNCTUAL].light));
      }

      return Promise.all(pending);
    }().then(function (objects) {
      var node; // .isBone isn't in glTF spec. See .markDefs

      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }

      if (node !== objects[0]) {
        for (var i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i]);
        }
      }

      if (nodeDef.name !== undefined) {
        node.userData.name = nodeDef.name;
        node.name = PropertyBinding.sanitizeNodeName(nodeDef.name);
      }

      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);

      if (nodeDef.matrix !== undefined) {
        var matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix(matrix);
      } else {
        if (nodeDef.translation !== undefined) {
          node.position.fromArray(nodeDef.translation);
        }

        if (nodeDef.rotation !== undefined) {
          node.quaternion.fromArray(nodeDef.rotation);
        }

        if (nodeDef.scale !== undefined) {
          node.scale.fromArray(nodeDef.scale);
        }
      }

      return node;
    });
  };
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   * @param {number} sceneIndex
   * @return {Promise<Scene>}
   */


  GLTFParser.prototype.loadScene = function () {
    // scene node hierachy builder
    function buildNodeHierachy(nodeId, parentObject, json, parser) {
      var nodeDef = json.nodes[nodeId];
      return parser.getDependency('node', nodeId).then(function (node) {
        if (nodeDef.skin === undefined) return node; // build skeleton here as well

        var skinEntry;
        return parser.getDependency('skin', nodeDef.skin).then(function (skin) {
          skinEntry = skin;
          var pendingJoints = [];

          for (var i = 0, il = skinEntry.joints.length; i < il; i++) {
            pendingJoints.push(parser.getDependency('node', skinEntry.joints[i]));
          }

          return Promise.all(pendingJoints);
        }).then(function (jointNodes) {
          node.traverse(function (mesh) {
            if (!mesh.isMesh) return;
            var bones = [];
            var boneInverses = [];

            for (var j = 0, jl = jointNodes.length; j < jl; j++) {
              var jointNode = jointNodes[j];

              if (jointNode) {
                bones.push(jointNode);
                var mat = new Matrix4();

                if (skinEntry.inverseBindMatrices !== undefined) {
                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16);
                }

                boneInverses.push(mat);
              } else {
                console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinEntry.joints[j]);
              }
            }

            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld);
          });
          return node;
        });
      }).then(function (node) {
        // build node hierachy
        parentObject.add(node);
        var pending = [];

        if (nodeDef.children) {
          var children = nodeDef.children;

          for (var i = 0, il = children.length; i < il; i++) {
            var child = children[i];
            pending.push(buildNodeHierachy(child, node, json, parser));
          }
        }

        return Promise.all(pending);
      });
    }

    return function loadScene(sceneIndex) {
      var json = this.json;
      var extensions = this.extensions;
      var sceneDef = this.json.scenes[sceneIndex];
      var parser = this;
      var scene = new Scene$2();
      if (sceneDef.name !== undefined) scene.name = sceneDef.name;
      assignExtrasToUserData(scene, sceneDef);
      if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
      var nodeIds = sceneDef.nodes || [];
      var pending = [];

      for (var i = 0, il = nodeIds.length; i < il; i++) {
        pending.push(buildNodeHierachy(nodeIds[i], scene, json, parser));
      }

      return Promise.all(pending).then(function () {
        return scene;
      });
    };
  }();

  return GLTFLoader;
}();/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.6.9
*/
// DEFLATE is a complex format; to read this code, you should probably check the RFC first:
// https://tools.ietf.org/html/rfc1951
// You may also wish to take a look at the guide I made about this program:
// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad
// Some of the following code is similar to that of UZIP.js:
// https://github.com/photopea/UZIP.js
// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.
// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint
// is better for memory in most engines (I *think*).
var ch2 = {};

var durl = function durl(c) {
  return URL.createObjectURL(new Blob([c], {
    type: 'text/javascript'
  }));
};

var cwk = function cwk(u) {
  return new Worker(u);
};

try {
  URL.revokeObjectURL(durl(''));
} catch (e) {
  // We're in Deno or a very old browser
  durl = function durl(c) {
    return 'data:application/javascript;charset=UTF-8,' + encodeURI(c);
  }; // If Deno, this is necessary; if not, this changes nothing


  cwk = function cwk(u) {
    return new Worker(u, {
      type: 'module'
    });
  };
}

var wk = function wk(c, id, msg, transfer, cb) {
  var w = cwk(ch2[id] || (ch2[id] = durl(c)));

  w.onerror = function (e) {
    return cb(e.error, null);
  };

  w.onmessage = function (e) {
    return cb(null, e.data);
  };

  w.postMessage(msg, transfer);
  return w;
}; // aliases for shorter compressed code (most minifers don't do this)


var u8 = Uint8Array,
    u16 = Uint16Array,
    u32 = Uint32Array; // fixed length extra bits

var fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0,
/* unused */
0, 0,
/* impossible */
0]); // fixed distance extra bits
// see fleb note

var fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
/* unused */
0, 0]); // code length index map

var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); // get base, reverse index map from extra bits

var freb = function freb(eb, start) {
  var b = new u16(31);

  for (var i = 0; i < 31; ++i) {
    b[i] = start += 1 << eb[i - 1];
  } // numbers here are at max 18 bits


  var r = new u32(b[30]);

  for (var i = 1; i < 30; ++i) {
    for (var j = b[i]; j < b[i + 1]; ++j) {
      r[j] = j - b[i] << 5 | i;
    }
  }

  return [b, r];
};

var _a = freb(fleb, 2),
    fl = _a[0],
    revfl = _a[1]; // we can ignore the fact that the other numbers are wrong; they never happen anyway


fl[28] = 258, revfl[258] = 28;

var _b = freb(fdeb, 0),
    fd = _b[0],
    revfd = _b[1]; // map of value to reverse (assuming 16 bits)


var rev = new u16(32768);

for (var i = 0; i < 32768; ++i) {
  // reverse table algorithm from SO
  var x$1 = (i & 0xAAAA) >>> 1 | (i & 0x5555) << 1;
  x$1 = (x$1 & 0xCCCC) >>> 2 | (x$1 & 0x3333) << 2;
  x$1 = (x$1 & 0xF0F0) >>> 4 | (x$1 & 0x0F0F) << 4;
  rev[i] = ((x$1 & 0xFF00) >>> 8 | (x$1 & 0x00FF) << 8) >>> 1;
} // create huffman tree from u8 "map": index -> code length for code index
// mb (max bits) must be at most 15
// TODO: optimize/split up?


var hMap = function hMap(cd, mb, r) {
  var s = cd.length; // index

  var i = 0; // u16 "map": index -> # of codes with bit length = index

  var l = new u16(mb); // length of cd must be 288 (total # of codes)

  for (; i < s; ++i) {
    ++l[cd[i] - 1];
  } // u16 "map": index -> minimum code for bit length = index


  var le = new u16(mb);

  for (i = 0; i < mb; ++i) {
    le[i] = le[i - 1] + l[i - 1] << 1;
  }

  var co;

  if (r) {
    // u16 "map": index -> number of actual bits, symbol for code
    co = new u16(1 << mb); // bits to remove for reverser

    var rvb = 15 - mb;

    for (i = 0; i < s; ++i) {
      // ignore 0 lengths
      if (cd[i]) {
        // num encoding both symbol and bits read
        var sv = i << 4 | cd[i]; // free bits

        var r_1 = mb - cd[i]; // start value

        var v = le[cd[i] - 1]++ << r_1; // m is end value

        for (var m = v | (1 << r_1) - 1; v <= m; ++v) {
          // every 16 bit value starting with the code yields the same result
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s);

    for (i = 0; i < s; ++i) {
      if (cd[i]) {
        co[i] = rev[le[cd[i] - 1]++] >>> 15 - cd[i];
      }
    }
  }

  return co;
}; // fixed length tree


var flt = new u8(288);

for (var i = 0; i < 144; ++i) {
  flt[i] = 8;
}

for (var i = 144; i < 256; ++i) {
  flt[i] = 9;
}

for (var i = 256; i < 280; ++i) {
  flt[i] = 7;
}

for (var i = 280; i < 288; ++i) {
  flt[i] = 8;
} // fixed distance tree


var fdt = new u8(32);

for (var i = 0; i < 32; ++i) {
  fdt[i] = 5;
} // fixed length map


var flm = /*#__PURE__*/hMap(flt, 9, 0),
    flrm = /*#__PURE__*/hMap(flt, 9, 1); // fixed distance map

var fdm = /*#__PURE__*/hMap(fdt, 5, 0),
    fdrm = /*#__PURE__*/hMap(fdt, 5, 1); // find max of array

var max = function max(a) {
  var m = a[0];

  for (var i = 1; i < a.length; ++i) {
    if (a[i] > m) m = a[i];
  }

  return m;
}; // read d, starting at bit p and mask with m


var bits = function bits(d, p, m) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8) >> (p & 7) & m;
}; // read d, starting at bit p continuing for at least 16 bits


var bits16 = function bits16(d, p) {
  var o = p / 8 | 0;
  return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);
}; // get end of byte


var shft = function shft(p) {
  return (p / 8 | 0) + (p & 7 && 1);
}; // typed array slice - allows garbage collector to free original reference,
// while being more compatible than .slice


var slc = function slc(v, s, e) {
  if (s == null || s < 0) s = 0;
  if (e == null || e > v.length) e = v.length; // can't use .constructor in case user-supplied

  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);
  n.set(v.subarray(s, e));
  return n;
}; // expands raw DEFLATE data


var inflt = function inflt(dat, buf, st) {
  // source length
  var sl = dat.length;
  if (!sl || st && !st.l && sl < 5) return buf || new u8(0); // have to estimate size

  var noBuf = !buf || st; // no state

  var noSt = !st || st.i;
  if (!st) st = {}; // Assumes roughly 33% compression ratio average

  if (!buf) buf = new u8(sl * 3); // ensure buffer can fit at least l elements

  var cbuf = function cbuf(l) {
    var bl = buf.length; // need to increase size to fit

    if (l > bl) {
      // Double or set to necessary, whichever is greater
      var nbuf = new u8(Math.max(bl * 2, l));
      nbuf.set(buf);
      buf = nbuf;
    }
  }; //  last chunk         bitpos           bytes


  var final = st.f || 0,
      pos = st.p || 0,
      bt = st.b || 0,
      lm = st.l,
      dm = st.d,
      lbt = st.m,
      dbt = st.n; // total bits

  var tbts = sl * 8;

  do {
    if (!lm) {
      // BFINAL - this is only 1 when last chunk is next
      st.f = final = bits(dat, pos, 1); // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman

      var type = bits(dat, pos + 1, 3);
      pos += 3;

      if (!type) {
        // go to end of byte boundary
        var s = shft(pos) + 4,
            l = dat[s - 4] | dat[s - 3] << 8,
            t = s + l;

        if (t > sl) {
          if (noSt) throw 'unexpected EOF';
          break;
        } // ensure size


        if (noBuf) cbuf(bt + l); // Copy over uncompressed data

        buf.set(dat.subarray(s, t), bt); // Get new bitpos, update byte count

        st.b = bt += l, st.p = pos = t * 8;
        continue;
      } else if (type == 1) lm = flrm, dm = fdrm, lbt = 9, dbt = 5;else if (type == 2) {
        //  literal                            lengths
        var hLit = bits(dat, pos, 31) + 257,
            hcLen = bits(dat, pos + 10, 15) + 4;
        var tl = hLit + bits(dat, pos + 5, 31) + 1;
        pos += 14; // length+distance tree

        var ldt = new u8(tl); // code length tree

        var clt = new u8(19);

        for (var i = 0; i < hcLen; ++i) {
          // use index map to get real code
          clt[clim[i]] = bits(dat, pos + i * 3, 7);
        }

        pos += hcLen * 3; // code lengths bits

        var clb = max(clt),
            clbmsk = (1 << clb) - 1; // code lengths map

        var clm = hMap(clt, clb, 1);

        for (var i = 0; i < tl;) {
          var r = clm[bits(dat, pos, clbmsk)]; // bits read

          pos += r & 15; // symbol

          var s = r >>> 4; // code length to copy

          if (s < 16) {
            ldt[i++] = s;
          } else {
            //  copy   count
            var c = 0,
                n = 0;
            if (s == 16) n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];else if (s == 17) n = 3 + bits(dat, pos, 7), pos += 3;else if (s == 18) n = 11 + bits(dat, pos, 127), pos += 7;

            while (n--) {
              ldt[i++] = c;
            }
          }
        } //    length tree                 distance tree


        var lt = ldt.subarray(0, hLit),
            dt = ldt.subarray(hLit); // max length bits

        lbt = max(lt); // max dist bits

        dbt = max(dt);
        lm = hMap(lt, lbt, 1);
        dm = hMap(dt, dbt, 1);
      } else throw 'invalid block type';

      if (pos > tbts) {
        if (noSt) throw 'unexpected EOF';
        break;
      }
    } // Make sure the buffer can hold this + the largest possible addition
    // Maximum chunk size (practically, theoretically infinite) is 2^17;


    if (noBuf) cbuf(bt + 131072);
    var lms = (1 << lbt) - 1,
        dms = (1 << dbt) - 1;
    var lpos = pos;

    for (;; lpos = pos) {
      // bits read, code
      var c = lm[bits16(dat, pos) & lms],
          sym = c >>> 4;
      pos += c & 15;

      if (pos > tbts) {
        if (noSt) throw 'unexpected EOF';
        break;
      }

      if (!c) throw 'invalid length/literal';
      if (sym < 256) buf[bt++] = sym;else if (sym == 256) {
        lpos = pos, lm = null;
        break;
      } else {
        var add = sym - 254; // no extra bits needed if less

        if (sym > 264) {
          // index
          var i = sym - 257,
              b = fleb[i];
          add = bits(dat, pos, (1 << b) - 1) + fl[i];
          pos += b;
        } // dist


        var d = dm[bits16(dat, pos) & dms],
            dsym = d >>> 4;
        if (!d) throw 'invalid distance';
        pos += d & 15;
        var dt = fd[dsym];

        if (dsym > 3) {
          var b = fdeb[dsym];
          dt += bits16(dat, pos) & (1 << b) - 1, pos += b;
        }

        if (pos > tbts) {
          if (noSt) throw 'unexpected EOF';
          break;
        }

        if (noBuf) cbuf(bt + 131072);
        var end = bt + add;

        for (; bt < end; bt += 4) {
          buf[bt] = buf[bt - dt];
          buf[bt + 1] = buf[bt + 1 - dt];
          buf[bt + 2] = buf[bt + 2 - dt];
          buf[bt + 3] = buf[bt + 3 - dt];
        }

        bt = end;
      }
    }

    st.l = lm, st.p = lpos, st.b = bt;
    if (lm) final = 1, st.m = lbt, st.d = dm, st.n = dbt;
  } while (!final);

  return bt == buf.length ? buf : slc(buf, 0, bt);
}; // starting at p, write the minimum number of bits that can hold v to d


var wbits = function wbits(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
}; // starting at p, write the minimum number of bits (>8) that can hold v to d


var wbits16 = function wbits16(d, p, v) {
  v <<= p & 7;
  var o = p / 8 | 0;
  d[o] |= v;
  d[o + 1] |= v >>> 8;
  d[o + 2] |= v >>> 16;
}; // creates code lengths from a frequency table


var hTree = function hTree(d, mb) {
  // Need extra info to make a tree
  var t = [];

  for (var i = 0; i < d.length; ++i) {
    if (d[i]) t.push({
      s: i,
      f: d[i]
    });
  }

  var s = t.length;
  var t2 = t.slice();
  if (!s) return [et, 0];

  if (s == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return [v, 1];
  }

  t.sort(function (a, b) {
    return a.f - b.f;
  }); // after i2 reaches last ind, will be stopped
  // freq must be greater than largest possible number of symbols

  t.push({
    s: -1,
    f: 25001
  });
  var l = t[0],
      r = t[1],
      i0 = 0,
      i1 = 1,
      i2 = 2;
  t[0] = {
    s: -1,
    f: l.f + r.f,
    l: l,
    r: r
  }; // efficient algorithm from UZIP.js
  // i0 is lookbehind, i2 is lookahead - after processing two low-freq
  // symbols that combined have high freq, will start processing i2 (high-freq,
  // non-composite) symbols instead
  // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/

  while (i1 != s - 1) {
    l = t[t[i0].f < t[i2].f ? i0++ : i2++];
    r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];
    t[i1++] = {
      s: -1,
      f: l.f + r.f,
      l: l,
      r: r
    };
  }

  var maxSym = t2[0].s;

  for (var i = 1; i < s; ++i) {
    if (t2[i].s > maxSym) maxSym = t2[i].s;
  } // code lengths


  var tr = new u16(maxSym + 1); // max bits in tree

  var mbt = ln(t[i1 - 1], tr, 0);

  if (mbt > mb) {
    // more algorithms from UZIP.js
    // TODO: find out how this code works (debt)
    //  ind    debt
    var i = 0,
        dt = 0; //    left            cost

    var lft = mbt - mb,
        cst = 1 << lft;
    t2.sort(function (a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });

    for (; i < s; ++i) {
      var i2_1 = t2[i].s;

      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else break;
    }

    dt >>>= lft;

    while (dt > 0) {
      var i2_2 = t2[i].s;
      if (tr[i2_2] < mb) dt -= 1 << mb - tr[i2_2]++ - 1;else ++i;
    }

    for (; i >= 0 && dt; --i) {
      var i2_3 = t2[i].s;

      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }

    mbt = mb;
  }

  return [new u8(tr), mbt];
}; // get the max length and assign length codes


var ln = function ln(n, l, d) {
  return n.s == -1 ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1)) : l[n.s] = d;
}; // length codes generation


var lc = function lc(c) {
  var s = c.length; // Note that the semicolon was intentional

  while (s && !c[--s]) {
  }

  var cl = new u16(++s); //  ind      num         streak

  var cli = 0,
      cln = c[0],
      cls = 1;

  var w = function w(v) {
    cl[cli++] = v;
  };

  for (var i = 1; i <= s; ++i) {
    if (c[i] == cln && i != s) ++cls;else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138) {
          w(32754);
        }

        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;

        for (; cls > 6; cls -= 6) {
          w(8304);
        }

        if (cls > 2) w(cls - 3 << 5 | 8208), cls = 0;
      }

      while (cls--) {
        w(cln);
      }

      cls = 1;
      cln = c[i];
    }
  }

  return [cl.subarray(0, cli), s];
}; // calculate the length of output from tree, code lengths


var clen = function clen(cf, cl) {
  var l = 0;

  for (var i = 0; i < cl.length; ++i) {
    l += cf[i] * cl[i];
  }

  return l;
}; // writes a fixed block
// returns the new bit pos


var wfblk = function wfblk(out, pos, dat) {
  // no need to write 00 as type: TypedArray defaults to 0
  var s = dat.length;
  var o = shft(pos + 2);
  out[o] = s & 255;
  out[o + 1] = s >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;

  for (var i = 0; i < s; ++i) {
    out[o + i + 4] = dat[i];
  }

  return (o + 4 + s) * 8;
}; // writes a block


var wblk = function wblk(dat, out, final, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, final);
  ++lf[256];

  var _a = hTree(lf, 15),
      dlt = _a[0],
      mlb = _a[1];

  var _b = hTree(df, 15),
      ddt = _b[0],
      mdb = _b[1];

  var _c = lc(dlt),
      lclt = _c[0],
      nlc = _c[1];

  var _d = lc(ddt),
      lcdt = _d[0],
      ndc = _d[1];

  var lcfreq = new u16(19);

  for (var i = 0; i < lclt.length; ++i) {
    lcfreq[lclt[i] & 31]++;
  }

  for (var i = 0; i < lcdt.length; ++i) {
    lcfreq[lcdt[i] & 31]++;
  }

  var _e = hTree(lcfreq, 7),
      lct = _e[0],
      mlcb = _e[1];

  var nlcc = 19;

  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc) {
  }

  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen) return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;

  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;

    for (var i = 0; i < nlcc; ++i) {
      wbits(out, p + 3 * i, lct[clim[i]]);
    }

    p += 3 * nlcc;
    var lcts = [lclt, lcdt];

    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];

      for (var i = 0; i < clct.length; ++i) {
        var len = clct[i] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15) wbits(out, p, clct[i] >>> 5 & 127), p += clct[i] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }

  for (var i = 0; i < li; ++i) {
    if (syms[i] > 255) {
      var len = syms[i] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7) wbits(out, p, syms[i] >>> 23 & 31), p += fleb[len];
      var dst = syms[i] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3) wbits16(out, p, syms[i] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];
    }
  }

  wbits16(out, p, lm[256]);
  return p + ll[256];
}; // deflate options (nice << 13) | chain


var deo = /*#__PURE__*/new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]); // empty

var et = /*#__PURE__*/new u8(0); // compresses data into a raw DEFLATE buffer

var dflt = function dflt(dat, lvl, plvl, pre, post, lst) {
  var s = dat.length;
  var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post); // writing to this writes to the output buffer

  var w = o.subarray(pre, o.length - post);
  var pos = 0;

  if (!lvl || s < 8) {
    for (var i = 0; i <= s; i += 65535) {
      // end
      var e = i + 65535;

      if (e < s) {
        // write full block
        pos = wfblk(w, pos, dat.subarray(i, e));
      } else {
        // write final block
        w[i] = lst;
        pos = wfblk(w, pos, dat.subarray(i, s));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13,
        c = opt & 8191;
    var msk_1 = (1 << plvl) - 1; //    prev 2-byte val map    curr 2-byte val map

    var prev = new u16(32768),
        head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3),
        bs2_1 = 2 * bs1_1;

    var hsh = function hsh(i) {
      return (dat[i] ^ dat[i + 1] << bs1_1 ^ dat[i + 2] << bs2_1) & msk_1;
    }; // 24576 is an arbitrary number of maximum symbols per block
    // 424 buffer for last block


    var syms = new u32(25000); // length/literal freq   distance freq

    var lf = new u16(288),
        df = new u16(32); //  l/lcnt  exbits  index  l/lind  waitdx  bitpos

    var lc_1 = 0,
        eb = 0,
        i = 0,
        li = 0,
        wi = 0,
        bs = 0;

    for (; i < s; ++i) {
      // hash value
      // deopt when i > s - 3 - at end, deopt acceptable
      var hv = hsh(i); // index mod 32768    previous index mod

      var imod = i & 32767,
          pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod; // We always should modify head and prev, but only add symbols if
      // this data is not yet processed ("wait" for wait index)

      if (wi <= i) {
        // bytes remaining
        var rem = s - i;

        if ((lc_1 > 7000 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);
          li = lc_1 = eb = 0, bs = i;

          for (var j = 0; j < 286; ++j) {
            lf[j] = 0;
          }

          for (var j = 0; j < 30; ++j) {
            df[j] = 0;
          }
        } //  len    dist   chain


        var l = 2,
            d = 0,
            ch_1 = c,
            dif = imod - pimod & 32767;

        if (rem > 2 && hv == hsh(i - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i); // max possible length
          // not capped at dif because decompressors implement "rolling" index population

          var ml = Math.min(258, rem);

          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i + l] == dat[i + l - dif]) {
              var nl = 0;

              for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl) {
              }

              if (nl > l) {
                l = nl, d = dif; // break out early when we reach "nice" (we are satisfied enough)

                if (nl > maxn) break; // now, find the rarest 2-byte sequence within this
                // length of literals and search for that instead.
                // Much faster than just using the start

                var mmd = Math.min(dif, nl - 2);
                var md = 0;

                for (var j = 0; j < mmd; ++j) {
                  var ti = i - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md) md = cd, pimod = ti;
                }
              }
            } // check the previous match


            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        } // d will be nonzero only when a match was found


        if (d) {
          // store both dist and len data in one Uint32
          // Make sure this is recognized as a len/dist with 28th bit (2^28)
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d];
          var lin = revfl[l] & 31,
              din = revfd[d] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i];
          ++lf[dat[i]];
        }
      }
    }

    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos); // this is the easiest way to avoid needing to maintain state

    if (!lst && pos & 7) pos = wfblk(w, pos + 1, et);
  }

  return slc(o, 0, pre + shft(pos) + post);
}; // CRC32 table


var crct = /*#__PURE__*/function () {
  var t = new u32(256);

  for (var i = 0; i < 256; ++i) {
    var c = i,
        k = 9;

    while (--k) {
      c = (c & 1 && 0xEDB88320) ^ c >>> 1;
    }

    t[i] = c;
  }

  return t;
}(); // CRC32


var crc = function crc() {
  var c = -1;
  return {
    p: function p(d) {
      // closures have awful performance
      var cr = c;

      for (var i = 0; i < d.length; ++i) {
        cr = crct[cr & 255 ^ d[i]] ^ cr >>> 8;
      }

      c = cr;
    },
    d: function d() {
      return ~c;
    }
  };
}; // Alder32


var adler = function adler() {
  var a = 1,
      b = 0;
  return {
    p: function p(d) {
      // closures have awful performance
      var n = a,
          m = b;
      var l = d.length;

      for (var i = 0; i != l;) {
        var e = Math.min(i + 2655, l);

        for (; i < e; ++i) {
          m += n += d[i];
        }

        n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);
      }

      a = n, b = m;
    },
    d: function d() {
      a %= 65521, b %= 65521;
      return (a & 255) << 24 | a >>> 8 << 16 | (b & 255) << 8 | b >>> 8;
    }
  };
};

var dopt = function dopt(dat, opt, pre, post, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
}; // Walmart object spread


var mrg = function mrg(a, b) {
  var o = {};

  for (var k in a) {
    o[k] = a[k];
  }

  for (var k in b) {
    o[k] = b[k];
  }

  return o;
}; // worker clone
// This is possibly the craziest part of the entire codebase, despite how simple it may seem.
// The only parameter to this function is a closure that returns an array of variables outside of the function scope.
// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.
// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).
// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.
// This took me three weeks to figure out how to do.


var wcln = function wcln(fn, fnStr, td) {
  var dt = fn();
  var st = fn.toString();
  var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');

  for (var i = 0; i < dt.length; ++i) {
    var v = dt[i],
        k = ks[i];

    if (typeof v == 'function') {
      fnStr += ';' + k + '=';
      var st_1 = v.toString();

      if (v.prototype) {
        // for global objects
        if (st_1.indexOf('[native code]') != -1) {
          var spInd = st_1.indexOf(' ', 8) + 1;
          fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));
        } else {
          fnStr += st_1;

          for (var t in v.prototype) {
            fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();
          }
        }
      } else fnStr += st_1;
    } else td[k] = v;
  }

  return [fnStr, td];
};

var ch = []; // clone bufs

var cbfs = function cbfs(v) {
  var tl = [];

  for (var k in v) {
    if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32) tl.push((v[k] = new v[k].constructor(v[k])).buffer);
  }

  return tl;
}; // use a worker to execute code


var wrkr = function wrkr(fns, init, id, cb) {
  var _a;

  if (!ch[id]) {
    var fnStr = '',
        td_1 = {},
        m = fns.length - 1;

    for (var i = 0; i < m; ++i) {
      _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];
    }

    ch[id] = wcln(fns[m], fnStr, td_1);
  }

  var td = mrg({}, ch[id][1]);
  return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);
}; // base async inflate fn


var bInflt = function bInflt() {
  return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8];
};

var bDflt = function bDflt() {
  return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf];
}; // gzip extra


var gze = function gze() {
  return [gzh, gzhl, wbytes, crc, crct];
}; // gunzip extra


var guze = function guze() {
  return [gzs, gzl];
}; // zlib extra


var zle = function zle() {
  return [zlh, wbytes, adler];
}; // unzlib extra


var zule = function zule() {
  return [zlv];
}; // post buf


var pbf = function pbf(msg) {
  return postMessage(msg, [msg.buffer]);
}; // get u8


var gu8 = function gu8(o) {
  return o && o.size && new u8(o.size);
}; // async helper


var cbify = function cbify(dat, opts, fns, init, id, cb) {
  var w = wrkr(fns, init, id, function (err, dat) {
    w.terminate();
    cb(err, dat);
  });
  w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);
  return function () {
    w.terminate();
  };
}; // auto stream


var astrm = function astrm(strm) {
  strm.ondata = function (dat, final) {
    return postMessage([dat, final], [dat.buffer]);
  };

  return function (ev) {
    return strm.push(ev.data[0], ev.data[1]);
  };
}; // async stream attach


var astrmify = function astrmify(fns, strm, opts, init, id) {
  var t;
  var w = wrkr(fns, init, id, function (err, dat) {
    if (err) w.terminate(), strm.ondata.call(strm, err);else {
      if (dat[1]) w.terminate();
      strm.ondata.call(strm, err, dat[0], dat[1]);
    }
  });
  w.postMessage(opts);

  strm.push = function (d, f) {
    if (t) throw 'stream finished';
    if (!strm.ondata) throw 'no stream handler';
    w.postMessage([d, t = f], [d.buffer]);
  };

  strm.terminate = function () {
    w.terminate();
  };
}; // read 2 bytes


var b2 = function b2(d, b) {
  return d[b] | d[b + 1] << 8;
}; // read 4 bytes


var b4 = function b4(d, b) {
  return (d[b] | d[b + 1] << 8 | d[b + 2] << 16 | d[b + 3] << 24) >>> 0;
};

var b8 = function b8(d, b) {
  return b4(d, b) + b4(d, b + 4) * 4294967296;
}; // write bytes


var wbytes = function wbytes(d, b, v) {
  for (; v; ++b) {
    d[b] = v, v >>>= 8;
  }
}; // gzip header


var gzh = function gzh(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix

  if (o.mtime != 0) wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));

  if (fn) {
    c[3] = 8;

    for (var i = 0; i <= fn.length; ++i) {
      c[i + 10] = fn.charCodeAt(i);
    }
  }
}; // gzip footer: -8 to -4 = CRC, -4 to -0 is length
// gzip start


var gzs = function gzs(d) {
  if (d[0] != 31 || d[1] != 139 || d[2] != 8) throw 'invalid gzip data';
  var flg = d[3];
  var st = 10;
  if (flg & 4) st += d[10] | (d[11] << 8) + 2;

  for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++]) {
  }

  return st + (flg & 2);
}; // gzip length


var gzl = function gzl(d) {
  var l = d.length;
  return (d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16 | d[l - 1] << 24) >>> 0;
}; // gzip header length


var gzhl = function gzhl(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
}; // zlib header


var zlh = function zlh(c, o) {
  var lv = o.level,
      fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;
  c[0] = 120, c[1] = fl << 6 | (fl ? 32 - 2 * fl : 1);
}; // zlib valid


var zlv = function zlv(d) {
  if ((d[0] & 15) != 8 || d[0] >>> 4 > 7 || (d[0] << 8 | d[1]) % 31) throw 'invalid zlib data';
  if (d[1] & 32) throw 'invalid zlib data: preset dictionaries not supported';
};

function AsyncCmpStrm(opts, cb) {
  if (!cb && typeof opts == 'function') cb = opts, opts = {};
  this.ondata = cb;
  return opts;
} // zlib footer: -4 to -0 is Adler32

/**
 * Streaming DEFLATE compression
 */


var Deflate = /*#__PURE__*/function () {
  function Deflate(opts, cb) {
    if (!cb && typeof opts == 'function') cb = opts, opts = {};
    this.ondata = cb;
    this.o = opts || {};
  }

  Deflate.prototype.p = function (c, f) {
    this.ondata(dopt(c, this.o, 0, 0, !f), f);
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Deflate.prototype.push = function (chunk, final) {
    if (this.d) throw 'stream finished';
    if (!this.ondata) throw 'no stream handler';
    this.d = final;
    this.p(chunk, final || false);
  };

  return Deflate;
}();
/**
 * Asynchronous streaming DEFLATE compression
 */

var AsyncDeflate = /*#__PURE__*/function () {
  function AsyncDeflate(opts, cb) {
    astrmify([bDflt, function () {
      return [astrm, Deflate];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Deflate(ev.data);
      onmessage = astrm(strm);
    }, 6);
  }

  return AsyncDeflate;
}();
function deflate(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt], function (ev) {
    return pbf(deflateSync(ev.data[0], ev.data[1]));
  }, 0, cb);
}
/**
 * Compresses data with DEFLATE without any wrapper
 * @param data The data to compress
 * @param opts The compression options
 * @returns The deflated version of the data
 */

function deflateSync(data, opts) {
  return dopt(data, opts || {}, 0, 0);
}
/**
 * Streaming DEFLATE decompression
 */

var Inflate = /*#__PURE__*/function () {
  /**
   * Creates an inflation stream
   * @param cb The callback to call whenever data is inflated
   */
  function Inflate(cb) {
    this.s = {};
    this.p = new u8(0);
    this.ondata = cb;
  }

  Inflate.prototype.e = function (c) {
    if (this.d) throw 'stream finished';
    if (!this.ondata) throw 'no stream handler';
    var l = this.p.length;
    var n = new u8(l + c.length);
    n.set(this.p), n.set(c, l), this.p = n;
  };

  Inflate.prototype.c = function (final) {
    this.d = this.s.i = final || false;
    var bts = this.s.b;
    var dt = inflt(this.p, this.o, this.s);
    this.ondata(slc(dt, bts, this.s.b), this.d);
    this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;
    this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;
  };
  /**
   * Pushes a chunk to be inflated
   * @param chunk The chunk to push
   * @param final Whether this is the final chunk
   */


  Inflate.prototype.push = function (chunk, final) {
    this.e(chunk), this.c(final);
  };

  return Inflate;
}();
/**
 * Asynchronous streaming DEFLATE decompression
 */

var AsyncInflate = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous inflation stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncInflate(cb) {
    this.ondata = cb;
    astrmify([bInflt, function () {
      return [astrm, Inflate];
    }], this, 0, function () {
      var strm = new Inflate();
      onmessage = astrm(strm);
    }, 7);
  }

  return AsyncInflate;
}();
function inflate(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt], function (ev) {
    return pbf(inflateSync(ev.data[0], gu8(ev.data[1])));
  }, 1, cb);
}
/**
 * Expands DEFLATE data with no wrapper
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function inflateSync(data, out) {
  return inflt(data, out);
} // before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.

/**
 * Streaming GZIP compression
 */

var Gzip = /*#__PURE__*/function () {
  function Gzip(opts, cb) {
    this.c = crc();
    this.l = 0;
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  /**
   * Pushes a chunk to be GZIPped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Gzip.prototype.push = function (chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };

  Gzip.prototype.p = function (c, f) {
    this.c.p(c);
    this.l += c.length;
    var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);
    if (this.v) gzh(raw, this.o), this.v = 0;
    if (f) wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);
    this.ondata(raw, f);
  };

  return Gzip;
}();
/**
 * Asynchronous streaming GZIP compression
 */

var AsyncGzip = /*#__PURE__*/function () {
  function AsyncGzip(opts, cb) {
    astrmify([bDflt, gze, function () {
      return [astrm, Deflate, Gzip];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Gzip(ev.data);
      onmessage = astrm(strm);
    }, 8);
  }

  return AsyncGzip;
}();
function gzip(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt, gze, function () {
    return [gzipSync];
  }], function (ev) {
    return pbf(gzipSync(ev.data[0], ev.data[1]));
  }, 2, cb);
}
/**
 * Compresses data with GZIP
 * @param data The data to compress
 * @param opts The compression options
 * @returns The gzipped version of the data
 */

function gzipSync(data, opts) {
  if (!opts) opts = {};
  var c = crc(),
      l = data.length;
  c.p(data);
  var d = dopt(data, opts, gzhl(opts), 8),
      s = d.length;
  return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;
}
/**
 * Streaming GZIP decompression
 */

var Gunzip = /*#__PURE__*/function () {
  /**
   * Creates a GUNZIP stream
   * @param cb The callback to call whenever data is inflated
   */
  function Gunzip(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  /**
   * Pushes a chunk to be GUNZIPped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Gunzip.prototype.push = function (chunk, final) {
    Inflate.prototype.e.call(this, chunk);

    if (this.v) {
      var s = this.p.length > 3 ? gzs(this.p) : 4;
      if (s >= this.p.length && !final) return;
      this.p = this.p.subarray(s), this.v = 0;
    }

    if (final) {
      if (this.p.length < 8) throw 'invalid gzip stream';
      this.p = this.p.subarray(0, -8);
    } // necessary to prevent TS from using the closure value
    // This allows for workerization to function correctly


    Inflate.prototype.c.call(this, final);
  };

  return Gunzip;
}();
/**
 * Asynchronous streaming GZIP decompression
 */

var AsyncGunzip = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous GUNZIP stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncGunzip(cb) {
    this.ondata = cb;
    astrmify([bInflt, guze, function () {
      return [astrm, Inflate, Gunzip];
    }], this, 0, function () {
      var strm = new Gunzip();
      onmessage = astrm(strm);
    }, 9);
  }

  return AsyncGunzip;
}();
function gunzip(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt, guze, function () {
    return [gunzipSync];
  }], function (ev) {
    return pbf(gunzipSync(ev.data[0]));
  }, 3, cb);
}
/**
 * Expands GZIP data
 * @param data The data to decompress
 * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.
 * @returns The decompressed version of the data
 */

function gunzipSync(data, out) {
  return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));
}
/**
 * Streaming Zlib compression
 */

var Zlib = /*#__PURE__*/function () {
  function Zlib(opts, cb) {
    this.c = adler();
    this.v = 1;
    Deflate.call(this, opts, cb);
  }
  /**
   * Pushes a chunk to be zlibbed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Zlib.prototype.push = function (chunk, final) {
    Deflate.prototype.push.call(this, chunk, final);
  };

  Zlib.prototype.p = function (c, f) {
    this.c.p(c);
    var raw = dopt(c, this.o, this.v && 2, f && 4, !f);
    if (this.v) zlh(raw, this.o), this.v = 0;
    if (f) wbytes(raw, raw.length - 4, this.c.d());
    this.ondata(raw, f);
  };

  return Zlib;
}();
/**
 * Asynchronous streaming Zlib compression
 */

var AsyncZlib = /*#__PURE__*/function () {
  function AsyncZlib(opts, cb) {
    astrmify([bDflt, zle, function () {
      return [astrm, Deflate, Zlib];
    }], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {
      var strm = new Zlib(ev.data);
      onmessage = astrm(strm);
    }, 10);
  }

  return AsyncZlib;
}();
function zlib(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bDflt, zle, function () {
    return [zlibSync];
  }], function (ev) {
    return pbf(zlibSync(ev.data[0], ev.data[1]));
  }, 4, cb);
}
/**
 * Compress data with Zlib
 * @param data The data to compress
 * @param opts The compression options
 * @returns The zlib-compressed version of the data
 */

function zlibSync(data, opts) {
  if (!opts) opts = {};
  var a = adler();
  a.p(data);
  var d = dopt(data, opts, 2, 4);
  return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;
}
/**
 * Streaming Zlib decompression
 */

var Unzlib = /*#__PURE__*/function () {
  /**
   * Creates a Zlib decompression stream
   * @param cb The callback to call whenever data is inflated
   */
  function Unzlib(cb) {
    this.v = 1;
    Inflate.call(this, cb);
  }
  /**
   * Pushes a chunk to be unzlibbed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Unzlib.prototype.push = function (chunk, final) {
    Inflate.prototype.e.call(this, chunk);

    if (this.v) {
      if (this.p.length < 2 && !final) return;
      this.p = this.p.subarray(2), this.v = 0;
    }

    if (final) {
      if (this.p.length < 4) throw 'invalid zlib stream';
      this.p = this.p.subarray(0, -4);
    } // necessary to prevent TS from using the closure value
    // This allows for workerization to function correctly


    Inflate.prototype.c.call(this, final);
  };

  return Unzlib;
}();
/**
 * Asynchronous streaming Zlib decompression
 */

var AsyncUnzlib = /*#__PURE__*/function () {
  /**
   * Creates an asynchronous Zlib decompression stream
   * @param cb The callback to call whenever data is deflated
   */
  function AsyncUnzlib(cb) {
    this.ondata = cb;
    astrmify([bInflt, zule, function () {
      return [astrm, Inflate, Unzlib];
    }], this, 0, function () {
      var strm = new Unzlib();
      onmessage = astrm(strm);
    }, 11);
  }

  return AsyncUnzlib;
}();
function unzlib(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return cbify(data, opts, [bInflt, zule, function () {
    return [unzlibSync];
  }], function (ev) {
    return pbf(unzlibSync(ev.data[0], gu8(ev.data[1])));
  }, 5, cb);
}
/**
 * Expands Zlib data
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function unzlibSync(data, out) {
  return inflt((zlv(data), data.subarray(2, -4)), out);
} // Default algorithm for compression (used because having a known output size allows faster decompression)
/**
 * Streaming GZIP, Zlib, or raw DEFLATE decompression
 */

var Decompress = /*#__PURE__*/function () {
  /**
   * Creates a decompression stream
   * @param cb The callback to call whenever data is decompressed
   */
  function Decompress(cb) {
    this.G = Gunzip;
    this.I = Inflate;
    this.Z = Unzlib;
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be decompressed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Decompress.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no stream handler';

    if (!this.s) {
      if (this.p && this.p.length) {
        var n = new u8(this.p.length + chunk.length);
        n.set(this.p), n.set(chunk, this.p.length);
      } else this.p = chunk;

      if (this.p.length > 2) {
        var _this_1 = this;

        var cb = function cb() {
          _this_1.ondata.apply(_this_1, arguments);
        };

        this.s = this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8 ? new this.G(cb) : (this.p[0] & 15) != 8 || this.p[0] >> 4 > 7 || (this.p[0] << 8 | this.p[1]) % 31 ? new this.I(cb) : new this.Z(cb);
        this.s.push(this.p, final);
        this.p = null;
      }
    } else this.s.push(chunk, final);
  };

  return Decompress;
}();
/**
 * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression
 */

var AsyncDecompress = /*#__PURE__*/function () {
  /**
  * Creates an asynchronous decompression stream
  * @param cb The callback to call whenever data is decompressed
  */
  function AsyncDecompress(cb) {
    this.G = AsyncGunzip;
    this.I = AsyncInflate;
    this.Z = AsyncUnzlib;
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be decompressed
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  AsyncDecompress.prototype.push = function (chunk, final) {
    Decompress.prototype.push.call(this, chunk, final);
  };

  return AsyncDecompress;
}();
function decompress(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzip(data, opts, cb) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflate(data, opts, cb) : unzlib(data, opts, cb);
}
/**
 * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format
 * @param data The data to decompress
 * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.
 * @returns The decompressed version of the data
 */

function decompressSync(data, out) {
  return data[0] == 31 && data[1] == 139 && data[2] == 8 ? gunzipSync(data, out) : (data[0] & 15) != 8 || data[0] >> 4 > 7 || (data[0] << 8 | data[1]) % 31 ? inflateSync(data, out) : unzlibSync(data, out);
} // flatten a directory structure

var fltn = function fltn(d, p, t, o) {
  for (var k in d) {
    var val = d[k],
        n = p + k;
    if (val instanceof u8) t[n] = [val, o];else if (Array.isArray(val)) t[n] = [val[0], mrg(o, val[1])];else fltn(val, n + '/', t, o);
  }
}; // text encoder


var te = typeof TextEncoder != 'undefined' && /*#__PURE__*/new TextEncoder(); // text decoder

var td = typeof TextDecoder != 'undefined' && /*#__PURE__*/new TextDecoder(); // text decoder stream

var tds = 0;

try {
  td.decode(et, {
    stream: true
  });
  tds = 1;
} catch (e) {} // decode UTF8


var dutf8 = function dutf8(d) {
  for (var r = '', i = 0;;) {
    var c = d[i++];
    var eb = (c > 127) + (c > 223) + (c > 239);
    if (i + eb > d.length) return [r, slc(d, i - 1)];
    if (!eb) r += String.fromCharCode(c);else if (eb == 3) {
      c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | d[i++] & 63) - 65536, r += String.fromCharCode(55296 | c >> 10, 56320 | c & 1023);
    } else if (eb & 1) r += String.fromCharCode((c & 31) << 6 | d[i++] & 63);else r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | d[i++] & 63);
  }
};
/**
 * Streaming UTF-8 decoding
 */


var DecodeUTF8 = /*#__PURE__*/function () {
  /**
   * Creates a UTF-8 decoding stream
   * @param cb The callback to call whenever data is decoded
   */
  function DecodeUTF8(cb) {
    this.ondata = cb;
    if (tds) this.t = new TextDecoder();else this.p = et;
  }
  /**
   * Pushes a chunk to be decoded from UTF-8 binary
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  DecodeUTF8.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback';
    final = !!final;

    if (this.t) {
      this.ondata(this.t.decode(chunk, {
        stream: true
      }), final);

      if (final) {
        if (this.t.decode().length) throw 'invalid utf-8 data';
        this.t = null;
      }

      return;
    }

    if (!this.p) throw 'stream finished';
    var dat = new u8(this.p.length + chunk.length);
    dat.set(this.p);
    dat.set(chunk, this.p.length);

    var _a = dutf8(dat),
        ch = _a[0],
        np = _a[1];

    if (final) {
      if (np.length) throw 'invalid utf-8 data';
      this.p = null;
    } else this.p = np;

    this.ondata(ch, final);
  };

  return DecodeUTF8;
}();
/**
 * Streaming UTF-8 encoding
 */

var EncodeUTF8 = /*#__PURE__*/function () {
  /**
   * Creates a UTF-8 decoding stream
   * @param cb The callback to call whenever data is encoded
   */
  function EncodeUTF8(cb) {
    this.ondata = cb;
  }
  /**
   * Pushes a chunk to be encoded to UTF-8
   * @param chunk The string data to push
   * @param final Whether this is the last chunk
   */


  EncodeUTF8.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback';
    if (this.d) throw 'stream finished';
    this.ondata(strToU8(chunk), this.d = final || false);
  };

  return EncodeUTF8;
}();
/**
 * Converts a string into a Uint8Array for use with compression/decompression methods
 * @param str The string to encode
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless decoding a binary string.
 * @returns The string encoded in UTF-8/Latin-1 binary
 */

function strToU8(str, latin1) {
  if (latin1) {
    var ar_1 = new u8(str.length);

    for (var i = 0; i < str.length; ++i) {
      ar_1[i] = str.charCodeAt(i);
    }

    return ar_1;
  }

  if (te) return te.encode(str);
  var l = str.length;
  var ar = new u8(str.length + (str.length >> 1));
  var ai = 0;

  var w = function w(v) {
    ar[ai++] = v;
  };

  for (var i = 0; i < l; ++i) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i << 1));
      n.set(ar);
      ar = n;
    }

    var c = str.charCodeAt(i);
    if (c < 128 || latin1) w(c);else if (c < 2048) w(192 | c >> 6), w(128 | c & 63);else if (c > 55295 && c < 57344) c = 65536 + (c & 1023 << 10) | str.charCodeAt(++i) & 1023, w(240 | c >> 18), w(128 | c >> 12 & 63), w(128 | c >> 6 & 63), w(128 | c & 63);else w(224 | c >> 12), w(128 | c >> 6 & 63), w(128 | c & 63);
  }

  return slc(ar, 0, ai);
}
/**
 * Converts a Uint8Array to a string
 * @param dat The data to decode to string
 * @param latin1 Whether or not to interpret the data as Latin-1. This should
 *               not need to be true unless encoding to binary string.
 * @returns The original UTF-8/Latin-1 string
 */

function strFromU8(dat, latin1) {
  if (latin1) {
    var r = '';

    for (var i = 0; i < dat.length; i += 16384) {
      r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));
    }

    return r;
  } else if (td) return td.decode(dat);else {
    var _a = dutf8(dat),
        out = _a[0],
        ext = _a[1];

    if (ext.length) throw 'invalid utf-8 data';
    return out;
  }
}

var dbf = function dbf(l) {
  return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0;
}; // skip local zip header


var slzh = function slzh(d, b) {
  return b + 30 + b2(d, b + 26) + b2(d, b + 28);
}; // read zip header


var zh = function zh(d, b, z) {
  var fnl = b2(d, b + 28),
      fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)),
      es = b + 46 + fnl,
      bs = b4(d, b + 20);

  var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)],
      sc = _a[0],
      su = _a[1],
      off = _a[2];

  return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];
}; // read zip64 extra field


var z64e = function z64e(d, b) {
  for (; b2(d, b) != 1; b += 4 + b2(d, b + 2)) {
  }

  return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];
}; // extra field length


var exfl = function exfl(ex) {
  var le = 0;

  if (ex) {
    for (var k in ex) {
      var l = ex[k].length;
      if (l > 65535) throw 'extra field too long';
      le += l + 4;
    }
  }

  return le;
}; // write zip header


var wzh = function wzh(d, b, f, fn, u, c, ce, co) {
  var fl = fn.length,
      ex = f.extra,
      col = co && co.length;
  var exl = exfl(ex);
  wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;
  if (ce != null) d[b++] = 20, d[b++] = f.os;
  d[b] = 20, b += 2; // spec compliance? what's that?

  d[b++] = f.flag << 1 | (c == null && 8), d[b++] = u && 8;
  d[b++] = f.compression & 255, d[b++] = f.compression >> 8;
  var dt = new Date(f.mtime == null ? Date.now() : f.mtime),
      y = dt.getFullYear() - 1980;
  if (y < 0 || y > 119) throw 'date not in range 1980-2099';
  wbytes(d, b, y << 25 | dt.getMonth() + 1 << 21 | dt.getDate() << 16 | dt.getHours() << 11 | dt.getMinutes() << 5 | dt.getSeconds() >>> 1), b += 4;

  if (c != null) {
    wbytes(d, b, f.crc);
    wbytes(d, b + 4, c);
    wbytes(d, b + 8, f.size);
  }

  wbytes(d, b + 12, fl);
  wbytes(d, b + 14, exl), b += 16;

  if (ce != null) {
    wbytes(d, b, col);
    wbytes(d, b + 6, f.attrs);
    wbytes(d, b + 10, ce), b += 14;
  }

  d.set(fn, b);
  b += fl;

  if (exl) {
    for (var k in ex) {
      var exf = ex[k],
          l = exf.length;
      wbytes(d, b, +k);
      wbytes(d, b + 2, l);
      d.set(exf, b + 4), b += 4 + l;
    }
  }

  if (col) d.set(co, b), b += col;
  return b;
}; // write zip footer (end of central directory)


var wzf = function wzf(o, b, c, d, e) {
  wbytes(o, b, 0x6054B50); // skip disk

  wbytes(o, b + 8, c);
  wbytes(o, b + 10, c);
  wbytes(o, b + 12, d);
  wbytes(o, b + 16, e);
};
/**
 * A pass-through stream to keep data uncompressed in a ZIP archive.
 */


var ZipPassThrough = /*#__PURE__*/function () {
  /**
   * Creates a pass-through stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   */
  function ZipPassThrough(filename) {
    this.filename = filename;
    this.c = crc();
    this.size = 0;
    this.compression = 0;
  }
  /**
   * Processes a chunk and pushes to the output stream. You can override this
   * method in a subclass for custom behavior, but by default this passes
   * the data through. You must call this.ondata(err, chunk, final) at some
   * point in this method.
   * @param chunk The chunk to process
   * @param final Whether this is the last chunk
   */


  ZipPassThrough.prototype.process = function (chunk, final) {
    this.ondata(null, chunk, final);
  };
  /**
   * Pushes a chunk to be added. If you are subclassing this with a custom
   * compression algorithm, note that you must push data from the source
   * file only, pre-compression.
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  ZipPassThrough.prototype.push = function (chunk, final) {
    if (!this.ondata) throw 'no callback - add to ZIP archive before pushing';
    this.c.p(chunk);
    this.size += chunk.length;
    if (final) this.crc = this.c.d();
    this.process(chunk, final || false);
  };

  return ZipPassThrough;
}();

/**
 * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate
 * for better performance
 */

var ZipDeflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   * @param opts The compression options
   */
  function ZipDeflate(filename, opts) {
    var _this_1 = this;

    if (!opts) opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new Deflate(opts, function (dat, final) {
      _this_1.ondata(null, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
  }

  ZipDeflate.prototype.process = function (chunk, final) {
    try {
      this.d.push(chunk, final);
    } catch (e) {
      this.ondata(e, null, final);
    }
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  ZipDeflate.prototype.push = function (chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };

  return ZipDeflate;
}();
/**
 * Asynchronous streaming DEFLATE compression for ZIP archives
 */

var AsyncZipDeflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE stream that can be added to ZIP archives
   * @param filename The filename to associate with this data stream
   * @param opts The compression options
   */
  function AsyncZipDeflate(filename, opts) {
    var _this_1 = this;

    if (!opts) opts = {};
    ZipPassThrough.call(this, filename);
    this.d = new AsyncDeflate(opts, function (err, dat, final) {
      _this_1.ondata(err, dat, final);
    });
    this.compression = 8;
    this.flag = dbf(opts.level);
    this.terminate = this.d.terminate;
  }

  AsyncZipDeflate.prototype.process = function (chunk, final) {
    this.d.push(chunk, final);
  };
  /**
   * Pushes a chunk to be deflated
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  AsyncZipDeflate.prototype.push = function (chunk, final) {
    ZipPassThrough.prototype.push.call(this, chunk, final);
  };

  return AsyncZipDeflate;
}();

/**
 * A zippable archive to which files can incrementally be added
 */

var Zip = /*#__PURE__*/function () {
  /**
   * Creates an empty ZIP archive to which files can be added
   * @param cb The callback to call whenever data for the generated ZIP archive
   *           is available
   */
  function Zip(cb) {
    this.ondata = cb;
    this.u = [];
    this.d = 1;
  }
  /**
   * Adds a file to the ZIP archive
   * @param file The file stream to add
   */


  Zip.prototype.add = function (file) {
    var _this_1 = this;

    if (this.d & 2) throw 'stream finished';
    var f = strToU8(file.filename),
        fl = f.length;
    var com = file.comment,
        o = com && strToU8(com);
    var u = fl != file.filename.length || o && com.length != o.length;
    var hl = fl + exfl(file.extra) + 30;
    if (fl > 65535) throw 'filename too long';
    var header = new u8(hl);
    wzh(header, 0, file, f, u);
    var chks = [header];

    var pAll = function pAll() {
      for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {
        var chk = chks_1[_i];

        _this_1.ondata(null, chk, false);
      }

      chks = [];
    };

    var tr = this.d;
    this.d = 0;
    var ind = this.u.length;
    var uf = mrg(file, {
      f: f,
      u: u,
      o: o,
      t: function t() {
        if (file.terminate) file.terminate();
      },
      r: function r() {
        pAll();

        if (tr) {
          var nxt = _this_1.u[ind + 1];
          if (nxt) nxt.r();else _this_1.d = 1;
        }

        tr = 1;
      }
    });
    var cl = 0;

    file.ondata = function (err, dat, final) {
      if (err) {
        _this_1.ondata(err, dat, final);

        _this_1.terminate();
      } else {
        cl += dat.length;
        chks.push(dat);

        if (final) {
          var dd = new u8(16);
          wbytes(dd, 0, 0x8074B50);
          wbytes(dd, 4, file.crc);
          wbytes(dd, 8, cl);
          wbytes(dd, 12, file.size);
          chks.push(dd);
          uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;
          if (tr) uf.r();
          tr = 1;
        } else if (tr) pAll();
      }
    };

    this.u.push(uf);
  };
  /**
   * Ends the process of adding files and prepares to emit the final chunks.
   * This *must* be called after adding all desired files for the resulting
   * ZIP file to work properly.
   */


  Zip.prototype.end = function () {
    var _this_1 = this;

    if (this.d & 2) {
      if (this.d & 1) throw 'stream finishing';
      throw 'stream finished';
    }

    if (this.d) this.e();else this.u.push({
      r: function r() {
        if (!(_this_1.d & 1)) return;

        _this_1.u.splice(-1, 1);

        _this_1.e();
      },
      t: function t() {}
    });
    this.d = 3;
  };

  Zip.prototype.e = function () {
    var bt = 0,
        l = 0,
        tl = 0;

    for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
      var f = _a[_i];
      tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);
    }

    var out = new u8(tl + 22);

    for (var _b = 0, _c = this.u; _b < _c.length; _b++) {
      var f = _c[_b];
      wzh(out, bt, f, f.f, f.u, f.c, l, f.o);
      bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;
    }

    wzf(out, bt, this.u.length, tl, l);
    this.ondata(null, out, true);
    this.d = 2;
  };
  /**
   * A method to terminate any internal workers used by the stream. Subsequent
   * calls to add() will fail.
   */


  Zip.prototype.terminate = function () {
    for (var _i = 0, _a = this.u; _i < _a.length; _i++) {
      var f = _a[_i];
      f.t();
    }

    this.d = 2;
  };

  return Zip;
}();
function zip$1(data, opts, cb) {
  if (!cb) cb = opts, opts = {};
  if (typeof cb != 'function') throw 'no callback';
  var r = {};
  fltn(data, '', r, opts);
  var k = Object.keys(r);
  var lft = k.length,
      o = 0,
      tot = 0;
  var slft = lft,
      files = new Array(lft);
  var term = [];

  var tAll = function tAll() {
    for (var i = 0; i < term.length; ++i) {
      term[i]();
    }
  };

  var cbf = function cbf() {
    var out = new u8(tot + 22),
        oe = o,
        cdl = tot - o;
    tot = 0;

    for (var i = 0; i < slft; ++i) {
      var f = files[i];

      try {
        var l = f.c.length;
        wzh(out, tot, f, f.f, f.u, l);
        var badd = 30 + f.f.length + exfl(f.extra);
        var loc = tot + badd;
        out.set(f.c, loc);
        wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;
      } catch (e) {
        return cb(e, null);
      }
    }

    wzf(out, o, files.length, cdl, oe);
    cb(null, out);
  };

  if (!lft) cbf();

  var _loop_1 = function _loop_1(i) {
    var fn = k[i];
    var _a = r[fn],
        file = _a[0],
        p = _a[1];
    var c = crc(),
        size = file.length;
    c.p(file);
    var f = strToU8(fn),
        s = f.length;
    var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
    var exl = exfl(p.extra);
    var compression = p.level == 0 ? 0 : 8;

    var cbl = function cbl(e, d) {
      if (e) {
        tAll();
        cb(e, null);
      } else {
        var l = d.length;
        files[i] = mrg(p, {
          size: size,
          crc: c.d(),
          c: d,
          f: f,
          m: m,
          u: s != fn.length || m && com.length != ms,
          compression: compression
        });
        o += 30 + s + exl + l;
        tot += 76 + 2 * (s + exl) + (ms || 0) + l;
        if (! --lft) cbf();
      }
    };

    if (s > 65535) cbl('filename too long', null);
    if (!compression) cbl(null, file);else if (size < 160000) {
      try {
        cbl(null, deflateSync(file, p));
      } catch (e) {
        cbl(e, null);
      }
    } else term.push(deflate(file, p, cbl));
  }; // Cannot use lft because it can decrease


  for (var i = 0; i < slft; ++i) {
    _loop_1(i);
  }

  return tAll;
}
/**
 * Synchronously creates a ZIP file. Prefer using `zip` for better performance
 * with more than one file.
 * @param data The directory structure for the ZIP archive
 * @param opts The main options, merged with per-file options
 * @returns The generated ZIP archive
 */

function zipSync(data, opts) {
  if (!opts) opts = {};
  var r = {};
  var files = [];
  fltn(data, '', r, opts);
  var o = 0;
  var tot = 0;

  for (var fn in r) {
    var _a = r[fn],
        file = _a[0],
        p = _a[1];
    var compression = p.level == 0 ? 0 : 8;
    var f = strToU8(fn),
        s = f.length;
    var com = p.comment,
        m = com && strToU8(com),
        ms = m && m.length;
    var exl = exfl(p.extra);
    if (s > 65535) throw 'filename too long';
    var d = compression ? deflateSync(file, p) : file,
        l = d.length;
    var c = crc();
    c.p(file);
    files.push(mrg(p, {
      size: file.length,
      crc: c.d(),
      c: d,
      f: f,
      m: m,
      u: s != fn.length || m && com.length != ms,
      o: o,
      compression: compression
    }));
    o += 30 + s + exl + l;
    tot += 76 + 2 * (s + exl) + (ms || 0) + l;
  }

  var out = new u8(tot + 22),
      oe = o,
      cdl = tot - o;

  for (var i = 0; i < files.length; ++i) {
    var f = files[i];
    wzh(out, f.o, f, f.f, f.u, f.c.length);
    var badd = 30 + f.f.length + exfl(f.extra);
    out.set(f.c, f.o + badd);
    wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);
  }

  wzf(out, o, files.length, cdl, oe);
  return out;
}
/**
 * Streaming pass-through decompression for ZIP archives
 */

var UnzipPassThrough = /*#__PURE__*/function () {
  function UnzipPassThrough() {}

  UnzipPassThrough.prototype.push = function (data, final) {
    this.ondata(null, data, final);
  };

  UnzipPassThrough.compression = 0;
  return UnzipPassThrough;
}();
/**
 * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for
 * better performance.
 */

var UnzipInflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE decompression that can be used in ZIP archives
   */
  function UnzipInflate() {
    var _this_1 = this;

    this.i = new Inflate(function (dat, final) {
      _this_1.ondata(null, dat, final);
    });
  }

  UnzipInflate.prototype.push = function (data, final) {
    try {
      this.i.push(data, final);
    } catch (e) {
      this.ondata(e, data, final);
    }
  };

  UnzipInflate.compression = 8;
  return UnzipInflate;
}();
/**
 * Asynchronous streaming DEFLATE decompression for ZIP archives
 */

var AsyncUnzipInflate = /*#__PURE__*/function () {
  /**
   * Creates a DEFLATE decompression that can be used in ZIP archives
   */
  function AsyncUnzipInflate(_, sz) {
    var _this_1 = this;

    if (sz < 320000) {
      this.i = new Inflate(function (dat, final) {
        _this_1.ondata(null, dat, final);
      });
    } else {
      this.i = new AsyncInflate(function (err, dat, final) {
        _this_1.ondata(err, dat, final);
      });
      this.terminate = this.i.terminate;
    }
  }

  AsyncUnzipInflate.prototype.push = function (data, final) {
    if (this.i.terminate) data = slc(data, 0);
    this.i.push(data, final);
  };

  AsyncUnzipInflate.compression = 8;
  return AsyncUnzipInflate;
}();
/**
 * A ZIP archive decompression stream that emits files as they are discovered
 */

var Unzip = /*#__PURE__*/function () {
  /**
   * Creates a ZIP decompression stream
   * @param cb The callback to call whenever a file in the ZIP archive is found
   */
  function Unzip(cb) {
    this.onfile = cb;
    this.k = [];
    this.o = {
      0: UnzipPassThrough
    };
    this.p = et;
  }
  /**
   * Pushes a chunk to be unzipped
   * @param chunk The chunk to push
   * @param final Whether this is the last chunk
   */


  Unzip.prototype.push = function (chunk, final) {
    var _this_1 = this;

    if (!this.onfile) throw 'no callback';
    if (!this.p) throw 'stream finished';

    if (this.c > 0) {
      var len = Math.min(this.c, chunk.length);
      var toAdd = chunk.subarray(0, len);
      this.c -= len;
      if (this.d) this.d.push(toAdd, !this.c);else this.k[0].push(toAdd);
      chunk = chunk.subarray(len);
      if (chunk.length) return this.push(chunk, final);
    } else {
      var f = 0,
          i = 0,
          is = void 0,
          buf = void 0;
      if (!this.p.length) buf = chunk;else if (!chunk.length) buf = this.p;else {
        buf = new u8(this.p.length + chunk.length);
        buf.set(this.p), buf.set(chunk, this.p.length);
      }
      var l = buf.length,
          oc = this.c,
          add = oc && this.d;

      var _loop_2 = function _loop_2() {
        var _a;

        var sig = b4(buf, i);

        if (sig == 0x4034B50) {
          f = 1, is = i;
          this_1.d = null;
          this_1.c = 0;
          var bf = b2(buf, i + 6),
              cmp_1 = b2(buf, i + 8),
              u = bf & 2048,
              dd = bf & 8,
              fnl = b2(buf, i + 26),
              es = b2(buf, i + 28);

          if (l > i + 30 + fnl + es) {
            var chks_2 = [];
            this_1.k.unshift(chks_2);
            f = 2;
            var sc_1 = b4(buf, i + 18),
                su_1 = b4(buf, i + 22);
            var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);

            if (sc_1 == 4294967295) {
              _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];
            } else if (dd) sc_1 = -1;

            i += es;
            this_1.c = sc_1;
            var d_1;
            var file_1 = {
              name: fn_1,
              compression: cmp_1,
              start: function start() {
                if (!file_1.ondata) throw 'no callback';
                if (!sc_1) file_1.ondata(null, et, true);else {
                  var ctr = _this_1.o[cmp_1];
                  if (!ctr) throw 'unknown compression type ' + cmp_1;
                  d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);

                  d_1.ondata = function (err, dat, final) {
                    file_1.ondata(err, dat, final);
                  };

                  for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {
                    var dat = chks_3[_i];
                    d_1.push(dat, false);
                  }

                  if (_this_1.k[0] == chks_2 && _this_1.c) _this_1.d = d_1;else d_1.push(et, true);
                }
              },
              terminate: function terminate() {
                if (d_1 && d_1.terminate) d_1.terminate();
              }
            };
            if (sc_1 >= 0) file_1.size = sc_1, file_1.originalSize = su_1;
            this_1.onfile(file_1);
          }

          return "break";
        } else if (oc) {
          if (sig == 0x8074B50) {
            is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;
            return "break";
          } else if (sig == 0x2014B50) {
            is = i -= 4, f = 3, this_1.c = 0;
            return "break";
          }
        }
      };

      var this_1 = this;

      for (; i < l - 4; ++i) {
        var state_1 = _loop_2();

        if (state_1 === "break") break;
      }

      this.p = et;

      if (oc < 0) {
        var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);
        if (add) add.push(dat, !!f);else this.k[+(f == 2)].push(dat);
      }

      if (f & 2) return this.push(buf.subarray(i), final);
      this.p = buf.subarray(i);
    }

    if (final) {
      if (this.c) throw 'invalid zip file';
      this.p = null;
    }
  };
  /**
   * Registers a decoder with the stream, allowing for files compressed with
   * the compression type provided to be expanded correctly
   * @param decoder The decoder constructor
   */


  Unzip.prototype.register = function (decoder) {
    this.o[decoder.compression] = decoder;
  };

  return Unzip;
}();
/**
 * Asynchronously decompresses a ZIP archive
 * @param data The raw compressed ZIP file
 * @param cb The callback to call with the decompressed files
 * @returns A function that can be used to immediately terminate the unzipping
 */

function unzip(data, cb) {
  if (typeof cb != 'function') throw 'no callback';
  var term = [];

  var tAll = function tAll() {
    for (var i = 0; i < term.length; ++i) {
      term[i]();
    }
  };

  var files = {};
  var e = data.length - 22;

  for (; b4(data, e) != 0x6054B50; --e) {
    if (!e || data.length - e > 65558) {
      cb('invalid zip file', null);
      return;
    }
  }
  var lft = b2(data, e + 8);
  if (!lft) cb(null, {});
  var c = lft;
  var o = b4(data, e + 16);
  var z = o == 4294967295;

  if (z) {
    e = b4(data, e - 12);

    if (b4(data, e) != 0x6064B50) {
      cb('invalid zip file', null);
      return;
    }

    c = lft = b4(data, e + 32);
    o = b4(data, e + 48);
  }

  var _loop_3 = function _loop_3(i) {
    var _a = zh(data, o, z),
        c_1 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);

    o = no;

    var cbl = function cbl(e, d) {
      if (e) {
        tAll();
        cb(e, null);
      } else {
        files[fn] = d;
        if (! --lft) cb(null, files);
      }
    };

    if (!c_1) cbl(null, slc(data, b, b + sc));else if (c_1 == 8) {
      var infl = data.subarray(b, b + sc);

      if (sc < 320000) {
        try {
          cbl(null, inflateSync(infl, new u8(su)));
        } catch (e) {
          cbl(e, null);
        }
      } else term.push(inflate(infl, {
        size: su
      }, cbl));
    } else cbl('unknown compression type ' + c_1, null);
  };

  for (var i = 0; i < c; ++i) {
    _loop_3();
  }

  return tAll;
}
/**
 * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better
 * performance with more than one file.
 * @param data The raw compressed ZIP file
 * @returns The decompressed files
 */

function unzipSync(data) {
  var files = {};
  var e = data.length - 22;

  for (; b4(data, e) != 0x6054B50; --e) {
    if (!e || data.length - e > 65558) throw 'invalid zip file';
  }
  var c = b2(data, e + 8);
  if (!c) return {};
  var o = b4(data, e + 16);
  var z = o == 4294967295;

  if (z) {
    e = b4(data, e - 12);
    if (b4(data, e) != 0x6064B50) throw 'invalid zip file';
    c = b4(data, e + 32);
    o = b4(data, e + 48);
  }

  for (var i = 0; i < c; ++i) {
    var _a = zh(data, o, z),
        c_2 = _a[0],
        sc = _a[1],
        su = _a[2],
        fn = _a[3],
        no = _a[4],
        off = _a[5],
        b = slzh(data, off);

    o = no;
    if (!c_2) files[fn] = slc(data, b, b + sc);else if (c_2 == 8) files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));else throw 'unknown compression type ' + c_2;
  }

  return files;
}var fflate=/*#__PURE__*/Object.freeze({__proto__:null,Deflate:Deflate,AsyncDeflate:AsyncDeflate,deflate:deflate,deflateSync:deflateSync,Inflate:Inflate,AsyncInflate:AsyncInflate,inflate:inflate,inflateSync:inflateSync,Gzip:Gzip,AsyncGzip:AsyncGzip,gzip:gzip,gzipSync:gzipSync,Gunzip:Gunzip,AsyncGunzip:AsyncGunzip,gunzip:gunzip,gunzipSync:gunzipSync,Zlib:Zlib,AsyncZlib:AsyncZlib,zlib:zlib,zlibSync:zlibSync,Unzlib:Unzlib,AsyncUnzlib:AsyncUnzlib,unzlib:unzlib,unzlibSync:unzlibSync,compress:gzip,AsyncCompress:AsyncGzip,compressSync:gzipSync,Compress:Gzip,Decompress:Decompress,AsyncDecompress:AsyncDecompress,decompress:decompress,decompressSync:decompressSync,DecodeUTF8:DecodeUTF8,EncodeUTF8:EncodeUTF8,strToU8:strToU8,strFromU8:strFromU8,ZipPassThrough:ZipPassThrough,ZipDeflate:ZipDeflate,AsyncZipDeflate:AsyncZipDeflate,Zip:Zip,zip:zip$1,zipSync:zipSync,UnzipPassThrough:UnzipPassThrough,UnzipInflate:UnzipInflate,AsyncUnzipInflate:AsyncUnzipInflate,Unzip:Unzip,unzip:unzip,unzipSync:unzipSync});/**
 * NURBS utils
 *
 * See NURBSCurve and NURBSSurface.
 **/

/**************************************************************
 *    NURBS Utils
 **************************************************************/

/*
Finds knot vector span.

p : degree
u : parametric value
U : knot vector

returns the span
*/

function findSpan(p, u, U) {
  var n = U.length - p - 1;

  if (u >= U[n]) {
    return n - 1;
  }

  if (u <= U[p]) {
    return p;
  }

  var low = p;
  var high = n;
  var mid = Math.floor((low + high) / 2);

  while (u < U[mid] || u >= U[mid + 1]) {
    if (u < U[mid]) {
      high = mid;
    } else {
      low = mid;
    }

    mid = Math.floor((low + high) / 2);
  }

  return mid;
}
/*
Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2

span : span in which u lies
u    : parametric point
p    : degree
U    : knot vector

returns array[p+1] with basis functions values.
*/


function calcBasisFunctions(span, u, p, U) {
  var N = [];
  var left = [];
  var right = [];
  N[0] = 1.0;

  for (var j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    var saved = 0.0;

    for (var r = 0; r < j; ++r) {
      var rv = right[r + 1];
      var lv = left[j - r];
      var temp = N[r] / (rv + lv);
      N[r] = saved + rv * temp;
      saved = lv * temp;
    }

    N[j] = saved;
  }

  return N;
}
/*
Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.

p : degree of B-Spline
U : knot vector
P : control points (x, y, z, w)
u : parametric point

returns point for given u
*/


function calcBSplinePoint(p, U, P, u) {
  var span = findSpan(p, u, U);
  var N = calcBasisFunctions(span, u, p, U);
  var C = new Vector4(0, 0, 0, 0);

  for (var j = 0; j <= p; ++j) {
    var point = P[span - p + j];
    var Nj = N[j];
    var wNj = point.w * Nj;
    C.x += point.x * wNj;
    C.y += point.y * wNj;
    C.z += point.z * wNj;
    C.w += point.w * Nj;
  }

  return C;
}
/*
Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.

span : span in which u lies
u    : parametric point
p    : degree
n    : number of derivatives to calculate
U    : knot vector

returns array[n+1][p+1] with basis functions derivatives
*/


function calcBasisFunctionDerivatives(span, u, p, n, U) {
  var zeroArr = [];

  for (var i = 0; i <= p; ++i) {
    zeroArr[i] = 0.0;
  }

  var ders = [];

  for (var _i = 0; _i <= n; ++_i) {
    ders[_i] = zeroArr.slice(0);
  }

  var ndu = [];

  for (var _i2 = 0; _i2 <= p; ++_i2) {
    ndu[_i2] = zeroArr.slice(0);
  }

  ndu[0][0] = 1.0;
  var left = zeroArr.slice(0);
  var right = zeroArr.slice(0);

  for (var j = 1; j <= p; ++j) {
    left[j] = u - U[span + 1 - j];
    right[j] = U[span + j] - u;
    var saved = 0.0;

    for (var _r = 0; _r < j; ++_r) {
      var rv = right[_r + 1];
      var lv = left[j - _r];
      ndu[j][_r] = rv + lv;
      var temp = ndu[_r][j - 1] / ndu[j][_r];
      ndu[_r][j] = saved + rv * temp;
      saved = lv * temp;
    }

    ndu[j][j] = saved;
  }

  for (var _j = 0; _j <= p; ++_j) {
    ders[0][_j] = ndu[_j][p];
  }

  for (var _r2 = 0; _r2 <= p; ++_r2) {
    var s1 = 0;
    var s2 = 1;
    var a = [];

    for (var _i3 = 0; _i3 <= p; ++_i3) {
      a[_i3] = zeroArr.slice(0);
    }

    a[0][0] = 1.0;

    for (var k = 1; k <= n; ++k) {
      var d = 0.0;
      var rk = _r2 - k;
      var pk = p - k;

      if (_r2 >= k) {
        a[s2][0] = a[s1][0] / ndu[pk + 1][rk];
        d = a[s2][0] * ndu[rk][pk];
      }

      var j1 = rk >= -1 ? 1 : -rk;
      var j2 = _r2 - 1 <= pk ? k - 1 : p - _r2;

      for (var _j3 = j1; _j3 <= j2; ++_j3) {
        a[s2][_j3] = (a[s1][_j3] - a[s1][_j3 - 1]) / ndu[pk + 1][rk + _j3];
        d += a[s2][_j3] * ndu[rk + _j3][pk];
      }

      if (_r2 <= pk) {
        a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][_r2];
        d += a[s2][k] * ndu[_r2][pk];
      }

      ders[k][_r2] = d;
      var _j2 = s1;
      s1 = s2;
      s2 = _j2;
    }
  }

  var r = p;

  for (var _k = 1; _k <= n; ++_k) {
    for (var _j4 = 0; _j4 <= p; ++_j4) {
      ders[_k][_j4] *= r;
    }

    r *= p - _k;
  }

  return ders;
}
/*
    Calculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.

    p  : degree
    U  : knot vector
    P  : control points
    u  : Parametric points
    nd : number of derivatives

    returns array[d+1] with derivatives
    */


function calcBSplineDerivatives(p, U, P, u, nd) {
  var du = nd < p ? nd : p;
  var CK = [];
  var span = findSpan(p, u, U);
  var nders = calcBasisFunctionDerivatives(span, u, p, du, U);
  var Pw = [];

  for (var i = 0; i < P.length; ++i) {
    var point = P[i].clone();
    var w = point.w;
    point.x *= w;
    point.y *= w;
    point.z *= w;
    Pw[i] = point;
  }

  for (var k = 0; k <= du; ++k) {
    var _point = Pw[span - p].clone().multiplyScalar(nders[k][0]);

    for (var j = 1; j <= p; ++j) {
      _point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));
    }

    CK[k] = _point;
  }

  for (var _k2 = du + 1; _k2 <= nd + 1; ++_k2) {
    CK[_k2] = new Vector4(0, 0, 0);
  }

  return CK;
}
/*
Calculate "K over I"

returns k!/(i!(k-i)!)
*/


function calcKoverI(k, i) {
  var nom = 1;

  for (var j = 2; j <= k; ++j) {
    nom *= j;
  }

  var denom = 1;

  for (var _j5 = 2; _j5 <= i; ++_j5) {
    denom *= _j5;
  }

  for (var _j6 = 2; _j6 <= k - i; ++_j6) {
    denom *= _j6;
  }

  return nom / denom;
}
/*
Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.

Pders : result of function calcBSplineDerivatives

returns array with derivatives for rational curve.
*/


function calcRationalCurveDerivatives(Pders) {
  var nd = Pders.length;
  var Aders = [];
  var wders = [];

  for (var i = 0; i < nd; ++i) {
    var point = Pders[i];
    Aders[i] = new Vector3$1(point.x, point.y, point.z);
    wders[i] = point.w;
  }

  var CK = [];

  for (var k = 0; k < nd; ++k) {
    var v = Aders[k].clone();

    for (var _i4 = 1; _i4 <= k; ++_i4) {
      v.sub(CK[k - _i4].clone().multiplyScalar(calcKoverI(k, _i4) * wders[_i4]));
    }

    CK[k] = v.divideScalar(wders[0]);
  }

  return CK;
}
/*
Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.

p  : degree
U  : knot vector
P  : control points in homogeneous space
u  : parametric points
nd : number of derivatives

returns array with derivatives.
*/


function calcNURBSDerivatives(p, U, P, u, nd) {
  var Pders = calcBSplineDerivatives(p, U, P, u, nd);
  return calcRationalCurveDerivatives(Pders);
}/**
 * NURBS curve object
 *
 * Derives from Curve, overriding getPoint and getTangent.
 *
 * Implementation is based on (x, y [, z=0 [, w=1]]) control points with w=weight.
 *
 **/

var NURBSCurve = /*#__PURE__*/function (_Curve) {
  _inherits(NURBSCurve, _Curve);

  var _super = _createSuper(NURBSCurve);

  function NURBSCurve(degree, knots
  /* array of reals */
  , controlPoints
  /* array of Vector(2|3|4) */
  , startKnot
  /* index in knots */
  , endKnot
  /* index in knots */
  ) {
    var _this;

    _classCallCheck(this, NURBSCurve);

    _this = _super.call(this);
    _this.degree = degree;
    _this.knots = knots;
    _this.controlPoints = []; // Used by periodic NURBS to remove hidden spans

    _this.startKnot = startKnot || 0;
    _this.endKnot = endKnot || _this.knots.length - 1;

    for (var i = 0; i < controlPoints.length; ++i) {
      // ensure Vector4 for control points
      var point = controlPoints[i];
      _this.controlPoints[i] = new Vector4(point.x, point.y, point.z, point.w);
    }

    return _this;
  }

  _createClass(NURBSCurve, [{
    key: "getPoint",
    value: function getPoint(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3$1();
      var point = optionalTarget;
      var u = this.knots[this.startKnot] + t * (this.knots[this.endKnot] - this.knots[this.startKnot]); // linear mapping t->u
      // following results in (wx, wy, wz, w) homogeneous point

      var hpoint = calcBSplinePoint(this.degree, this.knots, this.controlPoints, u);

      if (hpoint.w !== 1.0) {
        // project to 3D space: (wx, wy, wz, w) -> (x, y, z, 1)
        hpoint.divideScalar(hpoint.w);
      }

      return point.set(hpoint.x, hpoint.y, hpoint.z);
    }
  }, {
    key: "getTangent",
    value: function getTangent(t) {
      var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3$1();
      var tangent = optionalTarget;
      var u = this.knots[0] + t * (this.knots[this.knots.length - 1] - this.knots[0]);
      var ders = calcNURBSDerivatives(this.degree, this.knots, this.controlPoints, u, 1);
      tangent.copy(ders[1]).normalize();
      return tangent;
    }
  }]);

  return NURBSCurve;
}(Curve);/**
 * Loader loads FBX file and generates Group representing FBX scene.
 * Requires FBX file to be >= 7.0 and in ASCII or >= 6400 in Binary format
 * Versions lower than this may load but will probably have errors
 *
 * Needs Support:
 *  Morph normals / blend shape normals
 *
 * FBX format references:
 *     https://wiki.blender.org/index.php/User:Mont29/Foundation/FBX_File_Structure
 *     http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_index_html (C++ SDK reference)
 *
 *     Binary format specification:
 *        https://code.blender.org/2013/08/fbx-binary-file-format-specification/
 */

var fbxTree;
var connections;
var sceneGraph;

var FBXLoader = /*#__PURE__*/function (_Loader) {
  _inherits(FBXLoader, _Loader);

  var _super = _createSuper(FBXLoader);

  function FBXLoader(manager) {
    _classCallCheck(this, FBXLoader);

    return _super.call(this, manager);
  }

  _createClass(FBXLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = scope.path === '' ? LoaderUtils.extractUrlBase(url) : scope.path;
      var loader = new FileLoader(this.manager);
      loader.setPath(scope.path);
      loader.setResponseType('arraybuffer');
      loader.setRequestHeader(scope.requestHeader);
      loader.setWithCredentials(scope.withCredentials);
      loader.load(url, function (buffer) {
        try {
          onLoad(scope.parse(buffer, path));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "parse",
    value: function parse(FBXBuffer, path) {
      if (isFbxFormatBinary(FBXBuffer)) {
        fbxTree = new BinaryParser().parse(FBXBuffer);
      } else {
        var FBXText = convertArrayBufferToString(FBXBuffer);

        if (!isFbxFormatASCII(FBXText)) {
          throw new Error('THREE.FBXLoader: Unknown format.');
        }

        if (getFbxVersion(FBXText) < 7000) {
          throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + getFbxVersion(FBXText));
        }

        fbxTree = new TextParser().parse(FBXText);
      } // console.log( fbxTree );


      var textureLoader = new TextureLoader(this.manager).setPath(this.resourcePath || path).setCrossOrigin(this.crossOrigin);
      return new FBXTreeParser(textureLoader, this.manager).parse(fbxTree);
    }
  }]);

  return FBXLoader;
}(Loader$1); // Parse the FBXTree object returned by the BinaryParser or TextParser and return a Group


var FBXTreeParser = /*#__PURE__*/function () {
  function FBXTreeParser(textureLoader, manager) {
    _classCallCheck(this, FBXTreeParser);

    this.textureLoader = textureLoader;
    this.manager = manager;
  }

  _createClass(FBXTreeParser, [{
    key: "parse",
    value: function parse() {
      connections = this.parseConnections();
      var images = this.parseImages();
      var textures = this.parseTextures(images);
      var materials = this.parseMaterials(textures);
      var deformers = this.parseDeformers();
      var geometryMap = new GeometryParser().parse(deformers);
      this.parseScene(deformers, geometryMap, materials);
      return sceneGraph;
    } // Parses FBXTree.Connections which holds parent-child connections between objects (e.g. material -> texture, model->geometry )
    // and details the connection type

  }, {
    key: "parseConnections",
    value: function parseConnections() {
      var connectionMap = new Map();

      if ('Connections' in fbxTree) {
        var rawConnections = fbxTree.Connections.connections;
        rawConnections.forEach(function (rawConnection) {
          var fromID = rawConnection[0];
          var toID = rawConnection[1];
          var relationship = rawConnection[2];

          if (!connectionMap.has(fromID)) {
            connectionMap.set(fromID, {
              parents: [],
              children: []
            });
          }

          var parentRelationship = {
            ID: toID,
            relationship: relationship
          };
          connectionMap.get(fromID).parents.push(parentRelationship);

          if (!connectionMap.has(toID)) {
            connectionMap.set(toID, {
              parents: [],
              children: []
            });
          }

          var childRelationship = {
            ID: fromID,
            relationship: relationship
          };
          connectionMap.get(toID).children.push(childRelationship);
        });
      }

      return connectionMap;
    } // Parse FBXTree.Objects.Video for embedded image data
    // These images are connected to textures in FBXTree.Objects.Textures
    // via FBXTree.Connections.

  }, {
    key: "parseImages",
    value: function parseImages() {
      var images = {};
      var blobs = {};

      if ('Video' in fbxTree.Objects) {
        var videoNodes = fbxTree.Objects.Video;

        for (var nodeID in videoNodes) {
          var videoNode = videoNodes[nodeID];
          var id = parseInt(nodeID);
          images[id] = videoNode.RelativeFilename || videoNode.Filename; // raw image data is in videoNode.Content

          if ('Content' in videoNode) {
            var arrayBufferContent = videoNode.Content instanceof ArrayBuffer && videoNode.Content.byteLength > 0;
            var base64Content = typeof videoNode.Content === 'string' && videoNode.Content !== '';

            if (arrayBufferContent || base64Content) {
              var image = this.parseImage(videoNodes[nodeID]);
              blobs[videoNode.RelativeFilename || videoNode.Filename] = image;
            }
          }
        }
      }

      for (var _id in images) {
        var filename = images[_id];
        if (blobs[filename] !== undefined) images[_id] = blobs[filename];else images[_id] = images[_id].split('\\').pop();
      }

      return images;
    } // Parse embedded image data in FBXTree.Video.Content

  }, {
    key: "parseImage",
    value: function parseImage(videoNode) {
      var content = videoNode.Content;
      var fileName = videoNode.RelativeFilename || videoNode.Filename;
      var extension = fileName.slice(fileName.lastIndexOf('.') + 1).toLowerCase();
      var type;

      switch (extension) {
        case 'bmp':
          type = 'image/bmp';
          break;

        case 'jpg':
        case 'jpeg':
          type = 'image/jpeg';
          break;

        case 'png':
          type = 'image/png';
          break;

        case 'tif':
          type = 'image/tiff';
          break;

        case 'tga':
          if (this.manager.getHandler('.tga') === null) {
            console.warn('FBXLoader: TGA loader not found, skipping ', fileName);
          }

          type = 'image/tga';
          break;

        default:
          console.warn('FBXLoader: Image type "' + extension + '" is not supported.');
          return;
      }

      if (typeof content === 'string') {
        // ASCII format
        return 'data:' + type + ';base64,' + content;
      } else {
        // Binary Format
        var array = new Uint8Array(content);
        return window.URL.createObjectURL(new Blob([array], {
          type: type
        }));
      }
    } // Parse nodes in FBXTree.Objects.Texture
    // These contain details such as UV scaling, cropping, rotation etc and are connected
    // to images in FBXTree.Objects.Video

  }, {
    key: "parseTextures",
    value: function parseTextures(images) {
      var textureMap = new Map();

      if ('Texture' in fbxTree.Objects) {
        var textureNodes = fbxTree.Objects.Texture;

        for (var nodeID in textureNodes) {
          var texture = this.parseTexture(textureNodes[nodeID], images);
          textureMap.set(parseInt(nodeID), texture);
        }
      }

      return textureMap;
    } // Parse individual node in FBXTree.Objects.Texture

  }, {
    key: "parseTexture",
    value: function parseTexture(textureNode, images) {
      var texture = this.loadTexture(textureNode, images);
      texture.ID = textureNode.id;
      texture.name = textureNode.attrName;
      var wrapModeU = textureNode.WrapModeU;
      var wrapModeV = textureNode.WrapModeV;
      var valueU = wrapModeU !== undefined ? wrapModeU.value : 0;
      var valueV = wrapModeV !== undefined ? wrapModeV.value : 0; // http://download.autodesk.com/us/fbx/SDKdocs/FBX_SDK_Help/files/fbxsdkref/class_k_fbx_texture.html#889640e63e2e681259ea81061b85143a
      // 0: repeat(default), 1: clamp

      texture.wrapS = valueU === 0 ? RepeatWrapping$1 : ClampToEdgeWrapping;
      texture.wrapT = valueV === 0 ? RepeatWrapping$1 : ClampToEdgeWrapping;

      if ('Scaling' in textureNode) {
        var values = textureNode.Scaling.value;
        texture.repeat.x = values[0];
        texture.repeat.y = values[1];
      }

      return texture;
    } // load a texture specified as a blob or data URI, or via an external URL using TextureLoader

  }, {
    key: "loadTexture",
    value: function loadTexture(textureNode, images) {
      var fileName;
      var currentPath = this.textureLoader.path;
      var children = connections.get(textureNode.id).children;

      if (children !== undefined && children.length > 0 && images[children[0].ID] !== undefined) {
        fileName = images[children[0].ID];

        if (fileName.indexOf('blob:') === 0 || fileName.indexOf('data:') === 0) {
          this.textureLoader.setPath(undefined);
        }
      }

      var texture;
      var extension = textureNode.FileName.slice(-3).toLowerCase();

      if (extension === 'tga') {
        var loader = this.manager.getHandler('.tga');

        if (loader === null) {
          console.warn('FBXLoader: TGA loader not found, creating placeholder texture for', textureNode.RelativeFilename);
          texture = new Texture();
        } else {
          loader.setPath(this.textureLoader.path);
          texture = loader.load(fileName);
        }
      } else if (extension === 'psd') {
        console.warn('FBXLoader: PSD textures are not supported, creating placeholder texture for', textureNode.RelativeFilename);
        texture = new Texture();
      } else {
        texture = this.textureLoader.load(fileName);
      }

      this.textureLoader.setPath(currentPath);
      return texture;
    } // Parse nodes in FBXTree.Objects.Material

  }, {
    key: "parseMaterials",
    value: function parseMaterials(textureMap) {
      var materialMap = new Map();

      if ('Material' in fbxTree.Objects) {
        var materialNodes = fbxTree.Objects.Material;

        for (var nodeID in materialNodes) {
          var material = this.parseMaterial(materialNodes[nodeID], textureMap);
          if (material !== null) materialMap.set(parseInt(nodeID), material);
        }
      }

      return materialMap;
    } // Parse single node in FBXTree.Objects.Material
    // Materials are connected to texture maps in FBXTree.Objects.Textures
    // FBX format currently only supports Lambert and Phong shading models

  }, {
    key: "parseMaterial",
    value: function parseMaterial(materialNode, textureMap) {
      var ID = materialNode.id;
      var name = materialNode.attrName;
      var type = materialNode.ShadingModel; // Case where FBX wraps shading model in property object.

      if (_typeof$1(type) === 'object') {
        type = type.value;
      } // Ignore unused materials which don't have any connections.


      if (!connections.has(ID)) return null;
      var parameters = this.parseParameters(materialNode, textureMap, ID);
      var material;

      switch (type.toLowerCase()) {
        case 'phong':
          material = new MeshPhongMaterial();
          break;

        case 'lambert':
          material = new MeshLambertMaterial();
          break;

        default:
          console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.', type);
          material = new MeshPhongMaterial();
          break;
      }

      material.setValues(parameters);
      material.name = name;
      return material;
    } // Parse FBX material and return parameters suitable for a three.js material
    // Also parse the texture map and return any textures associated with the material

  }, {
    key: "parseParameters",
    value: function parseParameters(materialNode, textureMap, ID) {
      var parameters = {};

      if (materialNode.BumpFactor) {
        parameters.bumpScale = materialNode.BumpFactor.value;
      }

      if (materialNode.Diffuse) {
        parameters.color = new Color$1().fromArray(materialNode.Diffuse.value);
      } else if (materialNode.DiffuseColor && (materialNode.DiffuseColor.type === 'Color' || materialNode.DiffuseColor.type === 'ColorRGB')) {
        // The blender exporter exports diffuse here instead of in materialNode.Diffuse
        parameters.color = new Color$1().fromArray(materialNode.DiffuseColor.value);
      }

      if (materialNode.DisplacementFactor) {
        parameters.displacementScale = materialNode.DisplacementFactor.value;
      }

      if (materialNode.Emissive) {
        parameters.emissive = new Color$1().fromArray(materialNode.Emissive.value);
      } else if (materialNode.EmissiveColor && (materialNode.EmissiveColor.type === 'Color' || materialNode.EmissiveColor.type === 'ColorRGB')) {
        // The blender exporter exports emissive color here instead of in materialNode.Emissive
        parameters.emissive = new Color$1().fromArray(materialNode.EmissiveColor.value);
      }

      if (materialNode.EmissiveFactor) {
        parameters.emissiveIntensity = parseFloat(materialNode.EmissiveFactor.value);
      }

      if (materialNode.Opacity) {
        parameters.opacity = parseFloat(materialNode.Opacity.value);
      }

      if (parameters.opacity < 1.0) {
        parameters.transparent = true;
      }

      if (materialNode.ReflectionFactor) {
        parameters.reflectivity = materialNode.ReflectionFactor.value;
      }

      if (materialNode.Shininess) {
        parameters.shininess = materialNode.Shininess.value;
      }

      if (materialNode.Specular) {
        parameters.specular = new Color$1().fromArray(materialNode.Specular.value);
      } else if (materialNode.SpecularColor && materialNode.SpecularColor.type === 'Color') {
        // The blender exporter exports specular color here instead of in materialNode.Specular
        parameters.specular = new Color$1().fromArray(materialNode.SpecularColor.value);
      }

      var scope = this;
      connections.get(ID).children.forEach(function (child) {
        var type = child.relationship;

        switch (type) {
          case 'Bump':
            parameters.bumpMap = scope.getTexture(textureMap, child.ID);
            break;

          case 'Maya|TEX_ao_map':
            parameters.aoMap = scope.getTexture(textureMap, child.ID);
            break;

          case 'DiffuseColor':
          case 'Maya|TEX_color_map':
            parameters.map = scope.getTexture(textureMap, child.ID);

            if (parameters.map !== undefined) {
              parameters.map.encoding = sRGBEncoding;
            }

            break;

          case 'DisplacementColor':
            parameters.displacementMap = scope.getTexture(textureMap, child.ID);
            break;

          case 'EmissiveColor':
            parameters.emissiveMap = scope.getTexture(textureMap, child.ID);

            if (parameters.emissiveMap !== undefined) {
              parameters.emissiveMap.encoding = sRGBEncoding;
            }

            break;

          case 'NormalMap':
          case 'Maya|TEX_normal_map':
            parameters.normalMap = scope.getTexture(textureMap, child.ID);
            break;

          case 'ReflectionColor':
            parameters.envMap = scope.getTexture(textureMap, child.ID);

            if (parameters.envMap !== undefined) {
              parameters.envMap.mapping = EquirectangularReflectionMapping;
              parameters.envMap.encoding = sRGBEncoding;
            }

            break;

          case 'SpecularColor':
            parameters.specularMap = scope.getTexture(textureMap, child.ID);

            if (parameters.specularMap !== undefined) {
              parameters.specularMap.encoding = sRGBEncoding;
            }

            break;

          case 'TransparentColor':
          case 'TransparencyFactor':
            parameters.alphaMap = scope.getTexture(textureMap, child.ID);
            parameters.transparent = true;
            break;

          case 'AmbientColor':
          case 'ShininessExponent': // AKA glossiness map

          case 'SpecularFactor': // AKA specularLevel

          case 'VectorDisplacementColor': // NOTE: Seems to be a copy of DisplacementColor

          default:
            console.warn('THREE.FBXLoader: %s map is not supported in three.js, skipping texture.', type);
            break;
        }
      });
      return parameters;
    } // get a texture from the textureMap for use by a material.

  }, {
    key: "getTexture",
    value: function getTexture(textureMap, id) {
      // if the texture is a layered texture, just use the first layer and issue a warning
      if ('LayeredTexture' in fbxTree.Objects && id in fbxTree.Objects.LayeredTexture) {
        console.warn('THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer.');
        id = connections.get(id).children[0].ID;
      }

      return textureMap.get(id);
    } // Parse nodes in FBXTree.Objects.Deformer
    // Deformer node can contain skinning or Vertex Cache animation data, however only skinning is supported here
    // Generates map of Skeleton-like objects for use later when generating and binding skeletons.

  }, {
    key: "parseDeformers",
    value: function parseDeformers() {
      var skeletons = {};
      var morphTargets = {};

      if ('Deformer' in fbxTree.Objects) {
        var DeformerNodes = fbxTree.Objects.Deformer;

        for (var nodeID in DeformerNodes) {
          var deformerNode = DeformerNodes[nodeID];
          var relationships = connections.get(parseInt(nodeID));

          if (deformerNode.attrType === 'Skin') {
            var skeleton = this.parseSkeleton(relationships, DeformerNodes);
            skeleton.ID = nodeID;
            if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: skeleton attached to more than one geometry is not supported.');
            skeleton.geometryID = relationships.parents[0].ID;
            skeletons[nodeID] = skeleton;
          } else if (deformerNode.attrType === 'BlendShape') {
            var morphTarget = {
              id: nodeID
            };
            morphTarget.rawTargets = this.parseMorphTargets(relationships, DeformerNodes);
            morphTarget.id = nodeID;
            if (relationships.parents.length > 1) console.warn('THREE.FBXLoader: morph target attached to more than one geometry is not supported.');
            morphTargets[nodeID] = morphTarget;
          }
        }
      }

      return {
        skeletons: skeletons,
        morphTargets: morphTargets
      };
    } // Parse single nodes in FBXTree.Objects.Deformer
    // The top level skeleton node has type 'Skin' and sub nodes have type 'Cluster'
    // Each skin node represents a skeleton and each cluster node represents a bone

  }, {
    key: "parseSkeleton",
    value: function parseSkeleton(relationships, deformerNodes) {
      var rawBones = [];
      relationships.children.forEach(function (child) {
        var boneNode = deformerNodes[child.ID];
        if (boneNode.attrType !== 'Cluster') return;
        var rawBone = {
          ID: child.ID,
          indices: [],
          weights: [],
          transformLink: new Matrix4().fromArray(boneNode.TransformLink.a) // transform: new Matrix4().fromArray( boneNode.Transform.a ),
          // linkMode: boneNode.Mode,

        };

        if ('Indexes' in boneNode) {
          rawBone.indices = boneNode.Indexes.a;
          rawBone.weights = boneNode.Weights.a;
        }

        rawBones.push(rawBone);
      });
      return {
        rawBones: rawBones,
        bones: []
      };
    } // The top level morph deformer node has type "BlendShape" and sub nodes have type "BlendShapeChannel"

  }, {
    key: "parseMorphTargets",
    value: function parseMorphTargets(relationships, deformerNodes) {
      var rawMorphTargets = [];

      for (var i = 0; i < relationships.children.length; i++) {
        var child = relationships.children[i];
        var morphTargetNode = deformerNodes[child.ID];
        var rawMorphTarget = {
          name: morphTargetNode.attrName,
          initialWeight: morphTargetNode.DeformPercent,
          id: morphTargetNode.id,
          fullWeights: morphTargetNode.FullWeights.a
        };
        if (morphTargetNode.attrType !== 'BlendShapeChannel') return;
        rawMorphTarget.geoID = connections.get(parseInt(child.ID)).children.filter(function (child) {
          return child.relationship === undefined;
        })[0].ID;
        rawMorphTargets.push(rawMorphTarget);
      }

      return rawMorphTargets;
    } // create the main Group() to be returned by the loader

  }, {
    key: "parseScene",
    value: function parseScene(deformers, geometryMap, materialMap) {
      sceneGraph = new Group();
      var modelMap = this.parseModels(deformers.skeletons, geometryMap, materialMap);
      var modelNodes = fbxTree.Objects.Model;
      var scope = this;
      modelMap.forEach(function (model) {
        var modelNode = modelNodes[model.ID];
        scope.setLookAtProperties(model, modelNode);
        var parentConnections = connections.get(model.ID).parents;
        parentConnections.forEach(function (connection) {
          var parent = modelMap.get(connection.ID);
          if (parent !== undefined) parent.add(model);
        });

        if (model.parent === null) {
          sceneGraph.add(model);
        }
      });
      this.bindSkeleton(deformers.skeletons, geometryMap, modelMap);
      this.createAmbientLight();
      sceneGraph.traverse(function (node) {
        if (node.userData.transformData) {
          if (node.parent) {
            node.userData.transformData.parentMatrix = node.parent.matrix;
            node.userData.transformData.parentMatrixWorld = node.parent.matrixWorld;
          }

          var transform = generateTransform(node.userData.transformData);
          node.applyMatrix4(transform);
          node.updateWorldMatrix();
        }
      });
      var animations = new AnimationParser().parse(); // if all the models where already combined in a single group, just return that

      if (sceneGraph.children.length === 1 && sceneGraph.children[0].isGroup) {
        sceneGraph.children[0].animations = animations;
        sceneGraph = sceneGraph.children[0];
      }

      sceneGraph.animations = animations;
    } // parse nodes in FBXTree.Objects.Model

  }, {
    key: "parseModels",
    value: function parseModels(skeletons, geometryMap, materialMap) {
      var modelMap = new Map();
      var modelNodes = fbxTree.Objects.Model;

      for (var nodeID in modelNodes) {
        var id = parseInt(nodeID);
        var node = modelNodes[nodeID];
        var relationships = connections.get(id);
        var model = this.buildSkeleton(relationships, skeletons, id, node.attrName);

        if (!model) {
          switch (node.attrType) {
            case 'Camera':
              model = this.createCamera(relationships);
              break;

            case 'Light':
              model = this.createLight(relationships);
              break;

            case 'Mesh':
              model = this.createMesh(relationships, geometryMap, materialMap);
              break;

            case 'NurbsCurve':
              model = this.createCurve(relationships, geometryMap);
              break;

            case 'LimbNode':
            case 'Root':
              model = new Bone();
              break;

            case 'Null':
            default:
              model = new Group();
              break;
          }

          model.name = node.attrName ? PropertyBinding.sanitizeNodeName(node.attrName) : '';
          model.ID = id;
        }

        this.getTransformData(model, node);
        modelMap.set(id, model);
      }

      return modelMap;
    }
  }, {
    key: "buildSkeleton",
    value: function buildSkeleton(relationships, skeletons, id, name) {
      var bone = null;
      relationships.parents.forEach(function (parent) {
        var _loop = function _loop(ID) {
          var skeleton = skeletons[ID];
          skeleton.rawBones.forEach(function (rawBone, i) {
            if (rawBone.ID === parent.ID) {
              var subBone = bone;
              bone = new Bone();
              bone.matrixWorld.copy(rawBone.transformLink); // set name and id here - otherwise in cases where "subBone" is created it will not have a name / id

              bone.name = name ? PropertyBinding.sanitizeNodeName(name) : '';
              bone.ID = id;
              skeleton.bones[i] = bone; // In cases where a bone is shared between multiple meshes
              // duplicate the bone here and and it as a child of the first bone

              if (subBone !== null) {
                bone.add(subBone);
              }
            }
          });
        };

        for (var ID in skeletons) {
          _loop(ID);
        }
      });
      return bone;
    } // create a PerspectiveCamera or OrthographicCamera

  }, {
    key: "createCamera",
    value: function createCamera(relationships) {
      var model;
      var cameraAttribute;
      relationships.children.forEach(function (child) {
        var attr = fbxTree.Objects.NodeAttribute[child.ID];

        if (attr !== undefined) {
          cameraAttribute = attr;
        }
      });

      if (cameraAttribute === undefined) {
        model = new Object3D();
      } else {
        var type = 0;

        if (cameraAttribute.CameraProjectionType !== undefined && cameraAttribute.CameraProjectionType.value === 1) {
          type = 1;
        }

        var nearClippingPlane = 1;

        if (cameraAttribute.NearPlane !== undefined) {
          nearClippingPlane = cameraAttribute.NearPlane.value / 1000;
        }

        var farClippingPlane = 1000;

        if (cameraAttribute.FarPlane !== undefined) {
          farClippingPlane = cameraAttribute.FarPlane.value / 1000;
        }

        var width = window.innerWidth;
        var height = window.innerHeight;

        if (cameraAttribute.AspectWidth !== undefined && cameraAttribute.AspectHeight !== undefined) {
          width = cameraAttribute.AspectWidth.value;
          height = cameraAttribute.AspectHeight.value;
        }

        var aspect = width / height;
        var fov = 45;

        if (cameraAttribute.FieldOfView !== undefined) {
          fov = cameraAttribute.FieldOfView.value;
        }

        var focalLength = cameraAttribute.FocalLength ? cameraAttribute.FocalLength.value : null;

        switch (type) {
          case 0:
            // Perspective
            model = new PerspectiveCamera(fov, aspect, nearClippingPlane, farClippingPlane);
            if (focalLength !== null) model.setFocalLength(focalLength);
            break;

          case 1:
            // Orthographic
            model = new OrthographicCamera(-width / 2, width / 2, height / 2, -height / 2, nearClippingPlane, farClippingPlane);
            break;

          default:
            console.warn('THREE.FBXLoader: Unknown camera type ' + type + '.');
            model = new Object3D();
            break;
        }
      }

      return model;
    } // Create a DirectionalLight, PointLight or SpotLight

  }, {
    key: "createLight",
    value: function createLight(relationships) {
      var model;
      var lightAttribute;
      relationships.children.forEach(function (child) {
        var attr = fbxTree.Objects.NodeAttribute[child.ID];

        if (attr !== undefined) {
          lightAttribute = attr;
        }
      });

      if (lightAttribute === undefined) {
        model = new Object3D();
      } else {
        var type; // LightType can be undefined for Point lights

        if (lightAttribute.LightType === undefined) {
          type = 0;
        } else {
          type = lightAttribute.LightType.value;
        }

        var color = 0xffffff;

        if (lightAttribute.Color !== undefined) {
          color = new Color$1().fromArray(lightAttribute.Color.value);
        }

        var intensity = lightAttribute.Intensity === undefined ? 1 : lightAttribute.Intensity.value / 100; // light disabled

        if (lightAttribute.CastLightOnObject !== undefined && lightAttribute.CastLightOnObject.value === 0) {
          intensity = 0;
        }

        var distance = 0;

        if (lightAttribute.FarAttenuationEnd !== undefined) {
          if (lightAttribute.EnableFarAttenuation !== undefined && lightAttribute.EnableFarAttenuation.value === 0) {
            distance = 0;
          } else {
            distance = lightAttribute.FarAttenuationEnd.value;
          }
        } // TODO: could this be calculated linearly from FarAttenuationStart to FarAttenuationEnd?


        var decay = 1;

        switch (type) {
          case 0:
            // Point
            model = new PointLight$1(color, intensity, distance, decay);
            break;

          case 1:
            // Directional
            model = new DirectionalLight(color, intensity);
            break;

          case 2:
            // Spot
            var angle = Math.PI / 3;

            if (lightAttribute.InnerAngle !== undefined) {
              angle = MathUtils.degToRad(lightAttribute.InnerAngle.value);
            }

            var penumbra = 0;

            if (lightAttribute.OuterAngle !== undefined) {
              // TODO: this is not correct - FBX calculates outer and inner angle in degrees
              // with OuterAngle > InnerAngle && OuterAngle <= Math.PI
              // while three.js uses a penumbra between (0, 1) to attenuate the inner angle
              penumbra = MathUtils.degToRad(lightAttribute.OuterAngle.value);
              penumbra = Math.max(penumbra, 1);
            }

            model = new SpotLight$1(color, intensity, distance, angle, penumbra, decay);
            break;

          default:
            console.warn('THREE.FBXLoader: Unknown light type ' + lightAttribute.LightType.value + ', defaulting to a PointLight.');
            model = new PointLight$1(color, intensity);
            break;
        }

        if (lightAttribute.CastShadows !== undefined && lightAttribute.CastShadows.value === 1) {
          model.castShadow = true;
        }
      }

      return model;
    }
  }, {
    key: "createMesh",
    value: function createMesh(relationships, geometryMap, materialMap) {
      var model;
      var geometry = null;
      var material = null;
      var materials = []; // get geometry and materials(s) from connections

      relationships.children.forEach(function (child) {
        if (geometryMap.has(child.ID)) {
          geometry = geometryMap.get(child.ID);
        }

        if (materialMap.has(child.ID)) {
          materials.push(materialMap.get(child.ID));
        }
      });

      if (materials.length > 1) {
        material = materials;
      } else if (materials.length > 0) {
        material = materials[0];
      } else {
        material = new MeshPhongMaterial({
          color: 0xcccccc
        });
        materials.push(material);
      }

      if ('color' in geometry.attributes) {
        materials.forEach(function (material) {
          material.vertexColors = true;
        });
      }

      if (geometry.FBX_Deformer) {
        model = new SkinnedMesh(geometry, material);
        model.normalizeSkinWeights();
      } else {
        model = new Mesh(geometry, material);
      }

      return model;
    }
  }, {
    key: "createCurve",
    value: function createCurve(relationships, geometryMap) {
      var geometry = relationships.children.reduce(function (geo, child) {
        if (geometryMap.has(child.ID)) geo = geometryMap.get(child.ID);
        return geo;
      }, null); // FBX does not list materials for Nurbs lines, so we'll just put our own in here.

      var material = new LineBasicMaterial({
        color: 0x3300ff,
        linewidth: 1
      });
      return new Line$1(geometry, material);
    } // parse the model node for transform data

  }, {
    key: "getTransformData",
    value: function getTransformData(model, modelNode) {
      var transformData = {};
      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);else transformData.eulerOrder = 'ZYX';
      if ('Lcl_Translation' in modelNode) transformData.translation = modelNode.Lcl_Translation.value;
      if ('PreRotation' in modelNode) transformData.preRotation = modelNode.PreRotation.value;
      if ('Lcl_Rotation' in modelNode) transformData.rotation = modelNode.Lcl_Rotation.value;
      if ('PostRotation' in modelNode) transformData.postRotation = modelNode.PostRotation.value;
      if ('Lcl_Scaling' in modelNode) transformData.scale = modelNode.Lcl_Scaling.value;
      if ('ScalingOffset' in modelNode) transformData.scalingOffset = modelNode.ScalingOffset.value;
      if ('ScalingPivot' in modelNode) transformData.scalingPivot = modelNode.ScalingPivot.value;
      if ('RotationOffset' in modelNode) transformData.rotationOffset = modelNode.RotationOffset.value;
      if ('RotationPivot' in modelNode) transformData.rotationPivot = modelNode.RotationPivot.value;
      model.userData.transformData = transformData;
    }
  }, {
    key: "setLookAtProperties",
    value: function setLookAtProperties(model, modelNode) {
      if ('LookAtProperty' in modelNode) {
        var children = connections.get(model.ID).children;
        children.forEach(function (child) {
          if (child.relationship === 'LookAtProperty') {
            var lookAtTarget = fbxTree.Objects.Model[child.ID];

            if ('Lcl_Translation' in lookAtTarget) {
              var pos = lookAtTarget.Lcl_Translation.value; // DirectionalLight, SpotLight

              if (model.target !== undefined) {
                model.target.position.fromArray(pos);
                sceneGraph.add(model.target);
              } else {
                // Cameras and other Object3Ds
                model.lookAt(new Vector3$1().fromArray(pos));
              }
            }
          }
        });
      }
    }
  }, {
    key: "bindSkeleton",
    value: function bindSkeleton(skeletons, geometryMap, modelMap) {
      var bindMatrices = this.parsePoseNodes();

      var _loop2 = function _loop2(ID) {
        var skeleton = skeletons[ID];
        var parents = connections.get(parseInt(skeleton.ID)).parents;
        parents.forEach(function (parent) {
          if (geometryMap.has(parent.ID)) {
            var geoID = parent.ID;
            var geoRelationships = connections.get(geoID);
            geoRelationships.parents.forEach(function (geoConnParent) {
              if (modelMap.has(geoConnParent.ID)) {
                var model = modelMap.get(geoConnParent.ID);
                model.bind(new Skeleton(skeleton.bones), bindMatrices[geoConnParent.ID]);
              }
            });
          }
        });
      };

      for (var ID in skeletons) {
        _loop2(ID);
      }
    }
  }, {
    key: "parsePoseNodes",
    value: function parsePoseNodes() {
      var bindMatrices = {};

      if ('Pose' in fbxTree.Objects) {
        var BindPoseNode = fbxTree.Objects.Pose;

        for (var nodeID in BindPoseNode) {
          if (BindPoseNode[nodeID].attrType === 'BindPose' && BindPoseNode[nodeID].NbPoseNodes > 0) {
            var poseNodes = BindPoseNode[nodeID].PoseNode;

            if (Array.isArray(poseNodes)) {
              poseNodes.forEach(function (poseNode) {
                bindMatrices[poseNode.Node] = new Matrix4().fromArray(poseNode.Matrix.a);
              });
            } else {
              bindMatrices[poseNodes.Node] = new Matrix4().fromArray(poseNodes.Matrix.a);
            }
          }
        }
      }

      return bindMatrices;
    } // Parse ambient color in FBXTree.GlobalSettings - if it's not set to black (default), create an ambient light

  }, {
    key: "createAmbientLight",
    value: function createAmbientLight() {
      if ('GlobalSettings' in fbxTree && 'AmbientColor' in fbxTree.GlobalSettings) {
        var ambientColor = fbxTree.GlobalSettings.AmbientColor.value;
        var r = ambientColor[0];
        var g = ambientColor[1];
        var b = ambientColor[2];

        if (r !== 0 || g !== 0 || b !== 0) {
          var color = new Color$1(r, g, b);
          sceneGraph.add(new AmbientLight$1(color, 1));
        }
      }
    }
  }]);

  return FBXTreeParser;
}(); // parse Geometry data from FBXTree and return map of BufferGeometries


var GeometryParser = /*#__PURE__*/function () {
  function GeometryParser() {
    _classCallCheck(this, GeometryParser);
  }

  _createClass(GeometryParser, [{
    key: "parse",
    // Parse nodes in FBXTree.Objects.Geometry
    value: function parse(deformers) {
      var geometryMap = new Map();

      if ('Geometry' in fbxTree.Objects) {
        var geoNodes = fbxTree.Objects.Geometry;

        for (var nodeID in geoNodes) {
          var relationships = connections.get(parseInt(nodeID));
          var geo = this.parseGeometry(relationships, geoNodes[nodeID], deformers);
          geometryMap.set(parseInt(nodeID), geo);
        }
      }

      return geometryMap;
    } // Parse single node in FBXTree.Objects.Geometry

  }, {
    key: "parseGeometry",
    value: function parseGeometry(relationships, geoNode, deformers) {
      switch (geoNode.attrType) {
        case 'Mesh':
          return this.parseMeshGeometry(relationships, geoNode, deformers);

        case 'NurbsCurve':
          return this.parseNurbsGeometry(geoNode);
      }
    } // Parse single node mesh geometry in FBXTree.Objects.Geometry

  }, {
    key: "parseMeshGeometry",
    value: function parseMeshGeometry(relationships, geoNode, deformers) {
      var skeletons = deformers.skeletons;
      var morphTargets = [];
      var modelNodes = relationships.parents.map(function (parent) {
        return fbxTree.Objects.Model[parent.ID];
      }); // don't create geometry if it is not associated with any models

      if (modelNodes.length === 0) return;
      var skeleton = relationships.children.reduce(function (skeleton, child) {
        if (skeletons[child.ID] !== undefined) skeleton = skeletons[child.ID];
        return skeleton;
      }, null);
      relationships.children.forEach(function (child) {
        if (deformers.morphTargets[child.ID] !== undefined) {
          morphTargets.push(deformers.morphTargets[child.ID]);
        }
      }); // Assume one model and get the preRotation from that
      // if there is more than one model associated with the geometry this may cause problems

      var modelNode = modelNodes[0];
      var transformData = {};
      if ('RotationOrder' in modelNode) transformData.eulerOrder = getEulerOrder(modelNode.RotationOrder.value);
      if ('InheritType' in modelNode) transformData.inheritType = parseInt(modelNode.InheritType.value);
      if ('GeometricTranslation' in modelNode) transformData.translation = modelNode.GeometricTranslation.value;
      if ('GeometricRotation' in modelNode) transformData.rotation = modelNode.GeometricRotation.value;
      if ('GeometricScaling' in modelNode) transformData.scale = modelNode.GeometricScaling.value;
      var transform = generateTransform(transformData);
      return this.genGeometry(geoNode, skeleton, morphTargets, transform);
    } // Generate a BufferGeometry from a node in FBXTree.Objects.Geometry

  }, {
    key: "genGeometry",
    value: function genGeometry(geoNode, skeleton, morphTargets, preTransform) {
      var geo = new BufferGeometry();
      if (geoNode.attrName) geo.name = geoNode.attrName;
      var geoInfo = this.parseGeoNode(geoNode, skeleton);
      var buffers = this.genBuffers(geoInfo);
      var positionAttribute = new Float32BufferAttribute(buffers.vertex, 3);
      positionAttribute.applyMatrix4(preTransform);
      geo.setAttribute('position', positionAttribute);

      if (buffers.colors.length > 0) {
        geo.setAttribute('color', new Float32BufferAttribute(buffers.colors, 3));
      }

      if (skeleton) {
        geo.setAttribute('skinIndex', new Uint16BufferAttribute(buffers.weightsIndices, 4));
        geo.setAttribute('skinWeight', new Float32BufferAttribute(buffers.vertexWeights, 4)); // used later to bind the skeleton to the model

        geo.FBX_Deformer = skeleton;
      }

      if (buffers.normal.length > 0) {
        var normalMatrix = new Matrix3().getNormalMatrix(preTransform);
        var normalAttribute = new Float32BufferAttribute(buffers.normal, 3);
        normalAttribute.applyNormalMatrix(normalMatrix);
        geo.setAttribute('normal', normalAttribute);
      }

      buffers.uvs.forEach(function (uvBuffer, i) {
        // subsequent uv buffers are called 'uv1', 'uv2', ...
        var name = 'uv' + (i + 1).toString(); // the first uv buffer is just called 'uv'

        if (i === 0) {
          name = 'uv';
        }

        geo.setAttribute(name, new Float32BufferAttribute(buffers.uvs[i], 2));
      });

      if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
        // Convert the material indices of each vertex into rendering groups on the geometry.
        var prevMaterialIndex = buffers.materialIndex[0];
        var startIndex = 0;
        buffers.materialIndex.forEach(function (currentIndex, i) {
          if (currentIndex !== prevMaterialIndex) {
            geo.addGroup(startIndex, i - startIndex, prevMaterialIndex);
            prevMaterialIndex = currentIndex;
            startIndex = i;
          }
        }); // the loop above doesn't add the last group, do that here.

        if (geo.groups.length > 0) {
          var lastGroup = geo.groups[geo.groups.length - 1];
          var lastIndex = lastGroup.start + lastGroup.count;

          if (lastIndex !== buffers.materialIndex.length) {
            geo.addGroup(lastIndex, buffers.materialIndex.length - lastIndex, prevMaterialIndex);
          }
        } // case where there are multiple materials but the whole geometry is only
        // using one of them


        if (geo.groups.length === 0) {
          geo.addGroup(0, buffers.materialIndex.length, buffers.materialIndex[0]);
        }
      }

      this.addMorphTargets(geo, geoNode, morphTargets, preTransform);
      return geo;
    }
  }, {
    key: "parseGeoNode",
    value: function parseGeoNode(geoNode, skeleton) {
      var geoInfo = {};
      geoInfo.vertexPositions = geoNode.Vertices !== undefined ? geoNode.Vertices.a : [];
      geoInfo.vertexIndices = geoNode.PolygonVertexIndex !== undefined ? geoNode.PolygonVertexIndex.a : [];

      if (geoNode.LayerElementColor) {
        geoInfo.color = this.parseVertexColors(geoNode.LayerElementColor[0]);
      }

      if (geoNode.LayerElementMaterial) {
        geoInfo.material = this.parseMaterialIndices(geoNode.LayerElementMaterial[0]);
      }

      if (geoNode.LayerElementNormal) {
        geoInfo.normal = this.parseNormals(geoNode.LayerElementNormal[0]);
      }

      if (geoNode.LayerElementUV) {
        geoInfo.uv = [];
        var i = 0;

        while (geoNode.LayerElementUV[i]) {
          if (geoNode.LayerElementUV[i].UV) {
            geoInfo.uv.push(this.parseUVs(geoNode.LayerElementUV[i]));
          }

          i++;
        }
      }

      geoInfo.weightTable = {};

      if (skeleton !== null) {
        geoInfo.skeleton = skeleton;
        skeleton.rawBones.forEach(function (rawBone, i) {
          // loop over the bone's vertex indices and weights
          rawBone.indices.forEach(function (index, j) {
            if (geoInfo.weightTable[index] === undefined) geoInfo.weightTable[index] = [];
            geoInfo.weightTable[index].push({
              id: i,
              weight: rawBone.weights[j]
            });
          });
        });
      }

      return geoInfo;
    }
  }, {
    key: "genBuffers",
    value: function genBuffers(geoInfo) {
      var buffers = {
        vertex: [],
        normal: [],
        colors: [],
        uvs: [],
        materialIndex: [],
        vertexWeights: [],
        weightsIndices: []
      };
      var polygonIndex = 0;
      var faceLength = 0;
      var displayedWeightsWarning = false; // these will hold data for a single face

      var facePositionIndexes = [];
      var faceNormals = [];
      var faceColors = [];
      var faceUVs = [];
      var faceWeights = [];
      var faceWeightIndices = [];
      var scope = this;
      geoInfo.vertexIndices.forEach(function (vertexIndex, polygonVertexIndex) {
        var materialIndex;
        var endOfFace = false; // Face index and vertex index arrays are combined in a single array
        // A cube with quad faces looks like this:
        // PolygonVertexIndex: *24 {
        //  a: 0, 1, 3, -3, 2, 3, 5, -5, 4, 5, 7, -7, 6, 7, 1, -1, 1, 7, 5, -4, 6, 0, 2, -5
        //  }
        // Negative numbers mark the end of a face - first face here is 0, 1, 3, -3
        // to find index of last vertex bit shift the index: ^ - 1

        if (vertexIndex < 0) {
          vertexIndex = vertexIndex ^ -1; // equivalent to ( x * -1 ) - 1

          endOfFace = true;
        }

        var weightIndices = [];
        var weights = [];
        facePositionIndexes.push(vertexIndex * 3, vertexIndex * 3 + 1, vertexIndex * 3 + 2);

        if (geoInfo.color) {
          var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.color);
          faceColors.push(data[0], data[1], data[2]);
        }

        if (geoInfo.skeleton) {
          if (geoInfo.weightTable[vertexIndex] !== undefined) {
            geoInfo.weightTable[vertexIndex].forEach(function (wt) {
              weights.push(wt.weight);
              weightIndices.push(wt.id);
            });
          }

          if (weights.length > 4) {
            if (!displayedWeightsWarning) {
              console.warn('THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights.');
              displayedWeightsWarning = true;
            }

            var wIndex = [0, 0, 0, 0];
            var Weight = [0, 0, 0, 0];
            weights.forEach(function (weight, weightIndex) {
              var currentWeight = weight;
              var currentIndex = weightIndices[weightIndex];
              Weight.forEach(function (comparedWeight, comparedWeightIndex, comparedWeightArray) {
                if (currentWeight > comparedWeight) {
                  comparedWeightArray[comparedWeightIndex] = currentWeight;
                  currentWeight = comparedWeight;
                  var tmp = wIndex[comparedWeightIndex];
                  wIndex[comparedWeightIndex] = currentIndex;
                  currentIndex = tmp;
                }
              });
            });
            weightIndices = wIndex;
            weights = Weight;
          } // if the weight array is shorter than 4 pad with 0s


          while (weights.length < 4) {
            weights.push(0);
            weightIndices.push(0);
          }

          for (var i = 0; i < 4; ++i) {
            faceWeights.push(weights[i]);
            faceWeightIndices.push(weightIndices[i]);
          }
        }

        if (geoInfo.normal) {
          var _data = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.normal);

          faceNormals.push(_data[0], _data[1], _data[2]);
        }

        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
          materialIndex = getData(polygonVertexIndex, polygonIndex, vertexIndex, geoInfo.material)[0];
        }

        if (geoInfo.uv) {
          geoInfo.uv.forEach(function (uv, i) {
            var data = getData(polygonVertexIndex, polygonIndex, vertexIndex, uv);

            if (faceUVs[i] === undefined) {
              faceUVs[i] = [];
            }

            faceUVs[i].push(data[0]);
            faceUVs[i].push(data[1]);
          });
        }

        faceLength++;

        if (endOfFace) {
          scope.genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength);
          polygonIndex++;
          faceLength = 0; // reset arrays for the next face

          facePositionIndexes = [];
          faceNormals = [];
          faceColors = [];
          faceUVs = [];
          faceWeights = [];
          faceWeightIndices = [];
        }
      });
      return buffers;
    } // Generate data for a single face in a geometry. If the face is a quad then split it into 2 tris

  }, {
    key: "genFace",
    value: function genFace(buffers, geoInfo, facePositionIndexes, materialIndex, faceNormals, faceColors, faceUVs, faceWeights, faceWeightIndices, faceLength) {
      var _loop3 = function _loop3(i) {
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[0]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[1]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[2]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 1]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[(i - 1) * 3 + 2]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 1]]);
        buffers.vertex.push(geoInfo.vertexPositions[facePositionIndexes[i * 3 + 2]]);

        if (geoInfo.skeleton) {
          buffers.vertexWeights.push(faceWeights[0]);
          buffers.vertexWeights.push(faceWeights[1]);
          buffers.vertexWeights.push(faceWeights[2]);
          buffers.vertexWeights.push(faceWeights[3]);
          buffers.vertexWeights.push(faceWeights[(i - 1) * 4]);
          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 1]);
          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 2]);
          buffers.vertexWeights.push(faceWeights[(i - 1) * 4 + 3]);
          buffers.vertexWeights.push(faceWeights[i * 4]);
          buffers.vertexWeights.push(faceWeights[i * 4 + 1]);
          buffers.vertexWeights.push(faceWeights[i * 4 + 2]);
          buffers.vertexWeights.push(faceWeights[i * 4 + 3]);
          buffers.weightsIndices.push(faceWeightIndices[0]);
          buffers.weightsIndices.push(faceWeightIndices[1]);
          buffers.weightsIndices.push(faceWeightIndices[2]);
          buffers.weightsIndices.push(faceWeightIndices[3]);
          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4]);
          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 1]);
          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 2]);
          buffers.weightsIndices.push(faceWeightIndices[(i - 1) * 4 + 3]);
          buffers.weightsIndices.push(faceWeightIndices[i * 4]);
          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 1]);
          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 2]);
          buffers.weightsIndices.push(faceWeightIndices[i * 4 + 3]);
        }

        if (geoInfo.color) {
          buffers.colors.push(faceColors[0]);
          buffers.colors.push(faceColors[1]);
          buffers.colors.push(faceColors[2]);
          buffers.colors.push(faceColors[(i - 1) * 3]);
          buffers.colors.push(faceColors[(i - 1) * 3 + 1]);
          buffers.colors.push(faceColors[(i - 1) * 3 + 2]);
          buffers.colors.push(faceColors[i * 3]);
          buffers.colors.push(faceColors[i * 3 + 1]);
          buffers.colors.push(faceColors[i * 3 + 2]);
        }

        if (geoInfo.material && geoInfo.material.mappingType !== 'AllSame') {
          buffers.materialIndex.push(materialIndex);
          buffers.materialIndex.push(materialIndex);
          buffers.materialIndex.push(materialIndex);
        }

        if (geoInfo.normal) {
          buffers.normal.push(faceNormals[0]);
          buffers.normal.push(faceNormals[1]);
          buffers.normal.push(faceNormals[2]);
          buffers.normal.push(faceNormals[(i - 1) * 3]);
          buffers.normal.push(faceNormals[(i - 1) * 3 + 1]);
          buffers.normal.push(faceNormals[(i - 1) * 3 + 2]);
          buffers.normal.push(faceNormals[i * 3]);
          buffers.normal.push(faceNormals[i * 3 + 1]);
          buffers.normal.push(faceNormals[i * 3 + 2]);
        }

        if (geoInfo.uv) {
          geoInfo.uv.forEach(function (uv, j) {
            if (buffers.uvs[j] === undefined) buffers.uvs[j] = [];
            buffers.uvs[j].push(faceUVs[j][0]);
            buffers.uvs[j].push(faceUVs[j][1]);
            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2]);
            buffers.uvs[j].push(faceUVs[j][(i - 1) * 2 + 1]);
            buffers.uvs[j].push(faceUVs[j][i * 2]);
            buffers.uvs[j].push(faceUVs[j][i * 2 + 1]);
          });
        }
      };

      for (var i = 2; i < faceLength; i++) {
        _loop3(i);
      }
    }
  }, {
    key: "addMorphTargets",
    value: function addMorphTargets(parentGeo, parentGeoNode, morphTargets, preTransform) {
      if (morphTargets.length === 0) return;
      parentGeo.morphTargetsRelative = true;
      parentGeo.morphAttributes.position = []; // parentGeo.morphAttributes.normal = []; // not implemented

      var scope = this;
      morphTargets.forEach(function (morphTarget) {
        morphTarget.rawTargets.forEach(function (rawTarget) {
          var morphGeoNode = fbxTree.Objects.Geometry[rawTarget.geoID];

          if (morphGeoNode !== undefined) {
            scope.genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, rawTarget.name);
          }
        });
      });
    } // a morph geometry node is similar to a standard  node, and the node is also contained
    // in FBXTree.Objects.Geometry, however it can only have attributes for position, normal
    // and a special attribute Index defining which vertices of the original geometry are affected
    // Normal and position attributes only have data for the vertices that are affected by the morph

  }, {
    key: "genMorphGeometry",
    value: function genMorphGeometry(parentGeo, parentGeoNode, morphGeoNode, preTransform, name) {
      var vertexIndices = parentGeoNode.PolygonVertexIndex !== undefined ? parentGeoNode.PolygonVertexIndex.a : [];
      var morphPositionsSparse = morphGeoNode.Vertices !== undefined ? morphGeoNode.Vertices.a : [];
      var indices = morphGeoNode.Indexes !== undefined ? morphGeoNode.Indexes.a : [];
      var length = parentGeo.attributes.position.count * 3;
      var morphPositions = new Float32Array(length);

      for (var i = 0; i < indices.length; i++) {
        var morphIndex = indices[i] * 3;
        morphPositions[morphIndex] = morphPositionsSparse[i * 3];
        morphPositions[morphIndex + 1] = morphPositionsSparse[i * 3 + 1];
        morphPositions[morphIndex + 2] = morphPositionsSparse[i * 3 + 2];
      } // TODO: add morph normal support


      var morphGeoInfo = {
        vertexIndices: vertexIndices,
        vertexPositions: morphPositions
      };
      var morphBuffers = this.genBuffers(morphGeoInfo);
      var positionAttribute = new Float32BufferAttribute(morphBuffers.vertex, 3);
      positionAttribute.name = name || morphGeoNode.attrName;
      positionAttribute.applyMatrix4(preTransform);
      parentGeo.morphAttributes.position.push(positionAttribute);
    } // Parse normal from FBXTree.Objects.Geometry.LayerElementNormal if it exists

  }, {
    key: "parseNormals",
    value: function parseNormals(NormalNode) {
      var mappingType = NormalNode.MappingInformationType;
      var referenceType = NormalNode.ReferenceInformationType;
      var buffer = NormalNode.Normals.a;
      var indexBuffer = [];

      if (referenceType === 'IndexToDirect') {
        if ('NormalIndex' in NormalNode) {
          indexBuffer = NormalNode.NormalIndex.a;
        } else if ('NormalsIndex' in NormalNode) {
          indexBuffer = NormalNode.NormalsIndex.a;
        }
      }

      return {
        dataSize: 3,
        buffer: buffer,
        indices: indexBuffer,
        mappingType: mappingType,
        referenceType: referenceType
      };
    } // Parse UVs from FBXTree.Objects.Geometry.LayerElementUV if it exists

  }, {
    key: "parseUVs",
    value: function parseUVs(UVNode) {
      var mappingType = UVNode.MappingInformationType;
      var referenceType = UVNode.ReferenceInformationType;
      var buffer = UVNode.UV.a;
      var indexBuffer = [];

      if (referenceType === 'IndexToDirect') {
        indexBuffer = UVNode.UVIndex.a;
      }

      return {
        dataSize: 2,
        buffer: buffer,
        indices: indexBuffer,
        mappingType: mappingType,
        referenceType: referenceType
      };
    } // Parse Vertex Colors from FBXTree.Objects.Geometry.LayerElementColor if it exists

  }, {
    key: "parseVertexColors",
    value: function parseVertexColors(ColorNode) {
      var mappingType = ColorNode.MappingInformationType;
      var referenceType = ColorNode.ReferenceInformationType;
      var buffer = ColorNode.Colors.a;
      var indexBuffer = [];

      if (referenceType === 'IndexToDirect') {
        indexBuffer = ColorNode.ColorIndex.a;
      }

      return {
        dataSize: 4,
        buffer: buffer,
        indices: indexBuffer,
        mappingType: mappingType,
        referenceType: referenceType
      };
    } // Parse mapping and material data in FBXTree.Objects.Geometry.LayerElementMaterial if it exists

  }, {
    key: "parseMaterialIndices",
    value: function parseMaterialIndices(MaterialNode) {
      var mappingType = MaterialNode.MappingInformationType;
      var referenceType = MaterialNode.ReferenceInformationType;

      if (mappingType === 'NoMappingInformation') {
        return {
          dataSize: 1,
          buffer: [0],
          indices: [0],
          mappingType: 'AllSame',
          referenceType: referenceType
        };
      }

      var materialIndexBuffer = MaterialNode.Materials.a; // Since materials are stored as indices, there's a bit of a mismatch between FBX and what
      // we expect.So we create an intermediate buffer that points to the index in the buffer,
      // for conforming with the other functions we've written for other data.

      var materialIndices = [];

      for (var i = 0; i < materialIndexBuffer.length; ++i) {
        materialIndices.push(i);
      }

      return {
        dataSize: 1,
        buffer: materialIndexBuffer,
        indices: materialIndices,
        mappingType: mappingType,
        referenceType: referenceType
      };
    } // Generate a NurbGeometry from a node in FBXTree.Objects.Geometry

  }, {
    key: "parseNurbsGeometry",
    value: function parseNurbsGeometry(geoNode) {
      if (NURBSCurve === undefined) {
        console.error('THREE.FBXLoader: The loader relies on NURBSCurve for any nurbs present in the model. Nurbs will show up as empty geometry.');
        return new BufferGeometry();
      }

      var order = parseInt(geoNode.Order);

      if (isNaN(order)) {
        console.error('THREE.FBXLoader: Invalid Order %s given for geometry ID: %s', geoNode.Order, geoNode.id);
        return new BufferGeometry();
      }

      var degree = order - 1;
      var knots = geoNode.KnotVector.a;
      var controlPoints = [];
      var pointsValues = geoNode.Points.a;

      for (var i = 0, l = pointsValues.length; i < l; i += 4) {
        controlPoints.push(new Vector4().fromArray(pointsValues, i));
      }

      var startKnot, endKnot;

      if (geoNode.Form === 'Closed') {
        controlPoints.push(controlPoints[0]);
      } else if (geoNode.Form === 'Periodic') {
        startKnot = degree;
        endKnot = knots.length - 1 - startKnot;

        for (var _i = 0; _i < degree; ++_i) {
          controlPoints.push(controlPoints[_i]);
        }
      }

      var curve = new NURBSCurve(degree, knots, controlPoints, startKnot, endKnot);
      var points = curve.getPoints(controlPoints.length * 12);
      return new BufferGeometry().setFromPoints(points);
    }
  }]);

  return GeometryParser;
}(); // parse animation data from FBXTree


var AnimationParser = /*#__PURE__*/function () {
  function AnimationParser() {
    _classCallCheck(this, AnimationParser);
  }

  _createClass(AnimationParser, [{
    key: "parse",
    // take raw animation clips and turn them into three.js animation clips
    value: function parse() {
      var animationClips = [];
      var rawClips = this.parseClips();

      if (rawClips !== undefined) {
        for (var key in rawClips) {
          var rawClip = rawClips[key];
          var clip = this.addClip(rawClip);
          animationClips.push(clip);
        }
      }

      return animationClips;
    }
  }, {
    key: "parseClips",
    value: function parseClips() {
      // since the actual transformation data is stored in FBXTree.Objects.AnimationCurve,
      // if this is undefined we can safely assume there are no animations
      if (fbxTree.Objects.AnimationCurve === undefined) return undefined;
      var curveNodesMap = this.parseAnimationCurveNodes();
      this.parseAnimationCurves(curveNodesMap);
      var layersMap = this.parseAnimationLayers(curveNodesMap);
      var rawClips = this.parseAnimStacks(layersMap);
      return rawClips;
    } // parse nodes in FBXTree.Objects.AnimationCurveNode
    // each AnimationCurveNode holds data for an animation transform for a model (e.g. left arm rotation )
    // and is referenced by an AnimationLayer

  }, {
    key: "parseAnimationCurveNodes",
    value: function parseAnimationCurveNodes() {
      var rawCurveNodes = fbxTree.Objects.AnimationCurveNode;
      var curveNodesMap = new Map();

      for (var nodeID in rawCurveNodes) {
        var rawCurveNode = rawCurveNodes[nodeID];

        if (rawCurveNode.attrName.match(/S|R|T|DeformPercent/) !== null) {
          var curveNode = {
            id: rawCurveNode.id,
            attr: rawCurveNode.attrName,
            curves: {}
          };
          curveNodesMap.set(curveNode.id, curveNode);
        }
      }

      return curveNodesMap;
    } // parse nodes in FBXTree.Objects.AnimationCurve and connect them up to
    // previously parsed AnimationCurveNodes. Each AnimationCurve holds data for a single animated
    // axis ( e.g. times and values of x rotation)

  }, {
    key: "parseAnimationCurves",
    value: function parseAnimationCurves(curveNodesMap) {
      var rawCurves = fbxTree.Objects.AnimationCurve; // TODO: Many values are identical up to roundoff error, but won't be optimised
      // e.g. position times: [0, 0.4, 0. 8]
      // position values: [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.23538335023477e-7, 93.67518615722656, -0.9982695579528809, 7.235384487103147e-7, 93.67520904541016, -0.9982695579528809]
      // clearly, this should be optimised to
      // times: [0], positions [7.23538335023477e-7, 93.67518615722656, -0.9982695579528809]
      // this shows up in nearly every FBX file, and generally time array is length > 100

      for (var nodeID in rawCurves) {
        var animationCurve = {
          id: rawCurves[nodeID].id,
          times: rawCurves[nodeID].KeyTime.a.map(convertFBXTimeToSeconds),
          values: rawCurves[nodeID].KeyValueFloat.a
        };
        var relationships = connections.get(animationCurve.id);

        if (relationships !== undefined) {
          var animationCurveID = relationships.parents[0].ID;
          var animationCurveRelationship = relationships.parents[0].relationship;

          if (animationCurveRelationship.match(/X/)) {
            curveNodesMap.get(animationCurveID).curves['x'] = animationCurve;
          } else if (animationCurveRelationship.match(/Y/)) {
            curveNodesMap.get(animationCurveID).curves['y'] = animationCurve;
          } else if (animationCurveRelationship.match(/Z/)) {
            curveNodesMap.get(animationCurveID).curves['z'] = animationCurve;
          } else if (animationCurveRelationship.match(/d|DeformPercent/) && curveNodesMap.has(animationCurveID)) {
            curveNodesMap.get(animationCurveID).curves['morph'] = animationCurve;
          }
        }
      }
    } // parse nodes in FBXTree.Objects.AnimationLayer. Each layers holds references
    // to various AnimationCurveNodes and is referenced by an AnimationStack node
    // note: theoretically a stack can have multiple layers, however in practice there always seems to be one per stack

  }, {
    key: "parseAnimationLayers",
    value: function parseAnimationLayers(curveNodesMap) {
      var rawLayers = fbxTree.Objects.AnimationLayer;
      var layersMap = new Map();

      var _loop4 = function _loop4(nodeID) {
        var layerCurveNodes = [];
        var connection = connections.get(parseInt(nodeID));

        if (connection !== undefined) {
          // all the animationCurveNodes used in the layer
          var children = connection.children;
          children.forEach(function (child, i) {
            if (curveNodesMap.has(child.ID)) {
              var curveNode = curveNodesMap.get(child.ID); // check that the curves are defined for at least one axis, otherwise ignore the curveNode

              if (curveNode.curves.x !== undefined || curveNode.curves.y !== undefined || curveNode.curves.z !== undefined) {
                if (layerCurveNodes[i] === undefined) {
                  var modelID = connections.get(child.ID).parents.filter(function (parent) {
                    return parent.relationship !== undefined;
                  })[0].ID;

                  if (modelID !== undefined) {
                    var rawModel = fbxTree.Objects.Model[modelID.toString()];

                    if (rawModel === undefined) {
                      console.warn('THREE.FBXLoader: Encountered a unused curve.', child);
                      return;
                    }

                    var node = {
                      modelName: rawModel.attrName ? PropertyBinding.sanitizeNodeName(rawModel.attrName) : '',
                      ID: rawModel.id,
                      initialPosition: [0, 0, 0],
                      initialRotation: [0, 0, 0],
                      initialScale: [1, 1, 1]
                    };
                    sceneGraph.traverse(function (child) {
                      if (child.ID === rawModel.id) {
                        node.transform = child.matrix;
                        if (child.userData.transformData) node.eulerOrder = child.userData.transformData.eulerOrder;
                      }
                    });
                    if (!node.transform) node.transform = new Matrix4(); // if the animated model is pre rotated, we'll have to apply the pre rotations to every
                    // animation value as well

                    if ('PreRotation' in rawModel) node.preRotation = rawModel.PreRotation.value;
                    if ('PostRotation' in rawModel) node.postRotation = rawModel.PostRotation.value;
                    layerCurveNodes[i] = node;
                  }
                }

                if (layerCurveNodes[i]) layerCurveNodes[i][curveNode.attr] = curveNode;
              } else if (curveNode.curves.morph !== undefined) {
                if (layerCurveNodes[i] === undefined) {
                  var deformerID = connections.get(child.ID).parents.filter(function (parent) {
                    return parent.relationship !== undefined;
                  })[0].ID;
                  var morpherID = connections.get(deformerID).parents[0].ID;
                  var geoID = connections.get(morpherID).parents[0].ID; // assuming geometry is not used in more than one model

                  var _modelID = connections.get(geoID).parents[0].ID;
                  var _rawModel = fbxTree.Objects.Model[_modelID];
                  var _node = {
                    modelName: _rawModel.attrName ? PropertyBinding.sanitizeNodeName(_rawModel.attrName) : '',
                    morphName: fbxTree.Objects.Deformer[deformerID].attrName
                  };
                  layerCurveNodes[i] = _node;
                }

                layerCurveNodes[i][curveNode.attr] = curveNode;
              }
            }
          });
          layersMap.set(parseInt(nodeID), layerCurveNodes);
        }
      };

      for (var nodeID in rawLayers) {
        _loop4(nodeID);
      }

      return layersMap;
    } // parse nodes in FBXTree.Objects.AnimationStack. These are the top level node in the animation
    // hierarchy. Each Stack node will be used to create a AnimationClip

  }, {
    key: "parseAnimStacks",
    value: function parseAnimStacks(layersMap) {
      var rawStacks = fbxTree.Objects.AnimationStack; // connect the stacks (clips) up to the layers

      var rawClips = {};

      for (var nodeID in rawStacks) {
        var children = connections.get(parseInt(nodeID)).children;

        if (children.length > 1) {
          // it seems like stacks will always be associated with a single layer. But just in case there are files
          // where there are multiple layers per stack, we'll display a warning
          console.warn('THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.');
        }

        var layer = layersMap.get(children[0].ID);
        rawClips[nodeID] = {
          name: rawStacks[nodeID].attrName,
          layer: layer
        };
      }

      return rawClips;
    }
  }, {
    key: "addClip",
    value: function addClip(rawClip) {
      var tracks = [];
      var scope = this;
      rawClip.layer.forEach(function (rawTracks) {
        tracks = tracks.concat(scope.generateTracks(rawTracks));
      });
      return new AnimationClip(rawClip.name, -1, tracks);
    }
  }, {
    key: "generateTracks",
    value: function generateTracks(rawTracks) {
      var tracks = [];
      var initialPosition = new Vector3$1();
      var initialRotation = new Quaternion();
      var initialScale = new Vector3$1();
      if (rawTracks.transform) rawTracks.transform.decompose(initialPosition, initialRotation, initialScale);
      initialPosition = initialPosition.toArray();
      initialRotation = new Euler().setFromQuaternion(initialRotation, rawTracks.eulerOrder).toArray();
      initialScale = initialScale.toArray();

      if (rawTracks.T !== undefined && Object.keys(rawTracks.T.curves).length > 0) {
        var positionTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.T.curves, initialPosition, 'position');
        if (positionTrack !== undefined) tracks.push(positionTrack);
      }

      if (rawTracks.R !== undefined && Object.keys(rawTracks.R.curves).length > 0) {
        var rotationTrack = this.generateRotationTrack(rawTracks.modelName, rawTracks.R.curves, initialRotation, rawTracks.preRotation, rawTracks.postRotation, rawTracks.eulerOrder);
        if (rotationTrack !== undefined) tracks.push(rotationTrack);
      }

      if (rawTracks.S !== undefined && Object.keys(rawTracks.S.curves).length > 0) {
        var scaleTrack = this.generateVectorTrack(rawTracks.modelName, rawTracks.S.curves, initialScale, 'scale');
        if (scaleTrack !== undefined) tracks.push(scaleTrack);
      }

      if (rawTracks.DeformPercent !== undefined) {
        var morphTrack = this.generateMorphTrack(rawTracks);
        if (morphTrack !== undefined) tracks.push(morphTrack);
      }

      return tracks;
    }
  }, {
    key: "generateVectorTrack",
    value: function generateVectorTrack(modelName, curves, initialValue, type) {
      var times = this.getTimesForAllAxes(curves);
      var values = this.getKeyframeTrackValues(times, curves, initialValue);
      return new VectorKeyframeTrack(modelName + '.' + type, times, values);
    }
  }, {
    key: "generateRotationTrack",
    value: function generateRotationTrack(modelName, curves, initialValue, preRotation, postRotation, eulerOrder) {
      if (curves.x !== undefined) {
        this.interpolateRotations(curves.x);
        curves.x.values = curves.x.values.map(MathUtils.degToRad);
      }

      if (curves.y !== undefined) {
        this.interpolateRotations(curves.y);
        curves.y.values = curves.y.values.map(MathUtils.degToRad);
      }

      if (curves.z !== undefined) {
        this.interpolateRotations(curves.z);
        curves.z.values = curves.z.values.map(MathUtils.degToRad);
      }

      var times = this.getTimesForAllAxes(curves);
      var values = this.getKeyframeTrackValues(times, curves, initialValue);

      if (preRotation !== undefined) {
        preRotation = preRotation.map(MathUtils.degToRad);
        preRotation.push(eulerOrder);
        preRotation = new Euler().fromArray(preRotation);
        preRotation = new Quaternion().setFromEuler(preRotation);
      }

      if (postRotation !== undefined) {
        postRotation = postRotation.map(MathUtils.degToRad);
        postRotation.push(eulerOrder);
        postRotation = new Euler().fromArray(postRotation);
        postRotation = new Quaternion().setFromEuler(postRotation).invert();
      }

      var quaternion = new Quaternion();
      var euler = new Euler();
      var quaternionValues = [];

      for (var i = 0; i < values.length; i += 3) {
        euler.set(values[i], values[i + 1], values[i + 2], eulerOrder);
        quaternion.setFromEuler(euler);
        if (preRotation !== undefined) quaternion.premultiply(preRotation);
        if (postRotation !== undefined) quaternion.multiply(postRotation);
        quaternion.toArray(quaternionValues, i / 3 * 4);
      }

      return new QuaternionKeyframeTrack(modelName + '.quaternion', times, quaternionValues);
    }
  }, {
    key: "generateMorphTrack",
    value: function generateMorphTrack(rawTracks) {
      var curves = rawTracks.DeformPercent.curves.morph;
      var values = curves.values.map(function (val) {
        return val / 100;
      });
      var morphNum = sceneGraph.getObjectByName(rawTracks.modelName).morphTargetDictionary[rawTracks.morphName];
      return new NumberKeyframeTrack(rawTracks.modelName + '.morphTargetInfluences[' + morphNum + ']', curves.times, values);
    } // For all animated objects, times are defined separately for each axis
    // Here we'll combine the times into one sorted array without duplicates

  }, {
    key: "getTimesForAllAxes",
    value: function getTimesForAllAxes(curves) {
      var times = []; // first join together the times for each axis, if defined

      if (curves.x !== undefined) times = times.concat(curves.x.times);
      if (curves.y !== undefined) times = times.concat(curves.y.times);
      if (curves.z !== undefined) times = times.concat(curves.z.times); // then sort them

      times = times.sort(function (a, b) {
        return a - b;
      }); // and remove duplicates

      if (times.length > 1) {
        var targetIndex = 1;
        var lastValue = times[0];

        for (var i = 1; i < times.length; i++) {
          var currentValue = times[i];

          if (currentValue !== lastValue) {
            times[targetIndex] = currentValue;
            lastValue = currentValue;
            targetIndex++;
          }
        }

        times = times.slice(0, targetIndex);
      }

      return times;
    }
  }, {
    key: "getKeyframeTrackValues",
    value: function getKeyframeTrackValues(times, curves, initialValue) {
      var prevValue = initialValue;
      var values = [];
      var xIndex = -1;
      var yIndex = -1;
      var zIndex = -1;
      times.forEach(function (time) {
        if (curves.x) xIndex = curves.x.times.indexOf(time);
        if (curves.y) yIndex = curves.y.times.indexOf(time);
        if (curves.z) zIndex = curves.z.times.indexOf(time); // if there is an x value defined for this frame, use that

        if (xIndex !== -1) {
          var xValue = curves.x.values[xIndex];
          values.push(xValue);
          prevValue[0] = xValue;
        } else {
          // otherwise use the x value from the previous frame
          values.push(prevValue[0]);
        }

        if (yIndex !== -1) {
          var yValue = curves.y.values[yIndex];
          values.push(yValue);
          prevValue[1] = yValue;
        } else {
          values.push(prevValue[1]);
        }

        if (zIndex !== -1) {
          var zValue = curves.z.values[zIndex];
          values.push(zValue);
          prevValue[2] = zValue;
        } else {
          values.push(prevValue[2]);
        }
      });
      return values;
    } // Rotations are defined as Euler angles which can have values  of any size
    // These will be converted to quaternions which don't support values greater than
    // PI, so we'll interpolate large rotations

  }, {
    key: "interpolateRotations",
    value: function interpolateRotations(curve) {
      for (var i = 1; i < curve.values.length; i++) {
        var initialValue = curve.values[i - 1];
        var valuesSpan = curve.values[i] - initialValue;
        var absoluteSpan = Math.abs(valuesSpan);

        if (absoluteSpan >= 180) {
          var numSubIntervals = absoluteSpan / 180;
          var step = valuesSpan / numSubIntervals;
          var nextValue = initialValue + step;
          var initialTime = curve.times[i - 1];
          var timeSpan = curve.times[i] - initialTime;
          var interval = timeSpan / numSubIntervals;
          var nextTime = initialTime + interval;
          var interpolatedTimes = [];
          var interpolatedValues = [];

          while (nextTime < curve.times[i]) {
            interpolatedTimes.push(nextTime);
            nextTime += interval;
            interpolatedValues.push(nextValue);
            nextValue += step;
          }

          curve.times = inject(curve.times, i, interpolatedTimes);
          curve.values = inject(curve.values, i, interpolatedValues);
        }
      }
    }
  }]);

  return AnimationParser;
}(); // parse an FBX file in ASCII format


var TextParser = /*#__PURE__*/function () {
  function TextParser() {
    _classCallCheck(this, TextParser);
  }

  _createClass(TextParser, [{
    key: "getPrevNode",
    value: function getPrevNode() {
      return this.nodeStack[this.currentIndent - 2];
    }
  }, {
    key: "getCurrentNode",
    value: function getCurrentNode() {
      return this.nodeStack[this.currentIndent - 1];
    }
  }, {
    key: "getCurrentProp",
    value: function getCurrentProp() {
      return this.currentProp;
    }
  }, {
    key: "pushStack",
    value: function pushStack(node) {
      this.nodeStack.push(node);
      this.currentIndent += 1;
    }
  }, {
    key: "popStack",
    value: function popStack() {
      this.nodeStack.pop();
      this.currentIndent -= 1;
    }
  }, {
    key: "setCurrentProp",
    value: function setCurrentProp(val, name) {
      this.currentProp = val;
      this.currentPropName = name;
    }
  }, {
    key: "parse",
    value: function parse(text) {
      this.currentIndent = 0;
      this.allNodes = new FBXTree();
      this.nodeStack = [];
      this.currentProp = [];
      this.currentPropName = '';
      var scope = this;
      var split = text.split(/[\r\n]+/);
      split.forEach(function (line, i) {
        var matchComment = line.match(/^[\s\t]*;/);
        var matchEmpty = line.match(/^[\s\t]*$/);
        if (matchComment || matchEmpty) return;
        var matchBeginning = line.match('^\\t{' + scope.currentIndent + '}(\\w+):(.*){', '');
        var matchProperty = line.match('^\\t{' + scope.currentIndent + '}(\\w+):[\\s\\t\\r\\n](.*)');
        var matchEnd = line.match('^\\t{' + (scope.currentIndent - 1) + '}}');

        if (matchBeginning) {
          scope.parseNodeBegin(line, matchBeginning);
        } else if (matchProperty) {
          scope.parseNodeProperty(line, matchProperty, split[++i]);
        } else if (matchEnd) {
          scope.popStack();
        } else if (line.match(/^[^\s\t}]/)) {
          // large arrays are split over multiple lines terminated with a ',' character
          // if this is encountered the line needs to be joined to the previous line
          scope.parseNodePropertyContinued(line);
        }
      });
      return this.allNodes;
    }
  }, {
    key: "parseNodeBegin",
    value: function parseNodeBegin(line, property) {
      var nodeName = property[1].trim().replace(/^"/, '').replace(/"$/, '');
      var nodeAttrs = property[2].split(',').map(function (attr) {
        return attr.trim().replace(/^"/, '').replace(/"$/, '');
      });
      var node = {
        name: nodeName
      };
      var attrs = this.parseNodeAttr(nodeAttrs);
      var currentNode = this.getCurrentNode(); // a top node

      if (this.currentIndent === 0) {
        this.allNodes.add(nodeName, node);
      } else {
        // a subnode
        // if the subnode already exists, append it
        if (nodeName in currentNode) {
          // special case Pose needs PoseNodes as an array
          if (nodeName === 'PoseNode') {
            currentNode.PoseNode.push(node);
          } else if (currentNode[nodeName].id !== undefined) {
            currentNode[nodeName] = {};
            currentNode[nodeName][currentNode[nodeName].id] = currentNode[nodeName];
          }

          if (attrs.id !== '') currentNode[nodeName][attrs.id] = node;
        } else if (typeof attrs.id === 'number') {
          currentNode[nodeName] = {};
          currentNode[nodeName][attrs.id] = node;
        } else if (nodeName !== 'Properties70') {
          if (nodeName === 'PoseNode') currentNode[nodeName] = [node];else currentNode[nodeName] = node;
        }
      }

      if (typeof attrs.id === 'number') node.id = attrs.id;
      if (attrs.name !== '') node.attrName = attrs.name;
      if (attrs.type !== '') node.attrType = attrs.type;
      this.pushStack(node);
    }
  }, {
    key: "parseNodeAttr",
    value: function parseNodeAttr(attrs) {
      var id = attrs[0];

      if (attrs[0] !== '') {
        id = parseInt(attrs[0]);

        if (isNaN(id)) {
          id = attrs[0];
        }
      }

      var name = '',
          type = '';

      if (attrs.length > 1) {
        name = attrs[1].replace(/^(\w+)::/, '');
        type = attrs[2];
      }

      return {
        id: id,
        name: name,
        type: type
      };
    }
  }, {
    key: "parseNodeProperty",
    value: function parseNodeProperty(line, property, contentLine) {
      var propName = property[1].replace(/^"/, '').replace(/"$/, '').trim();
      var propValue = property[2].replace(/^"/, '').replace(/"$/, '').trim(); // for special case: base64 image data follows "Content: ," line
      //    Content: ,
      //     "/9j/4RDaRXhpZgAATU0A..."

      if (propName === 'Content' && propValue === ',') {
        propValue = contentLine.replace(/"/g, '').replace(/,$/, '').trim();
      }

      var currentNode = this.getCurrentNode();
      var parentName = currentNode.name;

      if (parentName === 'Properties70') {
        this.parseNodeSpecialProperty(line, propName, propValue);
        return;
      } // Connections


      if (propName === 'C') {
        var connProps = propValue.split(',').slice(1);
        var from = parseInt(connProps[0]);
        var to = parseInt(connProps[1]);
        var rest = propValue.split(',').slice(3);
        rest = rest.map(function (elem) {
          return elem.trim().replace(/^"/, '');
        });
        propName = 'connections';
        propValue = [from, to];
        append(propValue, rest);

        if (currentNode[propName] === undefined) {
          currentNode[propName] = [];
        }
      } // Node


      if (propName === 'Node') currentNode.id = propValue; // connections

      if (propName in currentNode && Array.isArray(currentNode[propName])) {
        currentNode[propName].push(propValue);
      } else {
        if (propName !== 'a') currentNode[propName] = propValue;else currentNode.a = propValue;
      }

      this.setCurrentProp(currentNode, propName); // convert string to array, unless it ends in ',' in which case more will be added to it

      if (propName === 'a' && propValue.slice(-1) !== ',') {
        currentNode.a = parseNumberArray(propValue);
      }
    }
  }, {
    key: "parseNodePropertyContinued",
    value: function parseNodePropertyContinued(line) {
      var currentNode = this.getCurrentNode();
      currentNode.a += line; // if the line doesn't end in ',' we have reached the end of the property value
      // so convert the string to an array

      if (line.slice(-1) !== ',') {
        currentNode.a = parseNumberArray(currentNode.a);
      }
    } // parse "Property70"

  }, {
    key: "parseNodeSpecialProperty",
    value: function parseNodeSpecialProperty(line, propName, propValue) {
      // split this
      // P: "Lcl Scaling", "Lcl Scaling", "", "A",1,1,1
      // into array like below
      // ["Lcl Scaling", "Lcl Scaling", "", "A", "1,1,1" ]
      var props = propValue.split('",').map(function (prop) {
        return prop.trim().replace(/^\"/, '').replace(/\s/, '_');
      });
      var innerPropName = props[0];
      var innerPropType1 = props[1];
      var innerPropType2 = props[2];
      var innerPropFlag = props[3];
      var innerPropValue = props[4]; // cast values where needed, otherwise leave as strings

      switch (innerPropType1) {
        case 'int':
        case 'enum':
        case 'bool':
        case 'ULongLong':
        case 'double':
        case 'Number':
        case 'FieldOfView':
          innerPropValue = parseFloat(innerPropValue);
          break;

        case 'Color':
        case 'ColorRGB':
        case 'Vector3D':
        case 'Lcl_Translation':
        case 'Lcl_Rotation':
        case 'Lcl_Scaling':
          innerPropValue = parseNumberArray(innerPropValue);
          break;
      } // CAUTION: these props must append to parent's parent


      this.getPrevNode()[innerPropName] = {
        'type': innerPropType1,
        'type2': innerPropType2,
        'flag': innerPropFlag,
        'value': innerPropValue
      };
      this.setCurrentProp(this.getPrevNode(), innerPropName);
    }
  }]);

  return TextParser;
}(); // Parse an FBX file in Binary format


var BinaryParser = /*#__PURE__*/function () {
  function BinaryParser() {
    _classCallCheck(this, BinaryParser);
  }

  _createClass(BinaryParser, [{
    key: "parse",
    value: function parse(buffer) {
      var reader = new BinaryReader(buffer);
      reader.skip(23); // skip magic 23 bytes

      var version = reader.getUint32();

      if (version < 6400) {
        throw new Error('THREE.FBXLoader: FBX version not supported, FileVersion: ' + version);
      }

      var allNodes = new FBXTree();

      while (!this.endOfContent(reader)) {
        var node = this.parseNode(reader, version);
        if (node !== null) allNodes.add(node.name, node);
      }

      return allNodes;
    } // Check if reader has reached the end of content.

  }, {
    key: "endOfContent",
    value: function endOfContent(reader) {
      // footer size: 160bytes + 16-byte alignment padding
      // - 16bytes: magic
      // - padding til 16-byte alignment (at least 1byte?)
      //    (seems like some exporters embed fixed 15 or 16bytes?)
      // - 4bytes: magic
      // - 4bytes: version
      // - 120bytes: zero
      // - 16bytes: magic
      if (reader.size() % 16 === 0) {
        return (reader.getOffset() + 160 + 16 & ~0xf) >= reader.size();
      } else {
        return reader.getOffset() + 160 + 16 >= reader.size();
      }
    } // recursively parse nodes until the end of the file is reached

  }, {
    key: "parseNode",
    value: function parseNode(reader, version) {
      var node = {}; // The first three data sizes depends on version.

      var endOffset = version >= 7500 ? reader.getUint64() : reader.getUint32();
      var numProperties = version >= 7500 ? reader.getUint64() : reader.getUint32();
      version >= 7500 ? reader.getUint64() : reader.getUint32(); // the returned propertyListLen is not used

      var nameLen = reader.getUint8();
      var name = reader.getString(nameLen); // Regards this node as NULL-record if endOffset is zero

      if (endOffset === 0) return null;
      var propertyList = [];

      for (var i = 0; i < numProperties; i++) {
        propertyList.push(this.parseProperty(reader));
      } // Regards the first three elements in propertyList as id, attrName, and attrType


      var id = propertyList.length > 0 ? propertyList[0] : '';
      var attrName = propertyList.length > 1 ? propertyList[1] : '';
      var attrType = propertyList.length > 2 ? propertyList[2] : ''; // check if this node represents just a single property
      // like (name, 0) set or (name2, [0, 1, 2]) set of {name: 0, name2: [0, 1, 2]}

      node.singleProperty = numProperties === 1 && reader.getOffset() === endOffset ? true : false;

      while (endOffset > reader.getOffset()) {
        var subNode = this.parseNode(reader, version);
        if (subNode !== null) this.parseSubNode(name, node, subNode);
      }

      node.propertyList = propertyList; // raw property list used by parent

      if (typeof id === 'number') node.id = id;
      if (attrName !== '') node.attrName = attrName;
      if (attrType !== '') node.attrType = attrType;
      if (name !== '') node.name = name;
      return node;
    }
  }, {
    key: "parseSubNode",
    value: function parseSubNode(name, node, subNode) {
      // special case: child node is single property
      if (subNode.singleProperty === true) {
        var value = subNode.propertyList[0];

        if (Array.isArray(value)) {
          node[subNode.name] = subNode;
          subNode.a = value;
        } else {
          node[subNode.name] = value;
        }
      } else if (name === 'Connections' && subNode.name === 'C') {
        var array = [];
        subNode.propertyList.forEach(function (property, i) {
          // first Connection is FBX type (OO, OP, etc.). We'll discard these
          if (i !== 0) array.push(property);
        });

        if (node.connections === undefined) {
          node.connections = [];
        }

        node.connections.push(array);
      } else if (subNode.name === 'Properties70') {
        var keys = Object.keys(subNode);
        keys.forEach(function (key) {
          node[key] = subNode[key];
        });
      } else if (name === 'Properties70' && subNode.name === 'P') {
        var innerPropName = subNode.propertyList[0];
        var innerPropType1 = subNode.propertyList[1];
        var innerPropType2 = subNode.propertyList[2];
        var innerPropFlag = subNode.propertyList[3];
        var innerPropValue;
        if (innerPropName.indexOf('Lcl ') === 0) innerPropName = innerPropName.replace('Lcl ', 'Lcl_');
        if (innerPropType1.indexOf('Lcl ') === 0) innerPropType1 = innerPropType1.replace('Lcl ', 'Lcl_');

        if (innerPropType1 === 'Color' || innerPropType1 === 'ColorRGB' || innerPropType1 === 'Vector' || innerPropType1 === 'Vector3D' || innerPropType1.indexOf('Lcl_') === 0) {
          innerPropValue = [subNode.propertyList[4], subNode.propertyList[5], subNode.propertyList[6]];
        } else {
          innerPropValue = subNode.propertyList[4];
        } // this will be copied to parent, see above


        node[innerPropName] = {
          'type': innerPropType1,
          'type2': innerPropType2,
          'flag': innerPropFlag,
          'value': innerPropValue
        };
      } else if (node[subNode.name] === undefined) {
        if (typeof subNode.id === 'number') {
          node[subNode.name] = {};
          node[subNode.name][subNode.id] = subNode;
        } else {
          node[subNode.name] = subNode;
        }
      } else {
        if (subNode.name === 'PoseNode') {
          if (!Array.isArray(node[subNode.name])) {
            node[subNode.name] = [node[subNode.name]];
          }

          node[subNode.name].push(subNode);
        } else if (node[subNode.name][subNode.id] === undefined) {
          node[subNode.name][subNode.id] = subNode;
        }
      }
    }
  }, {
    key: "parseProperty",
    value: function parseProperty(reader) {
      var type = reader.getString(1);
      var length;

      switch (type) {
        case 'C':
          return reader.getBoolean();

        case 'D':
          return reader.getFloat64();

        case 'F':
          return reader.getFloat32();

        case 'I':
          return reader.getInt32();

        case 'L':
          return reader.getInt64();

        case 'R':
          length = reader.getUint32();
          return reader.getArrayBuffer(length);

        case 'S':
          length = reader.getUint32();
          return reader.getString(length);

        case 'Y':
          return reader.getInt16();

        case 'b':
        case 'c':
        case 'd':
        case 'f':
        case 'i':
        case 'l':
          var arrayLength = reader.getUint32();
          var encoding = reader.getUint32(); // 0: non-compressed, 1: compressed

          var compressedLength = reader.getUint32();

          if (encoding === 0) {
            switch (type) {
              case 'b':
              case 'c':
                return reader.getBooleanArray(arrayLength);

              case 'd':
                return reader.getFloat64Array(arrayLength);

              case 'f':
                return reader.getFloat32Array(arrayLength);

              case 'i':
                return reader.getInt32Array(arrayLength);

              case 'l':
                return reader.getInt64Array(arrayLength);
            }
          }

          if (typeof fflate === 'undefined') {
            console.error('THREE.FBXLoader: External library fflate.min.js required.');
          }

          var data = unzlibSync(new Uint8Array(reader.getArrayBuffer(compressedLength))); // eslint-disable-line no-undef

          var reader2 = new BinaryReader(data.buffer);

          switch (type) {
            case 'b':
            case 'c':
              return reader2.getBooleanArray(arrayLength);

            case 'd':
              return reader2.getFloat64Array(arrayLength);

            case 'f':
              return reader2.getFloat32Array(arrayLength);

            case 'i':
              return reader2.getInt32Array(arrayLength);

            case 'l':
              return reader2.getInt64Array(arrayLength);
          }

        default:
          throw new Error('THREE.FBXLoader: Unknown property type ' + type);
      }
    }
  }]);

  return BinaryParser;
}();

var BinaryReader = /*#__PURE__*/function () {
  function BinaryReader(buffer, littleEndian) {
    _classCallCheck(this, BinaryReader);

    this.dv = new DataView(buffer);
    this.offset = 0;
    this.littleEndian = littleEndian !== undefined ? littleEndian : true;
  }

  _createClass(BinaryReader, [{
    key: "getOffset",
    value: function getOffset() {
      return this.offset;
    }
  }, {
    key: "size",
    value: function size() {
      return this.dv.buffer.byteLength;
    }
  }, {
    key: "skip",
    value: function skip(length) {
      this.offset += length;
    } // seems like true/false representation depends on exporter.
    // true: 1 or 'Y'(=0x59), false: 0 or 'T'(=0x54)
    // then sees LSB.

  }, {
    key: "getBoolean",
    value: function getBoolean() {
      return (this.getUint8() & 1) === 1;
    }
  }, {
    key: "getBooleanArray",
    value: function getBooleanArray(size) {
      var a = [];

      for (var i = 0; i < size; i++) {
        a.push(this.getBoolean());
      }

      return a;
    }
  }, {
    key: "getUint8",
    value: function getUint8() {
      var value = this.dv.getUint8(this.offset);
      this.offset += 1;
      return value;
    }
  }, {
    key: "getInt16",
    value: function getInt16() {
      var value = this.dv.getInt16(this.offset, this.littleEndian);
      this.offset += 2;
      return value;
    }
  }, {
    key: "getInt32",
    value: function getInt32() {
      var value = this.dv.getInt32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    }
  }, {
    key: "getInt32Array",
    value: function getInt32Array(size) {
      var a = [];

      for (var i = 0; i < size; i++) {
        a.push(this.getInt32());
      }

      return a;
    }
  }, {
    key: "getUint32",
    value: function getUint32() {
      var value = this.dv.getUint32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    } // JavaScript doesn't support 64-bit integer so calculate this here
    // 1 << 32 will return 1 so using multiply operation instead here.
    // There's a possibility that this method returns wrong value if the value
    // is out of the range between Number.MAX_SAFE_INTEGER and Number.MIN_SAFE_INTEGER.
    // TODO: safely handle 64-bit integer

  }, {
    key: "getInt64",
    value: function getInt64() {
      var low, high;

      if (this.littleEndian) {
        low = this.getUint32();
        high = this.getUint32();
      } else {
        high = this.getUint32();
        low = this.getUint32();
      } // calculate negative value


      if (high & 0x80000000) {
        high = ~high & 0xFFFFFFFF;
        low = ~low & 0xFFFFFFFF;
        if (low === 0xFFFFFFFF) high = high + 1 & 0xFFFFFFFF;
        low = low + 1 & 0xFFFFFFFF;
        return -(high * 0x100000000 + low);
      }

      return high * 0x100000000 + low;
    }
  }, {
    key: "getInt64Array",
    value: function getInt64Array(size) {
      var a = [];

      for (var i = 0; i < size; i++) {
        a.push(this.getInt64());
      }

      return a;
    } // Note: see getInt64() comment

  }, {
    key: "getUint64",
    value: function getUint64() {
      var low, high;

      if (this.littleEndian) {
        low = this.getUint32();
        high = this.getUint32();
      } else {
        high = this.getUint32();
        low = this.getUint32();
      }

      return high * 0x100000000 + low;
    }
  }, {
    key: "getFloat32",
    value: function getFloat32() {
      var value = this.dv.getFloat32(this.offset, this.littleEndian);
      this.offset += 4;
      return value;
    }
  }, {
    key: "getFloat32Array",
    value: function getFloat32Array(size) {
      var a = [];

      for (var i = 0; i < size; i++) {
        a.push(this.getFloat32());
      }

      return a;
    }
  }, {
    key: "getFloat64",
    value: function getFloat64() {
      var value = this.dv.getFloat64(this.offset, this.littleEndian);
      this.offset += 8;
      return value;
    }
  }, {
    key: "getFloat64Array",
    value: function getFloat64Array(size) {
      var a = [];

      for (var i = 0; i < size; i++) {
        a.push(this.getFloat64());
      }

      return a;
    }
  }, {
    key: "getArrayBuffer",
    value: function getArrayBuffer(size) {
      var value = this.dv.buffer.slice(this.offset, this.offset + size);
      this.offset += size;
      return value;
    }
  }, {
    key: "getString",
    value: function getString(size) {
      // note: safari 9 doesn't support Uint8Array.indexOf; create intermediate array instead
      var a = [];

      for (var i = 0; i < size; i++) {
        a[i] = this.getUint8();
      }

      var nullByte = a.indexOf(0);
      if (nullByte >= 0) a = a.slice(0, nullByte);
      return LoaderUtils.decodeText(new Uint8Array(a));
    }
  }]);

  return BinaryReader;
}(); // FBXTree holds a representation of the FBX data, returned by the TextParser ( FBX ASCII format)
// and BinaryParser( FBX Binary format)


var FBXTree = /*#__PURE__*/function () {
  function FBXTree() {
    _classCallCheck(this, FBXTree);
  }

  _createClass(FBXTree, [{
    key: "add",
    value: function add(key, val) {
      this[key] = val;
    }
  }]);

  return FBXTree;
}(); // ************** UTILITY FUNCTIONS **************


function isFbxFormatBinary(buffer) {
  var CORRECT = "Kaydara FBX Binary  \0";
  return buffer.byteLength >= CORRECT.length && CORRECT === convertArrayBufferToString(buffer, 0, CORRECT.length);
}

function isFbxFormatASCII(text) {
  var CORRECT = ['K', 'a', 'y', 'd', 'a', 'r', 'a', '\\', 'F', 'B', 'X', '\\', 'B', 'i', 'n', 'a', 'r', 'y', '\\', '\\'];
  var cursor = 0;

  function read(offset) {
    var result = text[offset - 1];
    text = text.slice(cursor + offset);
    cursor++;
    return result;
  }

  for (var i = 0; i < CORRECT.length; ++i) {
    var num = read(1);

    if (num === CORRECT[i]) {
      return false;
    }
  }

  return true;
}

function getFbxVersion(text) {
  var versionRegExp = /FBXVersion: (\d+)/;
  var match = text.match(versionRegExp);

  if (match) {
    var version = parseInt(match[1]);
    return version;
  }

  throw new Error('THREE.FBXLoader: Cannot find the version number for the file given.');
} // Converts FBX ticks into real time seconds.


function convertFBXTimeToSeconds(time) {
  return time / 46186158000;
}

var dataArray = []; // extracts the data from the correct position in the FBX array based on indexing type

function getData(polygonVertexIndex, polygonIndex, vertexIndex, infoObject) {
  var index;

  switch (infoObject.mappingType) {
    case 'ByPolygonVertex':
      index = polygonVertexIndex;
      break;

    case 'ByPolygon':
      index = polygonIndex;
      break;

    case 'ByVertice':
      index = vertexIndex;
      break;

    case 'AllSame':
      index = infoObject.indices[0];
      break;

    default:
      console.warn('THREE.FBXLoader: unknown attribute mapping type ' + infoObject.mappingType);
  }

  if (infoObject.referenceType === 'IndexToDirect') index = infoObject.indices[index];
  var from = index * infoObject.dataSize;
  var to = from + infoObject.dataSize;
  return slice(dataArray, infoObject.buffer, from, to);
}

var tempEuler = new Euler();
var tempVec = new Vector3$1(); // generate transformation from FBX transform data
// ref: https://help.autodesk.com/view/FBX/2017/ENU/?guid=__files_GUID_10CDD63C_79C1_4F2D_BB28_AD2BE65A02ED_htm
// ref: http://docs.autodesk.com/FBX/2014/ENU/FBX-SDK-Documentation/index.html?url=cpp_ref/_transformations_2main_8cxx-example.html,topicNumber=cpp_ref__transformations_2main_8cxx_example_htmlfc10a1e1-b18d-4e72-9dc0-70d0f1959f5e

function generateTransform(transformData) {
  var lTranslationM = new Matrix4();
  var lPreRotationM = new Matrix4();
  var lRotationM = new Matrix4();
  var lPostRotationM = new Matrix4();
  var lScalingM = new Matrix4();
  var lScalingPivotM = new Matrix4();
  var lScalingOffsetM = new Matrix4();
  var lRotationOffsetM = new Matrix4();
  var lRotationPivotM = new Matrix4();
  var lParentGX = new Matrix4();
  var lParentLX = new Matrix4();
  var lGlobalT = new Matrix4();
  var inheritType = transformData.inheritType ? transformData.inheritType : 0;
  if (transformData.translation) lTranslationM.setPosition(tempVec.fromArray(transformData.translation));

  if (transformData.preRotation) {
    var array = transformData.preRotation.map(MathUtils.degToRad);
    array.push(transformData.eulerOrder);
    lPreRotationM.makeRotationFromEuler(tempEuler.fromArray(array));
  }

  if (transformData.rotation) {
    var _array = transformData.rotation.map(MathUtils.degToRad);

    _array.push(transformData.eulerOrder);

    lRotationM.makeRotationFromEuler(tempEuler.fromArray(_array));
  }

  if (transformData.postRotation) {
    var _array2 = transformData.postRotation.map(MathUtils.degToRad);

    _array2.push(transformData.eulerOrder);

    lPostRotationM.makeRotationFromEuler(tempEuler.fromArray(_array2));
    lPostRotationM.invert();
  }

  if (transformData.scale) lScalingM.scale(tempVec.fromArray(transformData.scale)); // Pivots and offsets

  if (transformData.scalingOffset) lScalingOffsetM.setPosition(tempVec.fromArray(transformData.scalingOffset));
  if (transformData.scalingPivot) lScalingPivotM.setPosition(tempVec.fromArray(transformData.scalingPivot));
  if (transformData.rotationOffset) lRotationOffsetM.setPosition(tempVec.fromArray(transformData.rotationOffset));
  if (transformData.rotationPivot) lRotationPivotM.setPosition(tempVec.fromArray(transformData.rotationPivot)); // parent transform

  if (transformData.parentMatrixWorld) {
    lParentLX.copy(transformData.parentMatrix);
    lParentGX.copy(transformData.parentMatrixWorld);
  }

  var lLRM = lPreRotationM.clone().multiply(lRotationM).multiply(lPostRotationM); // Global Rotation

  var lParentGRM = new Matrix4();
  lParentGRM.extractRotation(lParentGX); // Global Shear*Scaling

  var lParentTM = new Matrix4();
  lParentTM.copyPosition(lParentGX);
  var lParentGRSM = lParentTM.clone().invert().multiply(lParentGX);
  var lParentGSM = lParentGRM.clone().invert().multiply(lParentGRSM);
  var lLSM = lScalingM;
  var lGlobalRS = new Matrix4();

  if (inheritType === 0) {
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM).multiply(lLSM);
  } else if (inheritType === 1) {
    lGlobalRS.copy(lParentGRM).multiply(lParentGSM).multiply(lLRM).multiply(lLSM);
  } else {
    var lParentLSM = new Matrix4().scale(new Vector3$1().setFromMatrixScale(lParentLX));
    var lParentLSM_inv = lParentLSM.clone().invert();
    var lParentGSM_noLocal = lParentGSM.clone().multiply(lParentLSM_inv);
    lGlobalRS.copy(lParentGRM).multiply(lLRM).multiply(lParentGSM_noLocal).multiply(lLSM);
  }

  var lRotationPivotM_inv = lRotationPivotM.clone().invert();
  var lScalingPivotM_inv = lScalingPivotM.clone().invert(); // Calculate the local transform matrix

  var lTransform = lTranslationM.clone().multiply(lRotationOffsetM).multiply(lRotationPivotM).multiply(lPreRotationM).multiply(lRotationM).multiply(lPostRotationM).multiply(lRotationPivotM_inv).multiply(lScalingOffsetM).multiply(lScalingPivotM).multiply(lScalingM).multiply(lScalingPivotM_inv);
  var lLocalTWithAllPivotAndOffsetInfo = new Matrix4().copyPosition(lTransform);
  var lGlobalTranslation = lParentGX.clone().multiply(lLocalTWithAllPivotAndOffsetInfo);
  lGlobalT.copyPosition(lGlobalTranslation);
  lTransform = lGlobalT.clone().multiply(lGlobalRS); // from global to local

  lTransform.premultiply(lParentGX.invert());
  return lTransform;
} // Returns the three.js intrinsic Euler order corresponding to FBX extrinsic Euler order
// ref: http://help.autodesk.com/view/FBX/2017/ENU/?guid=__cpp_ref_class_fbx_euler_html


function getEulerOrder(order) {
  order = order || 0;
  var enums = ['ZYX', // -> XYZ extrinsic
  'YZX', // -> XZY extrinsic
  'XZY', // -> YZX extrinsic
  'ZXY', // -> YXZ extrinsic
  'YXZ', // -> ZXY extrinsic
  'XYZ' // -> ZYX extrinsic
  //'SphericXYZ', // not possible to support
  ];

  if (order === 6) {
    console.warn('THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect.');
    return enums[0];
  }

  return enums[order];
} // Parses comma separated list of numbers and returns them an array.
// Used internally by the TextParser


function parseNumberArray(value) {
  var array = value.split(',').map(function (val) {
    return parseFloat(val);
  });
  return array;
}

function convertArrayBufferToString(buffer, from, to) {
  if (from === undefined) from = 0;
  if (to === undefined) to = buffer.byteLength;
  return LoaderUtils.decodeText(new Uint8Array(buffer, from, to));
}

function append(a, b) {
  for (var i = 0, j = a.length, l = b.length; i < l; i++, j++) {
    a[j] = b[i];
  }
}

function slice(a, b, from, to) {
  for (var i = from, j = 0; i < to; i++, j++) {
    a[j] = b[i];
  }

  return a;
} // inject array a2 into array a1 at index


function inject(a1, index, a2) {
  return a1.slice(0, index).concat(a2).concat(a1.slice(index));
}/**
 * @author sunag / http://www.sunag.com.br
 */
var SkeletonUtils = {
  retarget: function () {
    var pos = new Vector3$1(),
        quat = new Quaternion(),
        scale = new Vector3$1(),
        bindBoneMatrix = new Matrix4(),
        relativeMatrix = new Matrix4(),
        globalMatrix = new Matrix4();
    return function (target, source, options) {
      options = options || {};
      options.preserveMatrix = options.preserveMatrix !== undefined ? options.preserveMatrix : true;
      options.preservePosition = options.preservePosition !== undefined ? options.preservePosition : true;
      options.preserveHipPosition = options.preserveHipPosition !== undefined ? options.preserveHipPosition : false;
      options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
      options.hip = options.hip !== undefined ? options.hip : "hip";
      options.names = options.names || {};
      var sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),
          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),
          bindBones,
          bone,
          name,
          boneTo,
          bonesPosition,
          i; // reset bones

      if (target.isObject3D) {
        target.skeleton.pose();
      } else {
        options.useTargetMatrix = true;
        options.preserveMatrix = false;
      }

      if (options.preservePosition) {
        bonesPosition = [];

        for (i = 0; i < bones.length; i++) {
          bonesPosition.push(bones[i].position.clone());
        }
      }

      if (options.preserveMatrix) {
        // reset matrix
        target.updateMatrixWorld();
        target.matrixWorld.identity(); // reset children matrix

        for (i = 0; i < target.children.length; ++i) {
          target.children[i].updateMatrixWorld(true);
        }
      }

      if (options.offsets) {
        bindBones = [];

        for (i = 0; i < bones.length; ++i) {
          bone = bones[i];
          name = options.names[bone.name] || bone.name;

          if (options.offsets && options.offsets[name]) {
            bone.matrix.multiply(options.offsets[name]);
            bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
            bone.updateMatrixWorld();
          }

          bindBones.push(bone.matrixWorld.clone());
        }
      }

      for (i = 0; i < bones.length; ++i) {
        bone = bones[i];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);
        globalMatrix.copy(bone.matrixWorld);

        if (boneTo) {
          boneTo.updateMatrixWorld();

          if (options.useTargetMatrix) {
            relativeMatrix.copy(boneTo.matrixWorld);
          } else {
            relativeMatrix.getInverse(target.matrixWorld);
            relativeMatrix.multiply(boneTo.matrixWorld);
          } // ignore scale to extract rotation


          scale.setFromMatrixScale(relativeMatrix);
          relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z)); // apply to global matrix

          globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));

          if (target.isObject3D) {
            var boneIndex = bones.indexOf(bone),
                wBindMatrix = bindBones ? bindBones[boneIndex] : bindBoneMatrix.getInverse(target.skeleton.boneInverses[boneIndex]);
            globalMatrix.multiply(wBindMatrix);
          }

          globalMatrix.copyPosition(relativeMatrix);
        }

        if (bone.parent && bone.parent.isBone) {
          bone.matrix.getInverse(bone.parent.matrixWorld);
          bone.matrix.multiply(globalMatrix);
        } else {
          bone.matrix.copy(globalMatrix);
        }

        if (options.preserveHipPosition && name === options.hip) {
          bone.matrix.setPosition(pos.set(0, bone.position.y, 0));
        }

        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
        bone.updateMatrixWorld();
      }

      if (options.preservePosition) {
        for (i = 0; i < bones.length; ++i) {
          bone = bones[i];
          name = options.names[bone.name] || bone.name;

          if (name !== options.hip) {
            bone.position.copy(bonesPosition[i]);
          }
        }
      }

      if (options.preserveMatrix) {
        // restore matrix
        target.updateMatrixWorld(true);
      }
    };
  }(),
  retargetClip: function retargetClip(target, source, clip, options) {
    options = options || {};
    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;
    options.fps = options.fps !== undefined ? options.fps : 30;
    options.names = options.names || [];

    if (!source.isObject3D) {
      source = this.getHelperFromSkeleton(source);
    }

    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),
        delta = 1 / options.fps,
        convertedTracks = [],
        mixer = new AnimationMixer(source),
        bones = this.getBones(target.skeleton),
        boneDatas = [],
        positionOffset,
        bone,
        boneTo,
        boneData,
        name,
        i,
        j;
    mixer.clipAction(clip).play();
    mixer.update(0);
    source.updateMatrixWorld();

    for (i = 0; i < numFrames; ++i) {
      var time = i * delta;
      this.retarget(target, source, options);

      for (j = 0; j < bones.length; ++j) {
        name = options.names[bones[j].name] || bones[j].name;
        boneTo = this.getBoneByName(name, source.skeleton);

        if (boneTo) {
          bone = bones[j];
          boneData = boneDatas[j] = boneDatas[j] || {
            bone: bone
          };

          if (options.hip === name) {
            if (!boneData.pos) {
              boneData.pos = {
                times: new Float32Array(numFrames),
                values: new Float32Array(numFrames * 3)
              };
            }

            if (options.useFirstFramePosition) {
              if (i === 0) {
                positionOffset = bone.position.clone();
              }

              bone.position.sub(positionOffset);
            }

            boneData.pos.times[i] = time;
            bone.position.toArray(boneData.pos.values, i * 3);
          }

          if (!boneData.quat) {
            boneData.quat = {
              times: new Float32Array(numFrames),
              values: new Float32Array(numFrames * 4)
            };
          }

          boneData.quat.times[i] = time;
          bone.quaternion.toArray(boneData.quat.values, i * 4);
        }
      }

      mixer.update(delta);
      source.updateMatrixWorld();
    }

    for (i = 0; i < boneDatas.length; ++i) {
      boneData = boneDatas[i];

      if (boneData) {
        if (boneData.pos) {
          convertedTracks.push(new VectorKeyframeTrack(".bones[" + boneData.bone.name + "].position", boneData.pos.times, boneData.pos.values));
        }

        convertedTracks.push(new QuaternionKeyframeTrack(".bones[" + boneData.bone.name + "].quaternion", boneData.quat.times, boneData.quat.values));
      }
    }

    mixer.uncacheAction(clip);
    return new AnimationClip(clip.name, -1, convertedTracks);
  },
  getHelperFromSkeleton: function getHelperFromSkeleton(skeleton) {
    var source = new SkeletonHelper(skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
  },
  getSkeletonOffsets: function () {
    var targetParentPos = new Vector3$1(),
        targetPos = new Vector3$1(),
        sourceParentPos = new Vector3$1(),
        sourcePos = new Vector3$1(),
        targetDir = new Vector2(),
        sourceDir = new Vector2();
    return function (target, source, options) {
      options = options || {};
      options.hip = options.hip !== undefined ? options.hip : "hip";
      options.names = options.names || {};

      if (!source.isObject3D) {
        source = this.getHelperFromSkeleton(source);
      }

      var nameKeys = Object.keys(options.names),
          nameValues = Object.values(options.names),
          sourceBones = source.isObject3D ? source.skeleton.bones : this.getBones(source),
          bones = target.isObject3D ? target.skeleton.bones : this.getBones(target),
          offsets = [],
          bone,
          boneTo,
          name,
          i;
      target.skeleton.pose();

      for (i = 0; i < bones.length; ++i) {
        bone = bones[i];
        name = options.names[bone.name] || bone.name;
        boneTo = this.getBoneByName(name, sourceBones);

        if (boneTo && name !== options.hip) {
          var boneParent = this.getNearestBone(bone.parent, nameKeys),
              boneToParent = this.getNearestBone(boneTo.parent, nameValues);
          boneParent.updateMatrixWorld();
          boneToParent.updateMatrixWorld();
          targetParentPos.setFromMatrixPosition(boneParent.matrixWorld);
          targetPos.setFromMatrixPosition(bone.matrixWorld);
          sourceParentPos.setFromMatrixPosition(boneToParent.matrixWorld);
          sourcePos.setFromMatrixPosition(boneTo.matrixWorld);
          targetDir.subVectors(new Vector2(targetPos.x, targetPos.y), new Vector2(targetParentPos.x, targetParentPos.y)).normalize();
          sourceDir.subVectors(new Vector2(sourcePos.x, sourcePos.y), new Vector2(sourceParentPos.x, sourceParentPos.y)).normalize();
          var laterialAngle = targetDir.angle() - sourceDir.angle();
          var offset = new Matrix4().makeRotationFromEuler(new Euler(0, 0, laterialAngle));
          bone.matrix.multiply(offset);
          bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
          bone.updateMatrixWorld();
          offsets[name] = offset;
        }
      }

      return offsets;
    };
  }(),
  renameBones: function renameBones(skeleton, names) {
    var bones = this.getBones(skeleton);

    for (var i = 0; i < bones.length; ++i) {
      var bone = bones[i];

      if (names[bone.name]) {
        bone.name = names[bone.name];
      }
    }

    return this;
  },
  getBones: function getBones(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
  },
  getBoneByName: function getBoneByName(name, skeleton) {
    for (var i = 0, bones = this.getBones(skeleton); i < bones.length; i++) {
      if (name === bones[i].name) return bones[i];
    }
  },
  getNearestBone: function getNearestBone(bone, names) {
    while (bone.isBone) {
      if (names.indexOf(bone.name) !== -1) {
        return bone;
      }

      bone = bone.parent;
    }
  },
  findBoneTrackData: function findBoneTrackData(name, tracks) {
    var regexp = /\[(.*)\]\.(.*)/,
        result = {
      name: name
    };

    for (var i = 0; i < tracks.length; ++i) {
      // 1 is track name
      // 2 is track type
      var trackData = regexp.exec(tracks[i].name);

      if (trackData && name === trackData[1]) {
        result[trackData[2]] = i;
      }
    }

    return result;
  },
  getEqualsBonesNames: function getEqualsBonesNames(skeleton, targetSkeleton) {
    var sourceBones = this.getBones(skeleton),
        targetBones = this.getBones(targetSkeleton),
        bones = [];

    search: for (var i = 0; i < sourceBones.length; i++) {
      var boneName = sourceBones[i].name;

      for (var j = 0; j < targetBones.length; j++) {
        if (boneName === targetBones[j].name) {
          bones.push(boneName);
          continue search;
        }
      }
    }

    return bones;
  },
  clone: function clone(source) {
    var sourceLookup = new Map();
    var cloneLookup = new Map();
    var clone = source.clone();
    parallelTraverse(source, clone, function (sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone.traverse(function (node) {
      if (!node.isSkinnedMesh) return;
      var clonedMesh = node;
      var sourceMesh = sourceLookup.get(node);
      var sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone;
  }
};

function parallelTraverse(a, b, callback) {
  callback(a, b);

  for (var i = 0; i < a.children.length; i++) {
    parallelTraverse(a.children[i], b.children[i], callback);
  }
}/**
 * Loads a Wavefront .mtl file specifying materials
 */

var MTLLoader = /*#__PURE__*/function (_Loader) {
  _inherits(MTLLoader, _Loader);

  var _super = _createSuper(MTLLoader);

  function MTLLoader(manager) {
    _classCallCheck(this, MTLLoader);

    return _super.call(this, manager);
  }
  /**
   * Loads and parses a MTL asset from a URL.
   *
   * @param {String} url - URL to the MTL file.
   * @param {Function} [onLoad] - Callback invoked with the loaded object.
   * @param {Function} [onProgress] - Callback for download progress.
   * @param {Function} [onError] - Callback for download errors.
   *
   * @see setPath setResourcePath
   *
   * @note In order for relative texture references to resolve correctly
   * you must call setResourcePath() explicitly prior to load.
   */


  _createClass(MTLLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(text, path));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "setMaterialOptions",
    value: function setMaterialOptions(value) {
      this.materialOptions = value;
      return this;
    }
    /**
     * Parses a MTL file.
     *
     * @param {String} text - Content of MTL file
     * @return {MaterialCreator}
     *
     * @see setPath setResourcePath
     *
     * @note In order for relative texture references to resolve correctly
     * you must call setResourcePath() explicitly prior to parse.
     */

  }, {
    key: "parse",
    value: function parse(text, path) {
      var lines = text.split('\n');
      var info = {};
      var delimiter_pattern = /\s+/;
      var materialsInfo = {};

      for (var i = 0; i < lines.length; i++) {
        var line = lines[i];
        line = line.trim();

        if (line.length === 0 || line.charAt(0) === '#') {
          // Blank line or comment ignore
          continue;
        }

        var pos = line.indexOf(' ');
        var key = pos >= 0 ? line.substring(0, pos) : line;
        key = key.toLowerCase();
        var value = pos >= 0 ? line.substring(pos + 1) : '';
        value = value.trim();

        if (key === 'newmtl') {
          // New material
          info = {
            name: value
          };
          materialsInfo[value] = info;
        } else {
          if (key === 'ka' || key === 'kd' || key === 'ks' || key === 'ke') {
            var ss = value.split(delimiter_pattern, 3);
            info[key] = [parseFloat(ss[0]), parseFloat(ss[1]), parseFloat(ss[2])];
          } else {
            info[key] = value;
          }
        }
      }

      var materialCreator = new MaterialCreator(this.resourcePath || path, this.materialOptions);
      materialCreator.setCrossOrigin(this.crossOrigin);
      materialCreator.setManager(this.manager);
      materialCreator.setMaterials(materialsInfo);
      return materialCreator;
    }
  }]);

  return MTLLoader;
}(Loader$1);
/**
 * Create a new MTLLoader.MaterialCreator
 * @param baseUrl - Url relative to which textures are loaded
 * @param options - Set of options on how to construct the materials
 *                  side: Which side to apply the material
 *                        FrontSide (default), THREE.BackSide, THREE.DoubleSide
 *                  wrap: What type of wrapping to apply for textures
 *                        RepeatWrapping (default), THREE.ClampToEdgeWrapping, THREE.MirroredRepeatWrapping
 *                  normalizeRGB: RGBs need to be normalized to 0-1 from 0-255
 *                                Default: false, assumed to be already normalized
 *                  ignoreZeroRGBs: Ignore values of RGBs (Ka,Kd,Ks) that are all 0's
 *                                  Default: false
 * @constructor
 */


var MaterialCreator = /*#__PURE__*/function () {
  function MaterialCreator() {
    var baseUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MaterialCreator);

    this.baseUrl = baseUrl;
    this.options = options;
    this.materialsInfo = {};
    this.materials = {};
    this.materialsArray = [];
    this.nameLookup = {};
    this.crossOrigin = 'anonymous';
    this.side = this.options.side !== undefined ? this.options.side : FrontSide;
    this.wrap = this.options.wrap !== undefined ? this.options.wrap : RepeatWrapping$1;
  }

  _createClass(MaterialCreator, [{
    key: "setCrossOrigin",
    value: function setCrossOrigin(value) {
      this.crossOrigin = value;
      return this;
    }
  }, {
    key: "setManager",
    value: function setManager(value) {
      this.manager = value;
    }
  }, {
    key: "setMaterials",
    value: function setMaterials(materialsInfo) {
      this.materialsInfo = this.convert(materialsInfo);
      this.materials = {};
      this.materialsArray = [];
      this.nameLookup = {};
    }
  }, {
    key: "convert",
    value: function convert(materialsInfo) {
      if (!this.options) return materialsInfo;
      var converted = {};

      for (var mn in materialsInfo) {
        // Convert materials info into normalized form based on options
        var mat = materialsInfo[mn];
        var covmat = {};
        converted[mn] = covmat;

        for (var prop in mat) {
          var save = true;
          var value = mat[prop];
          var lprop = prop.toLowerCase();

          switch (lprop) {
            case 'kd':
            case 'ka':
            case 'ks':
              // Diffuse color (color under white light) using RGB values
              if (this.options && this.options.normalizeRGB) {
                value = [value[0] / 255, value[1] / 255, value[2] / 255];
              }

              if (this.options && this.options.ignoreZeroRGBs) {
                if (value[0] === 0 && value[1] === 0 && value[2] === 0) {
                  // ignore
                  save = false;
                }
              }

              break;
          }

          if (save) {
            covmat[lprop] = value;
          }
        }
      }

      return converted;
    }
  }, {
    key: "preload",
    value: function preload() {
      for (var mn in this.materialsInfo) {
        this.create(mn);
      }
    }
  }, {
    key: "getIndex",
    value: function getIndex(materialName) {
      return this.nameLookup[materialName];
    }
  }, {
    key: "getAsArray",
    value: function getAsArray() {
      var index = 0;

      for (var mn in this.materialsInfo) {
        this.materialsArray[index] = this.create(mn);
        this.nameLookup[mn] = index;
        index++;
      }

      return this.materialsArray;
    }
  }, {
    key: "create",
    value: function create(materialName) {
      if (this.materials[materialName] === undefined) {
        this.createMaterial_(materialName);
      }

      return this.materials[materialName];
    }
  }, {
    key: "createMaterial_",
    value: function createMaterial_(materialName) {
      // Create material
      var scope = this;
      var mat = this.materialsInfo[materialName];
      var params = {
        name: materialName,
        side: this.side
      };

      function resolveURL(baseUrl, url) {
        if (typeof url !== 'string' || url === '') return ''; // Absolute URL

        if (/^https?:\/\//i.test(url)) return url;
        return baseUrl + url;
      }

      function setMapForType(mapType, value) {
        if (params[mapType]) return; // Keep the first encountered texture

        var texParams = scope.getTextureParams(value, params);
        var map = scope.loadTexture(resolveURL(scope.baseUrl, texParams.url));
        map.repeat.copy(texParams.scale);
        map.offset.copy(texParams.offset);
        map.wrapS = scope.wrap;
        map.wrapT = scope.wrap;
        params[mapType] = map;
      }

      for (var prop in mat) {
        var value = mat[prop];
        var n = void 0;
        if (value === '') continue;

        switch (prop.toLowerCase()) {
          // Ns is material specular exponent
          case 'kd':
            // Diffuse color (color under white light) using RGB values
            params.color = new Color$1().fromArray(value);
            break;

          case 'ks':
            // Specular color (color when light is reflected from shiny surface) using RGB values
            params.specular = new Color$1().fromArray(value);
            break;

          case 'ke':
            // Emissive using RGB values
            params.emissive = new Color$1().fromArray(value);
            break;

          case 'map_kd':
            // Diffuse texture map
            setMapForType('map', value);
            break;

          case 'map_ks':
            // Specular map
            setMapForType('specularMap', value);
            break;

          case 'map_ke':
            // Emissive map
            setMapForType('emissiveMap', value);
            break;

          case 'norm':
            setMapForType('normalMap', value);
            break;

          case 'map_bump':
          case 'bump':
            // Bump texture map
            setMapForType('bumpMap', value);
            break;

          case 'map_d':
            // Alpha map
            setMapForType('alphaMap', value);
            params.transparent = true;
            break;

          case 'ns':
            // The specular exponent (defines the focus of the specular highlight)
            // A high exponent results in a tight, concentrated highlight. Ns values normally range from 0 to 1000.
            params.shininess = parseFloat(value);
            break;

          case 'd':
            n = parseFloat(value);

            if (n < 1) {
              params.opacity = n;
              params.transparent = true;
            }

            break;

          case 'tr':
            n = parseFloat(value);
            if (this.options && this.options.invertTrProperty) n = 1 - n;

            if (n > 0) {
              params.opacity = 1 - n;
              params.transparent = true;
            }

            break;
        }
      }

      this.materials[materialName] = new MeshPhongMaterial(params);
      return this.materials[materialName];
    }
  }, {
    key: "getTextureParams",
    value: function getTextureParams(value, matParams) {
      var texParams = {
        scale: new Vector2(1, 1),
        offset: new Vector2(0, 0)
      };
      var items = value.split(/\s+/);
      var pos;
      pos = items.indexOf('-bm');

      if (pos >= 0) {
        matParams.bumpScale = parseFloat(items[pos + 1]);
        items.splice(pos, 2);
      }

      pos = items.indexOf('-s');

      if (pos >= 0) {
        texParams.scale.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
        items.splice(pos, 4); // we expect 3 parameters here!
      }

      pos = items.indexOf('-o');

      if (pos >= 0) {
        texParams.offset.set(parseFloat(items[pos + 1]), parseFloat(items[pos + 2]));
        items.splice(pos, 4); // we expect 3 parameters here!
      }

      texParams.url = items.join(' ').trim();
      return texParams;
    }
  }, {
    key: "loadTexture",
    value: function loadTexture(url, mapping, onLoad, onProgress, onError) {
      var manager = this.manager !== undefined ? this.manager : DefaultLoadingManager;
      var loader = manager.getHandler(url);

      if (loader === null) {
        loader = new TextureLoader(manager);
      }

      if (loader.setCrossOrigin) loader.setCrossOrigin(this.crossOrigin);
      var texture = loader.load(url, onLoad, onProgress, onError);
      if (mapping !== undefined) texture.mapping = mapping;
      return texture;
    }
  }]);

  return MaterialCreator;
}();var _object_pattern = /^[og]\s*(.+)?/; // mtllib file_reference

var _material_library_pattern = /^mtllib /; // usemtl material_name

var _material_use_pattern = /^usemtl /; // usemap map_name

var _map_use_pattern = /^usemap /;

var _vA = new Vector3$1();

var _vB = new Vector3$1();

var _vC = new Vector3$1();

var _ab = new Vector3$1();

var _cb = new Vector3$1();

function ParserState() {
  var state = {
    objects: [],
    object: {},
    vertices: [],
    normals: [],
    colors: [],
    uvs: [],
    materials: {},
    materialLibraries: [],
    startObject: function startObject(name, fromDeclaration) {
      // If the current object (initial from reset) is not from a g/o declaration in the parsed
      // file. We need to use it for the first parsed g/o to keep things in sync.
      if (this.object && this.object.fromDeclaration === false) {
        this.object.name = name;
        this.object.fromDeclaration = fromDeclaration !== false;
        return;
      }

      var previousMaterial = this.object && typeof this.object.currentMaterial === 'function' ? this.object.currentMaterial() : undefined;

      if (this.object && typeof this.object._finalize === 'function') {
        this.object._finalize(true);
      }

      this.object = {
        name: name || '',
        fromDeclaration: fromDeclaration !== false,
        geometry: {
          vertices: [],
          normals: [],
          colors: [],
          uvs: [],
          hasUVIndices: false
        },
        materials: [],
        smooth: true,
        startMaterial: function startMaterial(name, libraries) {
          var previous = this._finalize(false); // New usemtl declaration overwrites an inherited material, except if faces were declared
          // after the material, then it must be preserved for proper MultiMaterial continuation.


          if (previous && (previous.inherited || previous.groupCount <= 0)) {
            this.materials.splice(previous.index, 1);
          }

          var material = {
            index: this.materials.length,
            name: name || '',
            mtllib: Array.isArray(libraries) && libraries.length > 0 ? libraries[libraries.length - 1] : '',
            smooth: previous !== undefined ? previous.smooth : this.smooth,
            groupStart: previous !== undefined ? previous.groupEnd : 0,
            groupEnd: -1,
            groupCount: -1,
            inherited: false,
            clone: function clone(index) {
              var cloned = {
                index: typeof index === 'number' ? index : this.index,
                name: this.name,
                mtllib: this.mtllib,
                smooth: this.smooth,
                groupStart: 0,
                groupEnd: -1,
                groupCount: -1,
                inherited: false
              };
              cloned.clone = this.clone.bind(cloned);
              return cloned;
            }
          };
          this.materials.push(material);
          return material;
        },
        currentMaterial: function currentMaterial() {
          if (this.materials.length > 0) {
            return this.materials[this.materials.length - 1];
          }

          return undefined;
        },
        _finalize: function _finalize(end) {
          var lastMultiMaterial = this.currentMaterial();

          if (lastMultiMaterial && lastMultiMaterial.groupEnd === -1) {
            lastMultiMaterial.groupEnd = this.geometry.vertices.length / 3;
            lastMultiMaterial.groupCount = lastMultiMaterial.groupEnd - lastMultiMaterial.groupStart;
            lastMultiMaterial.inherited = false;
          } // Ignore objects tail materials if no face declarations followed them before a new o/g started.


          if (end && this.materials.length > 1) {
            for (var mi = this.materials.length - 1; mi >= 0; mi--) {
              if (this.materials[mi].groupCount <= 0) {
                this.materials.splice(mi, 1);
              }
            }
          } // Guarantee at least one empty material, this makes the creation later more straight forward.


          if (end && this.materials.length === 0) {
            this.materials.push({
              name: '',
              smooth: this.smooth
            });
          }

          return lastMultiMaterial;
        }
      }; // Inherit previous objects material.
      // Spec tells us that a declared material must be set to all objects until a new material is declared.
      // If a usemtl declaration is encountered while this new object is being parsed, it will
      // overwrite the inherited material. Exception being that there was already face declarations
      // to the inherited material, then it will be preserved for proper MultiMaterial continuation.

      if (previousMaterial && previousMaterial.name && typeof previousMaterial.clone === 'function') {
        var declared = previousMaterial.clone(0);
        declared.inherited = true;
        this.object.materials.push(declared);
      }

      this.objects.push(this.object);
    },
    finalize: function finalize() {
      if (this.object && typeof this.object._finalize === 'function') {
        this.object._finalize(true);
      }
    },
    parseVertexIndex: function parseVertexIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseNormalIndex: function parseNormalIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 3) * 3;
    },
    parseUVIndex: function parseUVIndex(value, len) {
      var index = parseInt(value, 10);
      return (index >= 0 ? index - 1 : index + len / 2) * 2;
    },
    addVertex: function addVertex(a, b, c) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addVertexPoint: function addVertexPoint(a) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addVertexLine: function addVertexLine(a) {
      var src = this.vertices;
      var dst = this.object.geometry.vertices;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
    },
    addNormal: function addNormal(a, b, c) {
      var src = this.normals;
      var dst = this.object.geometry.normals;
      dst.push(src[a + 0], src[a + 1], src[a + 2]);
      dst.push(src[b + 0], src[b + 1], src[b + 2]);
      dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addFaceNormal: function addFaceNormal(a, b, c) {
      var src = this.vertices;
      var dst = this.object.geometry.normals;

      _vA.fromArray(src, a);

      _vB.fromArray(src, b);

      _vC.fromArray(src, c);

      _cb.subVectors(_vC, _vB);

      _ab.subVectors(_vA, _vB);

      _cb.cross(_ab);

      _cb.normalize();

      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
      dst.push(_cb.x, _cb.y, _cb.z);
    },
    addColor: function addColor(a, b, c) {
      var src = this.colors;
      var dst = this.object.geometry.colors;
      if (src[a] !== undefined) dst.push(src[a + 0], src[a + 1], src[a + 2]);
      if (src[b] !== undefined) dst.push(src[b + 0], src[b + 1], src[b + 2]);
      if (src[c] !== undefined) dst.push(src[c + 0], src[c + 1], src[c + 2]);
    },
    addUV: function addUV(a, b, c) {
      var src = this.uvs;
      var dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
      dst.push(src[b + 0], src[b + 1]);
      dst.push(src[c + 0], src[c + 1]);
    },
    addDefaultUV: function addDefaultUV() {
      var dst = this.object.geometry.uvs;
      dst.push(0, 0);
      dst.push(0, 0);
      dst.push(0, 0);
    },
    addUVLine: function addUVLine(a) {
      var src = this.uvs;
      var dst = this.object.geometry.uvs;
      dst.push(src[a + 0], src[a + 1]);
    },
    addFace: function addFace(a, b, c, ua, ub, uc, na, nb, nc) {
      var vLen = this.vertices.length;
      var ia = this.parseVertexIndex(a, vLen);
      var ib = this.parseVertexIndex(b, vLen);
      var ic = this.parseVertexIndex(c, vLen);
      this.addVertex(ia, ib, ic);
      this.addColor(ia, ib, ic); // normals

      if (na !== undefined && na !== '') {
        var nLen = this.normals.length;
        ia = this.parseNormalIndex(na, nLen);
        ib = this.parseNormalIndex(nb, nLen);
        ic = this.parseNormalIndex(nc, nLen);
        this.addNormal(ia, ib, ic);
      } else {
        this.addFaceNormal(ia, ib, ic);
      } // uvs


      if (ua !== undefined && ua !== '') {
        var uvLen = this.uvs.length;
        ia = this.parseUVIndex(ua, uvLen);
        ib = this.parseUVIndex(ub, uvLen);
        ic = this.parseUVIndex(uc, uvLen);
        this.addUV(ia, ib, ic);
        this.object.geometry.hasUVIndices = true;
      } else {
        // add placeholder values (for inconsistent face definitions)
        this.addDefaultUV();
      }
    },
    addPointGeometry: function addPointGeometry(vertices) {
      this.object.geometry.type = 'Points';
      var vLen = this.vertices.length;

      for (var vi = 0, l = vertices.length; vi < l; vi++) {
        var index = this.parseVertexIndex(vertices[vi], vLen);
        this.addVertexPoint(index);
        this.addColor(index);
      }
    },
    addLineGeometry: function addLineGeometry(vertices, uvs) {
      this.object.geometry.type = 'Line';
      var vLen = this.vertices.length;
      var uvLen = this.uvs.length;

      for (var vi = 0, l = vertices.length; vi < l; vi++) {
        this.addVertexLine(this.parseVertexIndex(vertices[vi], vLen));
      }

      for (var uvi = 0, _l = uvs.length; uvi < _l; uvi++) {
        this.addUVLine(this.parseUVIndex(uvs[uvi], uvLen));
      }
    }
  };
  state.startObject('', false);
  return state;
} //


var OBJLoader = /*#__PURE__*/function (_Loader) {
  _inherits(OBJLoader, _Loader);

  var _super = _createSuper(OBJLoader);

  function OBJLoader(manager) {
    var _this;

    _classCallCheck(this, OBJLoader);

    _this = _super.call(this, manager);
    _this.materials = null;
    return _this;
  }

  _createClass(OBJLoader, [{
    key: "load",
    value: function load(url, onLoad, onProgress, onError) {
      var scope = this;
      var loader = new FileLoader(this.manager);
      loader.setPath(this.path);
      loader.setRequestHeader(this.requestHeader);
      loader.setWithCredentials(this.withCredentials);
      loader.load(url, function (text) {
        try {
          onLoad(scope.parse(text));
        } catch (e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }

          scope.manager.itemError(url);
        }
      }, onProgress, onError);
    }
  }, {
    key: "setMaterials",
    value: function setMaterials(materials) {
      this.materials = materials;
      return this;
    }
  }, {
    key: "parse",
    value: function parse(text) {
      var state = new ParserState();

      if (text.indexOf('\r\n') !== -1) {
        // This is faster than String.split with regex that splits on both
        text = text.replace(/\r\n/g, '\n');
      }

      if (text.indexOf('\\\n') !== -1) {
        // join lines separated by a line continuation character (\)
        text = text.replace(/\\\n/g, '');
      }

      var lines = text.split('\n');
      var line = '',
          lineFirstChar = '';
      var lineLength = 0;
      var result = []; // Faster to just trim left side of the line. Use if available.

      var trimLeft = typeof ''.trimLeft === 'function';

      for (var i = 0, l = lines.length; i < l; i++) {
        line = lines[i];
        line = trimLeft ? line.trimLeft() : line.trim();
        lineLength = line.length;
        if (lineLength === 0) continue;
        lineFirstChar = line.charAt(0); // @todo invoke passed in handler if any

        if (lineFirstChar === '#') continue;

        if (lineFirstChar === 'v') {
          var data = line.split(/\s+/);

          switch (data[0]) {
            case 'v':
              state.vertices.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));

              if (data.length >= 7) {
                state.colors.push(parseFloat(data[4]), parseFloat(data[5]), parseFloat(data[6]));
              } else {
                // if no colors are defined, add placeholders so color and vertex indices match
                state.colors.push(undefined, undefined, undefined);
              }

              break;

            case 'vn':
              state.normals.push(parseFloat(data[1]), parseFloat(data[2]), parseFloat(data[3]));
              break;

            case 'vt':
              state.uvs.push(parseFloat(data[1]), parseFloat(data[2]));
              break;
          }
        } else if (lineFirstChar === 'f') {
          var lineData = line.substr(1).trim();
          var vertexData = lineData.split(/\s+/);
          var faceVertices = []; // Parse the face vertex data into an easy to work with format

          for (var j = 0, jl = vertexData.length; j < jl; j++) {
            var vertex = vertexData[j];

            if (vertex.length > 0) {
              var vertexParts = vertex.split('/');
              faceVertices.push(vertexParts);
            }
          } // Draw an edge between the first vertex and all subsequent vertices to form an n-gon


          var v1 = faceVertices[0];

          for (var _j = 1, _jl = faceVertices.length - 1; _j < _jl; _j++) {
            var v2 = faceVertices[_j];
            var v3 = faceVertices[_j + 1];
            state.addFace(v1[0], v2[0], v3[0], v1[1], v2[1], v3[1], v1[2], v2[2], v3[2]);
          }
        } else if (lineFirstChar === 'l') {
          var lineParts = line.substring(1).trim().split(' ');
          var lineVertices = [];
          var lineUVs = [];

          if (line.indexOf('/') === -1) {
            lineVertices = lineParts;
          } else {
            for (var li = 0, llen = lineParts.length; li < llen; li++) {
              var parts = lineParts[li].split('/');
              if (parts[0] !== '') lineVertices.push(parts[0]);
              if (parts[1] !== '') lineUVs.push(parts[1]);
            }
          }

          state.addLineGeometry(lineVertices, lineUVs);
        } else if (lineFirstChar === 'p') {
          var _lineData = line.substr(1).trim();

          var pointData = _lineData.split(' ');

          state.addPointGeometry(pointData);
        } else if ((result = _object_pattern.exec(line)) !== null) {
          // o object_name
          // or
          // g group_name
          // WORKAROUND: https://bugs.chromium.org/p/v8/issues/detail?id=2869
          // let name = result[ 0 ].substr( 1 ).trim();
          var name = (' ' + result[0].substr(1).trim()).substr(1);
          state.startObject(name);
        } else if (_material_use_pattern.test(line)) {
          // material
          state.object.startMaterial(line.substring(7).trim(), state.materialLibraries);
        } else if (_material_library_pattern.test(line)) {
          // mtl file
          state.materialLibraries.push(line.substring(7).trim());
        } else if (_map_use_pattern.test(line)) {
          // the line is parsed but ignored since the loader assumes textures are defined MTL files
          // (according to https://www.okino.com/conv/imp_wave.htm, 'usemap' is the old-style Wavefront texture reference method)
          console.warn('THREE.OBJLoader: Rendering identifier "usemap" not supported. Textures must be defined in MTL files.');
        } else if (lineFirstChar === 's') {
          result = line.split(' '); // smooth shading
          // @todo Handle files that have varying smooth values for a set of faces inside one geometry,
          // but does not define a usemtl for each face set.
          // This should be detected and a dummy material created (later MultiMaterial and geometry groups).
          // This requires some care to not create extra material on each smooth value for "normal" obj files.
          // where explicit usemtl defines geometry groups.
          // Example asset: examples/models/obj/cerberus/Cerberus.obj

          /*
          	 * http://paulbourke.net/dataformats/obj/
          	 *
          	 * From chapter "Grouping" Syntax explanation "s group_number":
          	 * "group_number is the smoothing group number. To turn off smoothing groups, use a value of 0 or off.
          	 * Polygonal elements use group numbers to put elements in different smoothing groups. For free-form
          	 * surfaces, smoothing groups are either turned on or off; there is no difference between values greater
          	 * than 0."
          	 */

          if (result.length > 1) {
            var value = result[1].trim().toLowerCase();
            state.object.smooth = value !== '0' && value !== 'off';
          } else {
            // ZBrush can produce "s" lines #11707
            state.object.smooth = true;
          }

          var material = state.object.currentMaterial();
          if (material) material.smooth = state.object.smooth;
        } else {
          // Handle null terminated files without exception
          if (line === '\0') continue;
          console.warn('THREE.OBJLoader: Unexpected line: "' + line + '"');
        }
      }

      state.finalize();
      var container = new Group();
      container.materialLibraries = [].concat(state.materialLibraries);
      var hasPrimitives = !(state.objects.length === 1 && state.objects[0].geometry.vertices.length === 0);

      if (hasPrimitives === true) {
        for (var _i = 0, _l2 = state.objects.length; _i < _l2; _i++) {
          var object = state.objects[_i];
          var geometry = object.geometry;
          var materials = object.materials;
          var isLine = geometry.type === 'Line';
          var isPoints = geometry.type === 'Points';
          var hasVertexColors = false; // Skip o/g line declarations that did not follow with any faces

          if (geometry.vertices.length === 0) continue;
          var buffergeometry = new BufferGeometry();
          buffergeometry.setAttribute('position', new Float32BufferAttribute(geometry.vertices, 3));

          if (geometry.normals.length > 0) {
            buffergeometry.setAttribute('normal', new Float32BufferAttribute(geometry.normals, 3));
          }

          if (geometry.colors.length > 0) {
            hasVertexColors = true;
            buffergeometry.setAttribute('color', new Float32BufferAttribute(geometry.colors, 3));
          }

          if (geometry.hasUVIndices === true) {
            buffergeometry.setAttribute('uv', new Float32BufferAttribute(geometry.uvs, 2));
          } // Create materials


          var createdMaterials = [];

          for (var mi = 0, miLen = materials.length; mi < miLen; mi++) {
            var sourceMaterial = materials[mi];
            var materialHash = sourceMaterial.name + '_' + sourceMaterial.smooth + '_' + hasVertexColors;
            var _material = state.materials[materialHash];

            if (this.materials !== null) {
              _material = this.materials.create(sourceMaterial.name); // mtl etc. loaders probably can't create line materials correctly, copy properties to a line material.

              if (isLine && _material && !(_material instanceof LineBasicMaterial)) {
                var materialLine = new LineBasicMaterial();
                Material.prototype.copy.call(materialLine, _material);
                materialLine.color.copy(_material.color);
                _material = materialLine;
              } else if (isPoints && _material && !(_material instanceof PointsMaterial)) {
                var materialPoints = new PointsMaterial({
                  size: 10,
                  sizeAttenuation: false
                });
                Material.prototype.copy.call(materialPoints, _material);
                materialPoints.color.copy(_material.color);
                materialPoints.map = _material.map;
                _material = materialPoints;
              }
            }

            if (_material === undefined) {
              if (isLine) {
                _material = new LineBasicMaterial();
              } else if (isPoints) {
                _material = new PointsMaterial({
                  size: 1,
                  sizeAttenuation: false
                });
              } else {
                _material = new MeshPhongMaterial();
              }

              _material.name = sourceMaterial.name;
              _material.flatShading = sourceMaterial.smooth ? false : true;
              _material.vertexColors = hasVertexColors;
              state.materials[materialHash] = _material;
            }

            createdMaterials.push(_material);
          } // Create mesh


          var mesh = void 0;

          if (createdMaterials.length > 1) {
            for (var _mi = 0, _miLen = materials.length; _mi < _miLen; _mi++) {
              var _sourceMaterial = materials[_mi];
              buffergeometry.addGroup(_sourceMaterial.groupStart, _sourceMaterial.groupCount, _mi);
            }

            if (isLine) {
              mesh = new LineSegments(buffergeometry, createdMaterials);
            } else if (isPoints) {
              mesh = new Points(buffergeometry, createdMaterials);
            } else {
              mesh = new Mesh(buffergeometry, createdMaterials);
            }
          } else {
            if (isLine) {
              mesh = new LineSegments(buffergeometry, createdMaterials[0]);
            } else if (isPoints) {
              mesh = new Points(buffergeometry, createdMaterials[0]);
            } else {
              mesh = new Mesh(buffergeometry, createdMaterials[0]);
            }
          }

          mesh.name = object.name;
          container.add(mesh);
        }
      } else {
        // if there is only the default parser state object with no geometry data, interpret data as point cloud
        if (state.vertices.length > 0) {
          var _material2 = new PointsMaterial({
            size: 1,
            sizeAttenuation: false
          });

          var _buffergeometry = new BufferGeometry();

          _buffergeometry.setAttribute('position', new Float32BufferAttribute(state.vertices, 3));

          if (state.colors.length > 0 && state.colors[0] !== undefined) {
            _buffergeometry.setAttribute('color', new Float32BufferAttribute(state.colors, 3));

            _material2.vertexColors = true;
          }

          var points = new Points(_buffergeometry, _material2);
          container.add(points);
        }
      }

      return container;
    }
  }]);

  return OBJLoader;
}(Loader$1);var EXTENSIONS$1 = {
  OBJ: '.obj',
  MTL: '.mtl'
};

var OBJMTLLoader = /*#__PURE__*/function () {
  function OBJMTLLoader() {
    _classCallCheck(this, OBJMTLLoader);

    this.mtlLoader = new MTLLoader();
    this.objLoader = new OBJLoader();
  }

  _createClass(OBJMTLLoader, [{
    key: "tryLoadingMTL",
    value: function tryLoadingMTL(path) {
      var _this = this;

      var mtlPath = path.replace(EXTENSIONS$1.OBJ, EXTENSIONS$1.MTL);
      return new Promise(function (resolve) {
        _this.mtlLoader.load(mtlPath, function (material) {
          material.preload();
          resolve(material);
        }, function () {}, function () {
          return resolve(null);
        });
      });
    }
  }, {
    key: "loadObj",
    value: function loadObj(path, material) {
      var _this2 = this;

      if (material) {
        this.objLoader.setMaterials(material);
      }

      return new Promise(function (resolve) {
        return _this2.objLoader.load(path, resolve);
      });
    }
  }, {
    key: "load",
    value: function load(path, onComplete) {
      var _this3 = this;

      this.tryLoadingMTL(path).then(function (material) {
        return _this3.loadObj(path, material);
      }).then(onComplete);
    }
  }]);

  return OBJMTLLoader;
}();var _loaders;
var EXTENSIONS = {
  JSON: 'json',
  GLB: 'glb',
  GLTF: 'gltf',
  // COLLADA: 'dae',
  FBX: 'fbx',
  OBJ: 'obj'
};
var FULL_STOP = '.';
var loaders = (_loaders = {}, _defineProperty$1(_loaders, EXTENSIONS.JSON, ObjectLoader), _defineProperty$1(_loaders, EXTENSIONS.GLB, GLTFLoader), _defineProperty$1(_loaders, EXTENSIONS.GLTF, GLTFLoader), _defineProperty$1(_loaders, EXTENSIONS.FBX, FBXLoader), _defineProperty$1(_loaders, EXTENSIONS.OBJ, OBJMTLLoader), _loaders);
var loaderInstances = {};

var extractExtension = function extractExtension(path) {
  return path.split(FULL_STOP).slice(-1).pop();
};

var getLoaderFromExtension = function getLoaderFromExtension(extension) {
  var instance = loaderInstances[extension];

  if (!instance) {
    var LoaderClass = loaders[extension] || ObjectLoader;
    instance = new LoaderClass();
    loaderInstances[extension] = instance;
  }

  return instance;
};

var glbParser = function glbParser(_ref) {
  var scene = _ref.scene,
      animations = _ref.animations;
  scene.traverse(function (object) {
    if (object.isMesh) {
      object.castShadow = true;
    }
  });
  return {
    animations: animations,
    scene: scene
  };
};

var gltfParser = function gltfParser(_ref2) {
  var scene = _ref2.scene,
      animations = _ref2.animations;
  return {
    scene: scene,
    animations: animations
  };
};

var defaultParser = function defaultParser(scene) {
  return {
    scene: scene
  };
};

var colladaParser = function colladaParser(_ref3) {
  var animations = _ref3.animations,
      scene = _ref3.scene,
      rawSceneData = _ref3.rawSceneData,
      buildVisualScene = _ref3.buildVisualScene;
  scene.traverse(function (node) {
    if (node.isSkinnedMesh) {
      node.frustumCulled = false;
    }
  });
  return {
    animations: animations,
    scene: scene,
    rawSceneData: rawSceneData,
    buildVisualScene: buildVisualScene
  };
};

var fbxParser = function fbxParser(scene) {
  scene.traverse(function (node) {
    if (node.isSkinnedMesh) {
      processMaterial(node.material, function (material) {
        return material.skinning = true;
      });
    }
  });
  return {
    scene: scene,
    animations: scene.animations
  };
};

var getModelParserFromExtension = function getModelParserFromExtension(extension) {
  var _EXTENSIONS$JSON$EXTE;

  return (_EXTENSIONS$JSON$EXTE = {}, _defineProperty$1(_EXTENSIONS$JSON$EXTE, EXTENSIONS.JSON, defaultParser), _defineProperty$1(_EXTENSIONS$JSON$EXTE, EXTENSIONS.GLB, glbParser), _defineProperty$1(_EXTENSIONS$JSON$EXTE, EXTENSIONS.GLTF, gltfParser), _defineProperty$1(_EXTENSIONS$JSON$EXTE, EXTENSIONS.COLLADA, colladaParser), _defineProperty$1(_EXTENSIONS$JSON$EXTE, EXTENSIONS.FBX, fbxParser), _EXTENSIONS$JSON$EXTE)[extension] || defaultParser;
};

var hasAnimations = function hasAnimations() {
  var animations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return animations.length > 0;
};

var Models = function Models() {
  var _this = this;

  _classCallCheck(this, Models);

  _defineProperty$1(this, "setCurrentLevel", function (level) {
    _this.currentLevel = level;
  });

  _defineProperty$1(this, "getModel", function (name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    console.warn(DEPRECATIONS.MODELS_GETMODEL);
    return _this.get(name, options);
  });

  _defineProperty$1(this, "get", function (name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var _ref4 = _this.map[name] || _this.map[buildAssetId(name, _this.currentLevel)] || {},
        scene = _ref4.scene,
        animations = _ref4.animations,
        extension = _ref4.extension;

    if (scene) {
      var elementOptions = _objectSpread2$1({
        name: name
      }, options);

      var model = scene.clone();

      if (extension !== EXTENSIONS.COLLADA && hasAnimations(animations)) {
        // we have no idea how to clone collada for the time being
        model = SkeletonUtils.clone(scene);
      }

      var element = new Element$1(_objectSpread2$1({
        body: prepareModel(model)
      }, elementOptions));
      element.setEntityType(ENTITY_TYPES.MODEL);

      if (hasAnimations(animations)) {
        element.addAnimationHandler(animations);
      }

      return element;
    }

    return false;
  });

  _defineProperty$1(this, "storeModel", function (name, model, extension) {
    model.extension = extension;
    _this.map[name] = model;
  });

  _defineProperty$1(this, "loadModels", function (models, level) {
    _this.models = models;
    var keys = Object.keys(_this.models);

    if (!keys.length) {
      return Promise.resolve('models');
    }

    return Promise.all(keys.map(function (name) {
      return _this.loadSingleFile(name, level);
    })).catch(function (e) {
      console.log(ASSETS_MODEL_LOAD_FAIL);
      console.log(e);
      return Promise.resolve();
    });
  });

  _defineProperty$1(this, "loadSingleFile", function (name, level) {
    var path = _this.models[name];
    var id = buildAssetId(name, level);
    var extension = extractExtension(path);
    var loader = getLoaderFromExtension(extension);
    var parser = getModelParserFromExtension(extension);
    return new Promise(function (resolve) {
      loader.load(path, function (model) {
        var parsedModel = parser(model);

        if (parsedModel) {
          _this.storeModel(id, parsedModel, extension);
        }

        resolve();
      });
    });
  });

  this.map = {};
  this.models = {};
  this.currentLevel = ROOT;
};

var Models$1 = new Models();var _DEFAULT_COMMON_ASSET;
var DEFAULT_COMMON_ASSETS = (_DEFAULT_COMMON_ASSET = {}, _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.AUDIO, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.VIDEO, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.IMAGES, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.TEXTURES, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.CUBETEXTURES, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.MODELS, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.PARTICLES, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.SCRIPTS, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, ASSETS_TYPES.SHADERS, {}), _defineProperty$1(_DEFAULT_COMMON_ASSET, "_isLoaded", false), _DEFAULT_COMMON_ASSET);
var DEFAULT_ASSETS = {
  common: DEFAULT_COMMON_ASSETS,
  levels: {}
};
var Assets = /*#__PURE__*/function () {
  function Assets() {
    var _this = this;

    _classCallCheck(this, Assets);

    _defineProperty$1(this, "setCurrentLevel", function (level) {
      _this.currentLevel = level;
      Models$1.setCurrentLevel(level);
      Audio$1.setCurrentLevel(level);
      Images$1.setCurrentLevel(level);
    });

    _defineProperty$1(this, "getCommonAssets", function () {
      return _this.assets.common || DEFAULT_COMMON_ASSETS;
    });

    _defineProperty$1(this, "getLevelAssets", function (level) {
      return _this.assets.levels[level] || DEFAULT_COMMON_ASSETS;
    });

    _defineProperty$1(this, "setLevelAssetsLoadedState", function (loaded, level) {
      if (_this.assets.levels[level]) {
        _this.assets.levels[level]._isLoaded = loaded;
      }
    });

    _defineProperty$1(this, "setLevelAssetsLoadingState", function (loading, level) {
      if (_this.assets.levels[level]) {
        _this.assets.levels[level]._isLoading = loading;
      }
    });

    _defineProperty$1(this, "getLevelAssetsLoadedState", function (level) {
      return level && _this.assets.levels[level] && _this.assets.levels[level]._isLoaded;
    });

    _defineProperty$1(this, "getLevelAssetsLoadingState", function (level) {
      return level && _this.assets.levels[level] && _this.assets.levels[level]._isLoading;
    });

    _defineProperty$1(this, "setCommonAssetsLoadedState", function (loaded) {
      _this.assets.common._isLoaded = loaded;
    });

    _defineProperty$1(this, "setCommonAssetsLoadingState", function (loading) {
      _this.assets.common._isLoading = loading;
    });

    _defineProperty$1(this, "getCommonAssetsLoadedState", function () {
      return _this.assets.common._isLoaded;
    });

    _defineProperty$1(this, "getCommonAssetsLoadingState", function () {
      return _this.assets.common._isLoading;
    });

    _defineProperty$1(this, "getAsssetsLoadedState", function (level) {
      return level ? _this.getLevelAssetsLoadedState(level) : _this.getCommonAssetsLoadedState();
    });

    _defineProperty$1(this, "getAssetsLoadingstate", function (level) {
      return level ? _this.getLevelAssetsLoadingState(level) : _this.getCommonAssetsLoadingState();
    });

    _defineProperty$1(this, "audio", function (level) {
      return level ? _this.getLevelAssets(level).audio : _this.getCommonAssets().audio;
    });

    _defineProperty$1(this, "video", function (level) {
      return level ? _this.getLevelAssets(level).video : _this.getCommonAssets().video;
    });

    _defineProperty$1(this, "images", function (level) {
      return level ? _this.getLevelAssets(level).images : _this.getCommonAssets().images;
    });

    _defineProperty$1(this, "textures", function (level) {
      return level ? _this.getLevelAssets(level).textures : _this.getCommonAssets().textures;
    });

    _defineProperty$1(this, "cubeTextures", function (level) {
      return level ? _this.getLevelAssets(level).cubetextures : _this.getCommonAssets().cubetextures;
    });

    _defineProperty$1(this, "models", function (level) {
      return level ? _this.getLevelAssets(level).models : _this.getCommonAssets().models;
    });

    _defineProperty$1(this, "particles", function (level) {
      return level ? _this.getLevelAssets(level).particles : _this.getCommonAssets().particles;
    });

    _defineProperty$1(this, "scripts", function (level) {
      return level ? _this.getLevelAssets(level).scripts : _this.getCommonAssets().scripts;
    });

    _defineProperty$1(this, "postAssetsLoad", function (level) {
      return function () {
        if (level) {
          _this.setLevelAssetsLoadedState(true, level);
        }

        _this.setCommonAssetsLoadedState(true);
      };
    });

    _defineProperty$1(this, "preAssetsLoad", function (level) {
      return function () {
        if (level) {
          _this.setLevelAssetsLoadingState(true, level);
        } else {
          _this.setCommonAssetsLoadingState(true);
        }
      };
    });

    _defineProperty$1(this, "handleAssetsLoadError", function (e) {
      console.log(e);
    });

    _defineProperty$1(this, "load", function (level) {
      if (_this.getAsssetsLoadedState(level) || _this.getAssetsLoadingstate(level)) {
        // we already loaded this assets, or we're still loading them
        return Promise.resolve();
      }

      _this.preAssetsLoad(level);

      return Promise.all([Audio$1.load(_this.audio(level), level), engine.load(_this.video(level), level), Images$1.load(_this.images(level), _this.textures(level), _this.cubeTextures(level), level), Models$1.loadModels(_this.models(level), level), Scripts$1.load(_this.scripts(level), level)]).then(_this.postAssetsLoad(level)).catch(_this.handleAssetsLoadError);
    });

    this.assets = DEFAULT_ASSETS;
    this.currentLevel = ROOT;
  }

  _createClass(Assets, [{
    key: "parseAssets",
    value: function parseAssets(assets) {
      var validAssetsTypes = Object.values(ASSETS_TYPES);

      var reducer = function reducer(group, assetType) {
        var lowerCaseType = assetType.toLowerCase();

        if (validAssetsTypes.includes(lowerCaseType)) {
          group.common[lowerCaseType] = assets[assetType];
        } else if (isLevelName(lowerCaseType)) {
          var levelAssets = assets[assetType] || {};
          group.levels[lowerCaseType] = _objectSpread2$1(_objectSpread2$1({}, DEFAULT_COMMON_ASSETS), levelAssets);
        }

        return group;
      };

      return Object.keys(assets).reduce(reducer, DEFAULT_ASSETS);
    }
  }, {
    key: "setAssets",
    value: function setAssets() {
      var assets = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_COMMON_ASSETS;
      this.assets = this.parseAssets(assets);
    }
  }, {
    key: "update",
    value: function update(dt) {
      Audio$1.update(dt);
      Lights$1.update(dt);
    }
  }]);

  return Assets;
}();
var Assets$1 = new Assets();/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
    Promise: undefined,
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; }, 0);
}/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty$1 = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x !== null && typeof x === 'object';
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {
    function UnsubscriptionErrorImpl(errors) {
        Error.call(this);
        this.message = errors ?
            errors.length + " errors occurred during unsubscription:\n" + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '';
        this.name = 'UnsubscriptionError';
        this.errors = errors;
        return this;
    }
    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return UnsubscriptionErrorImpl;
})();
var UnsubscriptionError = UnsubscriptionErrorImpl;/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */
var Subscription = /*@__PURE__*/ (function () {
    function Subscription(unsubscribe) {
        this.closed = false;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    Subscription.prototype.unsubscribe = function () {
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parentOrParents = _a._parentOrParents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parentOrParents = null;
        this._subscriptions = null;
        if (_parentOrParents instanceof Subscription) {
            _parentOrParents.remove(this);
        }
        else if (_parentOrParents !== null) {
            for (var index = 0; index < _parentOrParents.length; ++index) {
                var parent_1 = _parentOrParents[index];
                parent_1.remove(this);
            }
        }
        if (isFunction(_unsubscribe)) {
            try {
                _unsubscribe.call(this);
            }
            catch (e) {
                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
            }
        }
        if (isArray(_subscriptions)) {
            var index = -1;
            var len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    try {
                        sub.unsubscribe();
                    }
                    catch (e) {
                        errors = errors || [];
                        if (e instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
                        }
                        else {
                            errors.push(e);
                        }
                    }
                }
            }
        }
        if (errors) {
            throw new UnsubscriptionError(errors);
        }
    };
    Subscription.prototype.add = function (teardown) {
        var subscription = teardown;
        if (!teardown) {
            return Subscription.EMPTY;
        }
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (!(subscription instanceof Subscription)) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default: {
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
            }
        }
        var _parentOrParents = subscription._parentOrParents;
        if (_parentOrParents === null) {
            subscription._parentOrParents = this;
        }
        else if (_parentOrParents instanceof Subscription) {
            if (_parentOrParents === this) {
                return subscription;
            }
            subscription._parentOrParents = [_parentOrParents, this];
        }
        else if (_parentOrParents.indexOf(this) === -1) {
            _parentOrParents.push(this);
        }
        else {
            return subscription;
        }
        var subscriptions = this._subscriptions;
        if (subscriptions === null) {
            this._subscriptions = [subscription];
        }
        else {
            subscriptions.push(subscription);
        }
        return subscription;
    };
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = /*@__PURE__*/ (function () {
    return typeof Symbol === 'function'
        ? /*@__PURE__*/ Symbol('rxSubscriber')
        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();
})();/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this.syncErrorValue = null;
        _this.syncErrorThrown = false;
        _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty$1;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty$1;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    if (destinationOrNext instanceof Subscriber) {
                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
                        _this.destination = destinationOrNext;
                        destinationOrNext.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _parentOrParents = this._parentOrParents;
        this._parentOrParents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parentOrParents = _parentOrParents;
        return this;
    };
    return Subscriber;
}(Subscription));
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty$1) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */
function canReportError(observer) {
    while (observer) {
        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
        if (closed_1 || isStopped) {
            return false;
        }
        else if (destination && destination instanceof Subscriber) {
            observer = destination;
        }
        else {
            observer = null;
        }
    }
    return true;
}/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty$1);
    }
    return new Subscriber(nextOrObserver, error, complete);
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
var Observable = /*@__PURE__*/ (function () {
    function Observable(subscribe) {
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            sink.add(operator.call(sink, this.source));
        }
        else {
            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?
                this._subscribe(sink) :
                this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            if (canReportError(sink)) {
                sink.error(err);
            }
            else {
                console.warn(err);
            }
        }
    };
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    Observable.prototype[observable] = function () {
        return this;
    };
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {
    function ObjectUnsubscribedErrorImpl() {
        Error.call(this);
        this.message = 'object unsubscribed';
        this.name = 'ObjectUnsubscribedError';
        return this;
    }
    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ObjectUnsubscribedErrorImpl;
})();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        _this._isComplete = false;
        return _this;
    }
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));
var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    Action.prototype.schedule = function (state, delay) {
        return this;
    };
    return Action;
}(Subscription));/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        this.pending = true;
        this.delay = delay;
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        clearInterval(id);
        return undefined;
    };
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    Scheduler.now = function () { return Date.now(); };
    return Scheduler;
}());/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        _this.active = false;
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift());
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
var EMPTY$1 = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY$1;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        subscriber.complete();
    };
};/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function scheduleArray(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        var i = 0;
        sub.add(scheduler.schedule(function () {
            if (i === input.length) {
                subscriber.complete();
                return;
            }
            subscriber.next(input[i++]);
            if (!subscriber.closed) {
                sub.add(this.schedule());
            }
        }));
        return sub;
    });
}/** PURE_IMPORTS_START _Observable,_util_subscribeToArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return scheduleArray(input, scheduler);
    }
}/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_scheduled_scheduleArray PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
        return scheduleArray(args, scheduler);
    }
    else {
        return fromArray(args);
    }
}/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch$7, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch$7(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
var NotificationKind;
/*@__PURE__*/ (function (NotificationKind) {
    NotificationKind["NEXT"] = "N";
    NotificationKind["ERROR"] = "E";
    NotificationKind["COMPLETE"] = "C";
})(NotificationKind || (NotificationKind = {}));
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of(this.value);
            case 'E':
                return throwError(this.error);
            case 'C':
                return empty();
        }
        throw new Error('unexpected notification kind value');
    };
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        var destination = this.destination;
        destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
        this.unsubscribe();
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype._subscribe = function (subscriber) {
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AsapAction;
}(AsyncAction));/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        scheduler.actions.push(this);
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions[0]) && action.delay <= maxFrames) {
            actions.shift();
            this.frame = action.delay;
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function identity(x) {
    return x;
}/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function isObservable(obj) {
    return !!obj && (obj instanceof Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var ArgumentOutOfRangeErrorImpl = /*@__PURE__*/ (function () {
    function ArgumentOutOfRangeErrorImpl() {
        Error.call(this);
        this.message = 'argument out of range';
        this.name = 'ArgumentOutOfRangeError';
        return this;
    }
    ArgumentOutOfRangeErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return ArgumentOutOfRangeErrorImpl;
})();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var EmptyErrorImpl = /*@__PURE__*/ (function () {
    function EmptyErrorImpl() {
        Error.call(this);
        this.message = 'no elements in sequence';
        this.name = 'EmptyError';
        return this;
    }
    EmptyErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return EmptyErrorImpl;
})();
var EmptyError = EmptyErrorImpl;/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var TimeoutErrorImpl = /*@__PURE__*/ (function () {
    function TimeoutErrorImpl() {
        Error.call(this);
        this.message = 'Timeout has occurred';
        this.name = 'TimeoutError';
        return this;
    }
    TimeoutErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);
    return TimeoutErrorImpl;
})();
var TimeoutError = TimeoutErrorImpl;/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch$6, 0, state);
            }
        });
    };
}
function dispatch$6(state) {
    var _this = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext$1, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext$1(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_canReportError,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        if (canReportError(subject)) {
                            subject.error(err);
                        }
                        else {
                            console.warn(err);
                        }
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch$5, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
function dispatch$5(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$1 = iterable[iterator]();
        do {
            var item = iterator$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        if (typeof iterator$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$1.return) {
                    iterator$1.return();
                }
            });
        }
        return subscriber;
    };
};/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return !!value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}/** PURE_IMPORTS_START _subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (!!result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (!!result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo,_Observable PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, destination) {
    if (destination === void 0) {
        destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    }
    if (destination.closed) {
        return undefined;
    }
    if (result instanceof Observable) {
        return result.subscribe(destination);
    }
    return subscribeTo(result)(destination);
}/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    if (observables.length === 1 && isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable PURE_IMPORTS_END */
function scheduleObservable(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        sub.add(scheduler.schedule(function () {
            var observable$1 = input[observable]();
            sub.add(observable$1.subscribe({
                next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
            }));
        }));
        return sub;
    });
}/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function schedulePromise(input, scheduler) {
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        sub.add(scheduler.schedule(function () {
            return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            });
        }));
        return sub;
    });
}/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator PURE_IMPORTS_END */
function scheduleIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    return new Observable(function (subscriber) {
        var sub = new Subscription();
        var iterator$1;
        sub.add(function () {
            if (iterator$1 && typeof iterator$1.return === 'function') {
                iterator$1.return();
            }
        });
        sub.add(scheduler.schedule(function () {
            iterator$1 = input[iterator]();
            sub.add(scheduler.schedule(function () {
                if (subscriber.closed) {
                    return;
                }
                var value;
                var done;
                try {
                    var result = iterator$1.next();
                    value = result.value;
                    done = result.done;
                }
                catch (err) {
                    subscriber.error(err);
                    return;
                }
                if (done) {
                    subscriber.complete();
                }
                else {
                    subscriber.next(value);
                    this.schedule();
                }
            }));
        }));
        return sub;
    });
}/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}/** PURE_IMPORTS_START _scheduleObservable,_schedulePromise,_scheduleArray,_scheduleIterable,_util_isInteropObservable,_util_isPromise,_util_isArrayLike,_util_isIterable PURE_IMPORTS_END */
function scheduled(input, scheduler) {
    if (input != null) {
        if (isInteropObservable(input)) {
            return scheduleObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return schedulePromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return scheduleArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return scheduleIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}/** PURE_IMPORTS_START _Observable,_util_subscribeTo,_scheduled_scheduled PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    else {
        return scheduled(input, scheduler);
    }
}/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_InnerSubscriber,_map,_observable_from PURE_IMPORTS_END */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        var innerSubscriber = new InnerSubscriber(this, undefined, undefined);
        var destination = this.destination;
        destination.add(innerSubscriber);
        subscribeToResult(this, ish, value, index, innerSubscriber);
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
        this.unsubscribe();
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
function mergeAll(concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    return mergeMap(identity, concurrent);
}/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
function concatAll() {
    return mergeAll(1);
}/** PURE_IMPORTS_START _of,_operators_concatAll PURE_IMPORTS_END */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    return concatAll()(of.apply(void 0, observables));
}/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function defer(observableFactory) {
    return new Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from(input) : empty();
        return source.subscribe(subscriber);
    });
}/** PURE_IMPORTS_START _Observable,_util_isArray,_operators_map,_util_isObject,_from PURE_IMPORTS_END */
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 1) {
        var first_1 = sources[0];
        if (isArray(first_1)) {
            return forkJoinInternal(first_1, null);
        }
        if (isObject(first_1) && Object.getPrototypeOf(first_1) === Object.prototype) {
            var keys = Object.keys(first_1);
            return forkJoinInternal(keys.map(function (key) { return first_1[key]; }), keys);
        }
    }
    if (typeof sources[sources.length - 1] === 'function') {
        var resultSelector_1 = sources.pop();
        sources = (sources.length === 1 && isArray(sources[0])) ? sources[0] : sources;
        return forkJoinInternal(sources, null).pipe(map(function (args) { return resultSelector_1.apply(void 0, args); }));
    }
    return forkJoinInternal(sources, null);
}
function forkJoinInternal(sources, keys) {
    return new Observable(function (subscriber) {
        var len = sources.length;
        if (len === 0) {
            subscriber.complete();
            return;
        }
        var values = new Array(len);
        var completed = 0;
        var emitted = 0;
        var _loop_1 = function (i) {
            var source = from(sources[i]);
            var hasValue = false;
            subscriber.add(source.subscribe({
                next: function (value) {
                    if (!hasValue) {
                        hasValue = true;
                        emitted++;
                    }
                    values[i] = value;
                },
                error: function (err) { return subscriber.error(err); },
                complete: function () {
                    completed++;
                    if (completed === len || !hasValue) {
                        if (emitted === len) {
                            subscriber.next(keys ?
                                keys.reduce(function (result, key, i) { return (result[key] = values[i], result); }, {}) :
                                values);
                        }
                        subscriber.complete();
                    }
                }
            }));
        };
        for (var i = 0; i < len; i++) {
            _loop_1(i);
        }
    });
}/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction(options)) {
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        return fromEvent(target, eventName, options).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        return fromEventPattern(addHandler, removeHandler).pipe(map(function (args) { return isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */
function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch$4, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
function dispatch$4(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) {
        trueResult = EMPTY$1;
    }
    if (falseResult === void 0) {
        falseResult = EMPTY$1;
    }
    return defer(function () { return condition() ? trueResult : falseResult; });
}/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
function interval(period, scheduler) {
    if (period === void 0) {
        period = 0;
    }
    if (scheduler === void 0) {
        scheduler = async;
    }
    if (!isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async;
    }
    return new Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch$3, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
function dispatch$3(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable) {
        return observables[0];
    }
    return mergeAll(concurrent)(fromArray(observables, scheduler));
}/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
var NEVER = /*@__PURE__*/ new Observable(noop);
function never() {
    return NEVER;
}/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return EMPTY$1;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription();
            subscription.add(scheduler.schedule(dispatch$2, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
function dispatch$2(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function not(pred, thisArg) {
    function notPred() {
        return !(notPred.pred.apply(notPred.thisArg, arguments));
    }
    notPred.pred = pred;
    notPred.thisArg = thisArg;
    return notPred;
}/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));/** PURE_IMPORTS_START _util_not,_util_subscribeTo,_operators_filter,_Observable PURE_IMPORTS_END */
function partition(source, predicate, thisArg) {
    return [
        filter(predicate, thisArg)(new Observable(subscribeTo(source))),
        filter(not(predicate, thisArg))(new Observable(subscribeTo(source)))
    ];
}/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1) {
        if (isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray(observables, undefined).lift(new RaceOperator());
}
var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function range(start, count, scheduler) {
    if (start === void 0) {
        start = 0;
    }
    return new Observable(function (subscriber) {
        if (count === undefined) {
            count = start;
            start = 0;
        }
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch$1, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
function dispatch$1(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) {
        dueTime = 0;
    }
    var period = -1;
    if (isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler(scheduler)) {
        scheduler = async;
    }
    return new Observable(function (subscriber) {
        var due = isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
function using(resourceFactory, observableFactory) {
    return new Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from(result) : EMPTY$1;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        this.unsubscribe();
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                var destination = this.destination;
                destination.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--;
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));/** PURE_IMPORTS_START  PURE_IMPORTS_END */var index$2=/*#__PURE__*/Object.freeze({__proto__:null,Observable:Observable,ConnectableObservable:ConnectableObservable,GroupedObservable:GroupedObservable,observable:observable,Subject:Subject,BehaviorSubject:BehaviorSubject,ReplaySubject:ReplaySubject,AsyncSubject:AsyncSubject,asapScheduler:asap,asyncScheduler:async,queueScheduler:queue,animationFrameScheduler:animationFrame,VirtualTimeScheduler:VirtualTimeScheduler,VirtualAction:VirtualAction,Scheduler:Scheduler,Subscription:Subscription,Subscriber:Subscriber,Notification:Notification,get NotificationKind(){return NotificationKind},pipe:pipe,noop:noop,identity:identity,isObservable:isObservable,ArgumentOutOfRangeError:ArgumentOutOfRangeError,EmptyError:EmptyError,ObjectUnsubscribedError:ObjectUnsubscribedError,UnsubscriptionError:UnsubscriptionError,TimeoutError:TimeoutError,bindCallback:bindCallback,bindNodeCallback:bindNodeCallback,combineLatest:combineLatest,concat:concat,defer:defer,empty:empty,forkJoin:forkJoin,from:from,fromEvent:fromEvent,fromEventPattern:fromEventPattern,generate:generate,iif:iif,interval:interval,merge:merge,never:never,of:of,onErrorResumeNext:onErrorResumeNext,pairs:pairs,partition:partition,race:race,range:range,throwError:throwError,timer:timer,using:using,zip:zip,scheduled:scheduled,EMPTY:EMPTY$1,NEVER:NEVER,config:config});var ONE_MB = 1048576;

var Stats = /*#__PURE__*/function () {
  function Stats() {
    _classCallCheck(this, Stats);

    this.beginTime = (performance || Date).now();
    this.prevTime = this.beginTime;
    this.frames = 0;
    this._fps = 0;
    this._fpsMax = 100;
    this.fps = new Subject();
  }

  _createClass(Stats, [{
    key: "init",
    value: function init() {
      this.beginTime = (performance || Date).now();
    }
  }, {
    key: "getFPS",
    value: function getFPS() {
      this.frames++;
      var time = (performance || Date).now();

      if (time >= this.prevTime + 1000) {
        this._fps = this.frames * 1000 / (time - this.prevTime);
        this.prevTime = time;
        this.frames = 0;
        this.fps.next(this._fps);
      }

      this.beginTime = time;
      return this._fps;
    }
  }, {
    key: "subscribe",
    value: function subscribe(handler) {
      var _this = this;

      this.fps.subscribe(handler);
      return function () {
        return _this.fps.unsubscribe(handler);
      };
    }
  }, {
    key: "getMemoryUsage",
    value: function getMemoryUsage() {
      if (Features$1.isFeatureSupported(FEATURES.MEMORY)) {
        this.memory = performance.memory.usedJSHeapSize / ONE_MB;
        this.memoryMax = performance.memory.jsHeapSizeLimit / ONE_MB;
      }
    }
  }, {
    key: "update",
    value: function update() {
      this.getFPS();
    }
  }]);

  return Stats;
}();

var Stats$1 = new Stats();var Loader = /*#__PURE__*/function () {
  function Loader() {
    _classCallCheck(this, Loader);

    this.loader = new ObjectLoader();
  }

  _createClass(Loader, [{
    key: "load",
    value: function load() {}
  }]);

  return Loader;
}();var _excluded$4 = ["mesh", "scripts", "texture"];
var MeshLoader = /*#__PURE__*/function (_Loader) {
  _inherits(MeshLoader, _Loader);

  var _super = _createSuper(MeshLoader);

  function MeshLoader() {
    _classCallCheck(this, MeshLoader);

    return _super.call(this);
  }

  _createClass(MeshLoader, [{
    key: "load",
    value: function load() {
      var _this = this;

      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      this.options = options;

      try {
        elements.map(function (_ref) {
          var mesh = _ref.mesh,
              scripts = _ref.scripts,
              texture = _ref.texture,
              opts = _objectWithoutProperties(_ref, _excluded$4);

          return _this.loadMesh(_this.parseMesh(mesh), scripts, texture, opts);
        });
      } catch (e) {
        console.log(e);
      }
    }
  }, {
    key: "parseMesh",
    value: function parseMesh(mesh) {
      return this.loader.parse(mesh);
    }
  }, {
    key: "loadMesh",
    value: function loadMesh(_ref2, scripts, texture, elementOptions) {
      var geometry = _ref2.geometry,
          material = _ref2.material,
          position = _ref2.position,
          rotation = _ref2.rotation,
          scale = _ref2.scale;
      var _this$options$scriptE = this.options.scriptEnabled,
          scriptEnabled = _this$options$scriptE === void 0 ? true : _this$options$scriptE;
      var element = new Element$1(_objectSpread2$1({
        geometry: geometry,
        material: material
      }, elementOptions));
      element.setPosition(_objectSpread2$1({}, position));
      element.setRotation(_objectSpread2$1({}, rotation));
      element.setScale(_objectSpread2$1({}, scale));

      if (scripts && scripts.length) {
        element.addScripts(scripts.names, scripts.options, scriptEnabled);
        element.start();
      }

      return element;
    }
  }]);

  return MeshLoader;
}(Loader);
var MeshLoader$1 = new MeshLoader();var LAMP_COLOR = 0Xf1c40f;

var Light = /*#__PURE__*/function (_Entity) {
  _inherits(Light, _Entity);

  var _super = _createSuper(Light);

  function Light(_ref) {
    var _this;

    var color = _ref.color,
        intensity = _ref.intensity,
        _name = _ref.name;

    _classCallCheck(this, Light);

    _this = _super.call(this, {
      name: _name
    });

    _defineProperty$1(_assertThisInitialized(_this), "addHolder", function () {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lightholder';
      var body = Models$1.getModel(name);

      if (body) {
        _this.holder = body;

        _this.holder.setMaterialFromName(MATERIALS.BASIC, {
          wireframe: true,
          color: LAMP_COLOR
        });

        _this.holder.serializable = false;

        _this.holder.setPosition({
          x: _this.body.position.x,
          y: _this.body.position.y,
          z: _this.body.position.z
        });
      } else {
        console.warn(LIGHT_HOLDER_MODEL_NOT_FOUND);
      }
    });

    _this.color = color;
    _this.intensity = intensity;
    _this.name = _name || generateRandomName('Light');
    _this.isLightOn = false;
    _this.body = undefined; // helper body for this light

    _this.helper = undefined; // holder body representing the light

    _this.holder = undefined; // target body for the light (only used by directional light)

    _this.target = undefined;

    _this.setEntityType(ENTITY_TYPES.LIGHT.DEFAULT);

    Lights$1.add(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Light, [{
    key: "addToScene",
    value: function addToScene() {
      if (this.hasBody()) {
        Scene$1.add(this.body, this);
      }
    }
  }, {
    key: "hasHelper",
    value: function hasHelper() {
      return !!this.helper;
    }
  }, {
    key: "hasHolder",
    value: function hasHolder() {
      return !!this.holder;
    }
  }, {
    key: "getPosition",
    value: function getPosition() {
      return {
        x: this.body.position.x,
        y: this.body.position.y,
        z: this.body.position.z
      };
    }
  }, {
    key: "setPosition",
    value: function setPosition(where) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          _ref2$updateHolder = _ref2.updateHolder,
          updateHolder = _ref2$updateHolder === void 0 ? true : _ref2$updateHolder;

      var position = _objectSpread2$1(_objectSpread2$1({}, this.getPosition()), where);

      var x = position.x,
          y = position.y,
          z = position.z;

      if (this.hasBody()) {
        this.body.position.set(x, y, z);
      }

      if (this.hasHolder() & updateHolder) {
        this.holder.setPosition({
          x: x,
          y: y,
          z: z
        });
      }
    }
  }, {
    key: "isAlreadyOn",
    value: function isAlreadyOn() {
      return this.hasBody() && this.body.intensity === this.intensity;
    }
  }, {
    key: "isAlreadyOff",
    value: function isAlreadyOff() {
      return this.hasBody() && this.body.intensity <= 0;
    }
  }, {
    key: "setIntensity",
    value: function setIntensity(value) {
      if (this.hasBody()) {
        this.body.intensity = value;
      }
    }
  }, {
    key: "getIntensity",
    value: function getIntensity() {
      if (this.hasBody()) {
        return this.body.intensity;
      }
    }
  }, {
    key: "dim",
    value: function dim() {
      var _this2 = this;

      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getIntensity();
      var time = arguments.length > 1 ? arguments[1] : undefined;
      var intensity = this.getIntensity();
      return new Promise(function (resolve) {
        return new Between(intensity, value).time(time).on('update', function (value) {
          return !_this2.isDisposed() && _this2.setIntensity(value);
        }).on('complete', resolve);
      });
    }
  }, {
    key: "on",
    value: function on() {
      var _this3 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;

      if (this.hasBody()) {
        this.dim(this.intensity, time).then(function () {
          return _this3.isLightOn = true;
        });
      } else {
        console.log(LIGHT_NOT_FOUND);
      }
    }
  }, {
    key: "off",
    value: function off() {
      var _this4 = this;

      var time = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;

      if (this.hasBody()) {
        this.dim(0, time).then(function () {
          return _this4.isLightOn = false;
        });
      } else {
        console.log(LIGHT_NOT_FOUND);
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      var _this$body$position = this.body.position,
          x = _this$body$position.x,
          y = _this$body$position.y,
          z = _this$body$position.z;
      return {
        position: {
          x: x,
          y: y,
          z: z
        },
        color: this.color,
        intensity: this.intensity,
        name: this.name
      };
    }
  }]);

  return Light;
}(Entity);var DEFAULT_NEAR$2 = 0.1;
var DEFAULT_FAR$2 = 100;
var DEFAULT_FOV = 75;
var DEFAULT_POSITION$3 = {
  x: 0,
  y: 1,
  z: 0
};
var DEFAULT_INTENSITY$4 = 0.5;
var DEFAULT_MAP_SIZE$2 = 512;
var DEFAULT_BIAS$2 = -0.0001;
var WHITE$3 = 0xffffff;

var SunLight = /*#__PURE__*/function (_Light) {
  _inherits(SunLight, _Light);

  var _super = _createSuper(SunLight);

  function SunLight() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SunLight);

    var _options$color = options.color,
        color = _options$color === void 0 ? WHITE$3 : _options$color,
        _options$intensity = options.intensity,
        intensity = _options$intensity === void 0 ? DEFAULT_INTENSITY$4 : _options$intensity,
        _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('SunLight') : _options$name;
    _this = _super.call(this, {
      color: color,
      intensity: intensity,
      name: name
    });
    _this.options = options;

    _this.setLight({
      color: color,
      intensity: intensity
    });

    _this.setEntityType(ENTITY_TYPES.LIGHT.SUN);

    _this.setName(name);

    return _this;
  }

  _createClass(SunLight, [{
    key: "setLight",
    value: function setLight(_ref) {
      var light = _ref.light,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? WHITE$3 : _ref$color,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? DEFAULT_INTENSITY$4 : _ref$intensity;

      if (light) {
        this.setBody(light);
      } else {
        this.setBody(new DirectionalLight(color, intensity));
      }

      if (this.hasBody()) {
        this.postLightCreation();
      }
    }
  }, {
    key: "postLightCreation",
    value: function postLightCreation() {
      var _this$options = this.options,
          _this$options$positio = _this$options.position,
          position = _this$options$positio === void 0 ? DEFAULT_POSITION$3 : _this$options$positio,
          target = _this$options.target;
      this.setPosition(position);

      if (target) {
        this.setTarget(target);
      }

      this.setLightShadows();
      this.addToScene();
    }
  }, {
    key: "setLightShadows",
    value: function setLightShadows() {
      var _this$options2 = this.options,
          _this$options2$near = _this$options2.near,
          near = _this$options2$near === void 0 ? DEFAULT_NEAR$2 : _this$options2$near,
          _this$options2$far = _this$options2.far,
          far = _this$options2$far === void 0 ? DEFAULT_FAR$2 : _this$options2$far,
          _this$options2$mapSiz = _this$options2.mapSize,
          mapSize = _this$options2$mapSiz === void 0 ? DEFAULT_MAP_SIZE$2 : _this$options2$mapSiz,
          _this$options2$bias = _this$options2.bias,
          bias = _this$options2$bias === void 0 ? DEFAULT_BIAS$2 : _this$options2$bias,
          _this$options2$fov = _this$options2.fov,
          fov = _this$options2$fov === void 0 ? DEFAULT_FOV : _this$options2$fov;

      if (Config$1.lights().shadows) {
        this.body.castShadow = true;
        var d = far / 1.5;
        this.body.shadow.mapSize.height = mapSize;
        this.body.shadow.mapSize.width = mapSize;
        this.body.shadow.camera.left = -d;
        this.body.shadow.camera.right = d;
        this.body.shadow.camera.top = d;
        this.body.shadow.camera.bottom = -d;
        this.body.shadow.camera.near = near;
        this.body.shadow.camera.far = far;
        this.body.shadow.camera.fov = fov;
        this.body.shadow.bias = bias;
      }
    }
  }, {
    key: "getTargetMesh",
    value: function getTargetMesh(initialPosition) {
      var geometry = new SphereGeometry(3, 6, 6);
      var material = new MeshBasicMaterial({
        color: 0xeeeeee,
        wireframe: true
      });
      var target = new Element$1({
        geometry: geometry,
        material: material
      });
      target.position(initialPosition);
      return target;
    }
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      if (target.position) {
        this.body.target = target;
        Scene$1.add(this.body.target, null, false);
      }
    }
  }, {
    key: "getTargetPosition",
    value: function getTargetPosition() {
      return this.target;
    }
  }, {
    key: "addHelper",
    value: function addHelper() {
      this.helper = new DirectionalLightHelper(this.body, 5);
      this.shadowHelper = new CameraHelper(this.body.shadow.camera);
      Scene$1.add(this.helper, null, false);
      Scene$1.add(this.shadowHelper, null, false);
      this.addHolder();
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(SunLight.prototype), "update", this).call(this, dt);

      if (this.hasHelper()) {
        this.helper.update();
        this.shadowHelper.update();
      }

      if (this.hasHolder()) {
        this.setPosition(this.holder.getPosition(), {
          updateHolder: false
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(SunLight.prototype), "toJSON", this).call(this)), {}, {
        type: SUNLIGHT
      });
    }
  }]);

  return SunLight;
}(Light);var DEFAULT_POSITION$2 = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_INTENSITY$3 = 0.5;
var WHITE$2 = 0xffffff;

var AmbientLight = /*#__PURE__*/function (_Light) {
  _inherits(AmbientLight, _Light);

  var _super = _createSuper(AmbientLight);

  function AmbientLight() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, AmbientLight);

    var _options$color = options.color,
        color = _options$color === void 0 ? WHITE$2 : _options$color,
        _options$intensity = options.intensity,
        intensity = _options$intensity === void 0 ? DEFAULT_INTENSITY$3 : _options$intensity,
        _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('AmbientLight') : _options$name;
    _this = _super.call(this, {
      color: color,
      intensity: intensity,
      name: name
    });
    _this.options = options;

    _this.setLight({
      color: color,
      intensity: intensity
    });

    _this.setEntityType(ENTITY_TYPES.LIGHT.AMBIENT);

    _this.setName(name);

    return _this;
  }

  _createClass(AmbientLight, [{
    key: "setLight",
    value: function setLight(_ref) {
      var light = _ref.light,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? WHITE$2 : _ref$color,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? DEFAULT_INTENSITY$3 : _ref$intensity;

      if (light) {
        this.setBody(light);
      } else {
        this.setBody(new AmbientLight$1(color, intensity));
      }

      if (this.hasBody()) {
        this.postLightCreation();
      }
    }
  }, {
    key: "postLightCreation",
    value: function postLightCreation() {
      var _this$options$positio = this.options.position,
          position = _this$options$positio === void 0 ? DEFAULT_POSITION$2 : _this$options$positio;
      this.setPosition(position);
      this.addToScene();
    }
  }, {
    key: "addHelper",
    value: function addHelper() {
      this.helper = true;
      this.addHolder('ambientlightholder');
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(AmbientLight.prototype), "update", this).call(this, dt);

      if (this.hasHelper()) {
        this.setPosition(this.holder.getPosition(), {
          updateHolder: false
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(AmbientLight.prototype), "toJSON", this).call(this)), {}, {
        type: AMBIENTLIGHT
      });
    }
  }]);

  return AmbientLight;
}(Light);var DEFAULT_NEAR$1 = 0.1;
var DEFAULT_FAR$1 = 100;
var DEFAULT_POSITION$1 = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_INTENSITY$2 = 0.5;
var DEFAULT_DISTANCE = 0;
var DEFAULT_DECAY = 1;
var DEFAULT_MAP_SIZE$1 = 2048;
var DEFAULT_BIAS$1 = -0.0001;
var WHITE$1 = 0xffffff;
var GREEN$2 = 0x2ecc71;

var PointLight = /*#__PURE__*/function (_Light) {
  _inherits(PointLight, _Light);

  var _super = _createSuper(PointLight);

  function PointLight(options) {
    var _this;

    _classCallCheck(this, PointLight);

    var _options$color = options.color,
        color = _options$color === void 0 ? WHITE$1 : _options$color,
        _options$intensity = options.intensity,
        intensity = _options$intensity === void 0 ? DEFAULT_INTENSITY$2 : _options$intensity,
        _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('PointLight') : _options$name,
        distance = options.distance,
        decay = options.decay;
    _this = _super.call(this, {
      color: color,
      intensity: intensity,
      name: name
    });
    _this.options = options;

    _this.setLight({
      color: color,
      intensity: intensity,
      distance: distance,
      decay: decay
    });

    _this.setEntityType(ENTITY_TYPES.LIGHT.POINT);

    _this.setName(name);

    return _this;
  }

  _createClass(PointLight, [{
    key: "setLight",
    value: function setLight(_ref) {
      var light = _ref.light,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? WHITE$1 : _ref$color,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? DEFAULT_INTENSITY$2 : _ref$intensity,
          _ref$distance = _ref.distance,
          distance = _ref$distance === void 0 ? DEFAULT_DISTANCE : _ref$distance,
          _ref$decay = _ref.decay,
          decay = _ref$decay === void 0 ? DEFAULT_DECAY : _ref$decay;

      if (light) {
        this.setBody(light);
      } else {
        this.setBody(new PointLight$1(color, intensity, distance, decay));
      }

      if (this.hasBody()) {
        this.postLightCreation();
      }
    }
  }, {
    key: "postLightCreation",
    value: function postLightCreation() {
      var _this$options$positio = this.options.position,
          position = _this$options$positio === void 0 ? DEFAULT_POSITION$1 : _this$options$positio;
      this.setPosition(position);
      this.setLightShadows();
      this.addToScene();
    }
  }, {
    key: "setLightShadows",
    value: function setLightShadows() {
      var _this$options = this.options,
          _this$options$near = _this$options.near,
          near = _this$options$near === void 0 ? DEFAULT_NEAR$1 : _this$options$near,
          _this$options$far = _this$options.far,
          far = _this$options$far === void 0 ? DEFAULT_FAR$1 : _this$options$far,
          _this$options$mapSize = _this$options.mapSize,
          mapSize = _this$options$mapSize === void 0 ? DEFAULT_MAP_SIZE$1 : _this$options$mapSize,
          _this$options$bias = _this$options.bias,
          bias = _this$options$bias === void 0 ? DEFAULT_BIAS$1 : _this$options$bias;

      if (Config$1.lights().shadows) {
        this.body.castShadow = true;
        var d = far / 2;
        this.body.shadow.mapSize.height = mapSize;
        this.body.shadow.mapSize.width = mapSize;
        this.body.shadow.camera.left = -d;
        this.body.shadow.camera.right = d;
        this.body.shadow.camera.top = d;
        this.body.shadow.camera.bottom = -d;
        this.body.shadow.camera.near = near;
        this.body.shadow.camera.far = far;
        this.body.shadow.bias = bias;
      }
    }
  }, {
    key: "addHelper",
    value: function addHelper() {
      this.helper = new PointLightHelper(this.body, 2, GREEN$2);
      this.shadowHelper = new CameraHelper(this.body.shadow.camera);
      Scene$1.add(this.helper, null, false);
      Scene$1.add(this.shadowHelper, null, false);
      this.addHolder();
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(PointLight.prototype), "update", this).call(this, dt);

      if (this.hasHelper()) {
        this.helper.update();
        this.shadowHelper.update();
      }

      if (this.hasHolder()) {
        this.setPosition(this.holder.getPosition(), {
          updateHolder: false
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(PointLight.prototype), "toJSON", this).call(this)), {}, {
        distance: this.distance,
        type: POINTLIGHT
      });
    }
  }]);

  return PointLight;
}(Light);var LightLoader = /*#__PURE__*/function (_Loader) {
  _inherits(LightLoader, _Loader);

  var _super = _createSuper(LightLoader);

  function LightLoader() {
    var _this;

    _classCallCheck(this, LightLoader);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "createLight", function (useHelper) {
      return function (l) {
        var light;

        switch (l.type) {
          case SUNLIGHT:
            light = _this.createSunlight(l);
            break;

          case POINTLIGHT:
            light = _this.createPointlight(l);
            break;

          case AMBIENTLIGHT:
            light = _this.createAmbientLight(l);
            break;
        }

        if (light && useHelper) {
          light.addHelper();
        }
      };
    });

    return _this;
  }

  _createClass(LightLoader, [{
    key: "load",
    value: function load(lights, _ref) {
      var _ref$useHelper = _ref.useHelper,
          useHelper = _ref$useHelper === void 0 ? false : _ref$useHelper;
      lights.forEach(this.createLight(useHelper));
    }
  }, {
    key: "createSunlight",
    value: function createSunlight(_ref2) {
      var color = _ref2.color,
          intensity = _ref2.intensity,
          position = _ref2.position,
          target = _ref2.target,
          name = _ref2.name;
      return new SunLight({
        color: color,
        intensity: intensity,
        position: position,
        target: target,
        name: name
      });
    }
  }, {
    key: "createAmbientLight",
    value: function createAmbientLight(_ref3) {
      var color = _ref3.color,
          intensity = _ref3.intensity,
          position = _ref3.position,
          name = _ref3.name;
      return new AmbientLight({
        color: color,
        intensity: intensity,
        position: position,
        name: name
      });
    }
  }, {
    key: "createPointlight",
    value: function createPointlight(_ref4) {
      var color = _ref4.color,
          intensity = _ref4.intensity,
          position = _ref4.position,
          distance = _ref4.distance,
          name = _ref4.name;
      return new PointLight({
        color: color,
        intensity: intensity,
        position: position,
        distance: distance,
        name: name
      });
    }
  }]);

  return LightLoader;
}(Loader);
var LightLoader$1 = new LightLoader();var Pass = /*#__PURE__*/function () {
  function Pass() {
    _classCallCheck(this, Pass);

    // if set to true, the pass is processed by the composer
    this.enabled = true; // if set to true, the pass indicates to swap read and write buffer after rendering

    this.needsSwap = true; // if set to true, the pass clears its buffer before rendering

    this.clear = false; // if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.

    this.renderToScreen = false;
    this.isPass = true;
  }

  _createClass(Pass, [{
    key: "setSize",
    value: function setSize() {}
  }, {
    key: "render",
    value: function render() {
      console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
  }]);

  return Pass;
}(); // Helper for passes that need to fill the viewport with a single quad.

var _camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1); // https://github.com/mrdoob/three.js/pull/21358


var _geometry = new BufferGeometry();

_geometry.setAttribute('position', new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));

_geometry.setAttribute('uv', new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));

var FullScreenQuad = /*#__PURE__*/function () {
  function FullScreenQuad(material) {
    _classCallCheck(this, FullScreenQuad);

    this._mesh = new Mesh(_geometry, material);
  }

  _createClass(FullScreenQuad, [{
    key: "dispose",
    value: function dispose() {
      this._mesh.geometry.dispose();
    }
  }, {
    key: "render",
    value: function render(renderer) {
      renderer.render(this._mesh, _camera);
    }
  }, {
    key: "material",
    get: function get() {
      return this._mesh.material;
    },
    set: function set(value) {
      this._mesh.material = value;
    }
  }]);

  return FullScreenQuad;
}();var ShaderPass = /*#__PURE__*/function (_Pass) {
  _inherits(ShaderPass, _Pass);

  var _super = _createSuper(ShaderPass);

  function ShaderPass(shader, textureID) {
    var _this;

    _classCallCheck(this, ShaderPass);

    _this = _super.call(this);
    _this.textureID = textureID !== undefined ? textureID : 'tDiffuse';

    if (shader instanceof ShaderMaterial) {
      _this.uniforms = shader.uniforms;
      _this.material = shader;
    } else if (shader) {
      _this.uniforms = UniformsUtils.clone(shader.uniforms);
      _this.material = new ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: _this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }

    _this.fsQuad = new FullScreenQuad(_this.material);
    return _this;
  }

  _createClass(ShaderPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer
    /*, deltaTime, maskActive */
    ) {
      if (this.uniforms[this.textureID]) {
        this.uniforms[this.textureID].value = readBuffer.texture;
      }

      this.fsQuad.material = this.material;

      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

        if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        this.fsQuad.render(renderer);
      }
    }
  }]);

  return ShaderPass;
}(Pass);/**
 * Full-screen textured quad shader
 */
var CopyShader = {
  uniforms: {
    'tDiffuse': {
      value: null
    },
    'opacity': {
      value: 1.0
    }
  },
  vertexShader:
  /* glsl */
  "\n\n        varying vec2 vUv;\n\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }",
  fragmentShader:
  /* glsl */
  "\n\n        uniform float opacity;\n\n        uniform sampler2D tDiffuse;\n\n        varying vec2 vUv;\n\n        void main() {\n            gl_FragColor = texture2D( tDiffuse, vUv );\n            gl_FragColor.a *= opacity;\n        }"
};var MaskPass = /*#__PURE__*/function (_Pass) {
  _inherits(MaskPass, _Pass);

  var _super = _createSuper(MaskPass);

  function MaskPass(scene, camera) {
    var _this;

    _classCallCheck(this, MaskPass);

    _this = _super.call(this);
    _this.scene = scene;
    _this.camera = camera;
    _this.clear = true;
    _this.needsSwap = false;
    _this.inverse = false;
    return _this;
  }

  _createClass(MaskPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer
    /*, deltaTime, maskActive */
    ) {
      var context = renderer.getContext();
      var state = renderer.state; // don't update color or depth

      state.buffers.color.setMask(false);
      state.buffers.depth.setMask(false); // lock buffers

      state.buffers.color.setLocked(true);
      state.buffers.depth.setLocked(true); // set up stencil

      var writeValue, clearValue;

      if (this.inverse) {
        writeValue = 0;
        clearValue = 1;
      } else {
        writeValue = 1;
        clearValue = 0;
      }

      state.buffers.stencil.setTest(true);
      state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
      state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
      state.buffers.stencil.setClear(clearValue);
      state.buffers.stencil.setLocked(true); // draw into the stencil buffer

      renderer.setRenderTarget(readBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering

      state.buffers.color.setLocked(false);
      state.buffers.depth.setLocked(false); // only render where stencil is set to 1

      state.buffers.stencil.setLocked(false);
      state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1

      state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
      state.buffers.stencil.setLocked(true);
    }
  }]);

  return MaskPass;
}(Pass);var ClearMaskPass = /*#__PURE__*/function (_Pass) {
  _inherits(ClearMaskPass, _Pass);

  var _super = _createSuper(ClearMaskPass);

  function ClearMaskPass() {
    var _this;

    _classCallCheck(this, ClearMaskPass);

    _this = _super.call(this);
    _this.needsSwap = false;
    return _this;
  }

  _createClass(ClearMaskPass, [{
    key: "render",
    value: function render(renderer
    /*, writeBuffer, readBuffer, deltaTime, maskActive */
    ) {
      renderer.state.buffers.stencil.setLocked(false);
      renderer.state.buffers.stencil.setTest(false);
    }
  }]);

  return ClearMaskPass;
}(Pass);var EffectComposer = /*#__PURE__*/function () {
  function EffectComposer(renderer, renderTarget) {
    var _this = this;

    _classCallCheck(this, EffectComposer);

    _defineProperty$1(this, "ensureLastPassIsRendered", function () {
      _this.passes.forEach(function (pass, index) {
        return pass.renderToScreen = index === _this.passes.length - 1;
      });
    });

    this.renderer = renderer;

    if (renderTarget === undefined) {
      var size = renderer.getSize(new Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = new WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio);
      renderTarget.texture.name = 'EffectComposer.rt1';
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }

    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = 'EffectComposer.rt2';
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = []; // dependencies

    if (CopyShader === undefined) {
      console.error('THREE.EffectComposer relies on CopyShader');
    }

    if (ShaderPass === undefined) {
      console.error('THREE.EffectComposer relies on ShaderPass');
    }

    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new Clock();
  }

  _createClass(EffectComposer, [{
    key: "swapBuffers",
    value: function swapBuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }
  }, {
    key: "addPass",
    value: function addPass(pass) {
      this.passes.push(pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
  }, {
    key: "insertPass",
    value: function insertPass(pass, index) {
      this.passes.splice(index, 0, pass);
      pass.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
    }
  }, {
    key: "removePass",
    value: function removePass(pass) {
      var index = this.passes.indexOf(pass);

      if (index !== -1) {
        this.passes.splice(index, 1);
      }
    }
  }, {
    key: "isLastEnabledPass",
    value: function isLastEnabledPass(passIndex) {
      for (var i = passIndex + 1; i < this.passes.length; i++) {
        if (this.passes[i].enabled) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "render",
    value: function render(deltaTime) {
      // deltaTime value is in seconds
      if (deltaTime === undefined) {
        deltaTime = this.clock.getDelta();
      }

      var currentRenderTarget = this.renderer.getRenderTarget();
      var maskActive = false;

      for (var i = 0, il = this.passes.length; i < il; i++) {
        var pass = this.passes[i];
        if (pass.enabled === false) continue;
        pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
        pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

        if (pass.needsSwap) {
          if (maskActive) {
            var context = this.renderer.getContext();
            var stencil = this.renderer.state.buffers.stencil; //context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);

            stencil.setFunc(context.NOTEQUAL, 1, 0xffffffff);
            this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime); //context.stencilFunc(context.EQUAL, 1, 0xffffffff);

            stencil.setFunc(context.EQUAL, 1, 0xffffffff);
          }

          this.swapBuffers();
        }

        if (MaskPass !== undefined) {
          if (pass instanceof MaskPass) {
            maskActive = true;
          } else if (pass instanceof ClearMaskPass) {
            maskActive = false;
          }
        }
      }

      this.renderer.setRenderTarget(currentRenderTarget);
    }
  }, {
    key: "reset",
    value: function reset(renderTarget) {
      if (renderTarget === undefined) {
        var size = this.renderer.getSize(new Vector2());
        this._pixelRatio = this.renderer.getPixelRatio();
        this._width = size.width;
        this._height = size.height;
        renderTarget = this.renderTarget1.clone();
        renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }

      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this._width = width;
      this._height = height;
      var effectiveWidth = this._width * this._pixelRatio;
      var effectiveHeight = this._height * this._pixelRatio;
      this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
      this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

      for (var i = 0; i < this.passes.length; i++) {
        this.passes[i].setSize(effectiveWidth, effectiveHeight);
      }
    }
  }, {
    key: "setPixelRatio",
    value: function setPixelRatio(pixelRatio) {
      this._pixelRatio = pixelRatio;
      this.setSize(this._width, this._height);
    }
  }]);

  return EffectComposer;
}();var RenderPass = /*#__PURE__*/function (_Pass) {
  _inherits(RenderPass, _Pass);

  var _super = _createSuper(RenderPass);

  function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    var _this;

    _classCallCheck(this, RenderPass);

    _this = _super.call(this);
    _this.scene = scene;
    _this.camera = camera;
    _this.overrideMaterial = overrideMaterial;
    _this.clearColor = clearColor;
    _this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
    _this.clear = true;
    _this.clearDepth = false;
    _this.needsSwap = false;
    _this._oldClearColor = new Color$1();
    return _this;
  }

  _createClass(RenderPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer
    /*, deltaTime, maskActive */
    ) {
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      var oldClearAlpha, oldOverrideMaterial;

      if (this.overrideMaterial !== undefined) {
        oldOverrideMaterial = this.scene.overrideMaterial;
        this.scene.overrideMaterial = this.overrideMaterial;
      }

      if (this.clearColor) {
        renderer.getClearColor(this._oldClearColor);
        oldClearAlpha = renderer.getClearAlpha();
        renderer.setClearColor(this.clearColor, this.clearAlpha);
      }

      if (this.clearDepth) {
        renderer.clearDepth();
      }

      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

      if (this.clear) renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      renderer.render(this.scene, this.camera);

      if (this.clearColor) {
        renderer.setClearColor(this._oldClearColor, oldClearAlpha);
      }

      if (this.overrideMaterial !== undefined) {
        this.scene.overrideMaterial = oldOverrideMaterial;
      }

      renderer.autoClear = oldAutoClear;
    }
  }]);

  return RenderPass;
}(Pass);var HueSaturationShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "hue": {
      value: 0
    },
    "saturation": {
      value: 0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float hue;", "uniform float saturation;", "varying vec2 vUv;", "void main() {", "gl_FragColor = texture2D( tDiffuse, vUv );", // hue
  "float angle = hue * 3.14159265;", "float s = sin(angle), c = cos(angle);", "vec3 weights = (vec3(2.0 * c, -sqrt(3.0) * s - c, sqrt(3.0) * s - c) + 1.0) / 3.0;", "float len = length(gl_FragColor.rgb);", "gl_FragColor.rgb = vec3(", "dot(gl_FragColor.rgb, weights.xyz),", "dot(gl_FragColor.rgb, weights.zxy),", "dot(gl_FragColor.rgb, weights.yzx)", ");", // saturation
  "float average = (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3.0;", "if (saturation > 0.0) {", "gl_FragColor.rgb += (average - gl_FragColor.rgb) * (1.0 - 1.0 / (1.001 - saturation));", "} else {", "gl_FragColor.rgb += (average - gl_FragColor.rgb) * (-saturation);", "}", "}"].join("\n")
};
var HueSaturationEffect = (function (_ref) {
  var _ref$hue = _ref.hue,
      hue = _ref$hue === void 0 ? 0 : _ref$hue,
      _ref$saturation = _ref.saturation,
      saturation = _ref$saturation === void 0 ? 0 : _ref$saturation,
      _ref$renderToScreen = _ref.renderToScreen,
      renderToScreen = _ref$renderToScreen === void 0 ? false : _ref$renderToScreen;

  var shader = _objectSpread2$1({}, HueSaturationShader);

  shader.uniforms.hue.value = hue;
  shader.uniforms.saturation.value = saturation;
  var pass = new ShaderPass(shader);
  pass.renderToScreen = renderToScreen;
  return pass;
});var SepiaShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "amount": {
      value: 1.0
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform float amount;", "uniform sampler2D tDiffuse;", "varying vec2 vUv;", "void main() {", "vec4 color = texture2D( tDiffuse, vUv );", "vec3 c = color.rgb;", "color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );", "color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );", "color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );", "gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );", "}"].join("\n")
};
var SepiaEffect = (function (_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? 1.0 : _ref$value,
      _ref$renderToScreen = _ref.renderToScreen,
      renderToScreen = _ref$renderToScreen === void 0 ? false : _ref$renderToScreen;
  var shader = SepiaShader;
  shader.uniforms.amount.value = value;
  var pass = new ShaderPass(shader);
  pass.renderToScreen = renderToScreen;
  return pass;
});/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Convolution shader
 * ported from o3d sample to WebGL / GLSL
 * http://o3d.googlecode.com/svn/trunk/samples/convolution.html
 */
var ConvolutionShader = {
  defines: {
    "KERNEL_SIZE_FLOAT": "25.0",
    "KERNEL_SIZE_INT": "25"
  },
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "uImageIncrement": {
      value: new Vector2(0.001953125, 0.0)
    },
    "cKernel": {
      value: []
    }
  },
  vertexShader: ["uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vUv = uv - ((KERNEL_SIZE_FLOAT - 1.0) / 2.0) * uImageIncrement;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);", "}"].join("\n"),
  fragmentShader: ["uniform float cKernel[KERNEL_SIZE_INT];", "uniform sampler2D tDiffuse;", "uniform vec2 uImageIncrement;", "varying vec2 vUv;", "void main() {", "	vec2 imageCoord = vUv;", "	vec4 sum = vec4(0.0, 0.0, 0.0, 0.0);", "	for(int i = 0; i < KERNEL_SIZE_INT; i ++) {", "		sum += texture2D(tDiffuse, imageCoord) * cKernel[i];", "		imageCoord += uImageIncrement;", "	}", "	gl_FragColor = sum;", "}"].join("\n"),
  buildKernel: function buildKernel(sigma) {
    // We lop off the sqrt(2 * pi) * sigma term, since we're going to normalize anyway.
    function gauss(x, sigma) {
      return Math.exp(-(x * x) / (2.0 * sigma * sigma));
    }

    var i,
        values,
        sum,
        halfWidth,
        kMaxKernelSize = 25,
        kernelSize = 2 * Math.ceil(sigma * 3.0) + 1;
    if (kernelSize > kMaxKernelSize) kernelSize = kMaxKernelSize;
    halfWidth = (kernelSize - 1) * 0.5;
    values = new Array(kernelSize);
    sum = 0.0;

    for (i = 0; i < kernelSize; ++i) {
      values[i] = gauss(i - halfWidth, sigma);
      sum += values[i];
    } // normalize the kernel


    for (i = 0; i < kernelSize; ++i) {
      values[i] /= sum;
    }

    return values;
  }
};var BLUR_X = new Vector2(0.001953125, 0.0);
var BLUR_Y = new Vector2(0.0, 0.001953125);

var BloomPass = /*#__PURE__*/function (_Pass) {
  _inherits(BloomPass, _Pass);

  var _super = _createSuper(BloomPass);

  function BloomPass(_ref) {
    var _this;

    var _ref$strength = _ref.strength,
        strength = _ref$strength === void 0 ? 1 : _ref$strength,
        _ref$kernelSize = _ref.kernelSize,
        kernelSize = _ref$kernelSize === void 0 ? 25 : _ref$kernelSize,
        _ref$sigma = _ref.sigma,
        sigma = _ref$sigma === void 0 ? 4.0 : _ref$sigma,
        _ref$resolution = _ref.resolution,
        resolution = _ref$resolution === void 0 ? 256 : _ref$resolution,
        _ref$renderToScreen = _ref.renderToScreen,
        renderToScreen = _ref$renderToScreen === void 0 ? false : _ref$renderToScreen;

    _classCallCheck(this, BloomPass);

    _this = _super.call(this);
    var pars = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    _this.renderTargetX = new WebGLRenderTarget(resolution, resolution, pars);
    _this.renderTargetX.texture.name = "BloomPass.x";
    _this.renderTargetY = new WebGLRenderTarget(resolution, resolution, pars);
    _this.renderTargetY.texture.name = "BloomPass.y"; // copy material

    var copyShader = _objectSpread2$1({}, CopyShader);

    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    _this.copyUniforms["opacity"].value = strength;
    _this.materialCopy = new ShaderMaterial({
      uniforms: _this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: AdditiveBlending,
      transparent: true
    }); // convolution material

    var convolutionShader = _objectSpread2$1({}, ConvolutionShader);

    _this.convolutionUniforms = UniformsUtils.clone(convolutionShader.uniforms);
    _this.convolutionUniforms["uImageIncrement"].value = BLUR_X;
    _this.convolutionUniforms["cKernel"].value = ConvolutionShader.buildKernel(sigma);
    _this.materialConvolution = new ShaderMaterial({
      uniforms: _this.convolutionUniforms,
      vertexShader: convolutionShader.vertexShader,
      fragmentShader: convolutionShader.fragmentShader,
      defines: {
        "KERNEL_SIZE_FLOAT": kernelSize.toFixed(1),
        "KERNEL_SIZE_INT": kernelSize.toFixed(0)
      }
    });
    _this.needsSwap = false;
    _this.fsQuad = new FullScreenQuad(null);
    _this.renderToScreen = renderToScreen;
    return _this;
  }

  _createClass(BloomPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
      if (maskActive) renderer.state.buffers.stencil.setTest(false); // Render quad with blured scene into texture (convolution pass 1)

      this.fsQuad.material = this.materialConvolution;
      this.convolutionUniforms["tDiffuse"].value = readBuffer.texture;
      this.convolutionUniforms["uImageIncrement"].value = BLUR_X;
      renderer.setRenderTarget(this.renderTargetX);
      renderer.clear();
      this.fsQuad.render(renderer); // Render quad with blured scene into texture (convolution pass 2)

      this.convolutionUniforms["tDiffuse"].value = this.renderTargetX.texture;
      this.convolutionUniforms["uImageIncrement"].value = BLUR_Y;
      renderer.setRenderTarget(this.renderTargetY);
      renderer.clear();
      this.fsQuad.render(renderer); // Render original scene with superimposed blur to texture

      this.fsQuad.material = this.materialCopy;
      this.copyUniforms["tDiffuse"].value = this.renderTargetY.texture;
      if (maskActive) renderer.state.buffers.stencil.setTest(true);
      renderer.setRenderTarget(readBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
    }
  }]);

  return BloomPass;
}(Pass);/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Depth-of-field shader with bokeh
 * ported from GLSL shader by Martins Upitis
 * http://artmartinsh.blogspot.com/2010/02/glsl-lens-blur-filter-with-bokeh.html
 */
var BokehShader = {
  defines: {
    'DEPTH_PACKING': 1,
    'PERSPECTIVE_CAMERA': 1
  },
  uniforms: {
    'tColor': {
      value: null
    },
    'tDepth': {
      value: null
    },
    'focus': {
      value: 1.0
    },
    'aspect': {
      value: 1.0
    },
    'aperture': {
      value: 0.025
    },
    'maxblur': {
      value: 0.01
    },
    'nearClip': {
      value: 1.0
    },
    'farClip': {
      value: 1000.0
    }
  },
  vertexShader: ['varying vec2 vUv;', 'void main() {', '    vUv = uv;', '    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
  fragmentShader: ['#include <common>', 'varying vec2 vUv;', 'uniform sampler2D tColor;', 'uniform sampler2D tDepth;', 'uniform float maxblur;', // max blur amount
  'uniform float aperture;', // aperture - bigger values for shallower depth of field
  'uniform float nearClip;', 'uniform float farClip;', 'uniform float focus;', 'uniform float aspect;', '#include <packing>', 'float getDepth( const in vec2 screenPosition ) {', '    #if DEPTH_PACKING == 1', '    return unpackRGBAToDepth( texture2D( tDepth, screenPosition ) );', '    #else', '    return texture2D( tDepth, screenPosition ).x;', '    #endif', '}', 'float getViewZ( const in float depth ) {', '    #if PERSPECTIVE_CAMERA == 1', '    return perspectiveDepthToViewZ( depth, nearClip, farClip );', '    #else', '    return orthographicDepthToViewZ( depth, nearClip, farClip );', '    #endif', '}', 'void main() {', '    vec2 aspectcorrect = vec2( 1.0, aspect );', '    float viewZ = getViewZ( getDepth( vUv ) );', '    float factor = ( focus + viewZ );', // viewZ is <= 0, so this is a difference equation
  '    vec2 dofblur = vec2 ( clamp( factor * aperture, -maxblur, maxblur ) );', '    vec2 dofblur9 = dofblur * 0.9;', '    vec2 dofblur7 = dofblur * 0.7;', '    vec2 dofblur4 = dofblur * 0.4;', '    vec4 col = vec4( 0.0 );', '    col += texture2D( tColor, vUv.xy );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.15,  0.37 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.37,  0.15 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.37, -0.15 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.15, -0.37 ) * aspectcorrect ) * dofblur9 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.40,  0.0  ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur7 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,  -0.4  ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29,  0.29 ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.4,   0.0  ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2( -0.29, -0.29 ) * aspectcorrect ) * dofblur4 );', '    col += texture2D( tColor, vUv.xy + ( vec2(  0.0,   0.4  ) * aspectcorrect ) * dofblur4 );', '    gl_FragColor = col / 41.0;', '    gl_FragColor.a = 1.0;', '}'].join('\n')
};var BokehPass = /*#__PURE__*/function (_Pass) {
  _inherits(BokehPass, _Pass);

  var _super = _createSuper(BokehPass);

  function BokehPass(scene, camera, params) {
    var _this;

    _classCallCheck(this, BokehPass);

    _this = _super.call(this);
    var _params$focus = params.focus,
        focus = _params$focus === void 0 ? 1.0 : _params$focus,
        _params$aspect = params.aspect,
        aspect = _params$aspect === void 0 ? camera.aspect : _params$aspect,
        _params$aperture = params.aperture,
        aperture = _params$aperture === void 0 ? 0.025 : _params$aperture,
        _params$maxblur = params.maxblur,
        maxblur = _params$maxblur === void 0 ? 0.1 : _params$maxblur,
        _params$width = params.width,
        width = _params$width === void 0 ? window.innerWidth : _params$width,
        _params$height = params.height,
        height = _params$height === void 0 ? window.innerHeight : _params$height,
        _params$renderToScree = params.renderToScreen,
        renderToScreen = _params$renderToScree === void 0 ? false : _params$renderToScree;
    _this.scene = scene;
    _this.camera = camera;
    _this.renderTargetDepth = new WebGLRenderTarget(width, height, {
      minFilter: NearestFilter,
      magFilter: NearestFilter
    });
    _this.renderTargetDepth.texture.name = 'BokehPass.depth'; // depth material

    _this.materialDepth = new MeshDepthMaterial();
    _this.materialDepth.depthPacking = RGBADepthPacking;
    _this.materialDepth.blending = NoBlending;
    var bokehShader = BokehShader;
    var bokehUniforms = UniformsUtils.clone(bokehShader.uniforms);
    bokehUniforms['tDepth'].value = _this.renderTargetDepth.texture;
    bokehUniforms['focus'].value = focus;
    bokehUniforms['aspect'].value = aspect;
    bokehUniforms['aperture'].value = aperture;
    bokehUniforms['maxblur'].value = maxblur;
    bokehUniforms['nearClip'].value = camera.near;
    bokehUniforms['farClip'].value = camera.far;
    _this.materialBokeh = new ShaderMaterial({
      defines: Object.assign({}, bokehShader.defines),
      uniforms: bokehUniforms,
      vertexShader: bokehShader.vertexShader,
      fragmentShader: bokehShader.fragmentShader
    });
    _this.uniforms = bokehUniforms;
    _this.needsSwap = false;
    _this.fsQuad = new FullScreenQuad(_this.materialBokeh);
    _this._oldClearColor = new Color$1();
    _this.renderToScreen = renderToScreen;
    return _this;
  }

  _createClass(BokehPass, [{
    key: "setFocus",
    value: function setFocus(focus) {
      this.uniforms.focus.value = focus;
    }
  }, {
    key: "setAperture",
    value: function setAperture(aperture) {
      this.uniforms.aperture.value = aperture;
    }
  }, {
    key: "setMaxBlur",
    value: function setMaxBlur(maxblur) {
      this.uniforms.maxblur.value = maxblur;
    }
  }, {
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer
    /*, deltaTime, maskActive*/
    ) {
      this.scene.overrideMaterial = this.materialDepth;
      renderer.getClearColor(this._oldClearColor);
      var oldClearAlpha = renderer.getClearAlpha();
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      renderer.setClearColor(0xffffff);
      renderer.setClearAlpha(1.0);
      renderer.setRenderTarget(this.renderTargetDepth);
      renderer.clear();
      renderer.render(this.scene, this.camera); // Render bokeh composite

      this.uniforms['tColor'].value = readBuffer.texture;
      this.uniforms['nearClip'].value = this.camera.near;
      this.uniforms['farClip'].value = this.camera.far;

      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        renderer.clear();
        this.fsQuad.render(renderer);
      }

      this.scene.overrideMaterial = null;
      renderer.setClearColor(this._oldClearColor);
      renderer.setClearAlpha(oldClearAlpha);
      renderer.autoClear = oldAutoClear;
    }
  }]);

  return BokehPass;
}(Pass);var DepthOfField = /*#__PURE__*/function (_BokehPass) {
  _inherits(DepthOfField, _BokehPass);

  var _super = _createSuper(DepthOfField);

  function DepthOfField(params) {
    _classCallCheck(this, DepthOfField);

    var _config$screen = Config$1.screen(),
        width = _config$screen.w,
        height = _config$screen.h,
        aspect = _config$screen.ratio;

    return _super.call(this, Scene$1.scene, Scene$1.getCameraBody(), _objectSpread2$1(_objectSpread2$1({}, params), {}, {
      width: width,
      height: height,
      aspect: aspect
    }));
  }

  return DepthOfField;
}(BokehPass);/**
 * THANKS TO https://flatuicolors.com/ for providing the palettes below.
 */
var BASE = {
  WHITE: 0XFFFFFF,
  BLACK: 0x000000,
  RED: 0xFF0000,
  GREEN: 0x00FF00,
  BLUE: 0x0000FF,
  YELLOW: 0xFFFF00,
  CYAN: 0x00FFFF,
  MAGENTA: 0xFF00FF,
  SILVER: 0xC0C0C0,
  GRAY: 0x808080,
  MAROON: 0x800000,
  OLIVE: 0x808000,
  PURPLE: 0x800080,
  TEAL: 0x008080,
  NAVY: 0x000080
};
var FRENCH_PALETTE = {
  /**
   * french palette by Lea Poisson https://bit.ly/3iEo73B from 🇫🇷
   */
  FLAT_FLESH: 0Xfad390,
  SQUASH_BLOSSOM: 0Xf6b93b,
  ICELAND_POPPY: 0Xfa983a,
  CARROT_ORANGE: 0Xe58e26,
  MELON_MELODY: 0Xf8c291,
  MANDARIN_RED: 0Xe55039,
  TOMATO_RED: 0Xeb2f06,
  JALAPENO_RED: 0Xb71540,
  LIVID: 0X6a89cc,
  AZRAQ_BLUE: 0X4a69bd,
  YUE_GUANG_LAN_BLUE: 0X1e3799,
  DARK_SAPPHIRE: 0X0c2461,
  SPRAY: 0X82ccdd,
  DUPAIN: 0X60a3bc,
  GOOD_SAMARITAN: 0X3c6382,
  FOREST_BLUE: 0X0a3d62,
  PARADISE_GREEN: 0Xb8e994,
  AURORA_GREEN: 0X78e08f,
  WATERFALL: 0X38ada9,
  REEF_ENCOUNTER: 0X079992
};
var PALETTES = {
  BASE: BASE,
  FRENCH_PALETTE: FRENCH_PALETTE,
  FRENCH: FRENCH_PALETTE
};var MAX_EDGE_THICKNESS = 4;
var MAX_EDGE_GLOW = 4;
var DEFAULT_EDGE_GLOW = 0.0;
var DEFAULT_EDGE_THICKNES = 1.0;
var DEFAULT_EDGE_STRENGTH = 10.0;
var BlurDirectionX = new Vector2(1.0, 0.0);
var BlurDirectionY = new Vector2(0.0, 1.0);

var replaceDepthToViewZ = function replaceDepthToViewZ(string, camera) {
  var type = camera.isPerspectiveCamera ? 'perspective' : 'orthographic';
  return string.replace(/DEPTH_TO_VIEW_Z/g, type + 'DepthToViewZ');
};

var SelectiveOutline = /*#__PURE__*/function (_Pass) {
  _inherits(SelectiveOutline, _Pass);

  var _super = _createSuper(SelectiveOutline);

  function SelectiveOutline(_ref) {
    var _this;

    var _ref$resolution = _ref.resolution,
        resolution = _ref$resolution === void 0 ? {} : _ref$resolution,
        _ref$selectedObjects = _ref.selectedObjects,
        selectedObjects = _ref$selectedObjects === void 0 ? [] : _ref$selectedObjects,
        _ref$visibleEdgeColor = _ref.visibleEdgeColor,
        visibleEdgeColor = _ref$visibleEdgeColor === void 0 ? PALETTES.BASE.WHITE : _ref$visibleEdgeColor,
        _ref$hiddenEdgeColor = _ref.hiddenEdgeColor,
        hiddenEdgeColor = _ref$hiddenEdgeColor === void 0 ? PALETTES.BASE.WHITE : _ref$hiddenEdgeColor;

    _classCallCheck(this, SelectiveOutline);

    _this = _super.call(this);
    _this.isPass = true;

    var _config$screen = Config$1.screen(),
        height = _config$screen.h,
        width = _config$screen.w;

    var _resolution$x = resolution.x,
        resolutionX = _resolution$x === void 0 ? width : _resolution$x,
        _resolution$y = resolution.y,
        resolutionY = _resolution$y === void 0 ? height : _resolution$y;
    _this.renderScene = Scene$1.getScene();
    _this.renderCamera = Scene$1.getCameraBody();
    _this.selectedObjects = selectedObjects;
    _this.visibleEdgeColor = new Color$1(visibleEdgeColor);
    _this.hiddenEdgeColor = new Color$1(hiddenEdgeColor);
    _this.edgeGlow = DEFAULT_EDGE_GLOW;
    _this.usePatternTexture = false;
    _this.edgeThickness = DEFAULT_EDGE_THICKNES;
    _this.edgeStrength = DEFAULT_EDGE_STRENGTH;
    _this.downSampleRatio = 2;
    _this.pulsePeriod = 0;
    _this._visibilityCache = new Map();
    _this.resolution = new Vector2(resolutionX, resolutionY);
    var pars = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBAFormat
    };
    var resx = Math.round(_this.resolutionX / _this.downSampleRatio);
    var resy = Math.round(_this.resolutionY / _this.downSampleRatio);
    _this.renderTargetMaskBuffer = new WebGLRenderTarget(_this.resolutionX, _this.resolutionY, pars);
    _this.renderTargetMaskBuffer.texture.name = 'OutlinePass.mask';
    _this.renderTargetMaskBuffer.texture.generateMipmaps = false;
    _this.depthMaterial = new MeshDepthMaterial();
    _this.depthMaterial.side = DoubleSide;
    _this.depthMaterial.depthPacking = RGBADepthPacking;
    _this.depthMaterial.blending = NoBlending;
    _this.prepareMaskMaterial = _this.getPrepareMaskMaterial();
    _this.prepareMaskMaterial.side = DoubleSide;
    _this.prepareMaskMaterial.fragmentShader = replaceDepthToViewZ(_this.prepareMaskMaterial.fragmentShader, _this.renderCamera);
    _this.renderTargetDepthBuffer = new WebGLRenderTarget(_this.resolutionX, _this.resolutionY, pars);
    _this.renderTargetDepthBuffer.texture.name = 'OutlinePass.depth';
    _this.renderTargetDepthBuffer.texture.generateMipmaps = false;
    _this.renderTargetMaskDownSampleBuffer = new WebGLRenderTarget(resx, resy, pars);
    _this.renderTargetMaskDownSampleBuffer.texture.name = 'OutlinePass.depthDownSample';
    _this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = false;
    _this.renderTargetBlurBuffer1 = new WebGLRenderTarget(resx, resy, pars);
    _this.renderTargetBlurBuffer1.texture.name = 'OutlinePass.blur1';
    _this.renderTargetBlurBuffer1.texture.generateMipmaps = false;
    _this.renderTargetBlurBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
    _this.renderTargetBlurBuffer2.texture.name = 'OutlinePass.blur2';
    _this.renderTargetBlurBuffer2.texture.generateMipmaps = false;
    _this.edgeDetectionMaterial = _this.getEdgeDetectionMaterial();
    _this.renderTargetEdgeBuffer1 = new WebGLRenderTarget(resx, resy, pars);
    _this.renderTargetEdgeBuffer1.texture.name = 'OutlinePass.edge1';
    _this.renderTargetEdgeBuffer1.texture.generateMipmaps = false;
    _this.renderTargetEdgeBuffer2 = new WebGLRenderTarget(Math.round(resx / 2), Math.round(resy / 2), pars);
    _this.renderTargetEdgeBuffer2.texture.name = 'OutlinePass.edge2';
    _this.renderTargetEdgeBuffer2.texture.generateMipmaps = false;
    _this.separableBlurMaterial1 = _this.getSeperableBlurMaterial(MAX_EDGE_THICKNESS);

    _this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);

    _this.separableBlurMaterial1.uniforms['kernelRadius'].value = 1;
    _this.separableBlurMaterial2 = _this.getSeperableBlurMaterial(MAX_EDGE_GLOW);

    _this.separableBlurMaterial2.uniforms['texSize'].value.set(Math.round(resx / 2), Math.round(resy / 2));

    _this.separableBlurMaterial2.uniforms['kernelRadius'].value = MAX_EDGE_GLOW; // Overlay material

    _this.overlayMaterial = _this.getOverlayMaterial(); // copy material

    if (CopyShader === undefined) console.error('THREE.OutlinePass relies on CopyShader');
    var copyShader = CopyShader;
    _this.copyUniforms = UniformsUtils.clone(copyShader.uniforms);
    _this.copyUniforms['opacity'].value = 1.0;
    _this.materialCopy = new ShaderMaterial({
      uniforms: _this.copyUniforms,
      vertexShader: copyShader.vertexShader,
      fragmentShader: copyShader.fragmentShader,
      blending: NoBlending,
      depthTest: false,
      depthWrite: false,
      transparent: true
    });
    _this.enabled = true;
    _this.needsSwap = false;
    _this._oldClearColor = new Color$1();
    _this.oldClearAlpha = 1;
    _this.fsQuad = new FullScreenQuad(null);
    _this.tempPulseColor1 = new Color$1();
    _this.tempPulseColor2 = new Color$1();
    _this.textureMatrix = new Matrix4();
    return _this;
  }

  _createClass(SelectiveOutline, [{
    key: "setSelectedObjects",
    value: function setSelectedObjects() {
      var selectedObjects = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.selectedObjects = selectedObjects.map(function (o) {
        return o.getBody();
      });
    }
  }, {
    key: "setVisibleEdgeColor",
    value: function setVisibleEdgeColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PALETTES.BASE.WHITE;
      this.visibleEdgeColor = new Color$1(color);
    }
  }, {
    key: "setHiddenEdgeColor",
    value: function setHiddenEdgeColor() {
      var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : PALETTES.BASE.WHITE;
      this.hiddenEdgeColor = new Color$1(color);
    }
  }, {
    key: "setEdgeGlow",
    value: function setEdgeGlow() {
      var glow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EDGE_GLOW;
      this.edgeGlow = glow;
    }
  }, {
    key: "setEdgeStrength",
    value: function setEdgeStrength() {
      var strength = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EDGE_STRENGTH;
      this.edgeStrength = strength;
    }
  }, {
    key: "setEdgeThickness",
    value: function setEdgeThickness() {
      var thickness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_EDGE_THICKNES;
      this.edgeThickness = thickness;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.renderTargetMaskBuffer.dispose();
      this.renderTargetDepthBuffer.dispose();
      this.renderTargetMaskDownSampleBuffer.dispose();
      this.renderTargetBlurBuffer1.dispose();
      this.renderTargetBlurBuffer2.dispose();
      this.renderTargetEdgeBuffer1.dispose();
      this.renderTargetEdgeBuffer2.dispose();
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this.renderTargetMaskBuffer.setSize(width, height);
      this.renderTargetDepthBuffer.setSize(width, height);
      var resx = Math.round(width / this.downSampleRatio);
      var resy = Math.round(height / this.downSampleRatio);
      this.renderTargetMaskDownSampleBuffer.setSize(resx, resy);
      this.renderTargetBlurBuffer1.setSize(resx, resy);
      this.renderTargetEdgeBuffer1.setSize(resx, resy);
      this.separableBlurMaterial1.uniforms['texSize'].value.set(resx, resy);
      resx = Math.round(resx / 2);
      resy = Math.round(resy / 2);
      this.renderTargetBlurBuffer2.setSize(resx, resy);
      this.renderTargetEdgeBuffer2.setSize(resx, resy);
      this.separableBlurMaterial2.uniforms['texSize'].value.set(resx, resy);
    }
  }, {
    key: "changeVisibilityOfSelectedObjects",
    value: function changeVisibilityOfSelectedObjects(bVisible) {
      var cache = this._visibilityCache;

      function gatherSelectedMeshesCallBack(object) {
        if (object.isMesh) {
          if (bVisible === true) {
            object.visible = cache.get(object);
          } else {
            cache.set(object, object.visible);
            object.visible = bVisible;
          }
        }
      }

      for (var i = 0; i < this.selectedObjects.length; i++) {
        var selectedObject = this.selectedObjects[i];
        selectedObject.traverse(gatherSelectedMeshesCallBack);
      }
    }
  }, {
    key: "changeVisibilityOfNonSelectedObjects",
    value: function changeVisibilityOfNonSelectedObjects(bVisible) {
      var cache = this._visibilityCache;
      var selectedMeshes = [];

      function gatherSelectedMeshesCallBack(object) {
        if (object.isMesh) selectedMeshes.push(object);
      }

      for (var i = 0; i < this.selectedObjects.length; i++) {
        var selectedObject = this.selectedObjects[i];
        selectedObject.traverse(gatherSelectedMeshesCallBack);
      }

      function VisibilityChangeCallBack(object) {
        if (object.isMesh || object.isSprite) {
          // only meshes and sprites are supported by OutlinePass
          var bFound = false;

          for (var _i = 0; _i < selectedMeshes.length; _i++) {
            var selectedObjectId = selectedMeshes[_i].id;

            if (selectedObjectId === object.id) {
              bFound = true;
              break;
            }
          }

          if (bFound === false) {
            var visibility = object.visible;

            if (bVisible === false || cache.get(object) === true) {
              object.visible = bVisible;
            }

            cache.set(object, visibility);
          }
        } else if (object.isPoints || object.isLine) {
          // the visibilty of points and lines is always set to false in order to
          // not affect the outline computation
          if (bVisible === true) {
            object.visible = cache.get(object); // restore
          } else {
            cache.set(object, object.visible);
            object.visible = bVisible;
          }
        }
      }

      this.renderScene.traverse(VisibilityChangeCallBack);
    }
  }, {
    key: "updateTextureMatrix",
    value: function updateTextureMatrix() {
      this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      this.textureMatrix.multiply(this.renderCamera.projectionMatrix);
      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
    }
  }, {
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer, deltaTime, maskActive) {
      if (this.selectedObjects.length > 0) {
        renderer.getClearColor(this._oldClearColor);
        this.oldClearAlpha = renderer.getClearAlpha();
        var oldAutoClear = renderer.autoClear;
        renderer.autoClear = false;
        if (maskActive) renderer.state.buffers.stencil.setTest(false);
        renderer.setClearColor(0xffffff, 1); // Make selected objects invisible

        this.changeVisibilityOfSelectedObjects(false);
        var currentBackground = this.renderScene.background;
        this.renderScene.background = null; // 1. Draw Non Selected objects in the depth buffer

        this.renderScene.overrideMaterial = this.depthMaterial;
        renderer.setRenderTarget(this.renderTargetDepthBuffer);
        renderer.clear();
        renderer.render(this.renderScene, this.renderCamera); // Make selected objects visible

        this.changeVisibilityOfSelectedObjects(true);

        this._visibilityCache.clear(); // Update Texture Matrix for Depth compare


        this.updateTextureMatrix(); // Make non selected objects invisible, and draw only the selected objects, by comparing the depth buffer of non selected objects

        this.changeVisibilityOfNonSelectedObjects(false);
        this.renderScene.overrideMaterial = this.prepareMaskMaterial;
        this.prepareMaskMaterial.uniforms['cameraNearFar'].value.set(this.renderCamera.near, this.renderCamera.far);
        this.prepareMaskMaterial.uniforms['depthTexture'].value = this.renderTargetDepthBuffer.texture;
        this.prepareMaskMaterial.uniforms['textureMatrix'].value = this.textureMatrix;
        renderer.setRenderTarget(this.renderTargetMaskBuffer);
        renderer.clear();
        renderer.render(this.renderScene, this.renderCamera);
        this.renderScene.overrideMaterial = null;
        this.changeVisibilityOfNonSelectedObjects(true);

        this._visibilityCache.clear();

        this.renderScene.background = currentBackground; // 2. Downsample to Half resolution

        this.fsQuad.material = this.materialCopy;
        this.copyUniforms['tDiffuse'].value = this.renderTargetMaskBuffer.texture;
        renderer.setRenderTarget(this.renderTargetMaskDownSampleBuffer);
        renderer.clear();
        this.fsQuad.render(renderer);
        this.tempPulseColor1.copy(this.visibleEdgeColor);
        this.tempPulseColor2.copy(this.hiddenEdgeColor);

        if (this.pulsePeriod > 0) {
          var scalar = (1 + 0.25) / 2 + Math.cos(performance.now() * 0.01 / this.pulsePeriod) * (1.0 - 0.25) / 2;
          this.tempPulseColor1.multiplyScalar(scalar);
          this.tempPulseColor2.multiplyScalar(scalar);
        } // 3. Apply Edge Detection Pass


        this.fsQuad.material = this.edgeDetectionMaterial;
        this.edgeDetectionMaterial.uniforms['maskTexture'].value = this.renderTargetMaskDownSampleBuffer.texture;
        this.edgeDetectionMaterial.uniforms['texSize'].value.set(this.renderTargetMaskDownSampleBuffer.width, this.renderTargetMaskDownSampleBuffer.height);
        this.edgeDetectionMaterial.uniforms['visibleEdgeColor'].value.set(this.tempPulseColor1.getHex());
        this.edgeDetectionMaterial.uniforms['hiddenEdgeColor'].value.set(this.tempPulseColor2.getHex());
        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
        renderer.clear();
        this.fsQuad.render(renderer); // 4. Apply Blur on Half res

        this.fsQuad.material = this.separableBlurMaterial1;
        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;
        this.separableBlurMaterial1.uniforms['direction'].value = BlurDirectionX;
        this.separableBlurMaterial1.uniforms['kernelRadius'].value = this.edgeThickness;
        renderer.setRenderTarget(this.renderTargetBlurBuffer1);
        renderer.clear();
        this.fsQuad.render(renderer);
        this.separableBlurMaterial1.uniforms['colorTexture'].value = this.renderTargetBlurBuffer1.texture;
        this.separableBlurMaterial1.uniforms['direction'].value = BlurDirectionY;
        renderer.setRenderTarget(this.renderTargetEdgeBuffer1);
        renderer.clear();
        this.fsQuad.render(renderer); // Apply Blur on quarter res

        this.fsQuad.material = this.separableBlurMaterial2;
        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetEdgeBuffer1.texture;
        this.separableBlurMaterial2.uniforms['direction'].value = BlurDirectionX;
        renderer.setRenderTarget(this.renderTargetBlurBuffer2);
        renderer.clear();
        this.fsQuad.render(renderer);
        this.separableBlurMaterial2.uniforms['colorTexture'].value = this.renderTargetBlurBuffer2.texture;
        this.separableBlurMaterial2.uniforms['direction'].value = BlurDirectionY;
        renderer.setRenderTarget(this.renderTargetEdgeBuffer2);
        renderer.clear();
        this.fsQuad.render(renderer); // Blend it additively over the input texture

        this.fsQuad.material = this.overlayMaterial;
        this.overlayMaterial.uniforms['maskTexture'].value = this.renderTargetMaskBuffer.texture;
        this.overlayMaterial.uniforms['edgeTexture1'].value = this.renderTargetEdgeBuffer1.texture;
        this.overlayMaterial.uniforms['edgeTexture2'].value = this.renderTargetEdgeBuffer2.texture;
        this.overlayMaterial.uniforms['patternTexture'].value = this.patternTexture;
        this.overlayMaterial.uniforms['edgeStrength'].value = this.edgeStrength;
        this.overlayMaterial.uniforms['edgeGlow'].value = this.edgeGlow;
        this.overlayMaterial.uniforms['usePatternTexture'].value = this.usePatternTexture;
        if (maskActive) renderer.state.buffers.stencil.setTest(true);
        renderer.setRenderTarget(readBuffer);
        this.fsQuad.render(renderer);
        renderer.setClearColor(this._oldClearColor, this.oldClearAlpha);
        renderer.autoClear = oldAutoClear;
      }

      if (this.renderToScreen) {
        this.fsQuad.material = this.materialCopy;
        this.copyUniforms['tDiffuse'].value = readBuffer.texture;
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      }
    }
  }, {
    key: "getPrepareMaskMaterial",
    value: function getPrepareMaskMaterial() {
      return new ShaderMaterial({
        uniforms: {
          'depthTexture': {
            value: null
          },
          'cameraNearFar': {
            value: new Vector2(0.5, 0.5)
          },
          'textureMatrix': {
            value: null
          }
        },
        vertexShader: "#include <morphtarget_pars_vertex>\n                #include <skinning_pars_vertex>\n\n                varying vec4 projTexCoord;\n                varying vec4 vPosition;\n                uniform mat4 textureMatrix;\n\n                void main() {\n\n                    #include <skinbase_vertex>\n                    #include <begin_vertex>\n                    #include <morphtarget_vertex>\n                    #include <skinning_vertex>\n                    #include <project_vertex>\n\n                    vPosition = mvPosition;\n                    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n                    projTexCoord = textureMatrix * worldPosition;\n\n                }",
        fragmentShader: "#include <packing>\n                varying vec4 vPosition;\n                varying vec4 projTexCoord;\n                uniform sampler2D depthTexture;\n                uniform vec2 cameraNearFar;\n\n                void main() {\n\n                    float depth = unpackRGBAToDepth(texture2DProj(depthTexture, projTexCoord));\n                    float viewZ = - DEPTH_TO_VIEW_Z(depth, cameraNearFar.x, cameraNearFar.y);\n                    float depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n                    gl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n                }"
      });
    }
  }, {
    key: "getEdgeDetectionMaterial",
    value: function getEdgeDetectionMaterial() {
      return new ShaderMaterial({
        uniforms: {
          'maskTexture': {
            value: null
          },
          'texSize': {
            value: new Vector2(0.5, 0.5)
          },
          'visibleEdgeColor': {
            value: new Color$1(1.0, 1.0, 1.0)
          },
          'hiddenEdgeColor': {
            value: new Color$1(1.0, 1.0, 1.0)
          }
        },
        vertexShader: "varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",
        fragmentShader: "varying vec2 vUv;\n\n                uniform sampler2D maskTexture;\n                uniform vec2 texSize;\n                uniform vec3 visibleEdgeColor;\n                uniform vec3 hiddenEdgeColor;\n\n                void main() {\n                    vec2 invSize = 1.0 / texSize;\n                    vec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n                    vec4 c1 = texture2D(maskTexture, vUv + uvOffset.xy);\n                    vec4 c2 = texture2D(maskTexture, vUv - uvOffset.xy);\n                    vec4 c3 = texture2D(maskTexture, vUv + uvOffset.yw);\n                    vec4 c4 = texture2D(maskTexture, vUv - uvOffset.yw);\n                    float diff1 = (c1.r - c2.r)*0.5;\n                    float diff2 = (c3.r - c4.r)*0.5;\n                    float d = length(vec2(diff1, diff2));\n                    float a1 = min(c1.g, c2.g);\n                    float a2 = min(c3.g, c4.g);\n                    float visibilityFactor = min(a1, a2);\n                    vec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n                    gl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n                }"
      });
    }
  }, {
    key: "getSeperableBlurMaterial",
    value: function getSeperableBlurMaterial(maxRadius) {
      return new ShaderMaterial({
        defines: {
          'MAX_RADIUS': maxRadius
        },
        uniforms: {
          'colorTexture': {
            value: null
          },
          'texSize': {
            value: new Vector2(0.5, 0.5)
          },
          'direction': {
            value: new Vector2(0.5, 0.5)
          },
          'kernelRadius': {
            value: 1.0
          }
        },
        vertexShader: "varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",
        fragmentShader: "#include <common>\n                varying vec2 vUv;\n                uniform sampler2D colorTexture;\n                uniform vec2 texSize;\n                uniform vec2 direction;\n                uniform float kernelRadius;\n\n                float gaussianPdf(in float x, in float sigma) {\n                    return 0.39894 * exp(-0.5 * x * x/(sigma * sigma))/sigma;\n                }\n\n                void main() {\n                    vec2 invSize = 1.0 / texSize;\n                    float weightSum = gaussianPdf(0.0, kernelRadius);\n                    vec4 diffuseSum = texture2D(colorTexture, vUv) * weightSum;\n                    vec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n                    vec2 uvOffset = delta;\n                    for(int i = 1; i <= MAX_RADIUS; i ++) {\n                        float w = gaussianPdf(uvOffset.x, kernelRadius);\n                        vec4 sample1 = texture2D(colorTexture, vUv + uvOffset);\n                        vec4 sample2 = texture2D(colorTexture, vUv - uvOffset);\n                        diffuseSum += ((sample1 + sample2) * w);\n                        weightSum += (2.0 * w);\n                        uvOffset += delta;\n                    }\n                    gl_FragColor = diffuseSum/weightSum;\n                }"
      });
    }
  }, {
    key: "getOverlayMaterial",
    value: function getOverlayMaterial() {
      return new ShaderMaterial({
        uniforms: {
          'maskTexture': {
            value: null
          },
          'edgeTexture1': {
            value: null
          },
          'edgeTexture2': {
            value: null
          },
          'patternTexture': {
            value: null
          },
          'edgeStrength': {
            value: 1.0
          },
          'edgeGlow': {
            value: 1.0
          },
          'usePatternTexture': {
            value: 0.0
          }
        },
        vertexShader: "varying vec2 vUv;\n\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }",
        fragmentShader: "varying vec2 vUv;\n\n                uniform sampler2D maskTexture;\n                uniform sampler2D edgeTexture1;\n                uniform sampler2D edgeTexture2;\n                uniform sampler2D patternTexture;\n                uniform float edgeStrength;\n                uniform float edgeGlow;\n                uniform bool usePatternTexture;\n\n                void main() {\n                    vec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n                    vec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n                    vec4 maskColor = texture2D(maskTexture, vUv);\n                    vec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n                    float visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n                    vec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n                    vec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n                    if(usePatternTexture)\n                        finalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n                    gl_FragColor = finalColor;\n                }",
        blending: AdditiveBlending,
        depthTest: false,
        depthWrite: false,
        transparent: true
      });
    }
  }]);

  return SelectiveOutline;
}(Pass);/**
 * RGB Shift Shader
 * Shifts red and blue channels from center in opposite directions
 * Ported from http://kriss.cx/tom/2009/05/rgb-shift/
 * by Tom Butterworth / http://kriss.cx/tom/
 *
 * amount: shift distance (1 is width of input)
 * angle: shift angle in radians
 */
var DigitalGlitch = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    //diffuse texture
    "tDisp": {
      value: null
    },
    //displacement texture for digital glitch squares
    "byp": {
      value: 0
    },
    //apply the glitch ?
    "amount": {
      value: 0.08
    },
    "angle": {
      value: 0.02
    },
    "seed": {
      value: 0.02
    },
    "seed_x": {
      value: 0.02
    },
    //-1,1
    "seed_y": {
      value: 0.02
    },
    //-1,1
    "distortion_x": {
      value: 0.5
    },
    "distortion_y": {
      value: 0.6
    },
    "col_s": {
      value: 0.05
    }
  },
  vertexShader: ["varying vec2 vUv;", "void main() {", "	vUv = uv;", "	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform int byp;", //should we apply the glitch ?
  "uniform sampler2D tDiffuse;", "uniform sampler2D tDisp;", "uniform float amount;", "uniform float angle;", "uniform float seed;", "uniform float seed_x;", "uniform float seed_y;", "uniform float distortion_x;", "uniform float distortion_y;", "uniform float col_s;", "varying vec2 vUv;", "float rand(vec2 co){", "	return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);", "}", "void main() {", "	if(byp<1) {", "		vec2 p = vUv;", "		float xs = floor(gl_FragCoord.x / 0.5);", "		float ys = floor(gl_FragCoord.y / 0.5);", //based on staffantans glitch shader for unity https://github.com/staffantan/unityglitch
  "		vec4 normal = texture2D (tDisp, p*seed*seed);", "		if(p.y<distortion_x+col_s && p.y>distortion_x-col_s*seed) {", "			if(seed_x>0.){", "				p.y = 1. - (p.y + distortion_y);", "			}", "			else {", "				p.y = distortion_y;", "			}", "		}", "		if(p.x<distortion_y+col_s && p.x>distortion_y-col_s*seed) {", "			if(seed_y>0.){", "				p.x=distortion_x;", "			}", "			else {", "				p.x = 1. - (p.x + distortion_x);", "			}", "		}", "		p.x+=normal.x*seed_x*(seed/5.);", "		p.y+=normal.y*seed_y*(seed/5.);", //base from RGB shift shader
  "		vec2 offset = amount * vec2( cos(angle), sin(angle));", "		vec4 cr = texture2D(tDiffuse, p + offset);", "		vec4 cga = texture2D(tDiffuse, p);", "		vec4 cb = texture2D(tDiffuse, p - offset);", "		gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);", //add noise
  "		vec4 snow = 200.*amount*vec4(rand(vec2(xs * seed,ys * seed*50.))*0.2);", "		gl_FragColor = gl_FragColor+ snow;", "	}", "	else {", "		gl_FragColor=texture2D (tDiffuse, vUv);", "	}", "}"].join("\n")
};var GlitchEffect = /*#__PURE__*/function (_Pass) {
  _inherits(GlitchEffect, _Pass);

  var _super = _createSuper(GlitchEffect);

  function GlitchEffect(_ref) {
    var _this;

    var _ref$dt_size = _ref.dt_size,
        dt_size = _ref$dt_size === void 0 ? 64 : _ref$dt_size;

    _classCallCheck(this, GlitchEffect);

    _this = _super.call(this);
    _this.uniforms = UniformsUtils.clone(DigitalGlitch.uniforms);
    _this.uniforms["tDisp"].value = _this.generateHeightmap(dt_size);
    _this.material = new ShaderMaterial({
      uniforms: _this.uniforms,
      vertexShader: DigitalGlitch.vertexShader,
      fragmentShader: DigitalGlitch.fragmentShader
    });
    _this.fsQuad = new FullScreenQuad(_this.material);
    _this.goWild = false;
    _this.curF = 0;

    _this.generateTrigger();

    return _this;
  }

  _createClass(GlitchEffect, [{
    key: "shouldGoWild",
    value: function shouldGoWild(flag) {
      this.goWild = flag;
    }
  }, {
    key: "generateTrigger",
    value: function generateTrigger() {
      this.randX = MathUtils.randInt(120, 240);
    }
  }, {
    key: "generateHeightmap",
    value: function generateHeightmap(dt_size) {
      var data_arr = new Float32Array(dt_size * dt_size * 3);
      var length = dt_size * dt_size;

      for (var i = 0; i < length; i++) {
        var val = MathUtils.randFloat(0, 1);
        data_arr[i * 3 + 0] = val;
        data_arr[i * 3 + 1] = val;
        data_arr[i * 3 + 2] = val;
      }

      return new DataTexture(data_arr, dt_size, dt_size, RGBFormat, FloatType$1);
    }
  }, {
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer) {
      this.uniforms["tDiffuse"].value = readBuffer.texture;
      this.uniforms['seed'].value = Math.random(); //default seeding

      this.uniforms['byp'].value = 0;

      if (this.curF % this.randX == 0 || this.goWild == true) {
        this.uniforms['amount'].value = Math.random() / 30;
        this.uniforms['angle'].value = MathUtils.randFloat(-Math.PI, Math.PI);
        this.uniforms['seed_x'].value = MathUtils.randFloat(-1, 1);
        this.uniforms['seed_y'].value = MathUtils.randFloat(-1, 1);
        this.uniforms['distortion_x'].value = MathUtils.randFloat(0, 1);
        this.uniforms['distortion_y'].value = MathUtils.randFloat(0, 1);
        this.curF = 0;
        this.generateTrigger();
      } else if (this.curF % this.randX < this.randX / 5) {
        this.uniforms['amount'].value = Math.random() / 90;
        this.uniforms['angle'].value = MathUtils.randFloat(-Math.PI, Math.PI);
        this.uniforms['distortion_x'].value = MathUtils.randFloat(0, 1);
        this.uniforms['distortion_y'].value = MathUtils.randFloat(0, 1);
        this.uniforms['seed_x'].value = MathUtils.randFloat(-0.3, 0.3);
        this.uniforms['seed_y'].value = MathUtils.randFloat(-0.3, 0.3);
      } else if (this.goWild == false) {
        this.uniforms['byp'].value = 1;
      }

      this.curF++;

      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer);
        if (this.clear) renderer.clear();
        this.fsQuad.render(renderer);
      }
    }
  }]);

  return GlitchEffect;
}(Pass);var PixelShader = {
  uniforms: {
    "tDiffuse": {
      value: null
    },
    "resolution": {
      value: null
    },
    "pixelSize": {
      value: 1.
    }
  },
  vertexShader: ["varying highp vec2 vUv;", "void main() {", "vUv = uv;", "gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );", "}"].join("\n"),
  fragmentShader: ["uniform sampler2D tDiffuse;", "uniform float pixelSize;", "uniform vec2 resolution;", "varying highp vec2 vUv;", "void main(){", "vec2 dxy = pixelSize / resolution;", "vec2 coord = dxy * floor( vUv / dxy );", "gl_FragColor = texture2D(tDiffuse, coord);", "}"].join("\n")
};

var PixelEffect = /*#__PURE__*/function (_ShaderPass) {
  _inherits(PixelEffect, _ShaderPass);

  var _super = _createSuper(PixelEffect);

  function PixelEffect(_ref) {
    var _this;

    var _ref$pixelSize = _ref.pixelSize,
        pixelSize = _ref$pixelSize === void 0 ? 16 : _ref$pixelSize,
        _ref$renderToScreen = _ref.renderToScreen,
        renderToScreen = _ref$renderToScreen === void 0 ? false : _ref$renderToScreen;

    _classCallCheck(this, PixelEffect);

    var _Config$screen = Config$1.screen(),
        h = _Config$screen.h,
        w = _Config$screen.w,
        devicePixelRatio = _Config$screen.devicePixelRatio;

    _this = _super.call(this, PixelShader);
    _this.renderToScreen = renderToScreen;
    _this.uniforms["pixelSize"].value = pixelSize;
    _this.uniforms["resolution"].value = new Vector2(w, h);

    _this.uniforms["resolution"].value.multiplyScalar(devicePixelRatio);

    return _this;
  }

  _createClass(PixelEffect, [{
    key: "setPixelSize",
    value: function setPixelSize() {
      var pixelSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;
      this.uniforms["pixelSize"].value = pixelSize;
    }
  }, {
    key: "onWindowResize",
    value: function onWindowResize() {
      var _Config$screen2 = Config$1.screen(),
          h = _Config$screen2.h,
          w = _Config$screen2.w,
          devicePixelRatio = _Config$screen2.devicePixelRatio;

      this.uniforms["resolution"].value.set(w, h).multiplyScalar(devicePixelRatio);
    }
  }]);

  return PixelEffect;
}(ShaderPass);/**
 * Reference: https://en.wikipedia.org/wiki/Cel_shading
 *
 * API
 *
 * 1. Traditional
 *
 * const effect = new OutlineEffect(renderer);
 *
 * function render() {
 *
 *     effect.render(scene, camera);
 *
 * }
 *
 * 2. VR compatible
 *
 * const effect = new OutlineEffect(renderer);
 * let renderingOutline = false;
 *
 * scene.onAfterRender = function () {
 *
 *     if (renderingOutline) return;
 *
 *     renderingOutline = true;
 *
 *     effect.renderOutline(scene, camera);
 *
 *     renderingOutline = false;
 *
 * };
 *
 * function render() {
 *
 *     this.renderer.render(scene, camera);
 *
 * }
 *
 * // How to set default outline parameters
 * new OutlineEffect(renderer, {
 *     this.defaultThickness: 0.01,
 *     this.defaultColor: [0, 0, 0],
 *     this.defaultAlpha: 0.8,
    this.defaultKeepAlive: true // keeps outline material in cache even if material is removed from scene
 * });
 *
 * // How to set outline parameters for each material
 * material.userData.outlineParameters = {
 *     thickness: 0.01,
 *     color: [0, 0, 0]
 *     alpha: 0.8,
 *     visible: true,
 *     keepAlive: true
 * };
 */

var DEFAULT_THICKNESS = 0.003;
var DEFAULT_COLOR = 0x000000;
var DEFAULT_ALPHA = 1.0;
var DEFAULT_KEEPALIVE = false;

var OutlineEffect = /*#__PURE__*/function () {
  function OutlineEffect(_ref) {
    var _this = this;

    var _ref$defaultThickness = _ref.defaultThickness,
        defaultThickness = _ref$defaultThickness === void 0 ? DEFAULT_THICKNESS : _ref$defaultThickness,
        _ref$defaultColor = _ref.defaultColor,
        defaultColor = _ref$defaultColor === void 0 ? DEFAULT_COLOR : _ref$defaultColor,
        _ref$defaultAlpha = _ref.defaultAlpha,
        defaultAlpha = _ref$defaultAlpha === void 0 ? DEFAULT_ALPHA : _ref$defaultAlpha,
        _ref$defaultKeepAlive = _ref.defaultKeepAlive,
        defaultKeepAlive = _ref$defaultKeepAlive === void 0 ? DEFAULT_KEEPALIVE : _ref$defaultKeepAlive;

    _classCallCheck(this, OutlineEffect);

    _defineProperty$1(this, "createMaterial", function () {
      return new ShaderMaterial({
        type: 'OutlineEffect',
        uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['displacementmap'], _this.uniformsOutline]),
        vertexShader: _this.vertexShader,
        fragmentShader: _this.fragmentShader,
        side: BackSide
      });
    });

    _defineProperty$1(this, "getOutlineMaterialFromCache", function (originalMaterial) {
      var data = _this.cache[originalMaterial.uuid];

      if (data === undefined) {
        data = {
          material: _this.createMaterial(),
          used: true,
          defaultKeepAlive: _this.defaultKeepAlive,
          count: 0
        };
        _this.cache[originalMaterial.uuid] = data;
      }

      data.used = true;
      return data.material;
    });

    _defineProperty$1(this, "getOutlineMaterial", function (originalMaterial) {
      var outlineMaterial = _this.getOutlineMaterialFromCache(originalMaterial);

      _this.originalMaterials[outlineMaterial.uuid] = originalMaterial;

      _this.updateOutlineMaterial(outlineMaterial, originalMaterial);

      return outlineMaterial;
    });

    _defineProperty$1(this, "isCompatible", function (object) {
      var geometry = object.geometry;
      var hasNormals = false;

      if (object.geometry !== undefined) {
        if (geometry.isBufferGeometry) {
          hasNormals = geometry.attributes.normal !== undefined;
        } else {
          hasNormals = true; // the renderer always produces a normal attribute for Geometry
        }
      }

      return object.isMesh === true && object.material !== undefined && hasNormals === true;
    });

    _defineProperty$1(this, "setOutlineMaterial", function (object) {
      if (_this.isCompatible(object) === false) return;

      if (Array.isArray(object.material)) {
        for (var i = 0, il = object.material.length; i < il; i++) {
          object.material[i] = _this.getOutlineMaterial(object.material[i]);
        }
      } else {
        object.material = _this.getOutlineMaterial(object.material);
      }

      _this.originalOnBeforeRenders[object.uuid] = object.onBeforeRender;
      object.onBeforeRender = _this.onBeforeRender;
    });

    _defineProperty$1(this, "restoreOriginalMaterial", function (object) {
      if (_this.isCompatible(object) === false) return;

      if (Array.isArray(object.material)) {
        for (var i = 0, il = object.material.length; i < il; i++) {
          object.material[i] = _this.originalMaterials[object.material[i].uuid];
        }
      } else {
        object.material = _this.originalMaterials[object.material.uuid];
      }

      object.onBeforeRender = _this.originalOnBeforeRenders[object.uuid];
    });

    _defineProperty$1(this, "onBeforeRender", function (renderer, scene, camera, geometry, material) {
      var originalMaterial = _this.originalMaterials[material.uuid]; // just in case

      if (originalMaterial === undefined) return;

      _this.updateUniforms(material, originalMaterial);
    });

    _defineProperty$1(this, "updateUniforms", function (material, originalMaterial) {
      var outlineParameters = originalMaterial.userData.outlineParameters;
      material.uniforms.outlineAlpha.value = originalMaterial.opacity;

      if (outlineParameters !== undefined) {
        if (outlineParameters.thickness !== undefined) material.uniforms.outlineThickness.value = outlineParameters.thickness;
        if (outlineParameters.color !== undefined) material.uniforms.outlineColor.value.fromArray(outlineParameters.color);
        if (outlineParameters.alpha !== undefined) material.uniforms.outlineAlpha.value = outlineParameters.alpha;
      }

      if (originalMaterial.displacementMap) {
        material.uniforms.displacementMap.value = originalMaterial.displacementMap;
        material.uniforms.displacementScale.value = originalMaterial.displacementScale;
        material.uniforms.displacementBias.value = originalMaterial.displacementBias;
      }
    });

    _defineProperty$1(this, "updateOutlineMaterial", function (material, originalMaterial) {
      if (material.name === 'invisible') return;
      var outlineParameters = originalMaterial.userData.outlineParameters;
      material.fog = originalMaterial.fog;
      material.toneMapped = originalMaterial.toneMapped;
      material.premultipliedAlpha = originalMaterial.premultipliedAlpha;
      material.displacementMap = originalMaterial.displacementMap;

      if (outlineParameters !== undefined) {
        if (originalMaterial.visible === false) {
          material.visible = false;
        } else {
          material.visible = outlineParameters.visible !== undefined ? outlineParameters.visible : true;
        }

        material.transparent = outlineParameters.alpha !== undefined && outlineParameters.alpha < 1.0 ? true : originalMaterial.transparent;
        if (outlineParameters.keepAlive !== undefined) _this.cache[originalMaterial.uuid].keepAlive = outlineParameters.keepAlive;
      } else {
        material.transparent = originalMaterial.transparent;
        material.visible = originalMaterial.visible;
      }

      if (originalMaterial.wireframe === true || originalMaterial.depthTest === false) material.visible = false;

      if (originalMaterial.clippingPlanes) {
        material.clipping = true;
        material.clippingPlanes = originalMaterial.clippingPlanes;
        material.clipIntersection = originalMaterial.clipIntersection;
        material.clipShadows = originalMaterial.clipShadows;
      }

      material.version = originalMaterial.version; // update outline material if necessary
    });

    _defineProperty$1(this, "cleanupCache", function () {
      var keys; // clear originialMaterials

      keys = Object.keys(_this.originalMaterials);

      for (var i = 0, il = keys.length; i < il; i++) {
        _this.originalMaterials[keys[i]] = undefined;
      } // this.originalOnBeforeRenders


      keys = Object.keys(_this.originalOnBeforeRenders);

      for (var _i = 0, _il = keys.length; _i < _il; _i++) {
        _this.originalOnBeforeRenders[keys[_i]] = undefined;
      } // remove unused outlineMaterial from this.cache


      keys = Object.keys(_this.cache);

      for (var _i2 = 0, _il2 = keys.length; _i2 < _il2; _i2++) {
        var key = keys[_i2];

        if (_this.cache[key].used === false) {
          _this.cache[key].count++;

          if (_this.cache[key].keepAlive === false && _this.cache[key].count > _this.removeThresholdCount) {
            delete _this.cache[key];
          }
        } else {
          _this.cache[key].used = false;
          _this.cache[key].count = 0;
        }
      }
    });

    this.enabled = true;
    this.renderer = Scene$1.getRenderer();
    this.defaultThickness = defaultThickness;
    this.defaultColor = new Color$1(defaultColor);
    this.defaultAlpha = defaultAlpha;
    this.defaultKeepAlive = defaultKeepAlive; // object.material.uuid -> outlineMaterial or
    // object.material[n].uuid -> outlineMaterial
    // save at the outline material creation and release
    // if it's unused this.removeThresholdCount frames
    // unless keepAlive is true.

    this.cache = {};
    this.removeThresholdCount = 60; // outlineMaterial.uuid -> object.material or
    // outlineMaterial.uuid -> object.material[n]
    // save before render and release after render.

    this.originalMaterials = {}; // object.uuid -> originalOnBeforeRender
    // save before render and release after render.

    this.originalOnBeforeRenders = {}; //this.this.cache = this.cache;  // for debug

    this.uniformsOutline = {
      outlineThickness: {
        value: this.defaultThickness
      },
      outlineColor: {
        value: this.defaultColor
      },
      outlineAlpha: {
        value: this.defaultAlpha
      }
    };
    this.vertexShader = ['#include <common>', '#include <uv_pars_vertex>', '#include <displacementmap_pars_vertex>', '#include <fog_pars_vertex>', '#include <morphtarget_pars_vertex>', '#include <skinning_pars_vertex>', '#include <logdepthbuf_pars_vertex>', '#include <clipping_planes_pars_vertex>', 'uniform float outlineThickness;', 'vec4 calculateOutline(vec4 pos, vec3 normal, vec4 skinned) {', '    float thickness = outlineThickness;', '    const float ratio = 1.0;', // TODO: support outline thickness ratio for each vertex
    '    vec4 pos2 = projectionMatrix * modelViewMatrix * vec4(skinned.xyz + normal, 1.0);', // NOTE: subtract pos2 from pos because BackSide objectNormal is negative
    '    vec4 norm = normalize(pos - pos2);', '    return pos + norm * thickness * pos.w * ratio;', '}', 'void main() {', '    #include <uv_vertex>', '    #include <beginnormal_vertex>', '    #include <morphnormal_vertex>', '    #include <skinbase_vertex>', '    #include <skinnormal_vertex>', '    #include <begin_vertex>', '    #include <morphtarget_vertex>', '    #include <skinning_vertex>', '    #include <displacementmap_vertex>', '    #include <project_vertex>', '    vec3 outlineNormal = - objectNormal;', // the outline material is always rendered with BackSide
    '    gl_Position = calculateOutline(gl_Position, outlineNormal, vec4(transformed, 1.0));', '    #include <logdepthbuf_vertex>', '    #include <clipping_planes_vertex>', '    #include <fog_vertex>', '}'].join('\n');
    this.fragmentShader = ['#include <common>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <clipping_planes_pars_fragment>', 'uniform vec3 outlineColor;', 'uniform float outlineAlpha;', 'void main() {', '    #include <clipping_planes_fragment>', '    #include <logdepthbuf_fragment>', '    gl_FragColor = vec4(outlineColor, outlineAlpha);', '    #include <tonemapping_fragment>', '    #include <encodings_fragment>', '    #include <fog_fragment>', '    #include <premultiplied_alpha_fragment>', '}'].join('\n');
    /*
     * See #9918
     *
     * The following property copies and wrapper methods enable
     * OutlineEffect to be called from other *Effect, like
     *
     * effect = new StereoEffect(new OutlineEffect(renderer));
     *
     * function render () {
     *
      *     effect.render(scene, camera);
     *
     * }
     */

    this.autoClear = this.renderer.autoClear;
    this.domElement = this.renderer.domElement;
    this.shadowMap = this.renderer.shadowMap;
  }

  _createClass(OutlineEffect, [{
    key: "renderOutline",
    value: function renderOutline(scene, camera) {
      var currentAutoClear = this.renderer.autoClear;
      var currentSceneAutoUpdate = scene.autoUpdate;
      var currentSceneBackground = scene.background;
      var currentShadowMapEnabled = this.renderer.shadowMap.enabled;
      scene.autoUpdate = false;
      scene.background = null;
      this.renderer.autoClear = false;
      this.renderer.shadowMap.enabled = false;
      scene.traverse(this.setOutlineMaterial);
      this.renderer.render(scene, camera);
      scene.traverse(this.restoreOriginalMaterial);
      this.cleanupCache();
      scene.autoUpdate = currentSceneAutoUpdate;
      scene.background = currentSceneBackground;
      this.renderer.autoClear = currentAutoClear;
      this.renderer.shadowMap.enabled = currentShadowMapEnabled;
    }
  }, {
    key: "render",
    value: function render(scene, camera, dt) {
      var renderTarget;
      var forceClear = false;

      if (arguments[3] !== undefined) {
        console.warn('THREE.OutlineEffect.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.');
        renderTarget = arguments[3];
      }

      if (arguments[4] !== undefined) {
        console.warn('THREE.OutlineEffect.render(): the forceClear argument has been removed. Use .clear() instead.');
        forceClear = arguments[4];
      }

      if (renderTarget !== undefined) this.renderer.setRenderTarget(renderTarget);
      if (forceClear) this.renderer.clear();

      if (this.enabled === false) {
        this.renderer.render(scene, camera);
        return;
      }

      var currentAutoClear = this.renderer.autoClear;
      this.renderer.autoClear = this.autoClear;
      this.renderer.render(scene, camera);
      this.renderer.autoClear = currentAutoClear;
      this.renderOutline(scene, camera);
    }
  }, {
    key: "clear",
    value: function clear(color, depth, stencil) {
      this.renderer.clear(color, depth, stencil);
    }
  }, {
    key: "getPixelRatio",
    value: function getPixelRatio() {
      return this.renderer.getPixelRatio();
    }
  }, {
    key: "setPixelRatio",
    value: function setPixelRatio(value) {
      this.renderer.setPixelRatio(value);
    }
  }, {
    key: "getSize",
    value: function getSize(target) {
      return this.renderer.getSize(target);
    }
  }, {
    key: "setSize",
    value: function setSize(width, height, updateStyle) {
      this.renderer.setSize(width, height, updateStyle);
    }
  }, {
    key: "setViewport",
    value: function setViewport(x, y, width, height) {
      this.renderer.setViewport(x, y, width, height);
    }
  }, {
    key: "setScissor",
    value: function setScissor(x, y, width, height) {
      this.renderer.setScissor(x, y, width, height);
    }
  }, {
    key: "setScissorTest",
    value: function setScissorTest(boolean) {
      this.renderer.setScissorTest(boolean);
    }
  }, {
    key: "setRenderTarget",
    value: function setRenderTarget(renderTarget) {
      this.renderer.setRenderTarget(renderTarget);
    }
  }]);

  return OutlineEffect;
}();var PostProcessing = /*#__PURE__*/function () {
  function PostProcessing() {
    var _this = this,
        _this$map;

    _classCallCheck(this, PostProcessing);

    _defineProperty$1(this, "isEnabled", function () {
      return _this.enabled && (!!_this.effects.length || !!_this.customs.length);
    });

    _defineProperty$1(this, "init", function () {
      var _Config$postprocessin = Config$1.postprocessing(),
          _Config$postprocessin2 = _Config$postprocessin.enabled,
          enabled = _Config$postprocessin2 === void 0 ? false : _Config$postprocessin2;

      _this.enabled = enabled;

      if (enabled) {
        window.addEventListener('resize', _this.onWindowResize, false);
        _this.composer = new EffectComposer(Scene$1.getRenderer());

        _this.composer.addPass(new RenderPass(Scene$1.getScene(), Scene$1.getCameraBody()));
      }
    });

    _defineProperty$1(this, "dispose", function () {
      window.removeEventListener('resize', _this.onWindowResize);
    });

    _defineProperty$1(this, "onWindowResize", function () {
      var _Config$screen = Config$1.screen(),
          h = _Config$screen.h,
          w = _Config$screen.w;

      _this.composer.setSize(w, h);

      _this.effects.forEach(function (effect) {
        if (effect.onWindowResize) {
          effect.onWindowResize();
        }
      });
    });

    _defineProperty$1(this, "addEffectToComposer", function (effect) {
      _this.composer.addPass(effect);

      _this.effects.push(effect);

      _this.composer.ensureLastPassIsRendered();
    });

    _defineProperty$1(this, "addEffectToCustomEffects", function (effect) {
      _this.customs.push(effect);
    });

    _defineProperty$1(this, "add", function (desiredEffect) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var effect;

      if (typeof desiredEffect === 'string') {
        var effectDescription = _this.get(desiredEffect);

        if (effectDescription) {
          effect = PostProcessing.createEffect(effectDescription, options);
        } else {
          console.error(EFFECT_UNAVAILABLE);
          return;
        }
      } else {
        effect = PostProcessing.createEffect(desiredEffect, options);
      }

      if (effect) {
        if (effect.isPass) {
          _this.addEffectToComposer(effect);
        } else {
          _this.addEffectToCustomEffects(effect);
        }

        return effect;
      } else {
        console.error(EFFECT_COULD_NOT_BE_CREATED);
      }
    });

    this.map = (_this$map = {}, _defineProperty$1(_this$map, EFFECTS.SEPIA, {
      effect: SepiaEffect,
      isClass: false
    }), _defineProperty$1(_this$map, EFFECTS.HUE_SATURATION, {
      effect: HueSaturationEffect,
      isClass: false
    }), _defineProperty$1(_this$map, EFFECTS.BLOOM, {
      effect: BloomPass,
      isClass: true
    }), _defineProperty$1(_this$map, EFFECTS.DEPTH_OF_FIELD, {
      effect: DepthOfField,
      isClass: true
    }), _defineProperty$1(_this$map, EFFECTS.SELECTIVE_OUTLINE, {
      effect: SelectiveOutline,
      isClass: true
    }), _defineProperty$1(_this$map, EFFECTS.GLITCH, {
      effect: GlitchEffect,
      isClass: true
    }), _defineProperty$1(_this$map, EFFECTS.PIXEL, {
      effect: PixelEffect,
      isClass: true
    }), _defineProperty$1(_this$map, EFFECTS.OUTLINE, {
      effect: OutlineEffect,
      isClass: true
    }), _this$map);
    this.effects = [];
    this.customs = [];
    this.enabled = false;
  }

  _createClass(PostProcessing, [{
    key: "get",
    value: function get(id) {
      return this.map[id] || null;
    }
  }, {
    key: "render",
    value: function render(dt) {
      var scene = Scene$1.getScene();
      var camera = Scene$1.getCameraBody();
      this.composer.render(dt);
      this.customs.forEach(function (e) {
        return e.render(scene, camera, dt);
      });
    }
  }], [{
    key: "createEffect",
    value: function createEffect(_ref, options) {
      var effect = _ref.effect,
          isClass = _ref.isClass;
      var pass;

      if (effect && !isClass) {
        pass = effect(options);
      } else if (effect && isClass) {
        pass = new effect(options);
      }

      return pass;
    }
  }]);

  return PostProcessing;
}();
var PostProcessing$1 = new PostProcessing();function p(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}function u(t,e){for(var i=0;i<e.length;i++){var n=e[i];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n);}}function d(t,e,i){return e&&u(t.prototype,e),i&&u(t,i),t}function f(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,writable:!0,configurable:!0}}),e&&y(t,e);}function v(t){return (v=Object.setPrototypeOf?Object.getPrototypeOf:function(t){return t.__proto__||Object.getPrototypeOf(t)})(t)}function y(t,e){return (y=Object.setPrototypeOf||function(t,e){return t.__proto__=e,t})(t,e)}function m(t,e){return !e||"object"!=typeof e&&"function"!=typeof e?function(t){if(void 0===t)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}(t):e}var g=function(t,e){return Math.random()*(e-t)+t},C=function(t,e){return e?g(t,t+e):t},S=function(e,i){return i?new Color$1(g(e.r,i.r),g(e.g,i.g),g(e.b,i.b)):e?e.clone():new Color$1},z=function(t,i){return i?new Vector3$1(g(t.x,i.x),g(t.y,i.y),g(t.z,i.z)):t?t.clone():new Vector3$1},w=function(t,e,i){return t.clone().lerp(e,i)},_=function(t,e,i){return t*(1-i)+e*i},A=function(t){return (t.generate?t.generate():t)||0},b=Object.freeze({__proto__:null,getRandomBetween:g,getRandomWithSpread:C,getRandomColorBetween:S,getRandomVectorBetween:z,lerpColors:w,lerp:_,randomizerOrValue:A}),P=function(){function t(e){p(this,t),this.system=e,this.reset();}return d(t,[{key:"reset",value:function(){var t=this.system.options.particles;this.age=0,this.finished=!1,this.gravity=t.gravity,this.velocity=x(t.velocity),t.velocityBonus&&this.velocity.add(t.velocityBonus),this.acceleration=x(t.acceleration,!0),this.position=x(t.offset||new Vector3$1),this.ttl=C(t.ttl||1,t.ttlExtra)||1,this.alpha=this.startAlpha=this.endAlpha=null,this.startAlphaChangeAt=(t.startAlphaChangeAt||0)/this.ttl,t.fade&&(void 0!==t.alpha?this.alpha=A(t.alpha):(this.startAlpha=A(t.startAlpha),this.endAlpha=A(t.endAlpha))),this.colorize=Boolean(t.colorize),this.color=this.startColor=this.endColor=null,this.startColorChangeAt=(t.startColorChangeAt||0)/this.ttl,this.colorize&&(t.color?this.color=T(t.color):(this.startColor=T(t.startColor),this.endColor=T(t.endColor))),this.size=this.startSize=this.endSize=null,this.startSizeChangeAt=(t.startSizeChangeAt||0)/this.ttl,t.scaling&&(void 0!==t.size?this.size=A(t.size):(this.startSize=A(t.startSize),this.endSize=A(t.endSize))),this.rotation=this.rotationSpeed=null,t.rotating&&(this.rotation=A(t.rotation||0),this.rotationSpeed=A(t.rotationSpeed||0)),this.startWorldPosition=null,this.onUpdate=t.onUpdate,t.onSpawn&&t.onSpawn(this);}},{key:"update",value:function(t,e){if(!this.finished){0===this.age?(this.system.options.particles.worldPosition&&(this.startWorldPosition=this.system.getWorldPosition()),null===this.alpha&&null===this.startAlpha||this.system.setAlpha(t,this.alpha||this.startAlpha),null===this.color&&null===this.startColor||this.system.setColor(t,this.color||this.startColor),null===this.size&&null===this.startSize||this.system.setSize(t,this.size||this.startSize),null!==this.rotation&&this.system.setRotation(t,this.rotation)):(this.startColor&&this.age>=this.startColorChangeAt&&this.system.setColor(t,w(this.startColor,this.endColor,this.startColorChangeAt?(this.age-this.startColorChangeAt)/(1-this.startColorChangeAt):this.age)),null!=this.startAlpha&&this.age>=this.startAlphaChangeAt&&this.system.setAlpha(t,_(this.startAlpha,this.endAlpha,this.startAlphaChangeAt?(this.age-this.startAlphaChangeAt)/(1-this.startAlphaChangeAt):this.age)),null!=this.startSize&&this.age>=this.startSizeChangeAt&&this.system.setSize(t,_(this.startSize,this.endSize,this.startSizeChangeAt?(this.age-this.startSizeChangeAt)/(1-this.startSizeChangeAt):this.age))),this.gravity&&this.velocity&&(this.velocity.y+=this.gravity*e),this.rotationSpeed&&(this.rotation+=this.rotationSpeed*e,this.system.setRotation(t,this.rotation)),this.velocity&&(this.position.x+=this.velocity.x*e,this.position.y+=this.velocity.y*e,this.position.z+=this.velocity.z*e);var i=this.position;if(this.startWorldPosition){var n=this.system.getWorldPosition();n.sub(this.startWorldPosition),i=i.clone().sub(n);}this.system.setPosition(t,i),this.acceleration&&this.velocity&&(this.velocity.x+=this.acceleration.x*e,this.velocity.y+=this.acceleration.y*e,this.velocity.z+=this.acceleration.z*e),this.age+=e/this.ttl,this.onUpdate&&this.onUpdate(this),this.age>1&&(this.age=1,this.finished=!0);}}},{key:"worldPosition",get:function(){return this.system.getWorldPosition().add(this.position)}}]),t}();function x(t,i){return t?t.generate?t.generate():t.clone():i?null:new Vector3$1}function T(e,i){return e?e.generate?e.generate():e.clone():i?null:new Color$1(1,1,1)}var R=function(){function e(r){p(this,e),this.options=r;var o={globalColor:{value:new Color$1(r.color||16777215)},rendererScale:{value:1}},s="";r.perspective&&(s+="#define PERSPECTIVE\n"),r.map&&(s+="#define TEXTURE\n",o.texture={value:r.map}),r.perParticleColor&&(s+="#define COLORING\n"),r.perParticleRotation&&(s+="#define ROTATION\n"),r.constSize&&(s+="#define CONST_SIZE\n",o.constSize={value:r.constSize}),r.alphaTest&&(s+="#define ALPHA_TEST\n"),s+="\n",this.material=new ShaderMaterial({uniforms:o,vertexShader:s+"\n// attributes we get from geometry\nattribute float alpha;\n\n// per-particle size\n#ifdef CONST_SIZE\n    uniform float constSize;\n#else\n    attribute float size;\n#endif\n\n// per-particle rotation\n#ifdef ROTATION\n    attribute float rotation;\n#endif\n\n// system scale when using perspective mode\n#ifdef PERSPECTIVE\n    uniform float rendererScale;\n#endif\n\n// output params for fragment shader\nvarying float vAlpha;\n\n// set per-particle color\n#ifdef COLORING\n    varying vec3 vColor;\n#endif\n\n// get per-particle rotation\n#ifdef ROTATION\n    varying float vRotation;\n#endif\n\n// vertex shader main\nvoid main() \n{\n    // alpha and color\n    vAlpha = alpha;\n\n    // set color\n    #ifdef COLORING\n        vColor = color;\n    #endif\n\n    // set const size\n    #ifdef CONST_SIZE\n        float size = constSize;\n    #endif\n\n    // set position\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    gl_Position = projectionMatrix * mvPosition;\n\n    // apply rotation\n    #ifdef ROTATION\n        vRotation = rotation;\n    #endif\n    \n    // set size - either perspective or constant\n    #ifdef PERSPECTIVE\n        gl_PointSize = size * (rendererScale / length(mvPosition.xyz));\n    #else\n        gl_PointSize = size;\n    #endif\n}\n",fragmentShader:s+"\n// material uniforms\nuniform vec3 globalColor;\n\n// params we get from vertex shader\nvarying float vAlpha;\n\n// per-particle color from vertex shader\n#ifdef COLORING\n    varying vec3 vColor;\n#endif\n\n// per-particle rotation from vertex shader\n#ifdef ROTATION\n    varying float vRotation;\n#endif\n\n// diffuse texture\n#ifdef TEXTURE\n    uniform sampler2D texture;\n#endif\n\n// fragment shader main\nvoid main() \n{\n    // set default color if don't have per-particle colors\n    #ifndef COLORING\n        vec3 vColor = vec3(1,1,1);\n    #endif\n\n    // texture\n    #ifdef TEXTURE\n\n        // use rotation (rotate texture)\n        #ifdef ROTATION\n            float mid = 0.5;\n            vec2 rotated = vec2(cos(vRotation) * (gl_PointCoord.x - mid) + sin(vRotation) * (gl_PointCoord.y - mid) + mid,\n                          cos(vRotation) * (gl_PointCoord.y - mid) - sin(vRotation) * (gl_PointCoord.x - mid) + mid);\n            vec4 texture = texture2D(texture,  rotated);\n        // no rotation\n        #else\n            vec2 coords = vec2((gl_PointCoord.x - 0.5) + 0.5, (gl_PointCoord.y - 0.5) + 0.5);\n            vec4 texture = texture2D(texture, coords);\n        #endif\n\n        // get color with texture\n        gl_FragColor = vec4( globalColor * vColor, vAlpha ) * texture;\n        \n    // no texture (colors only)\n    #else\n        gl_FragColor = vec4( globalColor * vColor, vAlpha );\n    #endif\n\n    // check if need to discard pixel\n    #ifdef ALPHA_TEST\n        if (gl_FragColor.a < 0.00001) { discard; }\n    #endif\n}\n",transparent:Boolean(r.transparent),blending:r.blending,vertexColors:VertexColors,depthWrite:Boolean(r.depthWrite),depthTest:Boolean(r.depthTest)});}return d(e,[{key:"dispose",value:function(){this.material.dispose();}},{key:"setBaseScale",value:function(t){this.options.perspective&&(this.material.uniforms.rendererScale.value=t);}}]),e}(),O=function(t){return null!=t},E=function(){function i(e){p(this,i),e.particles=e.particles||{worldPosition:!0},e.system=e.system||{},this.options=e,this.hasStarted=!1;var n=e.particles;if("number"==typeof e.particles.size&&(console.warn("Note: replaced 'size' with 'globalSize' property since its more efficient and provided size value was constant anyway."),e.particles.globalSize=e.particles.size,delete e.particles.size),e.particles.color instanceof Color$1&&(console.warn("Note: replaced 'color' with 'globalColor' property since its more efficient and you provided color value was constant anyway."),e.particles.globalColor=e.particles.color,delete e.particles.color),e.particles.fade=O(n.startAlpha)||O(n.alpha),e.particles.rotating=O(n.rotationSpeed)||O(n.rotation),e.particles.colorize=O(n.color)||O(n.startColor),e.particles.scaling=O(n.size)||O(n.startSize),O(n.startAlpha)&&!O(n.endAlpha))throw new Error("When providing 'startAlpha' you must also provide 'endAlpha'!");if(O(n.startAlpha)&&O(n.alpha))throw new Error("When providing 'alpha' you can't also provide 'startAlpha'!");if(O(n.startColor)&&!O(n.endColor))throw new Error("When providing 'startColor' you must also provide 'endColor'!");if(O(n.startColor)&&O(n.color))throw new Error("When providing 'color' you can't also provide 'startColor'!");if(O(n.startSize)&&!O(n.endSize))throw new Error("When providing 'startSize' you must also provide 'endSize'!");if(O(n.startSize)&&O(n.size))throw new Error("When providing 'size' you can't also provide 'startSize'!");this.particleCount=e.system.particlesCount||10,this.blending=e.particles.blending||"opaque",this.threeBlend={opaque:NoBlending,additive:AdditiveBlending,multiply:MultiplyBlending,blend:NormalBlending}[this.blending],this.create(),e.autostart&&this.start();}return d(i,[{key:"create",value:function(){this._emitters=[];var t=this.options,e=t.system,i=t.particles;t.container;if(e.emitters)if(e.emitters instanceof Array)for(var n=0;n<e.emitters.length;++n)this.addEmitter(e.emitters[n]);else this.addEmitter(e.emitters);var r="opaque"!==this.blending;this.particlesGeometry=new BufferGeometry;var o=void 0===e.perspective||Boolean(e.perspective),s=new R({size:i.size||10,color:i.globalColor||16777215,blending:this.threeBlend,perspective:o,transparent:r,map:i.texture,perParticleColor:Boolean(i.colorize),alphaTest:"blend"===this.blending&&O(i.texture),constSize:O(i.globalSize)?i.globalSize:null,depthWrite:!O(e.depthWrite)||e.depthWrite,depthTest:!O(e.depthTest)||e.depthTest,perParticleRotation:i.rotating});this.material=s,this.speed=e.speed||1,this.reset(),this._aliveParticles=[],this._deadParticles=[];for(var a=new Float32Array(3*this.particleCount),p=i.colorize?new Float32Array(3*this.particleCount):null,u=i.fade?new Float32Array(1*this.particleCount):null,d=i.scaling?new Float32Array(1*this.particleCount):null,f=i.rotating?new Float32Array(1*this.particleCount):null,v=0;v<this.particleCount;v++){var y=3*v;a[y]=a[y+1]=a[y+2]=0,p&&(p[y]=p[y+1]=p[y+2]=1),u&&(u[v]=1),d&&(d[v]=1),f&&(f[v]=0),this._deadParticles.push(new P(this));}this.particlesGeometry.setAttribute("position",new BufferAttribute(a,3)),u&&this.particlesGeometry.setAttribute("alpha",new BufferAttribute(u,1)),p&&this.particlesGeometry.setAttribute("color",new BufferAttribute(p,3)),d&&this.particlesGeometry.setAttribute("size",new BufferAttribute(d,1)),f&&this.particlesGeometry.setAttribute("rotation",new BufferAttribute(f,1)),this.particlesGeometry.setDrawRange(0,0),this.material.setBaseScale(e.scale||400);var m=new Points(this.particlesGeometry,this.material.material);m.sortParticles=r,this.particleSystem=m,this._positionDirty=!0,this._colorsDirty=Boolean(p),this._alphaDirty=Boolean(u),this._rotateDirty=Boolean(f);}},{key:"start",value:function(){var t=this.options.container;t?(this.addTo(t),this.hasStarted=!0):console.log("no container for particle system, aborting.");}},{key:"stop",value:function(){this.ttl=0;}},{key:"addEmitter",value:function(t){this._emitters.push(t);}},{key:"dispose",value:function(){this.particlesGeometry.dispose(),this.material.dispose();}},{key:"reset",value:function(){this.ttl=this.options.system.ttl,this.age=0,this._timeToUpdateBS=0;}},{key:"getWorldPosition",value:function(){var t=new Vector3$1;return this.particleSystem.getWorldPosition(t),t}},{key:"addTo",value:function(t){t.add(this.particleSystem);}},{key:"setColor",value:function(t,e){t*=3;var i=this.particlesGeometry.attributes.color.array;i[t]=e.r,i[t+1]=e.g,i[t+2]=e.b,this._colorsDirty=!0;}},{key:"setPosition",value:function(t,e){t*=3;var i=this.particlesGeometry.attributes.position.array;i[t]=e.x,i[t+1]=e.y,i[t+2]=e.z,this._positionDirty=!0;}},{key:"setAlpha",value:function(t,e){this.particlesGeometry.attributes.alpha.array[t]=e,this._alphaDirty=!0;}},{key:"setRotation",value:function(t,e){this.particlesGeometry.attributes.rotation.array[t]=e,this._rotateDirty=!0;}},{key:"setSize",value:function(t,e){this.particlesGeometry.attributes.size.array[t]=e,this._sizeDirty=!0;}},{key:"removeAndDisposeIfFinished",value:function(){return !!this.finished&&(this.removeSelf(),this.dispose(),!0)}},{key:"update",value:function(t){if(this.hasStarted){if(void 0===t){var e=(new Date).getTime()/1e3;t=e-this._lastTime||0,this._lastTime=e;}if(0!==t){void 0!==this.ttl&&this.ttl>0&&(this.ttl-=t),t*=this.speed,this.dt=t,this.age+=t;var i=this._aliveParticles.length;if(!this.ttlExpired)for(var n=0;n<this._emitters.length;++n){var r=this._emitters[n].update(t,this);r&&this.spawnParticles(r);}for(n=this._aliveParticles.length-1;n>=0;--n){var o=this._aliveParticles[n];o.update(n,t),o.finished&&(this._aliveParticles.splice(n,1),this._deadParticles.push(o));}i!==this._aliveParticles.length&&this.particlesGeometry.setDrawRange(0,this._aliveParticles.length),this.particlesGeometry.attributes.position.needsUpdate=this._positionDirty,this._needBoundingSphereUpdate=this._needBoundingSphereUpdate||this._positionDirty,this._positionDirty=!1,this._colorsDirty&&(this.particlesGeometry.attributes.color.needsUpdate=!0,this._colorsDirty=!1),this._alphaDirty&&(this.particlesGeometry.attributes.alpha.needsUpdate=!0,this._alphaDirty=!1),this._sizeDirty&&(this.particlesGeometry.attributes.size.needsUpdate=!0,this._sizeDirty=!1),this._rotateDirty&&(this.particlesGeometry.attributes.rotation.needsUpdate=!0,this._rotateDirty=!1),this._needBoundingSphereUpdate&&(this._timeToUpdateBS-=t,this._timeToUpdateBS<=0&&(this._timeToUpdateBS=.2,this.particlesGeometry.computeBoundingSphere())),this.finished||this.options.system.onUpdate&&this.options.system.onUpdate(this);}}}},{key:"spawnParticles",value:function(t){for(var e=0;e<t;++e){if(0===this._deadParticles.length)return;var i=this._deadParticles.pop();i.reset(),this._aliveParticles.push(i);}}},{key:"removeSelf",value:function(){this.particleSystem.parent&&this.particleSystem.parent.remove(this.particleSystem);}},{key:"finished",get:function(){return this.ttlExpired&&0===this.particlesCount}},{key:"ttlExpired",get:function(){return void 0!==this.ttl&&this.ttl<=0}},{key:"particlesCount",get:function(){return this._aliveParticles.length}},{key:"maxParticlesCount",get:function(){return this._aliveParticles.length+this._deadParticles.length}}]),i}(),k=function(){function t(e){p(this,t),this.options=e,e.interval=e.interval||1,this.age=0,this.timeToSpawn=Math.random()*A(e.interval);}return d(t,[{key:"update",value:function(t,e){var i=0;if(0===this.age&&this.options.onSpawnBurst&&(i+=A(this.options.onSpawnBurst)),this.age+=t,!this.options.onInterval)return i;(this.timeToSpawn-=t,this.timeToSpawn<=0&&(this.timeToSpawn=A(this.options.interval),i+=A(this.options.onInterval)),this.options.detoretingMinTtl&&e.ttl<this.options.detoretingMinTtl)&&(i*=e.ttl/this.options.detoretingMinTtl);return i}}]),t}(),B=function(){function t(){p(this,t);}return d(t,[{key:"generate",value:function(){throw new Error("Not implemented.")}}]),t}(),D=function(t){function i(t,n){var r;return p(this,i),(r=m(this,v(i).call(this))).min=t||new Vector3$1(-1,-1,-1),r.max=n||new Vector3$1(1,1,1),r}return f(i,B),d(i,[{key:"generate",value:function(){return z(this.min,this.max)}}]),i}();function G(){return 2*Math.random()-1}var U=function(t){function i(t,e,n,r,o){var s;return p(this,i),(s=m(this,v(i).call(this))).maxRadius=t||1,s.minRadius=e||0,s.scaler=n,s.minVector=r,s.maxVector=o,s}return f(i,B),d(i,[{key:"generate",value:function(){var t=new Vector3$1(G(),G(),G());return (this.minVector||this.maxVector)&&t.clamp(this.minVector||new Vector3$1(-1,-1,-1),this.maxVector||new Vector3$1(1,1,1)),t.normalize().multiplyScalar(g(this.minRadius,this.maxRadius)),this.scaler&&t.multiply(this.scaler),t}}]),i}(),W=function(e){function i(e,n){var r;return p(this,i),(r=m(this,v(i).call(this))).min=e||new Color$1(0,0,0),r.max=n||new Color$1(1,1,1),r}return f(i,B),d(i,[{key:"generate",value:function(){return S(this.min,this.max)}}]),i}(),I=function(t){function e(t,i){var n;return p(this,e),(n=m(this,v(e).call(this))).min=t,n.max=i,n}return f(e,B),d(e,[{key:"generate",value:function(){return g(this.min,this.max)}}]),e}(),N=Object.freeze({__proto__:null,Randomizer:B,BoxRandomizer:D,SphereRandomizer:U,ColorsRandomizer:W,MinMaxRandomizer:I});
var index$1=/*#__PURE__*/Object.freeze({__proto__:null,Emitter:k,Particle:P,ParticlesSystem:E,Randomizers:N,Utils:b});var PARTICLE_EMITTER_TYPES = {
  SINGLE: 'SINGLE',
  GROUP: 'GROUP'
};var ParticleEmitter = /*#__PURE__*/function (_Entity) {
  _inherits(ParticleEmitter, _Entity);

  var _super = _createSuper(ParticleEmitter);

  function ParticleEmitter() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ParticleEmitter);

    _this = _super.call(this, {
      tag: 'particle '
    });
    var _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('Emitter') : _options$name;
    _this.options = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
      name: name
    });

    _this.setSystem();

    _this.setName(name);

    _this.setBody({
      body: new Object3D()
    });

    _this.setEntityType(ENTITY_TYPES.EFFECT.PARTICLE);

    return _this;
  }

  _createClass(ParticleEmitter, [{
    key: "setBody",
    value: function setBody(_ref) {
      var body = _ref.body;
      this.body = body;

      if (this.hasBody()) {
        this.addToScene();
      }
    }
  }, {
    key: "addToScene",
    value: function addToScene() {
      var _this$options$addUniv = this.options.addUniverse,
          addUniverse = _this$options$addUniv === void 0 ? true : _this$options$addUniv;

      if (this.hasBody()) {
        Scene$1.add(this.getBody(), this, addUniverse);
      } else {
        console.warn(ELEMENT_NOT_SET);
      }
    }
  }, {
    key: "isProtonEmitter",
    value: function isProtonEmitter() {
      return false;
    }
  }, {
    key: "getType",
    value: function getType() {
      return PARTICLE_EMITTER_TYPES.SINGLE;
    }
  }, {
    key: "hasSystem",
    value: function hasSystem() {
      return !!this.system;
    }
  }, {
    key: "isSystemDead",
    value: function isSystemDead() {
      return this.system.finished;
    }
  }, {
    key: "setSystem",
    value: function setSystem() {
      var _this$options = this.options,
          _this$options$contain = _this$options.container,
          container = _this$options$contain === void 0 ? this.getBody() : _this$options$contain,
          _this$options$autosta = _this$options.autostart,
          autostart = _this$options$autosta === void 0 ? false : _this$options$autosta,
          _this$options$particl = _this$options.particles,
          particles = _this$options$particl === void 0 ? {} : _this$options$particl,
          _this$options$system = _this$options.system,
          system = _this$options$system === void 0 ? {} : _this$options$system;
      this.system = new E({
        container: container,
        autostart: autostart,
        particles: particles,
        system: system
      });
    }
  }, {
    key: "getSystem",
    value: function getSystem() {
      return this.system;
    }
  }, {
    key: "emit",
    value: function emit() {
      if (this.hasSystem()) {
        var _this$system;

        (_this$system = this.system).start.apply(_this$system, arguments);
      }

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.hasSystem()) {
        this.system.stop();
      }
    }
  }, {
    key: "syncParticleEmitter",
    value: function syncParticleEmitter() {
      if (this.hasSystem()) {
        var _this$getWorldTransfo = this.getWorldTransform(),
            position = _this$getWorldTransfo.position,
            rotation = _this$getWorldTransfo.rotation;

        this.system.particleSystem.position.set(position.x, position.y, position.z);
        this.system.particleSystem.rotation.set(rotation.x, rotation.y, rotation.z);
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(ParticleEmitter.prototype), "dispose", this).call(this);
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(ParticleEmitter.prototype), "update", this).call(this, dt);

      if (this.hasSystem() && !this.isSystemDead()) {
        this.system.update(dt);
      }

      this.syncParticleEmitter();
    }
  }]);

  return ParticleEmitter;
}(Entity);var Fountain = /*#__PURE__*/function (_ParticleEmitter) {
  _inherits(Fountain, _ParticleEmitter);

  var _super = _createSuper(Fountain);

  function Fountain(_ref) {
    var container = _ref.container,
        autostart = _ref.autostart,
        particles = _ref.particles,
        system = _ref.system;

    _classCallCheck(this, Fountain);

    var options = {
      container: container,
      autostart: autostart,
      particles: _objectSpread2$1({
        ttl: 10,
        globalSize: 5,
        velocity: new N.SphereRandomizer(12.5),
        velocityBonus: new Vector3$1(0, 25, 0),
        particlesCount: 1000,
        blending: 'blend',
        gravity: -10,
        startAlpha: 1,
        endAlpha: 0,
        startColor: new N.ColorsRandomizer(),
        endColor: new N.ColorsRandomizer(),
        startAlphaChangeAt: 0,
        onUpdate: function onUpdate(particle) {
          var floorY = -10;

          if (particle.position.y < floorY) {
            particle.position.y = floorY;
            particle.velocity.y *= -0.5;
            particle.velocity.x *= 0.5;
            particle.velocity.z *= 0.5;
          }
        }
      }, particles),
      system: _objectSpread2$1({
        particlesCount: 100,
        emitters: new k({
          onInterval: new N.MinMaxRandomizer(0, 5),
          interval: new N.MinMaxRandomizer(0, 0.25)
        }),
        speed: 1
      }, system)
    };
    return _super.call(this, options);
  }

  return Fountain;
}(ParticleEmitter);var three_proton_min = {exports: {}};var require$$0 = /*@__PURE__*/getAugmentedNamespace(three_module);/*!
 * three.proton v0.2.0
 * https://github.com/drawcall/three.proton
 *
 * Copyright 2011-2020, ajiemath
 * Licensed under the MIT license
 * http://www.opensource.org/licenses/mit-license
 *
 */

(function (module, exports) {
(function(a,b){module.exports=b(require$$0);})(commonjsGlobal,function(a){function bd(a,b,c,d){bd._super_.call(this),this.camera=a,this.renderer=b,this.dis=c||20,d=d||"1234";for(var e=1;e<5;e++)this["d"+e]=d.indexOf(e+"")>=0;this.name="ScreenZone";}function bc(a,c,d,e,f,g){var h,i,j,k,l,e;bc._super_.call(this),b.Util.isUndefined(c,d,e,f,g)?(h=i=j=0,k=l=e=a||100):b.Util.isUndefined(e,f,g)?(h=i=j=0,k=a,l=c,e=d):(h=a,i=c,j=d,k=e,l=f,e=g),this.x=h,this.y=i,this.z=j,this.width=k,this.height=l,this.depth=e,this.friction=.85,this.max=6;}function bb(a,c,d){var e,f,g;bb._super_.call(this),b.Util.isUndefined(a,c,d)?e=f=g=0:(e=a,f=c,g=d),this.x=e,this.y=f,this.z=g;}function ba(b,c){ba._super_.call(this),b instanceof a.Geometry?this.geometry=b:this.geometry=b.geometry,this.scale=c||1;}function _(a,c,d,e){var f,i;_._super_.call(this),b.Util.isUndefined(c,d,e)?(f=0,i=a||100):(f=a,i=e),this.x=f,this.y=f,this.z=f,this.radius=i,this.tha=this.phi=0;}function $(a,c,d,e,f,g){$._super_.call(this),a instanceof b.Vector3D?(this.x1=a.x,this.y1=a.y,this.z1=a.z,this.x2=e.x,this.y2=e.y,this.z2=e.z):(this.x1=a,this.y1=c,this.z1=d,this.x2=e,this.y2=f,this.z2=g);}function Z(){this.vector=new b.Vector3D(0,0,0),this.random=0,this.crossType="dead",this.log=!0;}function Y(){Y._super_.call(this),this.targetPool=new b.Pool,this.materialPool=new b.Pool,this.name="CustomRender";}function X(b){X._super_.call(this,b),this._body=new a.Sprite(new a.SpriteMaterial({color:16777215})),this.name="SpriteRender";}function W(a){W._super_.call(this),this.points=a,this.name="PointsRender";}function V(c){V._super_.call(this),this.container=c,this._targetPool=new b.Pool,this._materialPool=new b.Pool,this._body=new a.Mesh(new a.BoxGeometry(50,50,50),new a.MeshLambertMaterial({color:"#ff0000"})),this.name="MeshRender";}function U(){this.name="BaseRender";}function R(a,c,d){this.mouseTarget=b.Util.initValue(a,window),this.ease=b.Util.initValue(c,.7),this._allowEmitting=!1,this.mouse=new b.Vector3D,this.initEventHandler(),R._super_.call(this,d);}function Q(a){this.selfBehaviours=[],Q._super_.call(this,a);}function P(a){this.initializes=[],this.particles=[],this.behaviours=[],this.currentEmitTime=0,this.totalEmitTimes=-1,this.damping=.006,this.bindEmitter=!0,this.rate=new b.Rate(1,.1),P._super_.call(this,a),this.id="emitter_"+P.ID++,this.cID=0,this.name="Emitter";}function O(a,b,c,d,e,f,g){O._super_.call(this,f,g),O.prototype.reset(a,b,c,d,e),this.name="Spring";}function N(a,b,c,d){N._super_.call(this,c,d),this.reset(a,b),this.name="Color";}function M(a,b,c,d,e){M._super_.call(this,d,e),this.reset(a,b,c),this.name="Rotate";}function L(a,b,c,d){L._super_.call(this,c,d),this.reset(a,b),this.name="Scale";}function K(a,b,c,d){K._super_.call(this,c,d),this.reset(a,b),this.name="Alpha";}function J(a,b,c,d){J._super_.call(this,c,d),this.reset(a,b),this.name="CrossZone";}function I(a,b,c,d,e){I._super_.call(this,d,e),this.reset(a,b,c),this.name="Collision";}function H(a,b,c){H._super_.call(this,0,-a,0,b,c),this.name="Gravity";}function G(a,b,c,d,e){G._super_.call(this,a,b,c,d,e),this.force*=-1,this.name="Repulsion";}function F(a,b,c,d,e,f){F._super_.call(this,e,f),this.reset(a,b,c,d),this.time=0,this.name="RandomDrift";}function E(a,c,d,e,f){E._super_.call(this,e,f),this.targetPosition=b.Util.initValue(a,new b.Vector3D),this.radius=b.Util.initValue(d,1e3),this.force=b.Util.initValue(this.normalizeValue(c),100),this.radiusSq=this.radius*this.radius,this.attractionForce=new b.Vector3D,this.lengthSq=0,this.name="Attraction";}function D(a,b,c,d,e){D._super_.call(this,d,e),D.prototype.reset.call(this,a,b,c),this.name="Force";}function C(a,c,d){C._super_.call(this),this.body=b.createArraySpan(a),this.w=c,this.h=b.Util.initValue(d,this.w);}function B(a,c,d){B._super_.call(this),this.radius=b.createSpan(a,c,d);}function A(a,c,d){A._super_.call(this),this.massPan=b.createSpan(a,c,d);}function z(a,c,d){z._super_.call(this),this.reset(a,c,d),this.dirVec=new b.Vector3D(0,0,0),this.name="Velocity";}function y(){y._super_.call(this),this.reset.apply(this,arguments);}function x(a,c,d){x._super_.call(this),this.lifePan=b.createSpan(a,c,d);}function v(){this.name="Initialize";}function u(a,c){this.numPan=b.createSpan(b.Util.initValue(a,1)),this.timePan=b.createSpan(b.Util.initValue(c,1)),this.startTime=0,this.nextTime=0,this.init();}function t(a,c){this.id="Behaviour_"+t.id++,this.life=b.Util.initValue(a,Infinity),this.easing=b.Util.initValue(c,b.ease.setEasingByName(b.ease.easeLinear)),this.age=0,this.energy=1,this.dead=!1,this.name="Behaviour";}function s(a,b,c,d,e,f){this.x=a,this.y=b,this.z=c,this.width=d,this.height=e,this.depth=f,this.bottom=this.y+this.height,this.right=this.x+this.width,this.right=this.x+this.width;}function q(a){this._arr=b.Util.isArray(a)?a:[a];}function p(a,c,d){this._isArray=!1,b.Util.isArray(a)?(this._isArray=!0,this.a=a):(this.a=b.Util.initValue(a,1),this.b=b.Util.initValue(c,this.a),this._center=b.Util.initValue(d,!1));}function j(){this.cID=0,this.list={};}function i(a){this.id="particle_"+i.ID++,this.name="Particle",this.reset("init"),b.Util.setPrototypeByObj(this,a);}function c(){this.initialize();}function b(a,c){this.preParticles=b.Util.initValue(a,b.POOL_MAX),this.integrationType=b.Util.initValue(c,b.EULER),this.emitters=[],this.renderers=[],this.pool=new b.Pool,b.integrator=new b.Integration(this.integrationType);}b.POOL_MAX=500,b.TIME_STEP=60,b.PI=3.142,b.DR=b.PI/180,b.MEASURE=100,b.EULER="euler",b.RK2="runge-kutta2",b.RK4="runge-kutta4",b.VERLET="verlet",b.PARTICLE_CREATED="partilcleCreated",b.PARTICLE_UPDATE="partilcleUpdate",b.PARTICLE_SLEEP="particleSleep",b.PARTICLE_DEAD="partilcleDead",b.PROTON_UPDATE="protonUpdate",b.PROTON_UPDATE_AFTER="protonUpdateAfter",b.EMITTER_ADDED="emitterAdded",b.EMITTER_REMOVED="emitterRemoved",b.bindEmtterEvent=!1,b.prototype={addRender:function(a){this.renderers.push(a),a.init(this);},removeRender:function(a){this.renderers.splice(this.renderers.indexOf(a),1),a.remove(this);},addEmitter:function(a){this.emitters.push(a),a.parent=this,this.dispatchEvent("EMITTER_ADDED",a);},removeEmitter:function(a){a.parent==this&&(this.emitters.splice(this.emitters.indexOf(a),1),a.parent=null,this.dispatchEvent("EMITTER_REMOVED",a));},update:function(a){this.dispatchEvent("PROTON_UPDATE",this);var b=a||.0167;if(b>0){var c=this.emitters.length;while(c--)this.emitters[c].update(b);}this.dispatchEvent("PROTON_UPDATE_AFTER",this);},getCount:function(){var a=0,b,c=this.emitters.length;for(b=0;b<c;b++)a+=this.emitters[b].particles.length;return a},destroy:function(){var a=0,b=this.emitters.length;for(a;a<b;a++)this.emitters[a].destroy(),delete this.emitters[a];this.emitters.length=0,this.pool.destroy();}},c.initialize=function(a){a.addEventListener=d.addEventListener,a.removeEventListener=d.removeEventListener,a.removeAllEventListeners=d.removeAllEventListeners,a.hasEventListener=d.hasEventListener,a.dispatchEvent=d.dispatchEvent;};var d=c.prototype;d._listeners=null,d.initialize=function(){},d.addEventListener=function(a,b){this._listeners?this.removeEventListener(a,b):this._listeners={},this._listeners[a]||(this._listeners[a]=[]),this._listeners[a].push(b);return b},d.removeEventListener=function(a,b){if(!!this._listeners){if(!this._listeners[a])return;var c=this._listeners[a];for(var d=0,e=c.length;d<e;d++)if(c[d]==b){e==1?delete this._listeners[a]:c.splice(d,1);break}}},d.removeAllEventListeners=function(a){a?this._listeners&&delete this._listeners[a]:this._listeners=null;},d.dispatchEvent=function(a,b){var c=!1,d=this._listeners;if(a&&d){var e=d[a];if(!e)return c;e=e.slice();var f,g=e.length;while(g--){var f=e[g];c=c||f(b);}}return !!c},d.hasEventListener=function(a){var b=this._listeners;return !!b&&!!b[a]},c.initialize(b.prototype),b.EventDispatcher=c;var e=e||{initValue:function(a,b){var a=a!=null&&a!=undefined?a:b;return a},isArray:function(a){return Object.prototype.toString.call(a)==="[object Array]"},destroyArray:function(a){a.length=0;},destroyObject:function(a){for(var b in a)delete a[b];},isUndefined:function(){for(var a in arguments){var b=arguments[a];if(b!==undefined)return !1}return !0},setVectorByObj:function(a,b){b.x!==undefined&&(a.p.x=b.x),b.y!==undefined&&(a.p.y=b.y),b.z!==undefined&&(a.p.z=b.z),b.vx!==undefined&&(a.v.x=b.vx),b.vy!==undefined&&(a.v.y=b.vy),b.vz!==undefined&&(a.v.z=b.vz),b.ax!==undefined&&(a.a.x=b.ax),b.ay!==undefined&&(a.a.y=b.ay),b.az!==undefined&&(a.a.z=b.az),b.p!==undefined&&a.p.copy(b.p),b.v!==undefined&&a.v.copy(b.v),b.a!==undefined&&a.a.copy(b.a),b.position!==undefined&&a.p.copy(b.position),b.velocity!==undefined&&a.v.copy(b.velocity),b.accelerate!==undefined&&a.a.copy(b.accelerate);},setPrototypeByObj:function(a,b,c){for(var d in b)a.hasOwnProperty(d)&&(c?c.indexOf(d)<0&&(a[d]=e._getValue(b[d])):a[d]=e._getValue(b[d]));return a},_getValue:function(a){return a instanceof p?a.getValue():a},inherits:function(a,b){a._super_=b;if(Object.create)a.prototype=Object.create(b.prototype,{constructor:{value:a}});else {var c=function(){};c.prototype=b.prototype,a.prototype=new c,a.prototype.constructor=a;}}};b.Util=e;var f=f||{getRGB:function(b){var c={};if(typeof b=="number")e=Math.floor(b),c.r=(b>>16&255)/255,c.g=(b>>8&255)/255,c.b=(b&255)/255;else if(typeof b=="string"){var d;if(d=/^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(b))c.r=Math.min(255,parseInt(d[1],10))/255,c.g=Math.min(255,parseInt(d[2],10))/255,c.b=Math.min(255,parseInt(d[3],10))/255;else if(d=/^\#([A-Fa-f0-9]+)$/.exec(b)){var e=d[1];c.r=parseInt(e.charAt(0)+e.charAt(1),16)/255,c.g=parseInt(e.charAt(2)+e.charAt(3),16)/255,c.b=parseInt(e.charAt(4)+e.charAt(5),16)/255;}}else b instanceof a.Color&&(c.r=b.r,c.g=b.g,c.b=b.b);return c}};b.ColorUtil=f;var g={toScreenPos:function(){var b=new a.Vector3;return function(a,c,d){b.copy(a),b.project(c),b.x=Math.round((b.x+1)*d.width/2),b.y=Math.round((-b.y+1)*d.height/2),b.z=0;return b}}(),toSpacePos:function(){var b=new a.Vector3,c=new a.Vector3,d;return function(a,e,f){b.set(a.x/f.width*2-1,-(a.y/f.height)*2+1,.5),b.unproject(e),c.copy(b.sub(e.position).normalize()),d=-e.position.z/c.z,b.copy(e.position),b.add(c.multiplyScalar(d));return b}}(),getTexture:function(){var c={};return function(d){if(d instanceof a.Texture)return d;if(typeof d=="string"){var e=b.PUID.hash(d);c[e]||(c[e]=new a.Texture(d));return c[e]}if(d instanceof Image){var e=b.PUID.hash(d.src);c[e]||(c[e]=new a.Texture(d));return c[e]}}}()};b.THREEUtil=g;var h=h||{_id:0,_uids:{},id:function(a){for(var b in this._uids)if(this._uids[b]==a)return b;var c="PUID_"+this._id++;this._uids[c]=a;return c},hash:function(a){return}};b.PUID=h,i.ID=0,i.prototype={getDirection:function(){return Math.atan2(this.v.x,-this.v.y)*(180/b.PI)},reset:function(a){this.life=Infinity,this.age=0,this.energy=1,this.dead=!1,this.sleep=!1,this.body=null,this.parent=null,this.mass=1,this.radius=10,this.alpha=1,this.scale=1,this.useColor=!1,this.useAlpha=!1,this.easing=b.ease.setEasingByName(b.ease.easeLinear),a?(this.p=new b.Vector3D,this.v=new b.Vector3D,this.a=new b.Vector3D,this.old={},this.old.p=this.p.clone(),this.old.v=this.v.clone(),this.old.a=this.a.clone(),this.behaviours=[],this.transform={},this.color={r:0,g:0,b:0},this.rotation=new b.Vector3D):(this.p.set(0,0,0),this.v.set(0,0,0),this.a.set(0,0,0),this.old.p.set(0,0,0),this.old.v.set(0,0,0),this.old.a.set(0,0,0),this.color.r=0,this.color.g=0,this.color.b=0,this.rotation.clear(),b.Util.destroyObject(this.transform),this.removeAllBehaviours());return this},update:function(a,b){if(!this.sleep){this.age+=a;var c=this.behaviours.length;while(c--)this.behaviours[c]&&this.behaviours[c].applyBehaviour(this,a,b);}if(this.age>=this.life)this.destroy();else {var d=this.easing(this.age/this.life);this.energy=Math.max(1-d,0);}},addBehaviour:function(a){this.behaviours.push(a),a.initialize(this);},addBehaviours:function(a){var b=a.length;while(b--)this.addBehaviour(a[b]);},removeBehaviour:function(a){var b=this.behaviours.indexOf(a);b>-1&&this.behaviours.splice(b,1);},removeAllBehaviours:function(){b.Util.destroyArray(this.behaviours);},destroy:function(){this.removeAllBehaviours(),this.energy=0,this.dead=!0,this.parent=null;}},b.Particle=i,j.prototype={create:function(a){this.cID++;return typeof a=="function"?new a:a.clone()},getCount:function(){var a=0;for(var b in this.list)a+=this.list[b].length;return a++},get:function(a){var c,d=a.__puid||b.PUID.id(a);this.list[d]&&this.list[d].length>0?c=this.list[d].pop():c=this.create(a),c.__puid=a.__puid||d;return c},expire:function(a){return this._getList(a.__puid).push(a)},destroy:function(){for(var a in this.list)this.list[a].length=0,delete this.list[a];},_getList:function(a){a=a||"default",this.list[a]||(this.list[a]=[]);return this.list[a]}},b.Pool=j;var k={randomAToB:function(a,b,c){return c?(Math.random()*(b-a)>>0)+a:a+Math.random()*(b-a)},randomFloating:function(a,b,c){return k.randomAToB(a-b,a+b,c)},randomZone:function(a){},degreeTransform:function(a){return a*b.PI/180},toColor16:function(a){return "#"+a.toString(16)},randomColor:function(){return "#"+("00000"+(Math.random()*16777216<<0).toString(16)).slice(-6)},lerp:function(a,b,c){return b+(a-b)*c},getNormal:function(a,b){a.x==0&&a.y==0?a.z==0?b.set(1,0,1):b.set(1,1,-a.y/a.z):a.x==0?b.set(1,0,1):b.set(-a.y/a.x,1,1);return b.normalize()},axisRotate:function(a,b,c,d){var e=Math.cos(d),f=Math.sin(d),g=c.dot(b)*(1-e);a.copy(c),a.cross(b).scalar(f),a.addValue(b.x*e,b.y*e,b.z*e),a.addValue(c.x*g,c.y*g,c.z*g);}};b.MathUtils=k;var m=function(a){this.type=b.Util.initValue(a,b.EULER);};m.prototype={integrate:function(a,b,c){this.euler(a,b,c);},euler:function(a,b,c){a.sleep||(a.old.p.copy(a.p),a.old.v.copy(a.v),a.a.scalar(1/a.mass),a.v.add(a.a.scalar(b)),a.p.add(a.old.v.scalar(b)),c&&a.v.scalar(c),a.a.clear());}},b.Integration=m;var n=function(a,b,c){this.x=a||0,this.y=b||0,this.z=c||0;};n.prototype={set:function(a,b,c){this.x=a,this.y=b,this.z=c;return this},setX:function(a){this.x=a;return this},setY:function(a){this.y=a;return this},setZ:function(a){this.z=a;return this},getGradient:function(){if(this.x!=0)return Math.atan2(this.y,this.x);if(this.y>0)return b.PI/2;if(this.y<0)return -b.PI/2},copy:function(a){this.x=a.x,this.y=a.y,this.z=a.z;return this},add:function(a,b){if(b!==undefined)return this.addVectors(a,b);this.x+=a.x,this.y+=a.y,this.z+=a.z;return this},addValue:function(a,b,c){this.x+=a,this.y+=b,this.z+=c;return this},addVectors:function(a,b){this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z;return this},addScalar:function(a){this.x+=a,this.y+=a,this.z+=a;return this},sub:function(a,b){if(b!==undefined)return this.subVectors(a,b);this.x-=a.x,this.y-=a.y,this.z-=a.z;return this},subVectors:function(a,b){this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z;return this},scalar:function(a){this.x*=a,this.y*=a,this.z*=a;return this},divideScalar:function(a){a!==0?(this.x/=a,this.y/=a,this.z/=a):this.set(0,0,0);return this},negate:function(){return this.scalar(-1)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z},cross:function(a){var b=this.x,c=this.y,d=this.z;this.x=c*a.z-d*a.y,this.y=d*a.x-b*a.z,this.z=b*a.y-c*a.x;return this},lengthSq:function(){return this.x*this.x+this.y*this.y+this.z*this.z},length:function(){return Math.sqrt(this.lengthSq())},normalize:function(){return this.divideScalar(this.length())},distanceTo:function(a){return Math.sqrt(this.distanceToSquared(a))},crossVectors:function(a,b){var c=a.x,d=a.y,e=a.z,f=b.x,g=b.y,h=b.z;this.x=d*h-e*g,this.y=e*f-c*h,this.z=c*g-d*f;return this},eulerFromDir:function(a){},applyEuler:function(){var a;return function(c){a===undefined&&(a=new b.Quaternion),this.applyQuaternion(a.setFromEuler(c));return this}}(),applyAxisAngle:function(){var a;return function(c,d){a===undefined&&(a=new b.Quaternion),this.applyQuaternion(a.setFromAxisAngle(c,d));return this}}(),applyQuaternion:function(a){var b=this.x,c=this.y,d=this.z,e=a.x,f=a.y,g=a.z,h=a.w,i=h*b+f*d-g*c,j=h*c+g*b-e*d,k=h*d+e*c-f*b,l=-e*b-f*c-g*d;this.x=i*h+l*-e+j*-g-k*-f,this.y=j*h+l*-f+k*-e-i*-g,this.z=k*h+l*-g+i*-f-j*-e;return this},distanceToSquared:function(a){var b=this.x-a.x,c=this.y-a.y,d=this.z-a.z;return b*b+c*c+d*d},lerp:function(a,b){this.x+=(a.x-this.x)*b,this.y+=(a.y-this.y)*b,this.z+=(a.z-this.z)*b;return this},equals:function(a){return a.x===this.x&&a.y===this.y&&a.z===this.z},clear:function(){this.x=0,this.y=0,this.z=0;return this},clone:function(){return new b.Vector3D(this.x,this.y,this.z)},toString:function(){return "x:"+this.x+"y:"+this.y+"z:"+this.z}},b.Vector3D=n;var o=function(a,b,c){this.radius=a||1,this.phi=c||0,this.theta=b||0;};o.prototype={set:function(a,b,c){this.radius=a||1,this.phi=c||0,this.theta=b||0;return this},setRadius:function(a){this.radius=a;return this},setPhi:function(a){this.phi=a;return this},setTheta:function(a){this.theta=a;return this},copy:function(a){this.radius=a.radius,this.phi=a.phi,this.theta=a.theta;return this},toVector3D:function(){return new b.Vector3D(this.getX(),this.getY(),this.getZ())},getX:function(){return this.radius*Math.sin(this.theta)*Math.cos(this.phi)},getY:function(){return -this.radius*Math.sin(this.theta)*Math.sin(this.phi)},getZ:function(){return this.radius*Math.cos(this.theta)},normalize:function(){this.radius=1;return this},equals:function(a){return a.radius===this.radius&&a.phi===this.phi&&a.theta===this.theta},clear:function(){this.radius=0,this.phi=0,this.theta=0;return this},clone:function(){return new o(this.radius,this.phi,this.theta)}},b.Polar3D=o,p.prototype={getValue:function(a){return this._isArray?this.a[this.a.length*Math.random()>>0]:this._center?b.MathUtils.randomFloating(this.a,this.b,a):b.MathUtils.randomAToB(this.a,this.b,a)}},b.createSpan=function(a,b,c){if(a instanceof p)return a;return b===undefined?new p(a):c===undefined?new p(a,b):new p(a,b,c)},b.Span=p,b.Util.inherits(q,b.Span),q.prototype.getValue=function(){var a=this._arr[this._arr.length*Math.random()>>0];return a=="random"||a=="Random"?b.MathUtils.randomColor():a},b.createArraySpan=function(a){if(!a)return null;return a instanceof b.ArraySpan?a:new b.ArraySpan(a)},b.ArraySpan=q;var r=function(a,b,c,d){this.x=a||0,this.y=b||0,this.z=c||0,this.w=d!==undefined?d:1;};r.prototype={set:function(a,b,c,d){this.x=a,this.y=b,this.z=c,this.w=d;return this},clone:function(){return new b.Quaternion(this.x,this.y,this.z,this.w)},copy:function(a){this.x=a.x,this.y=a.y,this.z=a.z,this.w=a.w;return this},setFromEuler:function(a){var b=Math.cos(a.x/2),c=Math.cos(a.y/2),d=Math.cos(a.z/2),e=Math.sin(a.x/2),f=Math.sin(a.y/2),g=Math.sin(a.z/2);this.x=e*c*d+b*f*g,this.y=b*f*d-e*c*g,this.z=b*c*g+e*f*d,this.w=b*c*d-e*f*g;return this},setFromAxisAngle:function(a,b){var c=b/2,d=Math.sin(c);this.x=a.x*d,this.y=a.y*d,this.z=a.z*d,this.w=Math.cos(c);return this},normalize:function(){var a=this.length();a===0?(this.x=0,this.y=0,this.z=0,this.w=1):(a=1/a,this.x*=a,this.y*=a,this.z*=a,this.w*=a);return this},length:function(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)},dot:function(a){return this.x*a.x+this.y*a.y+this.z*a.z+this.w*a.w}},b.Quaternion=r,s.prototype={contains:function(a,b,c){return a<=this.right&&a>=this.x&&b<=this.bottom&&b>=this.y&&c<=this.depth&&c>=this.z?!0:!1}},b.Box=s,t.id=0,t.prototype={reset:function(a,c){this.life=b.Util.initValue(a,Infinity),this.easing=b.Util.initValue(c,b.ease.setEasingByName(b.ease.easeLinear));},normalizeForce:function(a){return a.scalar(b.MEASURE)},normalizeValue:function(a){return a*b.MEASURE},initialize:function(a){},applyBehaviour:function(a,b,c){if(!this.dead){this.age+=b;if(this.age>=this.life){this.energy=0,this.dead=!0;return}var d=this.easing(a.age/a.life);this.energy=Math.max(1-d,0);}},destroy:function(){}},b.Behaviour=t,u.prototype={init:function(){this.startTime=0,this.nextTime=this.timePan.getValue();},getValue:function(a){this.startTime+=a;if(this.startTime>=this.nextTime){this.init();return this.numPan.b==1?this.numPan.getValue("Float")>.5?1:0:this.numPan.getValue("Int")}return 0}},b.Rate=u,v.prototype.reset=function(){},v.prototype.init=function(a,b){b?this.initialize(b):this.initialize(a);},v.prototype.initialize=function(a){},b.Initialize=v;var w={initialize:function(a,c,d){var e=d.length;while(e--){var f=d[e];f instanceof b.Initialize?f.init(a,c):w.init(a,c,f);}w.bindEmitter(a,c);},init:function(a,c,d){b.Util.setPrototypeByObj(c,d),b.Util.setVectorByObj(c,d);},bindEmitter:function(a,b){a.bindEmitter&&(b.p.add(a.p),b.v.add(a.v),b.a.add(a.a),b.v.applyEuler(a.rotation));}};b.InitializeUtil=w,b.Util.inherits(x,b.Initialize),x.prototype.initialize=function(a){this.lifePan.a==Infinity||this.lifePan.a=="infi"?a.life=Infinity:a.life=this.lifePan.getValue();},b.Life=x,b.Util.inherits(y,b.Initialize),y.prototype.reset=function(){this.zones?this.zones.length=0:this.zones=[];var a=Array.prototype.slice.call(arguments);this.zones=this.zones.concat(a);},y.prototype.addZone=function(){var a=Array.prototype.slice.call(arguments);this.zones=this.zones.concat(a);},y.prototype.initialize=function(){return function(a){var b=this.zones[Math.random()*this.zones.length>>0];b.getPosition(),a.p.x=b.vector.x,a.p.y=b.vector.y,a.p.z=b.vector.z;}}(),b.Position=y,b.P=y,b.Util.inherits(z,b.Initialize),z.prototype.reset=function(a,c,d){a instanceof b.Vector3D?(this.radiusPan=b.createSpan(1),this.dir=a.clone(),this.tha=c*b.DR,this._useV=!0):a instanceof b.Polar3D?(this.tha=c*b.DR,this.dirVec=a.toVector3D(),this._useV=!1):(this.radiusPan=b.createSpan(a),this.dir=c.clone().normalize(),this.tha=d*b.DR,this._useV=!0);},z.prototype.normalize=function(a){return a*b.MEASURE},z.prototype.initialize=function(){var a,c=new b.Vector3D(0,0,1),d=new b.Vector3D(0,0,0);return function(e){a=this.tha*Math.random(),this._useV&&this.dirVec.copy(this.dir).scalar(this.radiusPan.getValue()),b.MathUtils.getNormal(this.dirVec,c),d.copy(this.dirVec).applyAxisAngle(c,a),d.applyAxisAngle(this.dirVec.normalize(),Math.random()*b.PI*2),e.v.copy(d);return this}}(),b.Velocity=z,b.V=z,b.Util.inherits(A,b.Initialize),A.prototype.initialize=function(a){a.mass=this.massPan.getValue();},b.Mass=A,b.Util.inherits(B,b.Initialize),B.prototype.reset=function(a,c,d){this.radius=b.createSpan(a,c,d);},B.prototype.initialize=function(a){a.radius=this.radius.getValue(),a.transform.oldRadius=a.radius;},b.Radius=B,b.Util.inherits(C,b.Initialize),C.prototype.initialize=function(a){var b=this.body.getValue();this.w?a.body={width:this.w,height:this.h,body:b}:a.body=b;},b.Body=C,b.Util.inherits(D,b.Behaviour),D.prototype.reset=function(a,c,d){this.force=this.normalizeForce(new b.Vector3D(a,c,d)),this.force.id=Math.random();},D.prototype.applyBehaviour=function(a,b,c){D._super_.prototype.applyBehaviour.call(this,a,b,c),a.a.add(this.force);},b.F=b.Force=D,b.Util.inherits(E,b.Behaviour),E.prototype.reset=function(a,c,d,e,f){this.targetPosition=b.Util.initValue(a,new b.Vector3D),this.radius=b.Util.initValue(d,1e3),this.force=b.Util.initValue(this.normalizeValue(c),100),this.radiusSq=this.radius*this.radius,this.attractionForce=new b.Vector3D,this.lengthSq=0,e&&E._super_.prototype.reset.call(this,e,f);},E.prototype.applyBehaviour=function(a,b,c){E._super_.prototype.applyBehaviour.call(this,a,b,c),this.attractionForce.copy(this.targetPosition),this.attractionForce.sub(a.p),this.lengthSq=this.attractionForce.lengthSq(),this.lengthSq>4e-6&&this.lengthSq<this.radiusSq&&(this.attractionForce.normalize(),this.attractionForce.scalar(1-this.lengthSq/this.radiusSq),this.attractionForce.scalar(this.force),a.a.add(this.attractionForce));},b.Attraction=E,b.Util.inherits(F,b.Behaviour),F.prototype.reset=function(a,c,d,e,f,g){this.randomFoce=this.normalizeForce(new b.Vector3D(a,c,d)),this.delayPan=b.createSpan(e||.03),this.time=0,f&&F._super_.prototype.reset.call(this,f,g);},F.prototype.applyBehaviour=function(a,c,d){F._super_.prototype.applyBehaviour.call(this,a,c,d),this.time+=c;if(this.time>=this.delayPan.getValue()){var e=b.MathUtils.randomAToB(-this.randomFoce.x,this.randomFoce.x),f=b.MathUtils.randomAToB(-this.randomFoce.y,this.randomFoce.y),g=b.MathUtils.randomAToB(-this.randomFoce.z,this.randomFoce.z);a.a.addValue(e,f,g),this.time=0;}},b.RandomDrift=F,b.Util.inherits(G,b.Attraction),G.prototype.reset=function(a,b,c,d,e){G._super_.prototype.reset.call(this,a,b,c,d,e),this.force*=-1;},b.Repulsion=G,b.Util.inherits(H,b.Force),H.prototype.reset=function(a,b,c){H._super_.prototype.reset.call(this,0,-a,0,b,c);},b.Gravity=H,b.G=H,b.Util.inherits(I,b.Behaviour),I.prototype.reset=function(a,c,d,e,f){this.emitter=a,this.useMass=c,this.callback=d,this.particles=[],this.delta=new b.Vector3D,e&&I._super_.prototype.reset.call(this,e,f);},I.prototype.applyBehaviour=function(a,b,c){var d=this.emitter?this.emitter.particles.slice(c):this.particles.slice(c),e,f,g,h,i,j,k=d.length;while(k--){e=d[k];if(e==a)continue;this.delta.copy(e.p).sub(a.p),f=this.delta.lengthSq(),h=a.radius+e.radius,f<=h*h&&(g=h-Math.sqrt(f),g+=.5,i=this._getAverageMass(a,e),j=this._getAverageMass(e,a),a.p.add(this.delta.clone().normalize().scalar(g*-i)),e.p.add(this.delta.normalize().scalar(g*j)),this.callback&&this.callback(a,e));}},I.prototype._getAverageMass=function(a,b){return this.useMass?b.mass/(a.mass+b.mass):.5},b.Collision=I,b.Util.inherits(J,b.Behaviour),J.prototype.reset=function(a,c,d,e){var f,g;typeof a=="string"?(g=a,f=c):(g=c,f=a),this.zone=f,this.zone.crossType=b.Util.initValue(g,"dead"),d&&J._super_.prototype.reset.call(this,d,e);},J.prototype.applyBehaviour=function(a,b,c){J._super_.prototype.applyBehaviour.call(this,a,b,c),this.zone.crossing.call(this.zone,a);},b.CrossZone=J,b.Util.inherits(K,b.Behaviour),K.prototype.reset=function(a,c,d,e){c==null||c==undefined?this._same=!0:this._same=!1,this.a=b.createSpan(b.Util.initValue(a,1)),this.b=b.createSpan(c),d&&K._super_.prototype.reset.call(this,d,e);},K.prototype.initialize=function(a){a.useAlpha=!0,a.transform.alphaA=this.a.getValue(),this._same?a.transform.alphaB=a.transform.alphaA:a.transform.alphaB=this.b.getValue();},K.prototype.applyBehaviour=function(a,c,d){K._super_.prototype.applyBehaviour.call(this,a,c,d),a.alpha=b.MathUtils.lerp(a.transform.alphaA,a.transform.alphaB,this.energy),a.alpha<.002&&(a.alpha=0);},b.Alpha=K,b.Util.inherits(L,b.Behaviour),L.prototype.reset=function(a,c,d,e){c==null||c==undefined?this._same=!0:this._same=!1,this.a=b.createSpan(b.Util.initValue(a,1)),this.b=b.createSpan(c),d&&L._super_.prototype.reset.call(this,d,e);},L.prototype.initialize=function(a){a.transform.scaleA=this.a.getValue(),a.transform.oldRadius=a.radius,this._same?a.transform.scaleB=a.transform.scaleA:a.transform.scaleB=this.b.getValue();},L.prototype.applyBehaviour=function(a,c,d){L._super_.prototype.applyBehaviour.call(this,a,c,d),a.scale=b.MathUtils.lerp(a.transform.scaleA,a.transform.scaleB,this.energy),a.scale<5e-4&&(a.scale=0),a.radius=a.transform.oldRadius*a.scale;},b.Scale=L,b.Util.inherits(M,b.Behaviour),M.prototype.reset=function(a,c,d,e,f){this.a=a||0,this.b=c||0,this.c=d||0,a===undefined||a=="same"?this._type="same":c==undefined?this._type="set":d===undefined?this._type="to":(this._type="add",this.a=b.createSpan(this.a*b.DR),this.b=b.createSpan(this.b*b.DR),this.c=b.createSpan(this.c*b.DR)),e&&M._super_.prototype.reset.call(this,e,f);},M.prototype.initialize=function(a){switch(this._type){case"same":break;case"set":this._setRotation(a.rotation,this.a);break;case"to":a.transform.fR=a.transform.fR||new b.Vector3D,a.transform.tR=a.transform.tR||new b.Vector3D,this._setRotation(a.transform.fR,this.a),this._setRotation(a.transform.tR,this.b);break;case"add":a.transform.addR=new b.Vector3D(this.a.getValue(),this.b.getValue(),this.c.getValue());}},M.prototype._setRotation=function(a,c){a=a||new b.Vector3D;if(c=="random"){var d=b.MathUtils.randomAToB(-b.PI,b.PI),e=b.MathUtils.randomAToB(-b.PI,b.PI),f=b.MathUtils.randomAToB(-b.PI,b.PI);a.set(d,e,f);}else c instanceof b.Vector3D&&a.copy(c);},M.prototype.applyBehaviour=function(a,c,d){M._super_.prototype.applyBehaviour.call(this,a,c,d);switch(this._type){case"same":a.rotation||(a.rotation=new b.Vector3D),a.rotation.eulerFromDir(a.v);break;case"set":break;case"to":a.rotation.x=b.MathUtils.lerp(a.transform.fR.x,a.transform.tR.x,this.energy),a.rotation.y=b.MathUtils.lerp(a.transform.fR.y,a.transform.tR.y,this.energy),a.rotation.z=b.MathUtils.lerp(a.transform.fR.z,a.transform.tR.z,this.energy);break;case"add":a.rotation.add(a.transform.addR);}},b.Rotate=M,b.Util.inherits(N,b.Behaviour),N.prototype.reset=function(a,c,d,e){c==null||c==undefined?this._same=!0:this._same=!1,this.a=b.createArraySpan(a),this.b=b.createArraySpan(c),d&&N._super_.prototype.reset.call(this,d,e);},N.prototype.initialize=function(a){a.transform.colorA=b.ColorUtil.getRGB(this.a.getValue()),a.useColor=!0,this._same?a.transform.colorB=a.transform.colorA:a.transform.colorB=b.ColorUtil.getRGB(this.b.getValue());},N.prototype.applyBehaviour=function(a,c,d){N._super_.prototype.applyBehaviour.call(this,a,c,d),this._same?(a.color.r=a.transform.colorA.r,a.color.g=a.transform.colorA.g,a.color.b=a.transform.colorA.b):(a.color.r=b.MathUtils.lerp(a.transform.colorA.r,a.transform.colorB.r,this.energy),a.color.g=b.MathUtils.lerp(a.transform.colorA.g,a.transform.colorB.g,this.energy),a.color.b=b.MathUtils.lerp(a.transform.colorA.b,a.transform.colorB.b,this.energy));},b.Color=N,b.Util.inherits(O,b.Behaviour),O.prototype.reset=function(a,c,d,e,f){this.pos?this.pos.set(a,c,d):this.pos=new b.Vector3D(a,c,d),this.spring=e||.1,this.friction=f||.98;},O.prototype.applyBehaviour=function(a,b,c){O._super_.prototype.applyBehaviour.call(this,a,b,c),a.v.x+=(this.pos.x-a.p.x)*this.spring,a.v.y+=(this.pos.y-a.p.y)*this.spring,a.v.z+=(this.pos.z-a.p.z)*this.spring;},b.Spring=O,P.ID=0,b.Util.inherits(P,b.Particle),b.EventDispatcher.initialize(P.prototype),P.prototype.emit=function(a,c){this.currentEmitTime=0,this.totalEmitTimes=b.Util.initValue(a,Infinity),c==!0||c=="life"||c=="destroy"?this.life=a=="once"?1:this.totalEmitTimes:isNaN(c)||(this.life=c),this.rate.init();},P.prototype.stopEmit=function(){this.totalEmitTimes=-1,this.currentEmitTime=0;},P.prototype.removeAllParticles=function(){var a=this.particles.length;while(a--)this.particles[a].dead=!0;},P.prototype.createParticle=function(a,c){var d=this.parent.pool.get(b.Particle);this.setupParticle(d,a,c),this.parent&&this.parent.dispatchEvent("PARTICLE_CREATED",d),b.bindEmtterEvent&&this.dispatchEvent("PARTICLE_CREATED",d);return d},P.prototype.addSelfInitialize=function(a){a.init?a.init(this):this.initAll();},P.prototype.addInitialize=function(){var a=arguments.length;while(a--)this.initializes.push(arguments[a]);},P.prototype.removeInitialize=function(a){var b=this.initializes.indexOf(a);b>-1&&this.initializes.splice(b,1);},P.prototype.removeInitializers=function(){b.Util.destroyArray(this.initializes);},P.prototype.addBehaviour=function(){var a=arguments.length;while(a--)this.behaviours.push(arguments[a]);},P.prototype.removeBehaviour=function(a){var b=this.behaviours.indexOf(a);b>-1&&this.behaviours.splice(b,1);},P.prototype.removeAllBehaviours=function(){b.Util.destroyArray(this.behaviours);},P.prototype.integrate=function(a){var c=1-this.damping;b.integrator.integrate(this,a,c);var d=this.particles.length;while(d--){var e=this.particles[d];e.update(a,d),b.integrator.integrate(e,a,c),this.parent&&this.parent.dispatchEvent("PARTICLE_UPDATE",e),b.bindEmtterEvent&&this.dispatchEvent("PARTICLE_UPDATE",e);}},P.prototype.emitting=function(a){if(this.totalEmitTimes=="once"){var b=this.rate.getValue(99999);b>0&&(this.cID=b);while(b--)this.createParticle();this.totalEmitTimes="none";}else if(!isNaN(this.totalEmitTimes)){this.currentEmitTime+=a;if(this.currentEmitTime<this.totalEmitTimes){var b=this.rate.getValue(a);b>0&&(this.cID=b);while(b--)this.createParticle();}}},P.prototype.update=function(a){this.age+=a,(this.dead||this.age>=this.life)&&this.destroy(),this.emitting(a),this.integrate(a);var c,d=this.particles.length;while(d--)c=this.particles[d],c.dead&&(this.parent&&this.parent.dispatchEvent("PARTICLE_DEAD",c),b.bindEmtterEvent&&this.dispatchEvent("PARTICLE_DEAD",c),this.parent.pool.expire(c.reset()),this.particles.splice(d,1));},P.prototype.setupParticle=function(a,c,d){var e=this.initializes,f=this.behaviours;c&&(b.Util.isArray(c)?e=c:e=[c]),d&&(b.Util.isArray(d)?f=d:f=[d]),b.InitializeUtil.initialize(this,a,e),a.addBehaviours(f),a.parent=this,this.particles.push(a);},P.prototype.destroy=function(){this.dead=!0,this.energy=0,this.totalEmitTimes=-1,this.particles.length==0&&(this.removeInitializers(),this.removeAllBehaviours(),this.parent&&this.parent.removeEmitter(this));},b.Emitter=P,b.Util.inherits(Q,b.Emitter),Q.prototype.addSelfBehaviour=function(){var a=arguments.length,b;for(b=0;b<a;b++)this.selfBehaviours.push(arguments[b]);},Q.prototype.removeSelfBehaviour=function(a){var b=this.selfBehaviours.indexOf(a);b>-1&&this.selfBehaviours.splice(b,1);},Q.prototype.update=function(a){Q._super_.prototype.update.call(this,a);if(!this.sleep){var b=this.selfBehaviours.length,c;for(c=0;c<b;c++)this.selfBehaviours[c].applyBehaviour(this,a,c);}},b.BehaviourEmitter=Q,b.Util.inherits(R,b.Emitter),R.prototype.initEventHandler=function(){var a=this;this.mousemoveHandler=function(b){a.mousemove.call(a,b);},this.mousedownHandler=function(b){a.mousedown.call(a,b);},this.mouseupHandler=function(b){a.mouseup.call(a,b);},this.mouseTarget.addEventListener("mousemove",this.mousemoveHandler,!1);},R.prototype.emit=function(){this._allowEmitting=!0;},R.prototype.stopEmit=function(){this._allowEmitting=!1;},R.prototype.setCameraAndCanvas=function(a,b){this.camera=a,this.canvas=b;},R.prototype.setCameraAndRenderer=function(a,b){this.camera=a,this.renderer=b,this.canvas=b.domElement;},R.prototype.mousemove=function(a){var c=this.canvas.getBoundingClientRect(),d=a.clientX-c.left,e=a.clientY-c.top,f=this.renderer?this.renderer.getPixelRatio():1;d*=f,e*=f,this.mouse.x+=(d-this.mouse.x)*this.ease,this.mouse.y+=(e-this.mouse.y)*this.ease,this.p.copy(b.THREEUtil.toSpacePos(this.mouse,this.camera,this.canvas,this.renderer)),this._allowEmitting&&R._super_.prototype.emit.call(this,"once");},R.prototype.destroy=function(){R._super_.prototype.destroy.call(this),this.mouseTarget.removeEventListener("mousemove",this.mousemoveHandler,!1);},b.FollowEmitter=R;var S=S||{easeLinear:function(a){return a},easeInQuad:function(a){return Math.pow(a,2)},easeOutQuad:function(a){return -(Math.pow(a-1,2)-1)},easeInOutQuad:function(a){if((a/=.5)<1)return .5*Math.pow(a,2);return -0.5*((a-=2)*a-2)},easeInCubic:function(a){return Math.pow(a,3)},easeOutCubic:function(a){return Math.pow(a-1,3)+1},easeInOutCubic:function(a){if((a/=.5)<1)return .5*Math.pow(a,3);return .5*(Math.pow(a-2,3)+2)},easeInQuart:function(a){return Math.pow(a,4)},easeOutQuart:function(a){return -(Math.pow(a-1,4)-1)},easeInOutQuart:function(a){if((a/=.5)<1)return .5*Math.pow(a,4);return -0.5*((a-=2)*Math.pow(a,3)-2)},easeInSine:function(a){return -Math.cos(a*(b.PI/2))+1},easeOutSine:function(a){return Math.sin(a*(b.PI/2))},easeInOutSine:function(a){return -0.5*(Math.cos(b.PI*a)-1)},easeInExpo:function(a){return a===0?0:Math.pow(2,10*(a-1))},easeOutExpo:function(a){return a===1?1:-Math.pow(2,-10*a)+1},easeInOutExpo:function(a){if(a===0)return 0;if(a===1)return 1;if((a/=.5)<1)return .5*Math.pow(2,10*(a-1));return .5*(-Math.pow(2,-10*--a)+2)},easeInCirc:function(a){return -(Math.sqrt(1-a*a)-1)},easeOutCirc:function(a){return Math.sqrt(1-Math.pow(a-1,2))},easeInOutCirc:function(a){if((a/=.5)<1)return -0.5*(Math.sqrt(1-a*a)-1);return .5*(Math.sqrt(1-(a-=2)*a)+1)},easeInBack:function(a){var b=1.70158;return a*a*((b+1)*a-b)},easeOutBack:function(a){var b=1.70158;return (a=a-1)*a*((b+1)*a+b)+1},easeInOutBack:function(a){var b=1.70158;if((a/=.5)<1)return .5*a*a*(((b*=1.525)+1)*a-b);return .5*((a-=2)*a*(((b*=1.525)+1)*a+b)+2)},setEasingByName:function(a){return S[a]?S[a]:S.easeLinear}};for(var T in S)T!="setEasingByName"&&(b[T]=S[T]);b.ease=S,U.prototype={init:function(a){var b=this;this.proton=a,this.proton.addEventListener("PROTON_UPDATE",function(a){b.onProtonUpdate.call(b,a);}),this.proton.addEventListener("PARTICLE_CREATED",function(a){b.onParticleCreated.call(b,a);}),this.proton.addEventListener("PARTICLE_UPDATE",function(a){b.onParticleUpdate.call(b,a);}),this.proton.addEventListener("PARTICLE_DEAD",function(a){b.onParticleDead.call(b,a);});},remove:function(a){this.proton=null;},onParticleCreated:function(a){},onParticleUpdate:function(a){},onParticleDead:function(a){},onProtonUpdate:function(a){}},b.BaseRender=U,b.Util.inherits(V,b.BaseRender),V.prototype.onProtonUpdate=function(){},V.prototype.onParticleCreated=function(a){if(!a.target){a.body||(a.body=this._body),a.target=this._targetPool.get(a.body);if(a.useAlpha||a.useColor)a.target.material.__puid=b.PUID.id(a.body.material),a.target.material=this._materialPool.get(a.target.material);}a.target&&(a.target.position.copy(a.p),this.container.add(a.target));},V.prototype.onParticleUpdate=function(a){a.target&&(a.target.position.copy(a.p),a.target.rotation.set(a.rotation.x,a.rotation.y,a.rotation.z),this.scale(a),a.useAlpha&&(a.target.material.opacity=a.alpha,a.target.material.transparent=!0),a.useColor&&a.target.material.color.copy(a.color));},V.prototype.scale=function(a){a.target.scale.set(a.scale,a.scale,a.scale);},V.prototype.onParticleDead=function(a){a.target&&((a.useAlpha||a.useColor)&&this._materialPool.expire(a.target.material),this._targetPool.expire(a.target),this.container.remove(a.target),a.target=null);},b.MeshRender=V,b.Util.inherits(W,b.BaseRender),W.prototype.onProtonUpdate=function(){},W.prototype.onParticleCreated=function(b){b.target||(b.target=new a.Vector3),b.target.copy(b.p),this.points.geometry.vertices.push(b.target);},W.prototype.onParticleUpdate=function(a){a.target&&a.target.copy(a.p);},W.prototype.onParticleDead=function(a){if(a.target){var b=this.points.geometry.vertices.indexOf(a.target);b>-1&&this.points.geometry.vertices.splice(b,1),a.target=null;}},b.PointsRender=W,b.Util.inherits(X,b.MeshRender),X.prototype.scale=function(a){a.target.scale.set(a.scale*a.radius,a.scale*a.radius,1);},b.SpriteRender=X,b.Util.inherits(Y,b.BaseRender),Y.prototype.onProtonUpdate=function(){},Y.prototype.onParticleCreated=function(a){},Y.prototype.onParticleUpdate=function(a){},Y.prototype.onParticleDead=function(a){},b.CustomRender=Y,Z.prototype={getPosition:function(){return null},crossing:function(a){switch(this.crossType){case"bound":this._bound(a);break;case"cross":this._cross(a);break;case"dead":this._dead(a);}},_dead:function(a){},_bound:function(a){},_cross:function(a){}},b.Zone=Z,b.Util.inherits($,b.Zone),$.prototype.getPosition=function(){this.random=Math.random(),this.vector.x=this.x1+this.random*(this.x2-this.x1),this.vector.y=this.y1+this.random*(this.y2-this.y1),this.vector.z=this.z1+this.random*(this.z2-this.z1);return this.vector},$.prototype.crossing=function(a){this.log&&(console.error("Sorry LineZone does not support crossing method"),this.log=!1);},b.LineZone=$,b.Util.inherits(_,b.Zone),_.prototype.getPosition=function(){var a,c,d;return function(){this.random=Math.random(),d=this.random*this.radius,a=b.PI*Math.random(),c=b.PI*2*Math.random(),this.vector.x=this.x+d*Math.sin(a)*Math.cos(c),this.vector.y=this.y+d*Math.sin(c)*Math.sin(a),this.vector.z=this.z+d*Math.cos(a);return this.vector}}(),_.prototype._dead=function(a){var b=a.p.distanceTo(this);b-a.radius>this.radius&&(a.dead=!0);},_.prototype._bound=function(){var a=new b.Vector3D,c=new b.Vector3D,d;return function(b){var e=b.p.distanceTo(this);e+b.radius>=this.radius&&(a.copy(b.p).sub(this).normalize(),c.copy(b.v),d=2*c.dot(a),b.v.sub(a.scalar(d)));}}(),_.prototype._cross=function(a){this.log&&(console.error("Sorry SphereZone does not support _cross method"),this.log=!1);},b.SphereZone=_,b.Util.inherits(ba,b.Zone),ba.prototype.getPosition=function(){var a=this.geometry.vertices,b=a[a.length*Math.random()>>0];this.vector.x=b.x*this.scale,this.vector.y=b.y*this.scale,this.vector.z=b.z*this.scale;return this.vector},ba.prototype.crossing=function(a){this.log&&(console.error("Sorry MeshZone does not support crossing method"),this.log=!1);},b.MeshZone=ba,b.Util.inherits(bb,b.Zone),bb.prototype.getPosition=function(){this.vector.x=this.x,this.vector.y=this.y,this.vector.z=this.z;return this.vector},bb.prototype.crossing=function(a){this.log&&(console.error("Sorry PointZone does not support crossing method"),this.log=!1);},b.PointZone=bb,b.Util.inherits(bc,b.Zone),bc.prototype.getPosition=function(){this.vector.x=this.x+b.MathUtils.randomAToB(-0.5,.5)*this.width,this.vector.y=this.y+b.MathUtils.randomAToB(-0.5,.5)*this.height,this.vector.z=this.z+b.MathUtils.randomAToB(-0.5,.5)*this.depth;return this.vector},bc.prototype._dead=function(a){a.p.x+a.radius<this.x-this.width/2?a.dead=!0:a.p.x-a.radius>this.x+this.width/2&&(a.dead=!0),a.p.y+a.radius<this.y-this.height/2?a.dead=!0:a.p.y-a.radius>this.y+this.height/2&&(a.dead=!0),a.p.z+a.radius<this.z-this.depth/2?a.dead=!0:a.p.z-a.radius>this.z+this.depth/2&&(a.dead=!0);},bc.prototype._bound=function(a){a.p.x-a.radius<this.x-this.width/2?(a.p.x=this.x-this.width/2+a.radius,a.v.x*=-this.friction,this._static(a,"x")):a.p.x+a.radius>this.x+this.width/2&&(a.p.x=this.x+this.width/2-a.radius,a.v.x*=-this.friction,this._static(a,"x")),a.p.y-a.radius<this.y-this.height/2?(a.p.y=this.y-this.height/2+a.radius,a.v.y*=-this.friction,this._static(a,"y")):a.p.y+a.radius>this.y+this.height/2&&(a.p.y=this.y+this.height/2-a.radius,a.v.y*=-this.friction,this._static(a,"y")),a.p.z-a.radius<this.z-this.depth/2?(a.p.z=this.z-this.depth/2+a.radius,a.v.z*=-this.friction,this._static(a,"z")):a.p.z+a.radius>this.z+this.depth/2&&(a.p.z=this.z+this.depth/2-a.radius,a.v.z*=-this.friction,this._static(a,"z"));},bc.prototype._static=function(a,b){a.v[b]*a.a[b]>0||Math.abs(a.v[b])<Math.abs(a.a[b])*.0167*this.max&&(a.v[b]=0,a.a[b]=0);},bc.prototype._cross=function(a){a.p.x+a.radius<this.x-this.width/2&&a.v.x<=0?a.p.x=this.x+this.width/2+a.radius:a.p.x-a.radius>this.x+this.width/2&&a.v.x>=0&&(a.p.x=this.x-this.width/2-a.radius),a.p.y+a.radius<this.y-this.height/2&&a.v.y<=0?a.p.y=this.y+this.height/2+a.radius:a.p.y-a.radius>this.y+this.height/2&&a.v.y>=0&&(a.p.y=this.y-this.height/2-a.radius),a.p.z+a.radius<this.z-this.depth/2&&a.v.z<=0?a.p.z=this.z+this.depth/2+a.radius:a.p.z-a.radius>this.z+this.depth/2&&a.v.z>=0&&(a.p.z=this.z-this.depth/2-a.radius);},b.BoxZone=bc,b.Util.inherits(bd,b.Zone),bd.prototype.getPosition=function(){var a=new b.Vector3D,c;return function(){c=this.renderer.domElement,a.x=Math.random()*c.width,a.y=Math.random()*c.height,this.vector.copy(b.THREEUtil.toSpacePos(a,this.camera,c));return this.vector}}(),bd.prototype._dead=function(a){var c=b.THREEUtil.toScreenPos(a.p,this.camera,this.renderer.domElement),d=this.renderer.domElement;c.y+a.radius<-this.dis&&this.d1?a.dead=!0:c.y-a.radius>d.height+this.dis&&this.d3&&(a.dead=!0),c.x+a.radius<-this.dis&&this.d4?a.dead=!0:c.x-a.radius>d.width+this.dis&&this.d2&&(a.dead=!0);},bd.prototype._cross=function(){var a=new b.Vector3D;return function(c){var d=b.THREEUtil.toScreenPos(c.p,this.camera,this.renderer.domElement),e=this.renderer.domElement;d.y+c.radius<-this.dis?(a.x=d.x,a.y=e.height+this.dis+c.radius,c.p.y=b.THREEUtil.toSpacePos(a,this.camera,e).y):d.y-c.radius>e.height+this.dis&&(a.x=d.x,a.y=-this.dis-c.radius,c.p.y=b.THREEUtil.toSpacePos(a,this.camera,e).y),d.x+c.radius<-this.dis?(a.y=d.y,a.x=e.width+this.dis+c.radius,c.p.x=b.THREEUtil.toSpacePos(a,this.camera,e).x):d.x-c.radius>e.width+this.dis&&(a.y=d.y,a.x=-this.dis-c.radius,c.p.x=b.THREEUtil.toSpacePos(a,this.camera,e).x);}}(),bd.prototype._bound=function(a){var c=b.THREEUtil.toScreenPos(a.p,this.camera,this.renderer.domElement),d=this.renderer.domElement;c.y+a.radius<-this.dis?a.v.y*=-1:c.y-a.radius>d.height+this.dis&&(a.v.y*=-1),c.x+a.radius<-this.dis?a.v.y*=-1:c.x-a.radius>d.width+this.dis&&(a.v.y*=-1);},b.ScreenZone=bd;var be=function(){if(window.console&&window.console.trace){var a=Array.prototype.slice.call(arguments),b=arguments[0]+"";if(b.indexOf("+")==0){var c=parseInt(arguments[0]);be.once<c&&(a.shift(),console.trace.apply(console,a),be.once++);}else a.unshift("+15"),be.apply(console,a);}};be.once=0,b.log=be;var bf=bf||{addEventListener:function(a,b){a.addEventListener("PROTON_UPDATE",function(a){b(a);});},drawZone:function(c,d,e){var f,g,h;e instanceof b.PointZone?f=new a.SphereGeometry(15):e instanceof b.LineZone||(e instanceof b.BoxZone?f=new a.BoxGeometry(e.width,e.height,e.depth):e instanceof b.SphereZone?f=new a.SphereGeometry(e.radius,10,10):e instanceof b.MeshZone&&(e.geometry instanceof a.Geometry?f=e.geometry:f=e.geometry.geometry,f=new a.SphereGeometry(e.radius,10,10))),g=new a.MeshBasicMaterial({color:"#2194ce",wireframe:!0}),h=new a.Mesh(f,g),d.add(h),this.addEventListener(c,function(a){h.position.set(e.x,e.y,e.z);});},drawEmitter:function(b,c,d,e){var f=new a.OctahedronGeometry(15),g=new a.MeshBasicMaterial({color:e||"#aaa",wireframe:!0}),h=new a.Mesh(f,g);c.add(h),this.addEventListener(b,function(){h.position.copy(d.p),h.rotation.set(d.rotation.x,d.rotation.y,d.rotation.z);});},renderInfo:function(){function b(a){var b=a.emitters[0];return Math.round(b.p.x)+","+Math.round(b.p.y)+","+Math.round(b.p.z)}function a(a,b){var c=b=="material"?"_materialPool":"_targetPool",d=a.renderers[0];return d[c].cID}return function(c,d){this.addInfo(d);var e="";switch(this._infoType){case 2:e+="emitter:"+c.emitters.length+"<br>",e+="em speed:"+c.emitters[0].cID+"<br>",e+="pos:"+b(c);break;case 3:e+=c.renderers[0].name+"<br>",e+="target:"+a(c,"target")+"<br>",e+="material:"+a(c,"material");break;default:e+="particles:"+c.getCount()+"<br>",e+="pool:"+c.pool.getCount()+"<br>",e+="total:"+(c.getCount()+c.pool.getCount());}this._infoCon.innerHTML=e;}}(),addInfo:function(){return function(a){var b=this;if(!this._infoCon){this._infoCon=document.createElement("div"),this._infoCon.style.cssText=["position:fixed;bottom:0px;left:0;cursor:pointer;","opacity:0.9;z-index:10000;padding:10px;font-size:12px;","width:120px;height:50px;background-color:#002;color:#0ff;"].join(""),this._infoType=1,this._infoCon.addEventListener("click",function(a){b._infoType++,b._infoType>3&&(b._infoType=1);},!1);var c,d;switch(a){case 2:c="#201",d="#f08";break;case 3:c="#020",d="#0f0";break;default:c="#002",d="#0ff";}this._infoCon.style["background-color"]=c,this._infoCon.style.color=d;}this._infoCon.parentNode||document.body.appendChild(this._infoCon);}}()};b.Debug=bf;return b});
}(three_proton_min));

var Proton = three_proton_min.exports;var ParticleEmitterGroup = /*#__PURE__*/function (_Entity) {
  _inherits(ParticleEmitterGroup, _Entity);

  var _super = _createSuper(ParticleEmitterGroup);

  function ParticleEmitterGroup() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ParticleEmitterGroup);

    _this = _super.call(this, {
      tag: 'particle '
    });
    var _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('EmitterGroup') : _options$name,
        system = options.system;
    _this.options = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
      name: name
    });

    _this.setBody({
      body: new Object3D()
    });

    _this.setName(name);

    _this.setEntityType(ENTITY_TYPES.PARTICLE);

    _this.setSystem(system);

    return _this;
  }

  _createClass(ParticleEmitterGroup, [{
    key: "setBody",
    value: function setBody(_ref) {
      var body = _ref.body;
      this.body = body;

      if (this.hasBody()) {
        this.addToScene();
      }
    }
  }, {
    key: "addToScene",
    value: function addToScene() {
      var _this$options$addUniv = this.options.addUniverse,
          addUniverse = _this$options$addUniv === void 0 ? true : _this$options$addUniv;

      if (this.hasBody()) {
        Scene$1.add(this.getBody(), this, addUniverse);
      } else {
        console.warn(ELEMENT_NOT_SET);
      }
    }
  }, {
    key: "isProtonEmitter",
    value: function isProtonEmitter() {
      var _this2 = this;

      Object.keys(this.system).forEach(function (emitterId) {
        return _this2.system[emitterId].isProtonEmitter();
      });
    }
  }, {
    key: "getType",
    value: function getType() {
      return PARTICLE_EMITTER_TYPES.GROUP;
    }
  }, {
    key: "hasSystem",
    value: function hasSystem() {
      return !!this.system && !!Object.keys(this.system).length;
    }
  }, {
    key: "isSystemDead",
    value: function isSystemDead() {
      var _this3 = this;

      Object.keys(this.system).forEach(function (emitterId) {
        return _this3.system[emitterId].isSystemDead();
      });
    }
  }, {
    key: "setSystem",
    value: function setSystem() {
      var _this4 = this;

      var system = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      this.system = system.reduce(function (system, emitter) {
        system[emitter.getName()] = emitter;

        _this4.add(emitter);

        return system;
      }, {});
    }
  }, {
    key: "getSystem",
    value: function getSystem() {
      return this.system;
    }
  }, {
    key: "getEmitter",
    value: function getEmitter(name) {
      var emitter = this.system[name];

      if (emitter) {
        return emitter;
      } else {
        console.log(EMITTER_NOT_FOUND, name);
      }
    }
  }, {
    key: "forEach",
    value: function forEach(cb) {
      var _this5 = this;

      Object.keys(this.system).forEach(function (k) {
        cb(_this5.system[k]);
      });
    }
  }, {
    key: "emit",
    value: function emit() {
      var _this6 = this;

      for (var _len = arguments.length, options = new Array(_len), _key = 0; _key < _len; _key++) {
        options[_key] = arguments[_key];
      }

      if (this.hasSystem()) {
        Object.keys(this.system).forEach(function (emitterId) {
          var _this6$system$emitter;

          return (_this6$system$emitter = _this6.system[emitterId]).emit.apply(_this6$system$emitter, options);
        });
      }
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this7 = this;

      if (this.hasSystem()) {
        Object.keys(this.system).forEach(function (emitterId) {
          return _this7.system[emitterId].stop();
        });
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      var _this8 = this;

      _get(_getPrototypeOf(ParticleEmitterGroup.prototype), "dispose", this).call(this);

      Object.keys(this.system).forEach(function (emitterId) {
        return _this8.system[emitterId].dispose();
      });
    }
  }, {
    key: "update",
    value: function update(dt) {
      var _this9 = this;

      _get(_getPrototypeOf(ParticleEmitterGroup.prototype), "update", this).call(this, dt);

      if (this.hasSystem()) {
        Object.keys(this.system).forEach(function (emitterId) {
          return _this9.system[emitterId].update(dt);
        });
      }
    }
  }]);

  return ParticleEmitterGroup;
}(Entity);var _excluded$3 = ["initializers", "behaviours", "texture", "color", "rate"];
var DEFAULT_PARTICLE_COLOR = PALETTES.BASE.BLACK;
var SYSTEM_DISPOSE_TIMEOUT = 700;

var ProtonParticleEmitter = /*#__PURE__*/function (_ParticleEmitter) {
  _inherits(ProtonParticleEmitter, _ParticleEmitter);

  var _super = _createSuper(ProtonParticleEmitter);

  function ProtonParticleEmitter() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, ProtonParticleEmitter);

    var _options$initializers = options.initializers,
        initializers = _options$initializers === void 0 ? [] : _options$initializers,
        _options$behaviours = options.behaviours,
        behaviours = _options$behaviours === void 0 ? [] : _options$behaviours,
        _options$texture = options.texture,
        texture = _options$texture === void 0 ? false : _options$texture,
        _options$color = options.color,
        color = _options$color === void 0 ? DEFAULT_PARTICLE_COLOR : _options$color,
        rate = options.rate,
        rest = _objectWithoutProperties(options, _excluded$3);

    var parsedOptions = _objectSpread2$1({
      initializers: initializers,
      behaviours: behaviours,
      texture: texture,
      color: color,
      rate: rate
    }, rest);

    _this = _super.call(this, parsedOptions);

    _defineProperty$1(_assertThisInitialized(_this), "disposeSystem", function () {
      if (_this.hasSystem()) {
        _this.system.removeAllParticles();

        _this.system.destroy();
      }
    });

    return _this;
  }

  _createClass(ProtonParticleEmitter, [{
    key: "isProtonEmitter",
    value: function isProtonEmitter() {
      return true;
    }
  }, {
    key: "isSystemDead",
    value: function isSystemDead() {
      return this.system.dead;
    }
  }, {
    key: "createParticleBody",
    value: function createParticleBody(texture, color) {
      return new Sprite$1(new SpriteMaterial({
        map: Images$1.get(texture),
        transparent: true,
        color: color,
        blending: AdditiveBlending,
        depthWrite: false,
        fog: true
      }));
    }
  }, {
    key: "setSystem",
    value: function setSystem() {
      var _this2 = this;

      var _this$options = this.options,
          _this$options$initial = _this$options.initializers,
          initializers = _this$options$initial === void 0 ? [] : _this$options$initial,
          _this$options$behavio = _this$options.behaviours,
          behaviours = _this$options$behavio === void 0 ? [] : _this$options$behavio,
          texture = _this$options.texture,
          color = _this$options.color,
          rate = _this$options.rate;
      this.system = new Proton.Emitter();
      this.system.rate = rate;
      initializers.forEach(function (initializer) {
        return _this2.system.addInitialize(initializer);
      });

      if (texture) {
        this.system.addInitialize(new Proton.Body(this.createParticleBody(texture, color)));
      }

      behaviours.forEach(function (behaviour) {
        return _this2.system.addBehaviour(behaviour);
      });
    }
  }, {
    key: "emit",
    value: function emit() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'once';
      var life = arguments.length > 1 ? arguments[1] : undefined;

      if (this.hasSystem()) {
        this.system.emit(duration, life);
      }

      return this;
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this.hasSystem()) {
        this.system.stopEmit();
      }
    }
  }, {
    key: "syncParticleEmitter",
    value: function syncParticleEmitter() {
      var _this$getWorldTransfo = this.getWorldTransform(),
          position = _this$getWorldTransfo.position,
          rotation = _this$getWorldTransfo.rotation;

      this.system.rotation.x = rotation.x;
      this.system.rotation.y = rotation.y;
      this.system.rotation.z = rotation.z;
      this.system.p.x = position.x;
      this.system.p.y = position.y;
      this.system.p.z = position.z;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(ProtonParticleEmitter.prototype), "dispose", this).call(this);

      this.stop();
      setTimeout(this.disposeSystem, SYSTEM_DISPOSE_TIMEOUT);
    }
  }]);

  return ProtonParticleEmitter;
}(ParticleEmitter);var DEFAULT_SIZE$1 = 4;

var getSparksInitializers = function getSparksInitializers() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SIZE$1;
  return [new Proton.Mass(0.1), new Proton.Radius(size * .3), new Proton.Life(1), new Proton.Position(new Proton.SphereZone(size * 1.5))];
};

var getSparksBehaviours = function getSparksBehaviours() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SIZE$1;
  return [new Proton.RandomDrift(size * 0.75, size * 0.75, size * 0.75, .5), new Proton.Color('#ffffff'), new Proton.Scale(1, 0.1)];
};

var getSparksRate = function getSparksRate() {
  return new Proton.Rate(50, .5);
};

var getDebrisRate = function getDebrisRate() {
  return new Proton.Rate(10, .4);
};

var getFireRate$1 = function getFireRate() {
  return new Proton.Rate(10, .4);
};

var getDebrisInitializers = function getDebrisInitializers() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SIZE$1;
  return [new Proton.Mass(10), new Proton.Radius(size * .25), new Proton.Life(2), new Proton.Position(new Proton.SphereZone(size * .75))];
};

var getDebrisBehaviours = function getDebrisBehaviours() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SIZE$1;
  var zone = new Proton.BoxZone(0, 50, 0, 300, 100, 300);
  zone.friction = 0.95;
  zone.max = 7;
  return [new Proton.CrossZone(zone, "bound"), new Proton.Repulsion(new Proton.Vector3D(0, 0, 0), size * 12.5, size * 1.5), new Proton.G(3), new Proton.Color('#95a5a6', '#000000')];
};

var getFireInitializers$1 = function getFireInitializers() {
  var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_SIZE$1;
  return [new Proton.Mass(1), new Proton.Radius(size * 1.5), new Proton.Life(.2, .5), new Proton.Position(new Proton.SphereZone(size * 1.25))];
};

var getFireBehaviours$1 = function getFireBehaviours() {
  return [new Proton.Scale(1, 2), new Proton.Color('#c0392b', '#f1c40f')];
};

var Explosion = /*#__PURE__*/function (_ParticleEmitterGroup) {
  _inherits(Explosion, _ParticleEmitterGroup);

  var _super = _createSuper(Explosion);

  function Explosion() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Explosion);

    var _options$texture = options.texture,
        texture = _options$texture === void 0 ? false : _options$texture,
        _options$hasDebris = options.hasDebris,
        hasDebris = _options$hasDebris === void 0 ? false : _options$hasDebris,
        _options$size = options.size,
        size = _options$size === void 0 ? DEFAULT_SIZE$1 : _options$size;
    var sparks = new ProtonParticleEmitter({
      rate: getSparksRate(),
      texture: texture,
      initializers: getSparksInitializers(size),
      behaviours: getSparksBehaviours(size)
    });
    var fire = new ProtonParticleEmitter({
      rate: getFireRate$1(),
      texture: texture,
      initializers: getFireInitializers$1(size),
      behaviours: getFireBehaviours$1()
    });
    var system = [sparks, fire];

    if (hasDebris) {
      system.push(new ProtonParticleEmitter({
        rate: getDebrisRate(),
        texture: texture,
        initializers: getDebrisInitializers(size),
        behaviours: getDebrisBehaviours(size)
      }));
    }

    var name = 'ExplosionGroup';
    return _super.call(this, {
      system: system,
      name: name
    });
  }

  return Explosion;
}(ParticleEmitterGroup);var _excluded$2 = ["texture", "direction", "size", "strength", "colors"];

var getFireRate = function getFireRate() {
  return new Proton.Rate(new Proton.Span(10, 15), new Proton.Span(.05, .1));
};

var getFireInitializers = function getFireInitializers(direction, strength, size) {
  return [new Proton.Mass(1), new Proton.Life(1, 2), new Proton.Radius(size / 2, size / 1.5, 'center'), new Proton.Position(new Proton.SphereZone(size)), new Proton.V(new Proton.Span(strength, strength * 2), new Proton.Vector3D(direction.x, direction.y, direction.z), 5) //new Proton.Span(200, 500)
  ];
};

var getFireBehaviours = function getFireBehaviours(direction, strength) {
  var colors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [PALETTES.FRENCH.MANDARIN_RED, PALETTES.FRENCH.MELON_MELODY];
  return [new Proton.Scale(new Proton.Span(2, 2.5), 0), new Proton.G(strength / 100), new Proton.Color(colors[0], colors[1], Infinity, Proton.easeOutSine), new Proton.RandomDrift(direction.x / 100, direction.y / 100, direction.z / 100, 2.5)];
};

var Fire = /*#__PURE__*/function (_ProtonParticleEmitte) {
  _inherits(Fire, _ProtonParticleEmitte);

  var _super = _createSuper(Fire);

  function Fire(options) {
    _classCallCheck(this, Fire);

    var texture = options.texture,
        _options$direction = options.direction,
        direction = _options$direction === void 0 ? new Vector3$1(0, 1, 0) : _options$direction,
        _options$size = options.size,
        size = _options$size === void 0 ? 20 : _options$size,
        _options$strength = options.strength,
        strength = _options$strength === void 0 ? 100 : _options$strength,
        colors = options.colors,
        rest = _objectWithoutProperties(options, _excluded$2);

    var fireOptions = _objectSpread2$1({
      rate: getFireRate(),
      texture: texture,
      initializers: getFireInitializers(direction, strength, size),
      behaviours: getFireBehaviours(direction, strength, colors)
    }, rest);

    return _super.call(this, fireOptions);
  }

  return Fire;
}(ProtonParticleEmitter);var Rain = /*#__PURE__*/function (_ParticleEmitter) {
  _inherits(Rain, _ParticleEmitter);

  var _super = _createSuper(Rain);

  function Rain(_ref) {
    var container = _ref.container,
        autostart = _ref.autostart,
        particles = _ref.particles,
        system = _ref.system;

    _classCallCheck(this, Rain);

    var options = {
      container: container,
      autostart: autostart,
      particles: _objectSpread2$1({
        globalSize: 0.4,
        ttl: 5,
        velocity: new Vector3$1(0, -2, 0),
        velocityBonus: new Vector3$1(0, -60, 0),
        gravity: -10,
        startAlpha: 1,
        endAlpha: 0,
        startColor: new Color$1(1, 1, 1),
        endColor: new Color$1(0, 0, 0),
        startAlphaChangeAt: 0,
        blending: "additive",
        onSpawn: function onSpawn(particle) {
          particle.position.x = Math.random() * 100;
          particle.position.z = Math.random() * 100;
        }
      }, particles),
      system: _objectSpread2$1({
        particlesCount: 2000,
        emitters: new k({
          onInterval: new N.MinMaxRandomizer(0, 5),
          interval: new N.MinMaxRandomizer(0, 0.25)
        }),
        speed: 1.5
      }, system)
    };
    return _super.call(this, options);
  }

  return Rain;
}(ParticleEmitter);var Snow = /*#__PURE__*/function (_ParticleEmitter) {
  _inherits(Snow, _ParticleEmitter);

  var _super = _createSuper(Snow);

  function Snow(_ref) {
    var container = _ref.container,
        autostart = _ref.autostart,
        particles = _ref.particles,
        system = _ref.system;

    _classCallCheck(this, Snow);

    var options = {
      container: container,
      autostart: autostart,
      particles: _objectSpread2$1({
        globalSize: 0.7,
        ttl: 5,
        velocity: new N.SphereRandomizer(30),
        velocityBonus: new Vector3$1(0, -30, 0),
        gravity: -10,
        startAlpha: 0.8,
        endAlpha: 0,
        startColor: new Color$1(1, 1, 1),
        endColor: new Color$1(0, 0, 0),
        startAlphaChangeAt: 0,
        blending: "blend",
        onSpawn: function onSpawn(particle) {
          particle.position.x = Math.random() * 200;
          particle.position.z = Math.random() * 200;
        }
      }, particles),
      system: _objectSpread2$1({
        particlesCount: 4000,
        emitters: new k({
          onInterval: new N.MinMaxRandomizer(0, 5),
          interval: new N.MinMaxRandomizer(0, 0.25)
        }),
        speed: 1.5
      }, system)
    };
    return _super.call(this, options);
  }

  return Snow;
}(ParticleEmitter);var DEFAULT_SIZE = 4;

var getTrailRate = function getTrailRate() {
  return new Proton.Rate(new Proton.Span(10, 20), new Proton.Span(0.01, 0.015));
};

var getTrailInitialisers = function getTrailInitialisers(size) {
  return [new Proton.Mass(1), new Proton.Life(1, 2), new Proton.Radius(size)];
};

var getTrailBehaviour = function getTrailBehaviour() {
  return [new Proton.Alpha(1, 0), new Proton.Color("#ffffff"), new Proton.Scale(.5, 0.1)];
};

var Trail = /*#__PURE__*/function (_ParticleEmitterGroup) {
  _inherits(Trail, _ParticleEmitterGroup);

  var _super = _createSuper(Trail);

  function Trail() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Trail);

    var _options$texture = options.texture,
        texture = _options$texture === void 0 ? false : _options$texture,
        _options$size = options.size,
        size = _options$size === void 0 ? DEFAULT_SIZE : _options$size;
    var system = [new ProtonParticleEmitter({
      rate: getTrailRate(),
      texture: texture,
      initializers: getTrailInitialisers(size),
      behaviours: getTrailBehaviour()
    })];
    var name = 'TrailGroup';
    return _super.call(this, {
      system: system,
      name: name
    });
  }

  return Trail;
}(ParticleEmitterGroup);var PARTICLES = {
  RAIN: 'rain',
  EXPLOSION: 'explosion',
  FOUNTAIN: 'fountain',
  FIRE: 'fire',
  SNOW: 'snow',
  TRAIL: 'trail'
};
var GROUP = PARTICLE_EMITTER_TYPES.GROUP;
var Particles = /*#__PURE__*/function () {
  function Particles() {
    var _this = this,
        _this$map;

    _classCallCheck(this, Particles);

    _defineProperty$1(this, "isRegisteredEmitter", function (name) {
      return typeof name === 'string' && name in _this.map;
    });

    _defineProperty$1(this, "hasEmitters", function () {
      return _this.emitters.length > 0;
    });

    _defineProperty$1(this, "updateEmitters", function (dt) {
      _this.toDispose = [];
      Object.keys(_this.emitters).forEach(function (uuid) {
        var emitter = _this.emitters[uuid];

        _this.updateSingleEmitter(emitter, dt);
      });
    });

    this.map = (_this$map = {}, _defineProperty$1(_this$map, PARTICLES.RAIN, Rain), _defineProperty$1(_this$map, PARTICLES.EXPLOSION, Explosion), _defineProperty$1(_this$map, PARTICLES.FOUNTAIN, Fountain), _defineProperty$1(_this$map, PARTICLES.FIRE, Fire), _defineProperty$1(_this$map, PARTICLES.SNOW, Snow), _defineProperty$1(_this$map, PARTICLES.TRAIL, Trail), _this$map);
    this.emitters = {};
    this.toDispose = [];
  }

  _createClass(Particles, [{
    key: "init",
    value: function init() {
      this.proton = new Proton();
      this.proton.addRender(new Proton.SpriteRender(Scene$1.getScene()));
    }
  }, {
    key: "isInitialised",
    value: function isInitialised() {
      return !!this.proton;
    }
  }, {
    key: "get",
    value: function get(name) {
      return this.map[name] || null;
    }
  }, {
    key: "registerEmitter",
    value: function registerEmitter(key, Emitter) {
      this.map[key] = Emitter;
    }
  }, {
    key: "isValidEmitter",
    value: function isValidEmitter(emitter) {
      return emitter instanceof ParticleEmitter || emitter instanceof ParticleEmitterGroup || emitter instanceof ProtonParticleEmitter;
    }
  }, {
    key: "addParticleEmitter",
    value: function addParticleEmitter(emitter) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      console.warn(DEPRECATIONS.PARTICLES_ADD_PARTICLE_EMITTER);
      return this.add(emitter, options);
    }
  }, {
    key: "add",
    value: function add(_emitter) {
      var _this2 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var emitter;

      if (this.isRegisteredEmitter(_emitter)) {
        var Emitter = this.get(_emitter);
        emitter = new Emitter(options);
      } else if (this.isValidEmitter(_emitter)) {
        emitter = _emitter;
      } else {
        console.log(INVALID_EMITTER_ID);
        return;
      }

      this.emitters[emitter.uuid()] = emitter;

      if (emitter.getType() === GROUP) {
        emitter.forEach(function (singleEmitter) {
          _this2.handleSingleParticleEmitterCreation(singleEmitter);
        });
      } else {
        this.handleSingleParticleEmitterCreation(emitter);
      }

      return emitter;
    }
  }, {
    key: "handleSingleParticleEmitterCreation",
    value: function handleSingleParticleEmitterCreation(emitter) {
      if (emitter.isProtonEmitter()) {
        this.addProtonEmitter(emitter);
      }
    }
  }, {
    key: "addProtonEmitter",
    value: function addProtonEmitter(emitter) {
      this.proton.addEmitter(emitter.getSystem());
    }
  }, {
    key: "removeProtonEmitter",
    value: function removeProtonEmitter(emitter) {
      this.proton.removeEmitter(emitter.getSystem());
    }
  }, {
    key: "updateSingleEmitter",
    value: function updateSingleEmitter(emitter, dt) {
      if (!emitter.isProtonEmitter()) {
        emitter.update(dt);
      }

      if (emitter.isSystemDead()) {
        this.toDispose.push(emitter.uuid());
      }
    }
  }, {
    key: "disposeDeadEmitters",
    value: function disposeDeadEmitters() {
      var _this3 = this;

      this.toDispose.forEach(function (uuid) {
        var emitter = _this3.emitters[uuid];

        if (emitter.isProtonEmitter()) {
          _this3.removeProtonEmitter(emitter);
        } else {
          _this3.emitters[uuid].dispose();
        }

        delete _this3.emitters[uuid];
      });
    }
  }, {
    key: "update",
    value: function update(dt) {
      this.proton.update(dt);
      this.updateEmitters(dt);
      this.disposeDeadEmitters();
    }
  }, {
    key: "dispose",
    value: function dispose() {
      if (this.isInitialised()) {
        this.proton.destroy();
        this.proton = null;
      }
    }
  }]);

  return Particles;
}();
var Particles$1 = new Particles();var Orbit = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Orbit, _EventDispatcher);

  var _super = _createSuper(Orbit);

  function Orbit(object, domElement) {
    var _this;

    _classCallCheck(this, Orbit);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "setTarget", function (_ref) {
      var x = _ref.x,
          y = _ref.y,
          z = _ref.z;

      _this.target.set(x, y, z);
    });

    _defineProperty$1(_assertThisInitialized(_this), "update", function () {
      var position = _this.object.position;

      _this.offset.copy(position).sub(_this.target); // rotate this.offset to "y-axis-is-up" space


      _this.offset.applyQuaternion(_this.quat); // angle from z-axis around y-axis


      _this.spherical.setFromVector3(_this.offset);

      if (_this.autoRotate && _this.state === STATE.NONE) {
        rotateLeft(getAutoRotationAngle());
      }

      _this.spherical.theta += _this.sphericalDelta.theta;
      _this.spherical.phi += _this.sphericalDelta.phi; // restrict theta to be between desired limits

      _this.spherical.theta = Math.max(_this.minAzimuthAngle, Math.min(_this.maxAzimuthAngle, _this.spherical.theta)); // restrict phi to be between desired limits

      _this.spherical.phi = Math.max(_this.minPolarAngle, Math.min(_this.maxPolarAngle, _this.spherical.phi));

      _this.spherical.makeSafe();

      _this.spherical.radius *= _this.scale; // restrict radius to be between desired limits

      _this.spherical.radius = Math.max(_this.minDistance, Math.min(_this.maxDistance, _this.spherical.radius)); // move target to panned location

      _this.target.add(_this.panOffset);

      _this.offset.setFromSpherical(_this.spherical); // rotate this.offset back to "camera-up-vector-is-up" space


      _this.offset.applyQuaternion(_this.quatInverse);

      position.copy(_this.target).add(_this.offset);

      _this.object.lookAt(_this.target);

      if (_this.enableDamping === true) {
        _this.sphericalDelta.theta *= 1 - _this.dampingFactor;
        _this.sphericalDelta.phi *= 1 - _this.dampingFactor;

        _this.panOffset.multiplyScalar(1 - _this.dampingFactor);
      } else {
        _this.sphericalDelta.set(0, 0, 0);

        _this.panOffset.set(0, 0, 0);
      }

      _this.scale = 1; // update condition is:
      // min(camera displacement, camera rotation in radians)^2 > EPS
      // using small-angle approximation cos(x/2) = 1 - x^2 / 8

      if (_this.zoomChanged || _this.lastPosition.distanceToSquared(_this.object.position) > _this.EPS || 8 * (1 - _this.lastQuaternion.dot(_this.object.quaternion)) > _this.EPS) {
        _this.dispatchEvent(_this.changeEvent);

        _this.lastPosition.copy(_this.object.position);

        _this.lastQuaternion.copy(_this.object.quaternion);

        _this.zoomChanged = false;
        return true;
      }

      return false;
    });

    _defineProperty$1(_assertThisInitialized(_this), "rotateLeft", function (angle) {
      _this.sphericalDelta.theta -= angle;
    });

    _defineProperty$1(_assertThisInitialized(_this), "rotateUp", function (angle) {
      _this.sphericalDelta.phi -= angle;
    });

    _defineProperty$1(_assertThisInitialized(_this), "panLeft", function () {
      var v = new Vector3$1();
      return function (distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0); // get X column of objectMatrix

        v.multiplyScalar(-distance);

        _this.panOffset.add(v);
      };
    }());

    _defineProperty$1(_assertThisInitialized(_this), "panUp", function () {
      var v = new Vector3$1();
      return function (distance, objectMatrix) {
        if (_this.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1);
        } else {
          v.setFromMatrixColumn(objectMatrix, 0);
          v.crossVectors(_this.object.up, v);
        }

        v.multiplyScalar(distance);

        _this.panOffset.add(v);
      };
    }());

    _defineProperty$1(_assertThisInitialized(_this), "pan", function () {
      var offset = new Vector3$1();
      return function (deltaX, deltaY) {
        var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

        if (_this.object.isPerspectiveCamera) {
          // perspective
          var position = _this.object.position;
          offset.copy(position).sub(_this.target);
          var targetDistance = offset.length(); // half of the fov is center to top of screen

          targetDistance *= Math.tan(_this.object.fov / 2 * Math.PI / 180.0); // we use only clientHeight here so aspect ratio does not distort speed

          _this.panLeft(2 * deltaX * targetDistance / element.clientHeight, _this.object.matrix);

          _this.panUp(2 * deltaY * targetDistance / element.clientHeight, _this.object.matrix);
        } else if (_this.object.isOrthographicCamera) {
          // orthographic
          _this.panLeft(deltaX * (_this.object.right - _this.object.left) / _this.object.zoom / element.clientWidth, _this.object.matrix);

          _this.panUp(deltaY * (_this.object.top - _this.object.bottom) / _this.object.zoom / element.clientHeight, _this.object.matrix);
        } else {
          // camera neither orthographic nor perspective
          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');
          _this.enablePan = false;
        }
      };
    }());

    _defineProperty$1(_assertThisInitialized(_this), "dollyIn", function (dollyScale) {
      if (_this.object.isPerspectiveCamera) {
        _this.scale /= dollyScale;
      } else if (_this.object.isOrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom * dollyScale));

        _this.object.updateProjectionMatrix();

        _this.zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "dollyOut", function (dollyScale) {
      if (_this.object.isPerspectiveCamera) {
        _this.scale *= dollyScale;
      } else if (_this.object.isOrthographicCamera) {
        _this.object.zoom = Math.max(_this.minZoom, Math.min(_this.maxZoom, _this.object.zoom / dollyScale));

        _this.object.updateProjectionMatrix();

        _this.zoomChanged = true;
      } else {
        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.');
        _this.enableZoom = false;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseDownRotate", function (event) {
      _this.rotateStart.set(event.clientX, event.clientY);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseDownDolly", function (event) {
      _this.dollyStart.set(event.clientX, event.clientY);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseDownPan", function (event) {
      _this.panStart.set(event.clientX, event.clientY);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseMoveRotate", function (event) {
      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      _this.rotateEnd.set(event.clientX, event.clientY);

      _this.rotateDelta.subVectors(_this.rotateEnd, _this.rotateStart).multiplyScalar(_this.rotateSpeed);

      _this.rotateLeft(2 * Math.PI * _this.rotateDelta.x / element.clientHeight); // yes, height


      _this.rotateUp(2 * Math.PI * _this.rotateDelta.y / element.clientHeight);

      _this.rotateStart.copy(_this.rotateEnd);

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseMoveDolly", function (event) {
      _this.dollyEnd.set(event.clientX, event.clientY);

      _this.dollyDelta.subVectors(_this.dollyEnd, _this.dollyStart);

      if (_this.dollyDelta.y > 0) {
        _this.dollyIn(_this.getZoomScale());
      } else if (_this.dollyDelta.y < 0) {
        _this.dollyOut(_this.getZoomScale());
      }

      _this.dollyStart.copy(_this.dollyEnd);

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseMovePan", function (event) {
      _this.panEnd.set(event.clientX, event.clientY);

      _this.panDelta.subVectors(_this.panEnd, _this.panStart).multiplyScalar(_this.panSpeed);

      _this.pan(_this.panDelta.x, _this.panDelta.y);

      _this.panStart.copy(_this.panEnd);

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseUp", function (event) {});

    _defineProperty$1(_assertThisInitialized(_this), "handleMouseWheel", function (event) {
      if (event.deltaY < 0) {
        _this.dollyOut(_this.getZoomScale());
      } else if (event.deltaY > 0) {
        _this.dollyIn(_this.getZoomScale());
      }

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleKeyDown", function (event) {
      switch (event.keyCode) {
        case _this.keys.UP:
          _this.pan(0, _this.keyPanSpeed);

          _this.update();

          break;

        case _this.keys.BOTTOM:
          _this.pan(0, -_this.keyPanSpeed);

          _this.update();

          break;

        case _this.keys.LEFT:
          _this.pan(_this.keyPanSpeed, 0);

          _this.update();

          break;

        case _this.keys.RIGHT:
          _this.pan(-_this.keyPanSpeed, 0);

          _this.update();

          break;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTouchStartRotate", function (event) {
      _this.rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTouchStartDollyPan", function (event) {
      if (_this.enableZoom) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);

        _this.dollyStart.set(0, distance);
      }

      if (_this.enablePan) {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

        _this.panStart.set(x, y);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTouchMoveRotate", function (event) {
      var element = _this.domElement === document ? _this.domElement.body : _this.domElement;

      _this.rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);

      _this.rotateDelta.subVectors(_this.rotateEnd, _this.rotateStart).multiplyScalar(_this.rotateSpeed);

      _this.rotateLeft(2 * Math.PI * _this.rotateDelta.x / element.clientHeight); // yes, height


      _this.rotateUp(2 * Math.PI * _this.rotateDelta.y / element.clientHeight);

      _this.rotateStart.copy(_this.rotateEnd);

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTouchMoveDollyPan", function (event) {
      if (_this.enableZoom) {
        var dx = event.touches[0].pageX - event.touches[1].pageX;
        var dy = event.touches[0].pageY - event.touches[1].pageY;
        var distance = Math.sqrt(dx * dx + dy * dy);

        _this.dollyEnd.set(0, distance);

        _this.dollyDelta.set(0, Math.pow(_this.dollyEnd.y / _this.dollyStart.y, _this.zoomSpeed));

        _this.dollyIn(_this.dollyDelta.y);

        _this.dollyStart.copy(_this.dollyEnd);
      }

      if (_this.enablePan) {
        var x = 0.5 * (event.touches[0].pageX + event.touches[1].pageX);
        var y = 0.5 * (event.touches[0].pageY + event.touches[1].pageY);

        _this.panEnd.set(x, y);

        _this.panDelta.subVectors(_this.panEnd, _this.panStart).multiplyScalar(_this.panSpeed);

        _this.pan(_this.panDelta.x, _this.panDelta.y);

        _this.panStart.copy(_this.panEnd);
      }

      _this.update();
    });

    _defineProperty$1(_assertThisInitialized(_this), "handleTouchEnd", function (event) {});

    _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();

      switch (event.button) {
        case _this.mouseButtons.LEFT:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (_this.enablePan === false) return;

            _this.handleMouseDownPan(event);

            _this.state = _this.STATE.PAN;
          } else {
            if (_this.enableRotate === false) return;

            _this.handleMouseDownRotate(event);

            _this.state = _this.STATE.ROTATE;
          }

          break;

        case _this.mouseButtons.MIDDLE:
          if (_this.enableZoom === false) return;

          _this.handleMouseDownDolly(event);

          _this.state = _this.STATE.DOLLY;
          break;

        case _this.mouseButtons.RIGHT:
          if (_this.enablePan === false) return;

          _this.handleMouseDownPan(event);

          _this.state = _this.STATE.PAN;
          break;
      }

      if (_this.state !== _this.STATE.NONE) {
        document.addEventListener('mousemove', _this.onMouseMove, false);
        document.addEventListener('mouseup', _this.onMouseUp, false);

        _this.dispatchEvent(_this.startEvent);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();

      switch (_this.state) {
        case _this.STATE.ROTATE:
          if (_this.enableRotate === false) return;

          _this.handleMouseMoveRotate(event);

          break;

        case _this.STATE.DOLLY:
          if (_this.enableZoom === false) return;

          _this.handleMouseMoveDolly(event);

          break;

        case _this.STATE.PAN:
          if (_this.enablePan === false) return;

          _this.handleMouseMovePan(event);

          break;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseUp", function (event) {
      if (!_this.enabled) return;

      _this.handleMouseUp(event);

      document.removeEventListener('mousemove', _this.onMouseMove, false);
      document.removeEventListener('mouseup', _this.onMouseUp, false);

      _this.dispatchEvent(_this.endEvent);

      _this.state = _this.STATE.NONE;
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseWheel", function (event) {
      if (!_this.enabled || _this.enableZoom === false || _this.state !== _this.STATE.NONE && _this.state !== _this.STATE.ROTATE) return;
      event.preventDefault();
      event.stopPropagation();

      _this.dispatchEvent(_this.startEvent);

      _this.handleMouseWheel(event);

      _this.dispatchEvent(_this.endEvent);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onKeyDown", function (event) {
      if (!_this.enabled || _this.enableKeys === false || _this.enablePan === false) return;

      _this.handleKeyDown(event);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onTouchStart", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate
          if (_this.enableRotate === false) return;

          _this.handleTouchStartRotate(event);

          _this.state = _this.STATE.TOUCH_ROTATE;
          break;

        case 2:
          // two-fingered touch: dolly-pan
          if (_this.enableZoom === false && _this.enablePan === false) return;

          _this.handleTouchStartDollyPan(event);

          _this.state = _this.STATE.TOUCH_DOLLY_PAN;
          break;

        default:
          _this.state = _this.STATE.NONE;
      }

      if (_this.state !== _this.STATE.NONE) {
        _this.dispatchEvent(startEvent);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onTouchMove", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();
      event.stopPropagation();

      switch (event.touches.length) {
        case 1:
          // one-fingered touch: rotate
          if (_this.enableRotate === false) return;
          if (_this.state !== _this.STATE.TOUCH_ROTATE) return; // is this needed?

          _this.handleTouchMoveRotate(event);

          break;

        case 2:
          // two-fingered touch: dolly-pan
          if (_this.enableZoom === false && _this.enablePan === false) return;
          if (_this.state !== _this.STATE.TOUCH_DOLLY_PAN) return; // is this needed?

          _this.handleTouchMoveDollyPan(event);

          break;

        default:
          _this.state = _this.STATE.NONE;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onTouchEnd", function (event) {
      if (!_this.enabled) return;

      _this.handleTouchEnd(event);

      _this.dispatchEvent(_this.endEvent);

      _this.state = _this.STATE.NONE;
    });

    _defineProperty$1(_assertThisInitialized(_this), "onContextMenu", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();
    });

    _this.object = object;
    _this.domElement = domElement !== undefined ? domElement : document; // Set to false to disable this control

    _this.enabled = true; // "target" sets the location of focus, where the object orbits around

    _this.target = new Vector3$1(); // How far you can dolly in and out ( PerspectiveCamera only )

    _this.minDistance = 0;
    _this.maxDistance = Infinity; // How far you can zoom in and out ( OrthographicCamera only )

    _this.minZoom = 0;
    _this.maxZoom = Infinity; // How far you can orbit vertically, upper and lower limits.
    // Range is 0 to Math.PI radians.

    _this.minPolarAngle = 0; // radians

    _this.maxPolarAngle = Math.PI; // radians
    // How far you can orbit horizontally, upper and lower limits.
    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].

    _this.minAzimuthAngle = -Infinity; // radians

    _this.maxAzimuthAngle = Infinity; // radians
    // Set to true to enable damping (inertia)
    // If damping is enabled, you must call controls.update() in your animation loop

    _this.enableDamping = false;
    _this.dampingFactor = 0.25; // This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
    // Set to false to disable zooming

    _this.enableZoom = true;
    _this.zoomSpeed = 1.0; // Set to false to disable rotating

    _this.enableRotate = true;
    _this.rotateSpeed = 1.0; // Set to false to disable panning

    _this.enablePan = true;
    _this.panSpeed = 1.0;
    _this.screenSpacePanning = false; // if true, pan in screen-space

    _this.keyPanSpeed = 7.0; // pixels moved per arrow key push
    // Set to true to automatically rotate around the target
    // If auto-rotate is enabled, you must call controls.update() in your animation loop

    _this.autoRotate = false;
    _this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
    // Set to false to disable use of the keys

    _this.enableKeys = true; // The four arrow keys

    _this.keys = {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      BOTTOM: 40
    }; // Mouse buttons

    _this.mouseButtons = {
      LEFT: MOUSE.LEFT,
      MIDDLE: MOUSE.MIDDLE,
      RIGHT: MOUSE.RIGHT
    }; // for reset

    _this.target0 = _this.target.clone();
    _this.position0 = _this.object.position.clone();
    _this.zoom0 = _this.object.zoom;
    _this.changeEvent = {
      type: 'change'
    };
    _this.startEvent = {
      type: 'start'
    };
    _this.endEvent = {
      type: 'end'
    };
    _this.STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_DOLLY_PAN: 4
    };
    _this.state = _this.STATE.NONE;
    _this.EPS = 0.000001; // current position in spherical coordinates

    _this.spherical = new Spherical();
    _this.sphericalDelta = new Spherical();
    _this.scale = 1;
    _this.panOffset = new Vector3$1();
    _this.zoomChanged = false;
    _this.rotateStart = new Vector2();
    _this.rotateEnd = new Vector2();
    _this.rotateDelta = new Vector2();
    _this.panStart = new Vector2();
    _this.panEnd = new Vector2();
    _this.panDelta = new Vector2();
    _this.dollyStart = new Vector2();
    _this.dollyEnd = new Vector2();
    _this.dollyDelta = new Vector2();
    _this.offset = new Vector3$1(); // so camera.up is the orbit axis

    _this.quat = new Quaternion().setFromUnitVectors(_this.object.up, new Vector3$1(0, 1, 0));
    _this.quatInverse = _this.quat.clone().invert();
    _this.lastPosition = new Vector3$1();
    _this.lastQuaternion = new Quaternion();
    return _this;
  }

  _createClass(Orbit, [{
    key: "init",
    value: function init() {
      this.domElement.addEventListener('contextmenu', this.onContextMenu, false);
      this.domElement.addEventListener('mousedown', this.onMouseDown, false);
      this.domElement.addEventListener('wheel', this.onMouseWheel, false);
      this.domElement.addEventListener('touchstart', this.onTouchStart, false);
      this.domElement.addEventListener('touchend', this.onTouchEnd, false);
      this.domElement.addEventListener('touchmove', this.onTouchMove, false);
      window.addEventListener('keydown', this.onKeyDown, false); // force an update at start

      this.update();
    }
  }, {
    key: "setMinAzimuthAngle",
    value: function setMinAzimuthAngle() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -Infinity;
      this.minAzimuthAngle = angle;
    }
  }, {
    key: "setMaxAzimuthAngle",
    value: function setMaxAzimuthAngle() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
      this.maxAzimuthAngle = angle;
    }
  }, {
    key: "setMinPolarAngle",
    value: function setMinPolarAngle() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.minPolarAngle = angle;
    }
  }, {
    key: "setMaxPolarAngle",
    value: function setMaxPolarAngle() {
      var angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Math.PI;
      this.maxPolarAngle = angle;
    }
  }, {
    key: "setMinDistance",
    value: function setMinDistance() {
      var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      this.minDistance = distance;
    }
  }, {
    key: "setMaxDistance",
    value: function setMaxDistance() {
      var distance = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;
      this.maxDistance = distance;
    }
  }, {
    key: "getPolarAngle",
    value: function getPolarAngle() {
      return this.spherical.phi;
    }
  }, {
    key: "getAzimuthalAngle",
    value: function getAzimuthalAngle() {
      return spherical.theta;
    }
  }, {
    key: "saveState",
    value: function saveState() {
      this.target0.copy(this.target);
      this.position0.copy(this.object.position);
      this.zoom0 = this.object.zoom;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.target.copy(this.target0);
      this.object.position.copy(this.position0);
      this.object.zoom = this.zoom0;
      this.object.updateProjectionMatrix();
      this.dispatchEvent(this.changeEvent);
      this.update();
      this.state = STATE.NONE;
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.domElement.removeEventListener('contextmenu', this.onContextMenu, false);
      this.domElement.removeEventListener('mousedown', this.onMouseDown, false);
      this.domElement.removeEventListener('wheel', this.onMouseWheel, false);
      this.domElement.removeEventListener('touchstart', this.onTouchStart, false);
      this.domElement.removeEventListener('touchend', this.onTouchEnd, false);
      this.domElement.removeEventListener('touchmove', this.onTouchMove, false);
      document.removeEventListener('mousemove', this.onMouseMove, false);
      document.removeEventListener('mouseup', this.onMouseUp, false);
      window.removeEventListener('keydown', this.onKeyDown, false);
    }
  }, {
    key: "getAutoRotationAngle",
    value: function getAutoRotationAngle() {
      return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
    }
  }, {
    key: "getZoomScale",
    value: function getZoomScale() {
      return Math.pow(0.95, this.zoomSpeed);
    }
  }]);

  return Orbit;
}(EventDispatcher);var Gizmo = /*#__PURE__*/function (_Object3D) {
  _inherits(Gizmo, _Object3D);

  var _super = _createSuper(Gizmo);

  function Gizmo() {
    var _thisSuper, _this;

    _classCallCheck(this, Gizmo);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "updateMatrixWorld", function () {
      var space = _this.space;
      if (_this.mode === 'scale') space = 'local'; // scale always oriented to local rotation

      var quaternion = space === "local" ? _this.worldQuaternion : _this.identityQuaternion; // Show only gizmos for current transform mode

      _this.gizmo["translate"].visible = _this.mode === "translate";
      _this.gizmo["rotate"].visible = _this.mode === "rotate";
      _this.gizmo["scale"].visible = _this.mode === "scale";
      _this.helper["translate"].visible = _this.mode === "translate";
      _this.helper["rotate"].visible = _this.mode === "rotate";
      _this.helper["scale"].visible = _this.mode === "scale";
      var handles = [].concat(_toConsumableArray(_this.picker[_this.mode].children), _toConsumableArray(_this.gizmo[_this.mode].children), _toConsumableArray(_this.helper[_this.mode].children)); //handles = handles.concat(this.picker[this.mode].children);
      //handles = handles.concat(this.gizmo[this.mode].children);
      //handles = handles.concat(this.helper[this.mode].children);

      for (var i = 0; i < handles.length; i++) {
        var handle = handles[i]; // hide aligned to camera

        handle.visible = true;
        handle.rotation.set(0, 0, 0);
        handle.position.copy(_this.worldPosition);

        var eyeDistance = _this.worldPosition.distanceTo(_this.cameraPosition);

        handle.scale.set(1, 1, 1).multiplyScalar(eyeDistance * _this.size / 7); // TODO: simplify helpers and consider decoupling from gizmo

        if (handle.tag === 'helper') {
          handle.visible = false;

          if (handle.name === 'AXIS') {
            handle.position.copy(_this.worldPositionStart);
            handle.visible = !!_this.axis;

            if (_this.axis === 'X') {
              _this.tempQuaternion.setFromEuler(_this.tempEuler.set(0, 0, 0));

              handle.quaternion.copy(quaternion).multiply(_this.tempQuaternion);

              if (Math.abs(_this.alignVector.copy(_this.unitX).applyQuaternion(quaternion).dot(_this.eye)) > 0.9) {
                handle.visible = false;
              }
            }

            if (_this.axis === 'Y') {
              _this.tempQuaternion.setFromEuler(_this.tempEuler.set(0, 0, Math.PI / 2));

              handle.quaternion.copy(quaternion).multiply(_this.tempQuaternion);

              if (Math.abs(_this.alignVector.copy(_this.unitY).applyQuaternion(quaternion).dot(_this.eye)) > 0.9) {
                handle.visible = false;
              }
            }

            if (_this.axis === 'Z') {
              _this.tempQuaternion.setFromEuler(_this.tempEuler.set(0, Math.PI / 2, 0));

              handle.quaternion.copy(quaternion).multiply(_this.tempQuaternion);

              if (Math.abs(_this.alignVector.copy(_this.unitZ).applyQuaternion(quaternion).dot(_this.eye)) > 0.9) {
                handle.visible = false;
              }
            }

            if (_this.axis === 'XYZE') {
              _this.tempQuaternion.setFromEuler(_this.tempEuler.set(0, Math.PI / 2, 0));

              _this.alignVector.copy(_this.rotationAxis);

              handle.quaternion.setFromRotationMatrix(_this.lookAtMatrix.lookAt(_this.zeroVector, _this.alignVector, _this.unitY));
              handle.quaternion.multiply(_this.tempQuaternion);
              handle.visible = _this.dragging;
            }

            if (_this.axis === 'E') {
              handle.visible = false;
            }
          } else if (handle.name === 'START') {
            handle.position.copy(_this.worldPositionStart);
            handle.visible = _this.dragging;
          } else if (handle.name === 'END') {
            handle.position.copy(_this.worldPosition);
            handle.visible = _this.dragging;
          } else if (handle.name === 'DELTA') {
            handle.position.copy(_this.worldPositionStart);
            handle.quaternion.copy(_this.worldQuaternionStart);

            _this.tempVector.set(1e-10, 1e-10, 1e-10).add(_this.worldPositionStart).sub(_this.worldPosition).multiplyScalar(-1);

            _this.tempVector.applyQuaternion(_this.worldQuaternionStart.clone().invert());

            handle.scale.copy(_this.tempVector);
            handle.visible = _this.dragging;
          } else {
            handle.quaternion.copy(quaternion);

            if (_this.dragging) {
              handle.position.copy(_this.worldPositionStart);
            } else {
              handle.position.copy(_this.worldPosition);
            }

            if (_this.axis) {
              handle.visible = _this.axis.search(handle.name) !== -1;
            }
          } // If updating helper, skip rest of the loop


          continue;
        } // Align handles to current local or world rotation


        handle.quaternion.copy(quaternion);

        if (_this.mode === 'translate' || _this.mode === 'scale') {
          // Hide translate and scale axis facing the camera
          var AXIS_HIDE_TRESHOLD = 0.99;
          var PLANE_HIDE_TRESHOLD = 0.2;
          var AXIS_FLIP_TRESHOLD = -0.4;

          if (handle.name === 'X' || handle.name === 'XYZX') {
            if (Math.abs(_this.alignVector.copy(_this.unitX).applyQuaternion(quaternion).dot(_this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }

          if (handle.name === 'Y' || handle.name === 'XYZY') {
            if (Math.abs(_this.alignVector.copy(_this.unitY).applyQuaternion(quaternion).dot(_this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }

          if (handle.name === 'Z' || handle.name === 'XYZZ') {
            if (Math.abs(_this.alignVector.copy(_this.unitZ).applyQuaternion(quaternion).dot(_this.eye)) > AXIS_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }

          if (handle.name === 'XY') {
            if (Math.abs(_this.alignVector.copy(_this.unitZ).applyQuaternion(quaternion).dot(_this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }

          if (handle.name === 'YZ') {
            if (Math.abs(_this.alignVector.copy(_this.unitX).applyQuaternion(quaternion).dot(_this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          }

          if (handle.name === 'XZ') {
            if (Math.abs(_this.alignVector.copy(_this.unitY).applyQuaternion(quaternion).dot(_this.eye)) < PLANE_HIDE_TRESHOLD) {
              handle.scale.set(1e-10, 1e-10, 1e-10);
              handle.visible = false;
            }
          } // Flip translate and scale axis ocluded behind another axis


          if (handle.name.search('X') !== -1) {
            if (_this.alignVector.copy(_this.unitX).applyQuaternion(quaternion).dot(_this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === 'fwd') {
                handle.visible = false;
              } else {
                handle.scale.x *= -1;
              }
            } else if (handle.tag === 'bwd') {
              handle.visible = false;
            }
          }

          if (handle.name.search('Y') !== -1) {
            if (_this.alignVector.copy(_this.unitY).applyQuaternion(quaternion).dot(_this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === 'fwd') {
                handle.visible = false;
              } else {
                handle.scale.y *= -1;
              }
            } else if (handle.tag === 'bwd') {
              handle.visible = false;
            }
          }

          if (handle.name.search('Z') !== -1) {
            if (_this.alignVector.copy(_this.unitZ).applyQuaternion(quaternion).dot(_this.eye) < AXIS_FLIP_TRESHOLD) {
              if (handle.tag === 'fwd') {
                handle.visible = false;
              } else {
                handle.scale.z *= -1;
              }
            } else if (handle.tag === 'bwd') {
              handle.visible = false;
            }
          }
        } else if (_this.mode === 'rotate') {
          // Align handles to current local or world rotation
          _this.tempQuaternion2.copy(quaternion);

          _this.alignVector.copy(_this.eye).applyQuaternion(_this.tempQuaternion.copy(quaternion).invert());

          if (handle.name.search("E") !== -1) {
            handle.quaternion.setFromRotationMatrix(_this.lookAtMatrix.lookAt(_this.eye, _this.zeroVector, _this.unitY));
          }

          if (handle.name === 'X') {
            _this.tempQuaternion.setFromAxisAngle(_this.unitX, Math.atan2(-_this.alignVector.y, _this.alignVector.z));

            _this.tempQuaternion.multiplyQuaternions(_this.tempQuaternion2, _this.tempQuaternion);

            handle.quaternion.copy(_this.tempQuaternion);
          }

          if (handle.name === 'Y') {
            _this.tempQuaternion.setFromAxisAngle(_this.unitY, Math.atan2(_this.alignVector.x, _this.alignVector.z));

            _this.tempQuaternion.multiplyQuaternions(_this.tempQuaternion2, _this.tempQuaternion);

            handle.quaternion.copy(_this.tempQuaternion);
          }

          if (handle.name === 'Z') {
            _this.tempQuaternion.setFromAxisAngle(_this.unitZ, Math.atan2(_this.alignVector.y, _this.alignVector.x));

            _this.tempQuaternion.multiplyQuaternions(_this.tempQuaternion2, _this.tempQuaternion);

            handle.quaternion.copy(_this.tempQuaternion);
          }
        } // Hide disabled axes


        handle.visible = handle.visible && (handle.name.indexOf("X") === -1 || _this.showX);
        handle.visible = handle.visible && (handle.name.indexOf("Y") === -1 || _this.showY);
        handle.visible = handle.visible && (handle.name.indexOf("Z") === -1 || _this.showZ);
        handle.visible = handle.visible && (handle.name.indexOf("E") === -1 || _this.showX && _this.showY && _this.showZ); // highlight selected axis

        handle.material._opacity = handle.material._opacity || handle.material.opacity;
        handle.material._color = handle.material._color || handle.material.color.clone();
        handle.material.color.copy(handle.material._color);
        handle.material.opacity = handle.material._opacity;

        if (!_this.enabled) {
          handle.material.opacity *= 0.5;
          handle.material.color.lerp(new Color$1(1, 1, 1), 0.5);
        } else if (_this.axis) {
          if (handle.name === _this.axis) {
            handle.material.opacity = 1.0;
            handle.material.color.lerp(new Color$1(1, 1, 1), 0.5);
          } else if (_this.axis.split('').some(function (a) {
            return handle.name === a;
          })) {
            handle.material.opacity = 1.0;
            handle.material.color.lerp(new Color$1(1, 1, 1), 0.5);
          } else {
            handle.material.opacity *= 0.25;
            handle.material.color.lerp(new Color$1(1, 1, 1), 0.5);
          }
        }
      }

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Gizmo.prototype)), "updateMatrixWorld", _thisSuper).call(_thisSuper);
    });

    _this.type = 'TransformControlsGizmo'; // shared materials

    _this.gizmoMaterial = new MeshBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      side: DoubleSide,
      fog: false
    });
    _this.gizmoLineMaterial = new LineBasicMaterial({
      depthTest: false,
      depthWrite: false,
      transparent: true,
      linewidth: 1,
      fog: false
    });
    _this.arrowGeometry = new CylinderGeometry(0, 0.05, 0.2, 12, 1, false);
    _this.scaleHandleGeometry = new BoxGeometry(0.125, 0.125, 0.125);
    _this.lineGeometry = new BufferGeometry();

    _this.lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 0, 0], 3)); // Make unique material for each axis/color


    _this.matInvisible = _this.gizmoMaterial.clone();
    _this.matInvisible.opacity = 0.15;
    _this.matHelper = _this.gizmoMaterial.clone();
    _this.matHelper.opacity = 0.33;
    _this.matRed = _this.gizmoMaterial.clone();

    _this.matRed.color.set(0xff0000);

    _this.matGreen = _this.gizmoMaterial.clone();

    _this.matGreen.color.set(0x00ff00);

    _this.matBlue = _this.gizmoMaterial.clone();

    _this.matBlue.color.set(0x0000ff);

    _this.matWhiteTransperent = _this.gizmoMaterial.clone();
    _this.matWhiteTransperent.opacity = 0.25;
    _this.matYellowTransparent = _this.matWhiteTransperent.clone();

    _this.matYellowTransparent.color.set(0xffff00);

    _this.matCyanTransparent = _this.matWhiteTransperent.clone();

    _this.matCyanTransparent.color.set(0x00ffff);

    _this.matMagentaTransparent = _this.matWhiteTransperent.clone();

    _this.matMagentaTransparent.color.set(0xff00ff);

    _this.matYellow = _this.gizmoMaterial.clone();

    _this.matYellow.color.set(0xffff00);

    _this.matLineRed = _this.gizmoLineMaterial.clone();

    _this.matLineRed.color.set(0xff0000);

    _this.matLineGreen = _this.gizmoLineMaterial.clone();

    _this.matLineGreen.color.set(0x00ff00);

    _this.matLineBlue = _this.gizmoLineMaterial.clone();

    _this.matLineBlue.color.set(0x0000ff);

    _this.matLineCyan = _this.gizmoLineMaterial.clone();

    _this.matLineCyan.color.set(0x00ffff);

    _this.matLineMagenta = _this.gizmoLineMaterial.clone();

    _this.matLineMagenta.color.set(0xff00ff);

    _this.matLineYellow = _this.gizmoLineMaterial.clone();

    _this.matLineYellow.color.set(0xffff00);

    _this.matLineGray = _this.gizmoLineMaterial.clone();

    _this.matLineGray.color.set(0x787878);

    _this.matLineYellowTransparent = _this.matLineYellow.clone();
    _this.matLineYellowTransparent.opacity = 0.25;
    _this.tempVector = new Vector3$1(0, 0, 0);
    _this.tempEuler = new Euler();
    _this.alignVector = new Vector3$1(0, 1, 0);
    _this.zeroVector = new Vector3$1(0, 0, 0);
    _this.lookAtMatrix = new Matrix4();
    _this.tempQuaternion = new Quaternion();
    _this.tempQuaternion2 = new Quaternion();
    _this.identityQuaternion = new Quaternion();
    _this.unitX = new Vector3$1(1, 0, 0);
    _this.unitY = new Vector3$1(0, 1, 0);
    _this.unitZ = new Vector3$1(0, 0, 1); // Gizmo creation

    _this.gizmo = {};
    _this.picker = {};
    _this.helper = {};

    _this.add(_this.gizmo["translate"] = _this.setupGizmo(_this.getGizmoTranslate()));

    _this.add(_this.gizmo["rotate"] = _this.setupGizmo(_this.getGizmoRotate()));

    _this.add(_this.gizmo["scale"] = _this.setupGizmo(_this.getGizmoScale()));

    _this.add(_this.picker["translate"] = _this.setupGizmo(_this.getPickerTranslate()));

    _this.add(_this.picker["rotate"] = _this.setupGizmo(_this.getPickerRotate()));

    _this.add(_this.picker["scale"] = _this.setupGizmo(_this.getPickerScale()));

    _this.add(_this.helper["translate"] = _this.setupGizmo(_this.getHelperTranslate()));

    _this.add(_this.helper["rotate"] = _this.setupGizmo(_this.getHelperRotate()));

    _this.add(_this.helper["scale"] = _this.setupGizmo(_this.getHelperScale())); // Pickers should be hidden always


    _this.picker["translate"].visible = false;
    _this.picker["rotate"].visible = false;
    _this.picker["scale"].visible = false;
    _this.isTransformControlsGizmo = true;
    return _this;
  }

  _createClass(Gizmo, [{
    key: "createCircleGeometry",
    value: function createCircleGeometry(radius, arc) {
      var geometry = new BufferGeometry();
      var vertices = [];

      for (var i = 0; i <= 64 * arc; ++i) {
        vertices.push(0, Math.cos(i / 32 * Math.PI) * radius, Math.sin(i / 32 * Math.PI) * radius);
      }

      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      return geometry;
    }
  }, {
    key: "createTranslateHelperGeometry",
    value: function createTranslateHelperGeometry(radius, arc) {
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 1, 1, 1], 3));
      return geometry;
    }
  }, {
    key: "getGizmoTranslate",
    value: function getGizmoTranslate() {
      return {
        X: [[new Mesh(this.arrowGeometry, this.matRed), [1, 0, 0], [0, 0, -Math.PI / 2], null, 'fwd'], [new Mesh(this.arrowGeometry, this.matRed), [1, 0, 0], [0, 0, Math.PI / 2], null, 'bwd'], [new Line$1(this.lineGeometry, this.matLineRed)]],
        Y: [[new Mesh(this.arrowGeometry, this.matGreen), [0, 1, 0], null, null, 'fwd'], [new Mesh(this.arrowGeometry, this.matGreen), [0, 1, 0], [Math.PI, 0, 0], null, 'bwd'], [new Line$1(this.lineGeometry, this.matLineGreen), null, [0, 0, Math.PI / 2]]],
        Z: [[new Mesh(this.arrowGeometry, this.matBlue), [0, 0, 1], [Math.PI / 2, 0, 0], null, 'fwd'], [new Mesh(this.arrowGeometry, this.matBlue), [0, 0, 1], [-Math.PI / 2, 0, 0], null, 'bwd'], [new Line$1(this.lineGeometry, this.matLineBlue), null, [0, -Math.PI / 2, 0]]],
        XYZ: [[new Mesh(new OctahedronGeometry(0.1, 0), this.matWhiteTransperent), [0, 0, 0], [0, 0, 0]]],
        XY: [[new Mesh(new PlaneGeometry(0.295, 0.295), this.matYellowTransparent), [0.15, 0.15, 0]], [new Line$1(this.lineGeometry, this.matLineYellow), [0.18, 0.3, 0], null, [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineYellow), [0.3, 0.18, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
        YZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), this.matCyanTransparent), [0, 0.15, 0.15], [0, Math.PI / 2, 0]], [new Line$1(this.lineGeometry, this.matLineCyan), [0, 0.18, 0.3], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineCyan), [0, 0.3, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
        XZ: [[new Mesh(new PlaneGeometry(0.295, 0.295), this.matMagentaTransparent), [0.15, 0, 0.15], [-Math.PI / 2, 0, 0]], [new Line$1(this.lineGeometry, this.matLineMagenta), [0.18, 0, 0.3], null, [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineMagenta), [0.3, 0, 0.18], [0, -Math.PI / 2, 0], [0.125, 1, 1]]]
      };
    }
  }, {
    key: "getPickerTranslate",
    value: function getPickerTranslate() {
      return {
        X: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), this.matInvisible), [0.6, 0, 0], [0, 0, -Math.PI / 2]]],
        Y: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), this.matInvisible), [0, 0.6, 0]]],
        Z: [[new Mesh(new CylinderGeometry(0.2, 0, 1, 4, 1, false), this.matInvisible), [0, 0, 0.6], [Math.PI / 2, 0, 0]]],
        XYZ: [[new Mesh(new OctahedronGeometry(0.2, 0), this.matInvisible)]],
        XY: [[new Mesh(new PlaneGeometry(0.4, 0.4), this.matInvisible), [0.2, 0.2, 0]]],
        YZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), this.matInvisible), [0, 0.2, 0.2], [0, Math.PI / 2, 0]]],
        XZ: [[new Mesh(new PlaneGeometry(0.4, 0.4), this.matInvisible), [0.2, 0, 0.2], [-Math.PI / 2, 0, 0]]]
      };
    }
  }, {
    key: "getHelperTranslate",
    value: function getHelperTranslate() {
      return {
        START: [[new Mesh(new OctahedronGeometry(0.01, 2), this.matHelper), null, null, null, 'helper']],
        END: [[new Mesh(new OctahedronGeometry(0.01, 2), this.matHelper), null, null, null, 'helper']],
        DELTA: [[new Line$1(this.createTranslateHelperGeometry(), this.matHelper), null, null, null, 'helper']],
        X: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
        Y: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
        Z: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
      };
    }
  }, {
    key: "getGizmoRotate",
    value: function getGizmoRotate() {
      return {
        X: [[new Line$1(this.createCircleGeometry(1, 0.5), this.matLineRed)], [new Mesh(new OctahedronGeometry(0.04, 0), this.matRed), [0, 0, 0.99], null, [1, 3, 1]]],
        Y: [[new Line$1(this.createCircleGeometry(1, 0.5), this.matLineGreen), null, [0, 0, -Math.PI / 2]], [new Mesh(new OctahedronGeometry(0.04, 0), this.matGreen), [0, 0, 0.99], null, [3, 1, 1]]],
        Z: [[new Line$1(this.createCircleGeometry(1, 0.5), this.matLineBlue), null, [0, Math.PI / 2, 0]], [new Mesh(new OctahedronGeometry(0.04, 0), this.matBlue), [0.99, 0, 0], null, [1, 3, 1]]],
        E: [[new Line$1(this.createCircleGeometry(1.25, 1), this.matLineYellowTransparent), null, [0, Math.PI / 2, 0]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), this.matLineYellowTransparent), [1.17, 0, 0], [0, 0, -Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), this.matLineYellowTransparent), [-1.17, 0, 0], [0, 0, Math.PI / 2], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), this.matLineYellowTransparent), [0, -1.17, 0], [Math.PI, 0, 0], [1, 1, 0.001]], [new Mesh(new CylinderGeometry(0.03, 0, 0.15, 4, 1, false), this.matLineYellowTransparent), [0, 1.17, 0], [0, 0, 0], [1, 1, 0.001]]],
        XYZE: [[new Line$1(this.createCircleGeometry(1, 1), this.matLineGray), null, [0, Math.PI / 2, 0]]]
      };
    }
  }, {
    key: "getHelperRotate",
    value: function getHelperRotate() {
      return {
        AXIS: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']]
      };
    }
  }, {
    key: "getPickerRotate",
    value: function getPickerRotate() {
      return {
        X: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), this.matInvisible), [0, 0, 0], [0, -Math.PI / 2, -Math.PI / 2]]],
        Y: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), this.matInvisible), [0, 0, 0], [Math.PI / 2, 0, 0]]],
        Z: [[new Mesh(new TorusGeometry(1, 0.1, 4, 24), this.matInvisible), [0, 0, 0], [0, 0, -Math.PI / 2]]],
        E: [[new Mesh(new TorusGeometry(1.25, 0.1, 2, 24), this.matInvisible)]],
        XYZE: [[new Mesh(new SphereGeometry(0.7, 10, 8), this.matInvisible)]]
      };
    }
  }, {
    key: "getGizmoScale",
    value: function getGizmoScale() {
      return {
        X: [[new Mesh(this.scaleHandleGeometry, this.matRed), [0.8, 0, 0], [0, 0, -Math.PI / 2]], [new Line$1(this.lineGeometry, this.matLineRed), null, null, [0.8, 1, 1]]],
        Y: [[new Mesh(this.scaleHandleGeometry, this.matGreen), [0, 0.8, 0]], [new Line$1(this.lineGeometry, this.matLineGreen), null, [0, 0, Math.PI / 2], [0.8, 1, 1]]],
        Z: [[new Mesh(this.scaleHandleGeometry, this.matBlue), [0, 0, 0.8], [Math.PI / 2, 0, 0]], [new Line$1(this.lineGeometry, this.matLineBlue), null, [0, -Math.PI / 2, 0], [0.8, 1, 1]]],
        XY: [[new Mesh(this.scaleHandleGeometry, this.matYellowTransparent), [0.85, 0.85, 0], null, [2, 2, 0.2]], [new Line$1(this.lineGeometry, this.matLineYellow), [0.855, 0.98, 0], null, [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineYellow), [0.98, 0.855, 0], [0, 0, Math.PI / 2], [0.125, 1, 1]]],
        YZ: [[new Mesh(this.scaleHandleGeometry, this.matCyanTransparent), [0, 0.85, 0.85], null, [0.2, 2, 2]], [new Line$1(this.lineGeometry, this.matLineCyan), [0, 0.855, 0.98], [0, 0, Math.PI / 2], [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineCyan), [0, 0.98, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
        XZ: [[new Mesh(this.scaleHandleGeometry, this.matMagentaTransparent), [0.85, 0, 0.85], null, [2, 0.2, 2]], [new Line$1(this.lineGeometry, this.matLineMagenta), [0.855, 0, 0.98], null, [0.125, 1, 1]], [new Line$1(this.lineGeometry, this.matLineMagenta), [0.98, 0, 0.855], [0, -Math.PI / 2, 0], [0.125, 1, 1]]],
        XYZX: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), this.matWhiteTransperent), [1.1, 0, 0]]],
        XYZY: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), this.matWhiteTransperent), [0, 1.1, 0]]],
        XYZZ: [[new Mesh(new BoxGeometry(0.125, 0.125, 0.125), this.matWhiteTransperent), [0, 0, 1.1]]]
      };
    }
  }, {
    key: "getPickerScale",
    value: function getPickerScale() {
      return {
        X: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), this.matInvisible), [0.5, 0, 0], [0, 0, -Math.PI / 2]]],
        Y: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), this.matInvisible), [0, 0.5, 0]]],
        Z: [[new Mesh(new CylinderGeometry(0.2, 0, 0.8, 4, 1, false), this.matInvisible), [0, 0, 0.5], [Math.PI / 2, 0, 0]]],
        XY: [[new Mesh(this.scaleHandleGeometry, this.matInvisible), [0.85, 0.85, 0], null, [3, 3, 0.2]]],
        YZ: [[new Mesh(this.scaleHandleGeometry, this.matInvisible), [0, 0.85, 0.85], null, [0.2, 3, 3]]],
        XZ: [[new Mesh(this.scaleHandleGeometry, this.matInvisible), [0.85, 0, 0.85], null, [3, 0.2, 3]]],
        XYZX: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), this.matInvisible), [1.1, 0, 0]]],
        XYZY: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), this.matInvisible), [0, 1.1, 0]]],
        XYZZ: [[new Mesh(new BoxGeometry(0.2, 0.2, 0.2), this.matInvisible), [0, 0, 1.1]]]
      };
    }
  }, {
    key: "getHelperScale",
    value: function getHelperScale() {
      return {
        X: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], 'helper']],
        Y: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [0, -1e3, 0], [0, 0, Math.PI / 2], [1e6, 1, 1], 'helper']],
        Z: [[new Line$1(this.lineGeometry, this.matHelper.clone()), [0, 0, -1e3], [0, -Math.PI / 2, 0], [1e6, 1, 1], 'helper']]
      };
    }
  }, {
    key: "setupGizmo",
    value: function setupGizmo(gizmoMap) {
      var gizmo = new Object3D();

      for (var name in gizmoMap) {
        for (var i = gizmoMap[name].length; i--;) {
          var object = gizmoMap[name][i][0].clone();
          var position = gizmoMap[name][i][1];
          var rotation = gizmoMap[name][i][2];
          var scale = gizmoMap[name][i][3];
          var tag = gizmoMap[name][i][4]; // name and tag properties are essential for picking and updating logic.

          object.name = name;
          object.tag = tag;

          if (position) {
            object.position.set(position[0], position[1], position[2]);
          }

          if (rotation) {
            object.rotation.set(rotation[0], rotation[1], rotation[2]);
          }

          if (scale) {
            object.scale.set(scale[0], scale[1], scale[2]);
          }

          object.updateMatrix();
          var tempGeometry = object.geometry.clone();
          tempGeometry.applyMatrix4(object.matrix);
          object.geometry = tempGeometry;
          object.position.set(0, 0, 0);
          object.rotation.set(0, 0, 0);
          object.scale.set(1, 1, 1);
          gizmo.add(object);
        }
      }

      return gizmo;
    }
  }]);

  return Gizmo;
}(Object3D);var TransformControlsPlane = /*#__PURE__*/function (_Mesh) {
  _inherits(TransformControlsPlane, _Mesh);

  var _super = _createSuper(TransformControlsPlane);

  function TransformControlsPlane() {
    var _this;

    _classCallCheck(this, TransformControlsPlane);

    _this = _super.call(this, new PlaneGeometry(100000, 100000, 2, 2), new MeshBasicMaterial({
      visible: false,
      wireframe: true,
      side: DoubleSide,
      transparent: true,
      opacity: 0.1
    }));
    _this.type = 'TransformControlsPlane';
    _this.unitX = new Vector3$1(1, 0, 0);
    _this.unitY = new Vector3$1(0, 1, 0);
    _this.unitZ = new Vector3$1(0, 0, 1);
    _this.tempVector = new Vector3$1();
    _this.dirVector = new Vector3$1();
    _this.alignVector = new Vector3$1();
    _this.tempMatrix = new Matrix4();
    _this.identityQuaternion = new Quaternion();
    _this.isTransformControlsPlane = true;
    return _this;
  }

  _createClass(TransformControlsPlane, [{
    key: "updateMatrixWorld",
    value: function updateMatrixWorld() {
      var space = this.space;
      this.position.copy(this.worldPosition);
      if (this.mode === 'scale') space = 'local'; // scale always oriented to local rotation

      this.unitX.set(1, 0, 0).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion);
      this.unitY.set(0, 1, 0).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion);
      this.unitZ.set(0, 0, 1).applyQuaternion(space === "local" ? this.worldQuaternion : this.identityQuaternion); // Align the plane for current transform mode, axis and space.

      this.alignVector.copy(this.unitY);

      switch (this.mode) {
        case 'translate':
        case 'scale':
          switch (this.axis) {
            case 'X':
              this.alignVector.copy(this.eye).cross(this.unitX);
              this.dirVector.copy(this.unitX).cross(this.alignVector);
              break;

            case 'Y':
              this.alignVector.copy(this.eye).cross(this.unitY);
              this.dirVector.copy(this.unitY).cross(this.alignVector);
              break;

            case 'Z':
              this.alignVector.copy(this.eye).cross(this.unitZ);
              this.dirVector.copy(this.unitZ).cross(this.alignVector);
              break;

            case 'XY':
              this.dirVector.copy(this.unitZ);
              break;

            case 'YZ':
              this.dirVector.copy(this.unitX);
              break;

            case 'XZ':
              this.alignVector.copy(this.unitZ);
              this.dirVector.copy(this.unitY);
              break;

            case 'XYZ':
            case 'E':
              this.dirVector.set(0, 0, 0);
              break;
          }

          break;

        case 'rotate':
        default:
          // special case for rotate
          this.dirVector.set(0, 0, 0);
      }

      if (this.dirVector.length() === 0) {
        // If in rotate mode, make the plane parallel to camera
        this.quaternion.copy(this.cameraQuaternion);
      } else {
        this.tempMatrix.lookAt(this.tempVector.set(0, 0, 0), this.dirVector, this.alignVector);
        this.quaternion.setFromRotationMatrix(this.tempMatrix);
      }

      _get(_getPrototypeOf(TransformControlsPlane.prototype), "updateMatrixWorld", this).call(this);
    }
  }]);

  return TransformControlsPlane;
}(Mesh);var TransformControls = /*#__PURE__*/function (_Object3D) {
  _inherits(TransformControls, _Object3D);

  var _super = _createSuper(TransformControls);

  function TransformControls(camera, domElement) {
    var _this;

    _classCallCheck(this, TransformControls);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "pointerHover", function (pointer) {
      if (_this.object === undefined || _this.dragging === true || pointer.button !== undefined && pointer.button !== 0) return;

      _this.ray.setFromCamera(pointer, _this.camera);

      var intersect = _this.ray.intersectObjects(_this.gizmo.picker[_this.mode].children, true)[0] || false;

      if (intersect) {
        _this.axis = intersect.object.name;
      } else {
        _this.axis = null;
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "pointerDown", function (pointer) {
      if (_this.object === undefined || _this.dragging === true || pointer.button !== undefined && pointer.button !== 0) return;

      if ((pointer.button === 0 || pointer.button === undefined) && _this.axis !== null) {
        _this.ray.setFromCamera(pointer, _this.camera);

        var planeIntersect = _this.ray.intersectObjects([_this.plane], true)[0] || false;

        if (planeIntersect) {
          var space = _this.space;

          if (_this.mode === 'scale') {
            space = 'local';
          } else if (_this.axis === 'E' || _this.axis === 'XYZE' || _this.axis === 'XYZ') {
            space = 'world';
          }

          if (space === 'local' && _this.mode === 'rotate') {
            var snap = _this.rotationSnap;
            if (_this.axis === 'X' && snap) _this.object.rotation.x = Math.round(_this.object.rotation.x / snap) * snap;
            if (_this.axis === 'Y' && snap) _this.object.rotation.y = Math.round(_this.object.rotation.y / snap) * snap;
            if (_this.axis === 'Z' && snap) _this.object.rotation.z = Math.round(_this.object.rotation.z / snap) * snap;
          }

          _this.object.updateMatrixWorld();

          _this.object.parent.updateMatrixWorld();

          _this._positionStart.copy(_this.object.position);

          _this._quaternionStart.copy(_this.object.quaternion);

          _this._scaleStart.copy(_this.object.scale);

          _this.object.matrixWorld.decompose(_this.worldPositionStart, _this.worldQuaternionStart, _this.worldScaleStart);

          _this.pointStart.copy(planeIntersect.point).sub(_this.worldPositionStart);

          if (space === 'local') {
            _this.pointStart.applyQuaternion(_this.worldQuaternionStart.clone().invert());
          }
        }

        _this.dragging = true;
        _this.mouseDownEvent.mode = _this.mode;

        _this.dispatchEvent(_this.mouseDownEvent);
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "pointerMove", function (pointer) {
      var axis = _this.axis;
      var mode = _this.mode;
      var object = _this.object;
      var space = _this.space;

      if (mode === 'scale') {
        space = 'local';
      } else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {
        space = 'world';
      }

      if (object === undefined || axis === null || _this.dragging === false || pointer.button !== undefined && pointer.button !== 0) return;

      _this.ray.setFromCamera(pointer, _this.camera);

      var planeIntersect = _this.ray.intersectObjects([_this.plane], true)[0] || false;
      if (planeIntersect === false) return;

      _this.pointEnd.copy(planeIntersect.point).sub(_this.worldPositionStart);

      if (space === 'local') _this.pointEnd.applyQuaternion(_this.worldQuaternionStart.clone().invert());

      if (mode === 'translate') {
        if (axis.search('X') === -1) {
          _this.pointEnd.x = _this.pointStart.x;
        }

        if (axis.search('Y') === -1) {
          _this.pointEnd.y = _this.pointStart.y;
        }

        if (axis.search('Z') === -1) {
          _this.pointEnd.z = _this.pointStart.z;
        } // Apply translate


        if (space === 'local') {
          object.position.copy(_this.pointEnd).sub(_this.pointStart).applyQuaternion(_this._quaternionStart);
        } else {
          object.position.copy(_this.pointEnd).sub(_this.pointStart);
        }

        object.position.add(_this._positionStart); // Apply translation snap

        if (_this.translationSnap) {
          if (space === 'local') {
            object.position.applyQuaternion(_this._tempQuaternion.copy(_this._quaternionStart).invert());

            if (axis.search('X') !== -1) {
              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Y') !== -1) {
              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Z') !== -1) {
              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;
            }

            object.position.applyQuaternion(_this._quaternionStart);
          }

          if (space === 'world') {
            if (object.parent) {
              object.position.add(_this._tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }

            if (axis.search('X') !== -1) {
              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Y') !== -1) {
              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Z') !== -1) {
              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;
            }

            if (object.parent) {
              object.position.sub(_this._tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }
          }
        }
      } else if (mode === 'scale') {
        if (axis.search('XYZ') !== -1) {
          var d = _this.pointEnd.length() / _this.pointStart.length();

          if (_this.pointEnd.dot(_this.pointStart) < 0) d *= -1;

          _this._tempVector.set(d, d, d);
        } else {
          _this._tempVector.copy(_this.pointEnd).divide(_this.pointStart);

          if (axis.search('X') === -1) {
            _this._tempVector.x = 1;
          }

          if (axis.search('Y') === -1) {
            _this._tempVector.y = 1;
          }

          if (axis.search('Z') === -1) {
            _this._tempVector.z = 1;
          }
        } // Apply scale


        object.scale.copy(_this._scaleStart).multiply(_this._tempVector);
      } else if (mode === 'rotate') {
        var ROTATION_SPEED = 20 / _this.worldPosition.distanceTo(_this._tempVector.setFromMatrixPosition(_this.camera.matrixWorld));

        var quaternion = _this.space === "local" ? _this.worldQuaternion : _this._identityQuaternion;
        var unit = _unit[axis];

        if (axis === 'E') {
          _this._tempVector.copy(_this.pointEnd).cross(_this.pointStart);

          _this.rotationAxis.copy(_this.eye);

          _this.rotationAngle = _this.pointEnd.angleTo(_this.pointStart) * (_this._tempVector.dot(_this.eye) < 0 ? 1 : -1);
        } else if (axis === 'XYZE') {
          _this._tempVector.copy(_this.pointEnd).sub(_this.pointStart).cross(_this.eye).normalize();

          _this.rotationAxis.copy(_this._tempVector);

          _this.rotationAngle = _this.pointEnd.sub(_this.pointStart).dot(_this._tempVector.cross(_this.eye)) * ROTATION_SPEED;
        } else if (axis === 'X' || axis === 'Y' || axis === 'Z') {
          _this._alignVector.copy(unit).applyQuaternion(quaternion);

          _this.rotationAxis.copy(unit);

          _this._tempVector = unit.clone();
          _this._tempVector2 = _this.pointEnd.clone().sub(_this.pointStart);

          if (space === 'local') {
            _this._tempVector.applyQuaternion(quaternion);

            _this._tempVector2.applyQuaternion(_this.worldQuaternionStart);
          }

          _this.rotationAngle = _this._tempVector2.dot(_this._tempVector.cross(_this.eye).normalize()) * ROTATION_SPEED;
        } // Apply rotation snap


        if (_this.rotationSnap) _this.rotationAngle = Math.round(_this.rotationAngle / _this.rotationSnap) * _this.rotationSnap; // Apply rotate

        if (space === 'local') {
          object.quaternion.copy(_this._quaternionStart);
          object.quaternion.multiply(_this._tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle));
        } else {
          object.quaternion.copy(_this._tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle));
          object.quaternion.multiply(_this._quaternionStart);
        }
      }

      _this.dispatchEvent(_this.changeEvent);

      _this.dispatchEvent(_this.objectChangeEvent);
    });

    _defineProperty$1(_assertThisInitialized(_this), "pointerMove", function (pointer) {
      var axis = _this.axis;
      var mode = _this.mode;
      var object = _this.object;
      var space = _this.space;

      if (mode === 'scale') {
        space = 'local';
      } else if (axis === 'E' || axis === 'XYZE' || axis === 'XYZ') {
        space = 'world';
      }

      if (object === undefined || axis === null || _this.dragging === false || pointer.button !== undefined && pointer.button !== 0) return;

      _this.ray.setFromCamera(pointer, _this.camera);

      var planeIntersect = _this.ray.intersectObjects([_this.plane], true)[0] || false;
      if (planeIntersect === false) return;

      _this.pointEnd.copy(planeIntersect.point).sub(_this.worldPositionStart);

      if (space === 'local') _this.pointEnd.applyQuaternion(_this.worldQuaternionStart.clone().invert());

      if (mode === 'translate') {
        if (axis.search('X') === -1) {
          _this.pointEnd.x = _this.pointStart.x;
        }

        if (axis.search('Y') === -1) {
          _this.pointEnd.y = _this.pointStart.y;
        }

        if (axis.search('Z') === -1) {
          _this.pointEnd.z = _this.pointStart.z;
        } // Apply translate


        if (space === 'local') {
          object.position.copy(_this.pointEnd).sub(_this.pointStart).applyQuaternion(_this._quaternionStart);
        } else {
          object.position.copy(_this.pointEnd).sub(_this.pointStart);
        }

        object.position.add(_this._positionStart); // Apply translation snap

        if (_this.translationSnap) {
          if (space === 'local') {
            object.position.applyQuaternion(_this._tempQuaternion.copy(_this._quaternionStart).invert());

            if (axis.search('X') !== -1) {
              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Y') !== -1) {
              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Z') !== -1) {
              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;
            }

            object.position.applyQuaternion(_this._quaternionStart);
          }

          if (space === 'world') {
            if (object.parent) {
              object.position.add(_this._tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }

            if (axis.search('X') !== -1) {
              object.position.x = Math.round(object.position.x / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Y') !== -1) {
              object.position.y = Math.round(object.position.y / _this.translationSnap) * _this.translationSnap;
            }

            if (axis.search('Z') !== -1) {
              object.position.z = Math.round(object.position.z / _this.translationSnap) * _this.translationSnap;
            }

            if (object.parent) {
              object.position.sub(_this._tempVector.setFromMatrixPosition(object.parent.matrixWorld));
            }
          }
        }
      } else if (mode === 'scale') {
        if (axis.search('XYZ') !== -1) {
          var d = _this.pointEnd.length() / _this.pointStart.length();

          if (_this.pointEnd.dot(_this.pointStart) < 0) d *= -1;

          _this._tempVector.set(d, d, d);
        } else {
          _this._tempVector.copy(_this.pointEnd).divide(_this.pointStart);

          if (axis.search('X') === -1) {
            _this._tempVector.x = 1;
          }

          if (axis.search('Y') === -1) {
            _this._tempVector.y = 1;
          }

          if (axis.search('Z') === -1) {
            _this._tempVector.z = 1;
          }
        } // Apply scale


        object.scale.copy(_this._scaleStart).multiply(_this._tempVector);
      } else if (mode === 'rotate') {
        var ROTATION_SPEED = 20 / _this.worldPosition.distanceTo(_this._tempVector.setFromMatrixPosition(_this.camera.matrixWorld));

        var quaternion = _this.space === "local" ? _this.worldQuaternion : _this._identityQuaternion;
        var unit = _this._unit[axis];

        if (axis === 'E') {
          _this._tempVector.copy(_this.pointEnd).cross(_this.pointStart);

          _this.rotationAxis.copy(_this.eye);

          _this.rotationAngle = _this.pointEnd.angleTo(_this.pointStart) * (_this._tempVector.dot(_this.eye) < 0 ? 1 : -1);
        } else if (axis === 'XYZE') {
          _this._tempVector.copy(_this.pointEnd).sub(_this.pointStart).cross(_this.eye).normalize();

          _this.rotationAxis.copy(_this._tempVector);

          _this.rotationAngle = _this.pointEnd.sub(_this.pointStart).dot(_this._tempVector.cross(_this.eye)) * ROTATION_SPEED;
        } else if (axis === 'X' || axis === 'Y' || axis === 'Z') {
          _this._alignVector.copy(unit).applyQuaternion(quaternion);

          _this.rotationAxis.copy(unit);

          _this._tempVector = unit.clone();
          _this._tempVector2 = _this.pointEnd.clone().sub(_this.pointStart);

          if (space === 'local') {
            _this._tempVector.applyQuaternion(quaternion);

            _this._tempVector2.applyQuaternion(_this.worldQuaternionStart);
          }

          _this.rotationAngle = _this._tempVector2.dot(_this._tempVector.cross(_this.eye).normalize()) * ROTATION_SPEED;
        } // Apply this.rotation snap


        if (_this.rotationSnap) _this.rotationAngle = Math.round(_this.rotationAngle / _this.this.rotationSnap) * _this.this.rotationSnap; // Apply rotate

        if (space === 'local') {
          object.quaternion.copy(_this._quaternionStart);
          object.quaternion.multiply(_this._tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle));
        } else {
          object.quaternion.copy(_this._tempQuaternion.setFromAxisAngle(_this.rotationAxis, _this.rotationAngle));
          object.quaternion.multiply(_this._quaternionStart);
        }
      }

      _this.dispatchEvent(_this.changeEvent);

      _this.dispatchEvent(_this.objectChangeEvent);
    });

    _defineProperty$1(_assertThisInitialized(_this), "pointerUp", function (pointer) {
      if (pointer.button !== undefined && pointer.button !== 0) return;

      if (_this.dragging && _this.axis !== null) {
        _this.mouseUpEvent.mode = _this.mode;

        _this.dispatchEvent(_this.mouseUpEvent);
      }

      _this.dragging = false;
      if (pointer.button === undefined) _this.axis = null;
    });

    _defineProperty$1(_assertThisInitialized(_this), "getPointer", function (event) {
      var pointer = event.changedTouches ? event.changedTouches[0] : event;

      var rect = _this.domElement.getBoundingClientRect();

      return {
        x: (pointer.clientX - rect.left) / rect.width * 2 - 1,
        y: -(pointer.clientY - rect.top) / rect.height * 2 + 1,
        button: event.button
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "onContext", function (event) {
      event.preventDefault();
    });

    _defineProperty$1(_assertThisInitialized(_this), "onPointerHover", function (event) {
      if (!_this.enabled) return;

      _this.pointerHover(_this.getPointer(event));
    });

    _defineProperty$1(_assertThisInitialized(_this), "onPointerDown", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();
      document.addEventListener("mousemove", _this.onPointerMove, false);

      _this.pointerHover(_this.getPointer(event));

      _this.pointerDown(_this.getPointer(event));
    });

    _defineProperty$1(_assertThisInitialized(_this), "onPointerMove", function (event) {
      if (!_this.enabled) return;
      event.preventDefault();

      _this.pointerMove(_this.getPointer(event));
    });

    _defineProperty$1(_assertThisInitialized(_this), "onPointerUp", function (event) {
      if (!_this.enabled) return;
      event.preventDefault(); // Prevent MouseEvent on mobile

      document.removeEventListener("mousemove", _this.onPointerMove, false);

      _this.pointerUp(_this.getPointer(event));
    });

    _this.domElement = domElement !== undefined ? domElement : document;
    _this.visible = false;
    _this.gizmo = new Gizmo();
    _this.plane = new TransformControlsPlane();

    _this.add(_this.gizmo);

    _this.add(_this.plane);

    _this.changeEvent = {
      type: "change"
    };
    _this.mouseDownEvent = {
      type: "mouseDown"
    };
    _this.mouseUpEvent = {
      type: "mouseUp",
      mode: _this.mode
    };
    _this.objectChangeEvent = {
      type: "objectChange"
    };
    _this._camera = camera;
    _this._object = undefined;
    _this._enabled = true;
    _this._axis = null;

    _this.setAndDispatch('axis', null);

    _this._mode = 'translate';

    _this.setAndDispatch('mode', 'translate');

    _this._translationSnap = null;
    _this._rotationSnap = null;
    _this._space = 'world';

    _this.setAndDispatch('space', 'world');

    _this._size = 1;

    _this.setAndDispatch('size', 1);

    _this._dragging = false;

    _this.setAndDispatch('dragging', false);

    _this._showX = true;
    _this._showY = true;
    _this._showZ = true;

    _this.setAndDispatch('showX', true);

    _this.setAndDispatch('showY', true);

    _this.setAndDispatch('showZ', true);

    _this.ray = new Raycaster();
    _this._tempVector = new Vector3$1();
    _this._tempVector2 = new Vector3$1();
    _this._tempQuaternion = new Quaternion();
    _this._unit = {
      X: new Vector3$1(1, 0, 0),
      Y: new Vector3$1(0, 1, 0),
      Z: new Vector3$1(0, 0, 1)
    };
    _this._identityQuaternion = new Quaternion();
    _this._alignVector = new Vector3$1();
    _this._pointStart = new Vector3$1();
    _this._pointEnd = new Vector3$1();
    _this._rotationAxis = new Vector3$1();

    _this.setAndDispatch('rotationAxis', new Vector3$1());

    _this._rotationAngle = 0;
    _this._cameraPosition = new Vector3$1();

    _this.setAndDispatch('cameraPosition', new Vector3$1());

    _this._cameraQuaternion = new Quaternion();

    _this.setAndDispatch('cameraQuaternion', new Quaternion());

    _this.cameraScale = new Vector3$1();
    _this.parentPosition = new Vector3$1();
    _this._parentQuaternion = new Quaternion();
    _this.parentScale = new Vector3$1();
    _this._worldPositionStart = new Vector3$1();

    _this.setAndDispatch('worldPositionStart', new Vector3$1());

    _this._worldQuaternionStart = new Quaternion();

    _this.setAndDispatch('worldQuaternionStart', new Quaternion());

    _this.worldScaleStart = new Vector3$1();
    _this._worldPosition = new Vector3$1();

    _this.setAndDispatch('worldPosition', new Vector3$1());

    _this._worldQuaternion = new Quaternion();

    _this.setAndDispatch('worldQuaternion', new Quaternion());

    _this.worldScale = new Vector3$1();
    _this._eye = new Vector3$1();

    _this.setAndDispatch('eye', new Vector3$1());

    _this._positionStart = new Vector3$1();
    _this._quaternionStart = new Quaternion();
    _this._scaleStart = new Vector3$1();
    _this.isTransformControls = true;
    Scene$1.add(_assertThisInitialized(_this), null, false);
    return _this;
  }

  _createClass(TransformControls, [{
    key: "render",
    value: function render() {}
  }, {
    key: "update",
    value: function update() {}
  }, {
    key: "physicsUpdate",
    value: function physicsUpdate() {}
  }, {
    key: "setAndDispatch",
    value: function setAndDispatch(fieldName, value) {
      this["_".concat(fieldName)] = value;
      this.gizmo[fieldName] = value;
      this.plane[fieldName] = value;
      this.dispatchEvent({
        type: fieldName + "-changed",
        value: value
      });
      this.dispatchEvent(this.changeEvent);
    }
  }, {
    key: "getPrivateField",
    value: function getPrivateField(fieldName) {
      return this["_".concat(fieldName)];
    }
  }, {
    key: "enabled",
    value: function enabled(value) {
      this.setAndDispatch('enabled', value);
    }
  }, {
    key: "init",
    value: function init() {
      this.domElement.addEventListener("mousedown", this.onPointerDown, false);
      this.domElement.addEventListener("touchstart", this.onPointerDown, false);
      this.domElement.addEventListener("mousemove", this.onPointerHover, false);
      this.domElement.addEventListener("touchmove", this.onPointerHover, false);
      this.domElement.addEventListener("touchmove", this.onPointerMove, false);
      document.addEventListener("mouseup", this.onPointerUp, false);
      this.domElement.addEventListener("touchend", this.onPointerUp, false);
      this.domElement.addEventListener("touchcancel", this.onPointerUp, false);
      this.domElement.addEventListener("touchleave", this.onPointerUp, false);
      this.domElement.addEventListener("contextmenu", this.onContext, false);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.domElement.removeEventListener("mousedown", this.onPointerDown);
      this.domElement.removeEventListener("touchstart", this.onPointerDown);
      this.domElement.removeEventListener("mousemove", this.onPointerHover);
      this.domElement.removeEventListener("touchmove", this.onPointerHover);
      this.domElement.removeEventListener("touchmove", this.onPointerMove);
      document.removeEventListener("mouseup", this.onPointerUp);
      this.domElement.removeEventListener("touchend", this.onPointerUp);
      this.domElement.removeEventListener("touchcancel", this.onPointerUp);
      this.domElement.removeEventListener("touchleave", this.onPointerUp);
      this.domElement.removeEventListener("contextmenu", this.onContext);
    }
  }, {
    key: "attach",
    value: function attach(element) {
      if (!element) return;
      this.object = element.getBody();
      this.visible = true;
    }
  }, {
    key: "detach",
    value: function detach() {
      this.object = undefined;
      this.visible = false;
      this.axis = null;
    }
  }, {
    key: "updateMatrixWorld",
    value: function updateMatrixWorld() {
      if (this.object !== undefined) {
        this.object.updateMatrixWorld();
        this.object.parent.matrixWorld.decompose(this.parentPosition, this.parentQuaternion, this.parentScale);
        this.object.matrixWorld.decompose(this.worldPosition, this.worldQuaternion, this.worldScale);
      }

      this.camera.updateMatrixWorld();
      this.camera.matrixWorld.decompose(this.cameraPosition, this.cameraQuaternion, this.cameraScale);

      if (this.camera instanceof PerspectiveCamera) {
        this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize();
      } else if (this.camera instanceof OrthographicCamera) {
        this.eye.copy(this.cameraPosition).normalize();
      }

      _get(_getPrototypeOf(TransformControls.prototype), "updateMatrixWorld", this).call(this);
    }
  }, {
    key: "getMode",
    value: function getMode() {
      return this.mode;
    }
  }, {
    key: "setMode",
    value: function setMode(mode) {
      this.mode = mode;
    }
  }, {
    key: "setTranslationSnap",
    value: function setTranslationSnap(translationSnap) {
      this.translationSnap = translationSnap;
    }
  }, {
    key: "setRotationSnap",
    value: function setRotationSnap(rotationSnap) {
      this.rotationSnap = rotationSnap;
    }
  }, {
    key: "setSize",
    value: function setSize(size) {
      this.size = size;
    }
  }, {
    key: "getSize",
    value: function getSize() {
      return this.size;
    }
  }, {
    key: "setSpace",
    value: function setSpace(space) {
      this.space = space;
    }
  }, {
    key: "getSpace",
    value: function getSpace() {
      return this.space;
    }
  }, {
    key: "camera",
    set: function set(value) {
      this.setAndDispatch('camera', value);
    },
    get: function get() {
      return this.getPrivateField('camera');
    }
  }, {
    key: "object",
    set: function set(value) {
      this.setAndDispatch('object', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('object');
    }
  }, {
    key: "enabled",
    get: function get() {
      return this.getPrivateField('enabled');
    }
  }, {
    key: "axis",
    set: function set(value) {
      this.setAndDispatch('axis', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('axis');
    }
  }, {
    key: "mode",
    set: function set(value) {
      this.setAndDispatch('mode', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('mode');
    }
  }, {
    key: "translationSnap",
    set: function set(value) {
      this.setAndDispatch('translationSnap', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('translationSnap');
    }
  }, {
    key: "rotationSnap",
    set: function set(value) {
      this.setAndDispatch('rotationSnap', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('rotationSnap');
    }
  }, {
    key: "space",
    set: function set(value) {
      this.setAndDispatch('space', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('space');
    }
  }, {
    key: "size",
    set: function set(value) {
      this.setAndDispatch('size', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('size');
    }
  }, {
    key: "dragging",
    set: function set(value) {
      this.setAndDispatch('dragging', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('dragging');
    }
  }, {
    key: "showX",
    set: function set(value) {
      this.setAndDispatch('showX', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('showX');
    }
  }, {
    key: "showY",
    set: function set(value) {
      this.setAndDispatch('showY', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('showY');
    }
  }, {
    key: "showZ",
    set: function set(value) {
      this.setAndDispatch('showZ', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('showZ');
    }
  }, {
    key: "parentQuaternion",
    set: function set(value) {
      this.setAndDispatch('parentQuaternion', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('parentQuaternion');
    }
  }, {
    key: "worldPosition",
    set: function set(value) {
      this.setAndDispatch('worldPosition', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('worldPosition');
    }
  }, {
    key: "worldPositionStart",
    set: function set(value) {
      this.setAndDispatch('worldPositionStart', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('worldPositionStart');
    }
  }, {
    key: "worldQuaternion",
    set: function set(value) {
      this.setAndDispatch('worldQuaternion', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('worldQuaternion');
    }
  }, {
    key: "worldQuaternionStart",
    set: function set(value) {
      this.setAndDispatch('worldQuaternionStart', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('worldQuaternionStart');
    }
  }, {
    key: "cameraPosition",
    set: function set(value) {
      this.setAndDispatch('cameraPosition', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('cameraPosition');
    }
  }, {
    key: "cameraQuaternion",
    set: function set(value) {
      this.setAndDispatch('cameraQuaternion', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('cameraQuaternion');
    }
  }, {
    key: "pointStart",
    set: function set(value) {
      this.setAndDispatch('pointStart', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('pointStart');
    }
  }, {
    key: "pointEnd",
    set: function set(value) {
      this.setAndDispatch('pointEnd', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('pointEnd');
    }
  }, {
    key: "rotationAxis",
    set: function set(value) {
      this.setAndDispatch('rotationAxis', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('rotationAxis');
    }
  }, {
    key: "rotationAngle",
    set: function set(value) {
      this.setAndDispatch('rotationAngle', value);
    } // no
    ,
    get: function get() {
      return this.getPrivateField('rotationAngle');
    }
  }, {
    key: "eye",
    set: function set(value) {
      this.setAndDispatch('eye', value);
    } // si
    ,
    get: function get() {
      return this.getPrivateField('eye');
    }
  }]);

  return TransformControls;
}(Object3D);var CHANGE_EVENT = {
  type: 'change'
};
var LOCK_EVENT = {
  type: 'lock'
};
var UNLOCK_EVENT = {
  type: 'unlock'
};
var PI_2 = Math.PI / 2;

var FirstPersonControl = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(FirstPersonControl, _EventDispatcher);

  var _super = _createSuper(FirstPersonControl);

  function FirstPersonControl(camera, domElement) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, FirstPersonControl);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "hasPhysicsEnabled", function () {
      return _this.options.physicsEnabled;
    });

    _defineProperty$1(_assertThisInitialized(_this), "getDirection", function () {
      var direction = new Vector3$1(0, 0, -1);
      return function (v) {
        return v.copy(direction).applyQuaternion(_this.camera.getQuaternion());
      };
    }());

    _defineProperty$1(_assertThisInitialized(_this), "updateRaycasters", function () {
      _this.raycaster.ray.origin.copy(_this.getCharacter().getPosition());

      _this.raycaster.ray.origin.y -= _this.options.height;

      _this.headRaycaster.ray.origin.copy(_this.getCharacter().getPosition());

      _this.headRaycaster.ray.origin.y += _this.options.height;
    });

    _defineProperty$1(_assertThisInitialized(_this), "calculateCollisions", function () {
      return {
        onObject: _this.raycaster.intersectObjects(Scene$1.getChildren(), true).length > 0,
        headCollision: _this.headRaycaster.intersectObjects(Scene$1.getChildren(), true).length > 0
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateVelocity", function (dt) {
      _this.velocity.x -= _this.velocity.x * _this.options.slowDownFactor * dt;
      _this.velocity.z -= _this.velocity.z * _this.options.slowDownFactor * dt;
      _this.velocity.y -= 9.8 * _this.options.mass * dt; // 100.0 = mass

      if (_this.movement.forward || _this.movement.backwards) _this.velocity.z -= _this.direction.z * _this.options.speed * dt;
      if (_this.movement.left || _this.movement.right) _this.velocity.x -= _this.direction.x * _this.options.speed * dt;
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateDirection", function () {
      _this.direction.z = Number(_this.movement.forward) - Number(_this.movement.backwards);
      _this.direction.x = Number(_this.movement.right) - Number(_this.movement.left);

      _this.direction.normalize(); // this ensures consistent movements in all this.directions

    });

    _defineProperty$1(_assertThisInitialized(_this), "updateVelocityForCollisions", function () {
      _this.updateRaycasters();

      var _this$calculateCollis = _this.calculateCollisions(),
          onObject = _this$calculateCollis.onObject,
          headCollision = _this$calculateCollis.headCollision;

      if (onObject) {
        _this.velocity.y = Math.max(0, _this.velocity.y);
        _this.canJump = true;
      } else if (headCollision && _this.velocity.y > 0) {
        _this.velocity.y = 0;
      }
    });

    var _options$close = options.close,
        close = _options$close === void 0 ? 0 : _options$close,
        _options$far = options.far,
        far = _options$far === void 0 ? 1 : _options$far,
        _options$position = options.position,
        position = _options$position === void 0 ? camera.position : _options$position,
        _options$jumpSpeed = options.jumpSpeed,
        jumpSpeed = _options$jumpSpeed === void 0 ? 2 : _options$jumpSpeed,
        _options$speed = options.speed,
        speed = _options$speed === void 0 ? 2 : _options$speed,
        _options$slowDownFact = options.slowDownFactor,
        slowDownFactor = _options$slowDownFact === void 0 ? 20 : _options$slowDownFact,
        _options$mass = options.mass,
        mass = _options$mass === void 0 ? 100 : _options$mass,
        _options$height = options.height,
        height = _options$height === void 0 ? 1.8 : _options$height,
        _options$sensitivity = options.sensitivity,
        sensitivity = _options$sensitivity === void 0 ? 0.002 : _options$sensitivity,
        _options$target = options.target,
        target = _options$target === void 0 ? null : _options$target,
        _options$physicsEnabl = options.physicsEnabled,
        physicsEnabled = _options$physicsEnabl === void 0 ? false : _options$physicsEnabl;
    _this.options = {
      close: close,
      far: far,
      position: position,
      jumpSpeed: jumpSpeed,
      speed: speed,
      slowDownFactor: slowDownFactor,
      sensitivity: sensitivity,
      mass: mass,
      height: height,
      target: target,
      physicsEnabled: physicsEnabled
    };
    _this.camera = camera;

    if (!target) {
      _this.camera.setPosition({
        x: _this.options.position.x,
        y: _this.options.position.y + _this.options.height,
        z: _this.options.position.z
      });
    } else {
      _this.camera.setPosition({
        x: 0,
        y: _this.options.height,
        z: 0
      });
    }

    _this.character = target;
    _this.domElement = domElement || document.body;
    _this.isLocked = false;
    _this.euler = new Euler(0, 0, 0, 'YXZ');
    _this.vector = new Vector3$1(); // downwards raycaster, 0 is close, 10 is far

    _this.raycaster = new Raycaster(new Vector3$1(), new Vector3$1(0, -1, 0), close, far);
    _this.headRaycaster = new Raycaster(new Vector3$1(), new Vector3$1(0, 1, 0), close, far);
    _this.movement = {};
    _this.movement.forward = false;
    _this.movement.backwards = false;
    _this.movement.left = false;
    _this.movement.right = false;
    _this.canJump = false;
    _this.velocity = new Vector3$1();
    _this.direction = new Vector3$1();
    return _this;
  }

  _createClass(FirstPersonControl, [{
    key: "init",
    value: function init() {
      document.addEventListener('click', this.onClick.bind(this), false);
      document.addEventListener('mousemove', this.onMouseMove.bind(this), false);
      document.addEventListener('keydown', this.onKeyDown.bind(this), false);
      document.addEventListener('keyup', this.onKeyUp.bind(this), false);
      document.addEventListener('pointerlockchange', this.onPointerlockChange.bind(this), false);
      document.addEventListener('pointerlockerror', this.onPointerlockError.bind(this), false);
    }
  }, {
    key: "dispose",
    value: function dispose() {
      document.removeEventListener('click', this.onClick, false);
      document.removeEventListener('mousemove', this.onMouseMove, false);
      document.removeEventListener('keydown', this.onKeyDown, false);
      document.removeEventListener('keyup', this.onKeyUp, false);
      document.removeEventListener('pointerlockchange', this.onPointerlockChange, false);
      document.removeEventListener('pointerlockerror', this.onPointerlockError, false);
      this.unlock();
    }
  }, {
    key: "getCharacter",
    value: function getCharacter() {
      // FirstPersonControl will either control a character or the camera.
      return this.character || this.camera;
    }
  }, {
    key: "onClick",
    value: function onClick() {
      if (!this.isLocked) {
        this.lock();
      }
    }
  }, {
    key: "onKeyDown",
    value: function onKeyDown(event) {
      switch (event.keyCode) {
        case 38: // up

        case 87:
          // w
          this.movement.forward = true;
          break;

        case 37: // left

        case 65:
          // a
          this.movement.left = true;
          break;

        case 40: // down

        case 83:
          // s
          this.movement.backwards = true;
          break;

        case 39: // right

        case 68:
          // d
          this.movement.right = true;
          break;

        case 32:
          // space
          if (this.canJump === true) this.velocity.y += this.options.jumpSpeed;
          this.canJump = false;
          break;
      }
    }
  }, {
    key: "onKeyUp",
    value: function onKeyUp(event) {
      switch (event.keyCode) {
        case 38: // up

        case 87:
          // w
          this.movement.forward = false;
          break;

        case 37: // left

        case 65:
          // a
          this.movement.left = false;
          break;

        case 40: // down

        case 83:
          // s
          this.movement.backwards = false;
          break;

        case 39: // right

        case 68:
          // d
          this.movement.right = false;
          break;
      }
    }
  }, {
    key: "onMouseMove",
    value: function onMouseMove(event) {
      if (!this.isLocked) return;
      var movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
      var movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;
      var quaternion = this.camera.getQuaternion();
      this.euler.setFromQuaternion(quaternion);
      this.euler.y -= movementX * this.options.sensitivity;
      this.euler.x -= movementY * this.options.sensitivity;
      this.euler.x = Math.max(-PI_2, Math.min(PI_2, this.euler.x));
      quaternion.setFromEuler(this.euler);
      this.camera.setQuaternion(quaternion);
      this.dispatchEvent(CHANGE_EVENT);
    }
  }, {
    key: "onPointerlockChange",
    value: function onPointerlockChange() {
      if (document.pointerLockElement === this.domElement) {
        this.dispatchEvent(LOCK_EVENT);
        this.isLocked = true;
      } else {
        this.dispatchEvent(UNLOCK_EVENT);
        this.isLocked = false;
      }
    }
  }, {
    key: "onPointerlockError",
    value: function onPointerlockError(e) {
      console.error('Unable to use Pointer Lock API', e);
    }
  }, {
    key: "moveForward",
    value: function moveForward(distance) {
      // move forward parallel to the xz-plane
      // assumes camera.up is y-up
      var body = this.getCharacter().getBody();
      this.vector.setFromMatrixColumn(body.matrix, 0);
      this.vector.crossVectors(body.up, this.vector);
      body.position.addScaledVector(this.vector, distance);
    }
  }, {
    key: "moveRight",
    value: function moveRight(distance) {
      var body = this.getCharacter().getBody();
      this.vector.setFromMatrixColumn(body.matrix, 0);
      body.position.addScaledVector(this.vector, distance);
    }
  }, {
    key: "moveUpAndDown",
    value: function moveUpAndDown(dt) {
      var position = this.getCharacter().getPosition();
      position.y += this.velocity.y * dt; // new behavior

      if (position.y < this.options.height) {
        this.velocity.y = 0;
        position.y = this.options.height;
        this.canJump = true;
      }

      this.getCharacter().setPosition(position);
    }
  }, {
    key: "lock",
    value: function lock() {
      this.domElement.requestPointerLock();
    }
  }, {
    key: "unlock",
    value: function unlock() {
      document.exitPointerLock();
    }
  }, {
    key: "sendBodyUpdate",
    value: function sendBodyUpdate() {
      var element = this.getCharacter();

      if (Physics$1.hasElement(element)) {
        var _this$camera$getQuate = this.camera.getQuaternion(),
            y = _this$camera$getQuate.y,
            w = _this$camera$getQuate.w;

        var cameraDirection = this.camera.getDirection();
        Physics$1.updateBodyState(element, {
          direction: this.direction,
          movement: this.movement,
          quaternion: {
            x: 0,
            y: y,
            z: 0,
            w: w
          },
          cameraDirection: cameraDirection
        });
      }
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (this.isLocked) {
        this.updateDirection();
        this.updateVelocity(dt);

        if (!this.hasPhysicsEnabled()) {
          this.updateVelocityForCollisions();
          this.moveRight(-this.velocity.x * dt);
          this.moveForward(-this.velocity.z * dt);
          this.moveUpAndDown(dt);
        } else {
          this.sendBodyUpdate();
        }
      }
    }
  }]);

  return FirstPersonControl;
}(EventDispatcher);var FlyControl = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(FlyControl, _EventDispatcher);

  var _super = _createSuper(FlyControl);

  function FlyControl(object, domElement) {
    var _this;

    _classCallCheck(this, FlyControl);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "init", function () {
      _this.domElement.addEventListener('contextmenu', _this.onContextMenu, false);

      _this.domElement.addEventListener('mousemove', _this.onMouseMove, false);

      _this.domElement.addEventListener('mousedown', _this.onMouseDown, false);

      _this.domElement.addEventListener('mouseup', _this.onMouseUp, false);

      window.addEventListener('keydown', _this.onKeyDown, false);
      window.addEventListener('keyup', _this.onKeyUp, false);

      _this.updateMovementVector();

      _this.updateRotationVector();
    });

    _defineProperty$1(_assertThisInitialized(_this), "dispose", function () {
      _this.domElement.removeEventListener('contextmenu', _this.onContextMenu, false);

      _this.domElement.removeEventListener('mousedown', _this.onMouseDown, false);

      _this.domElement.removeEventListener('mousemove', _this.onMoudeMove, false);

      _this.domElement.removeEventListener('mouseup', _this.onMouseUp, false);

      window.removeEventListener('keydown', _this.onKeyDown, false);
      window.removeEventListener('keyup', _this.onKeyUp, false);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onKeyDown", function (event) {
      if (event.altKey) {
        return;
      } //event.preventDefault();


      switch (event.keyCode) {
        case 16:
          /* shift */
          _this.movementSpeedMultiplier = .1;
          break;

        case 87:
          /*W*/
          _this.moveState.forward = 1;
          break;

        case 83:
          /*S*/
          _this.moveState.back = 1;
          break;

        case 65:
          /*A*/
          _this.moveState.left = 1;
          break;

        case 68:
          /*D*/
          _this.moveState.right = 1;
          break;

        case 82:
          /*R*/
          _this.moveState.up = 1;
          break;

        case 70:
          /*F*/
          _this.moveState.down = 1;
          break;

        case 38:
          /*up*/
          _this.moveState.pitchUp = 1;
          break;

        case 40:
          /*down*/
          _this.moveState.pitchDown = 1;
          break;

        case 37:
          /*left*/
          _this.moveState.yawLeft = 1;
          break;

        case 39:
          /*right*/
          _this.moveState.yawRight = 1;
          break;

        case 81:
          /*Q*/
          _this.moveState.rollLeft = 1;
          break;

        case 69:
          /*E*/
          _this.moveState.rollRight = 1;
          break;
      }

      _this.updateMovementVector();

      _this.updateRotationVector();
    });

    _defineProperty$1(_assertThisInitialized(_this), "onKeyUp", function (event) {
      switch (event.keyCode) {
        case 16:
          /* shift */
          _this.movementSpeedMultiplier = 1;
          break;

        case 87:
          /*W*/
          _this.moveState.forward = 0;
          break;

        case 83:
          /*S*/
          _this.moveState.back = 0;
          break;

        case 65:
          /*A*/
          _this.moveState.left = 0;
          break;

        case 68:
          /*D*/
          _this.moveState.right = 0;
          break;

        case 82:
          /*R*/
          _this.moveState.up = 0;
          break;

        case 70:
          /*F*/
          _this.moveState.down = 0;
          break;

        case 38:
          /*up*/
          _this.moveState.pitchUp = 0;
          break;

        case 40:
          /*down*/
          _this.moveState.pitchDown = 0;
          break;

        case 37:
          /*left*/
          _this.moveState.yawLeft = 0;
          break;

        case 39:
          /*right*/
          _this.moveState.yawRight = 0;
          break;

        case 81:
          /*Q*/
          _this.moveState.rollLeft = 0;
          break;

        case 69:
          /*E*/
          _this.moveState.rollRight = 0;
          break;
      }

      _this.updateMovementVector();

      _this.updateRotationVector();
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseDown", function (event) {
      if (_this.domElement !== document) {
        _this.domElement.focus();
      }

      event.preventDefault();
      event.stopPropagation();

      if (_this.dragToLook) {
        _this.mouseStatus++;
      } else {
        switch (event.button) {
          case 0:
            _this.moveState.forward = 1;
            break;

          case 2:
            _this.moveState.back = 1;
            break;
        }

        _this.updateMovementVector();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseMove", function (event) {
      if (!_this.dragToLook || _this.mouseStatus > 0) {
        var container = _this.getContainerDimensions();

        var halfWidth = container.size[0] / 2;
        var halfHeight = container.size[1] / 2;
        _this.moveState.yawLeft = -(event.pageX - container.offset[0] - halfWidth) / halfWidth;
        _this.moveState.pitchDown = (event.pageY - container.offset[1] - halfHeight) / halfHeight;

        _this.updateRotationVector();
      }
    });

    _defineProperty$1(_assertThisInitialized(_this), "onMouseUp", function (event) {
      event.preventDefault();
      event.stopPropagation();

      if (_this.dragToLook) {
        _this.mouseStatus--;
        _this.moveState.yawLeft = _this.moveState.pitchDown = 0;
      } else {
        switch (event.button) {
          case 0:
            _this.moveState.forward = 0;
            break;

          case 2:
            _this.moveState.back = 0;
            break;
        }

        _this.updateMovementVector();
      }

      _this.updateRotationVector();
    });

    _defineProperty$1(_assertThisInitialized(_this), "onContextMenu", function (event) {
      return event.preventDefault();
    });

    _defineProperty$1(_assertThisInitialized(_this), "update", function (delta) {
      var moveMult = delta * _this.movementSpeed;
      var rotMult = delta * _this.rollSpeed;

      _this.object.translateX(_this.moveVector.x * moveMult);

      _this.object.translateY(_this.moveVector.y * moveMult);

      _this.object.translateZ(_this.moveVector.z * moveMult);

      _this.tmpQuaternion.set(_this.rotationVector.x * rotMult, _this.rotationVector.y * rotMult, _this.rotationVector.z * rotMult, 1).normalize();

      _this.object.quaternion.multiply(_this.tmpQuaternion); // expose the rotation vector for convenience


      _this.object.rotation.setFromQuaternion(_this.object.quaternion, _this.object.rotation.order);
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateMovementVector", function () {
      var forward = _this.moveState.forward || _this.autoForward && !_this.moveState.back ? 1 : 0;
      _this.moveVector.x = -_this.moveState.left + _this.moveState.right;
      _this.moveVector.y = -_this.moveState.down + _this.moveState.up;
      _this.moveVector.z = -forward + _this.moveState.back;
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateRotationVector", function () {
      _this.rotationVector.x = -_this.moveState.pitchDown + _this.moveState.pitchUp;
      _this.rotationVector.y = -_this.moveState.yawRight + _this.moveState.yawLeft;
      _this.rotationVector.z = -_this.moveState.rollRight + _this.moveState.rollLeft;
    });

    _defineProperty$1(_assertThisInitialized(_this), "getContainerDimensions", function () {
      if (_this.domElement != document) {
        return {
          size: [_this.domElement.offsetWidth, _this.domElement.offsetHeight],
          offset: [_this.domElement.offsetLeft, _this.domElement.offsetTop]
        };
      } else {
        return {
          size: [window.innerWidth, window.innerHeight],
          offset: [0, 0]
        };
      }
    });

    _this.domElement = domElement || document;
    _this.object = object;
    if (domElement) _this.domElement.setAttribute('tabindex', -1); // API

    _this.movementSpeed = 100;
    _this.rollSpeed = Math.PI / 24;
    _this.dragToLook = true;
    _this.autoForward = true; // disable default target object behavior
    // internals

    _this.tmpQuaternion = new Quaternion();
    _this.mouseStatus = 0;
    _this.moveState = {
      up: 0,
      down: 0,
      left: 0,
      right: 0,
      forward: 0,
      back: 0,
      pitchUp: 0,
      pitchDown: 0,
      yawLeft: 0,
      yawRight: 0,
      rollLeft: 0,
      rollRight: 0
    };
    _this.moveVector = new Vector3$1(0, 0, 0);
    _this.rotationVector = new Vector3$1(0, 0, 0);
    return _this;
  }

  _createClass(FlyControl, [{
    key: "update",
    value: function update() {}
  }, {
    key: "physicsUpdate",
    value: function physicsUpdate() {}
  }]);

  return FlyControl;
}(EventDispatcher);var CONTROLS = {
  ORBIT: 'orbit',
  TRANSFORM: 'transform',
  FPS: 'fps',
  FLY: 'fly'
};
var AVAILABLE_CONTROLS = Object.keys(CONTROLS);
var EVENTS = {
  CHANGE: 'change',
  DRAGGING_CHANGE: 'dragging-changed'
};
var Controls = /*#__PURE__*/function () {
  function Controls() {
    var _this = this,
        _this$controls;

    _classCallCheck(this, Controls);

    _defineProperty$1(this, "disposeSingleControls", function (control) {
      if (_this.controls[control] && _this.controls[control].dispose) {
        _this.controls[control].dispose();

        delete _this.controls[control];
      }
    });

    this.controls = (_this$controls = {}, _defineProperty$1(_this$controls, CONTROLS.ORBIT, undefined), _defineProperty$1(_this$controls, CONTROLS.TRANSFORM, undefined), _defineProperty$1(_this$controls, CONTROLS.FPS, undefined), _defineProperty$1(_this$controls, CONTROLS.FLY, undefined), _this$controls);
  }

  _createClass(Controls, [{
    key: "disposePreviousControls",
    value: function disposePreviousControls() {
      var controls = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      controls.forEach(this.disposeSingleControls.bind(this));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      AVAILABLE_CONTROLS.forEach(this.disposeSingleControls.bind(this));
    }
  }, {
    key: "getControl",
    value: function getControl(control) {
      if (control && this.controls[control]) {
        return this.controls[control];
      }
    }
  }, {
    key: "onPhysicsUpdate",
    value: function onPhysicsUpdate(dt) {
      var _this2 = this;

      Object.keys(this.controls).forEach(function (control) {
        _this2.controls[control] && _this2.controls[control].physicsUpdate(dt);
      });
    }
  }, {
    key: "update",
    value: function update(dt) {
      var _this3 = this;

      Object.keys(this.controls).forEach(function (control) {
        _this3.controls[control] && _this3.controls[control].update(dt);
      });
    }
  }, {
    key: "setOrbitControl",
    value: function setOrbitControl() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$target = _ref.target,
          target = _ref$target === void 0 ? new Vector3$1() : _ref$target;

      this.disposePreviousControls([CONTROLS.FPS, CONTROLS.FLY]);
      this.controls[CONTROLS.ORBIT] = new Orbit(Scene$1.getCameraBody(), Scene$1.getDOMElement());
      this.controls[CONTROLS.ORBIT].init();
      this.controls[CONTROLS.ORBIT].setTarget(target);
      return this.controls[CONTROLS.ORBIT];
    }
  }, {
    key: "setTransformControl",
    value: function setTransformControl() {
      var _this4 = this;

      this.controls[CONTROLS.TRANSFORM] = new TransformControls(Scene$1.getCameraBody(), Scene$1.getDOMElement());
      this.controls[CONTROLS.TRANSFORM].init();
      this.controls[CONTROLS.TRANSFORM].addEventListener(EVENTS.CHANGE, Scene$1.render);
      this.controls[CONTROLS.TRANSFORM].addEventListener(EVENTS.DRAGGING_CHANGE, function (event) {
        if (_this4.controls[CONTROLS.ORBIT]) {
          _this4.controls[CONTROLS.ORBIT].enabled = !event.value;
        }
      });
      return this.controls.transform;
    }
  }, {
    key: "setFirstPersonControl",
    value: function setFirstPersonControl(options) {
      this.controls[CONTROLS.FPS] = new FirstPersonControl(Scene$1.getCamera(), Scene$1.getDOMElement(), options);
      this.controls[CONTROLS.FPS].init();
      return this.controls[CONTROLS.FPS];
    }
  }, {
    key: "setFlyControl",
    value: function setFlyControl() {
      this.controls[CONTROLS.FLY] = new FlyControl(Scene$1.getCameraBody(), Scene$1.getDOMElement());
      this.controls[CONTROLS.FLY].init();
      return this.controls[CONTROLS.FLY];
    }
  }]);

  return Controls;
}();
var Controls$1 = new Controls();var author = {
  name: 'Marco Stagni',
  email: 'mrc.stagni@gmail.com',
  website: 'http://mage.studio'
};
var Level = /*#__PURE__*/function (_EventDispatcher) {
  _inherits(Level, _EventDispatcher);

  var _super = _createSuper(Level);

  function Level(props) {
    var _this;

    _classCallCheck(this, Level);

    _this = _super.call(this);

    _defineProperty$1(_assertThisInitialized(_this), "onStateChange", function (state) {});

    _defineProperty$1(_assertThisInitialized(_this), "parseScene", function (_ref) {
      var _ref$elements = _ref.elements,
          elements = _ref$elements === void 0 ? [] : _ref$elements,
          _ref$models = _ref.models,
          models = _ref$models === void 0 ? [] : _ref$models,
          _ref$lights = _ref.lights,
          lights = _ref$lights === void 0 ? [] : _ref$lights;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        if (elements.length) {
          for (var i in models) {
            elements.push(models[i]);
          }

          MeshLoader$1.load(elements, options);
        }

        if (lights.length) {
          LightLoader$1.load(lights, options);
        }

        Scene$1.updateChildren();
        resolve();
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "getJSONUrl", function () {
      return null;
    });

    _defineProperty$1(_assertThisInitialized(_this), "loadScene", function () {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getJSONUrl();

      if (getWindow() && url) {
        return fetch$1(url).then(function (res) {
          return res.json();
        }).then(_this.parseScene).catch(function () {
          return Promise.resolve();
        });
      }

      return Promise.resolve();
    });

    _defineProperty$1(_assertThisInitialized(_this), "preload", function () {
      var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _this.getJSONUrl();
      return _this.loadScene(url);
    });

    _defineProperty$1(_assertThisInitialized(_this), "cancelNextAnimationFrame", function () {
      return cancelAnimationFrame(_this.requestAnimationFrameId);
    });

    _defineProperty$1(_assertThisInitialized(_this), "init", function () {
      Scene$1.create(_this.getName());
      Scene$1.createCamera(new Camera());
      Physics$1.init().then(function () {
        Particles$1.init();
        PostProcessing$1.init();
        Stats$1.init();

        _this.render();

        if (_this.onCreate instanceof Function) {
          _this.onCreate();
        } else {
          console.log(ONCREATE_NOT_AVAILABLE);
        }
      });
    });

    _defineProperty$1(_assertThisInitialized(_this), "dispose", function () {
      _this.onBeforeDispose();

      Physics$1.dispose();
      Audio$1.dispose();
      Particles$1.dispose();
      PostProcessing$1.dispose();
      Universe$1.bigfreeze();
      Scene$1.dispose();
      Controls$1.dispose();

      _this.cancelNextAnimationFrame();

      _this.onDispose();
    });

    _this.props = props;
    _this.name = _this.constructor.name;
    _this.debug = true;
    _this.inputListenersAreSet = false;
    _this.render = _this.render.bind(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Level, [{
    key: "getName",
    value: function getName() {
      return this.name;
    }
  }, {
    key: "prepareScene",
    value: function prepareScene() {}
  }, {
    key: "onCreate",
    value: function onCreate() {}
  }, {
    key: "onUpdate",
    value: function onUpdate() {}
  }, {
    key: "onBeforeDispose",
    value: function onBeforeDispose() {}
  }, {
    key: "onDispose",
    value: function onDispose() {}
  }, {
    key: "requestNextAnimationFrame",
    value: function requestNextAnimationFrame() {
      this.requestAnimationFrameId = requestNextFrame(this.render);
    }
  }, {
    key: "render",
    value: function render() {
      var dt = Scene$1.clock.getDelta();

      if (PostProcessing$1.isEnabled()) {
        PostProcessing$1.render(dt);
      } else {
        Scene$1.render(dt);
      }

      Particles$1.update(dt);
      this.onUpdate(dt);
      Scene$1.update(dt);
      Assets$1.update(dt);
      Stats$1.update(dt);
      Controls$1.update(dt);
      Input$1.update(dt);
      this.requestNextAnimationFrame();
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, Lights$1.toJSON()), Universe$1.toJSON());
    }
  }]);

  return Level;
}(EventDispatcher);var index=/*#__PURE__*/Object.freeze({__proto__:null,getState:getState,createStore:createStore,dispatch:dispatch$8});var CURRENT_SCENE_NAME = 'CURRENT_SCENE_NAME';
var STATE_SNAPSHOT = 'STATE_SNAPSHOT';
var TIMESTAMP = 'TIMESTAMP';
var CURRENT_SCENE_JSON = 'CURRENT_SCENE_JSON';
var CURRENT_PATH = 'CURRENT_PATH';
var Storage = /*#__PURE__*/function () {
  function Storage() {
    _classCallCheck(this, Storage);
  }

  _createClass(Storage, [{
    key: "save",
    value: function save() {
      if (Storage.isLocalStorageAvailable()) {
        try {
          var state = getState();
          var timestamp = +new Date();
          var currentScene = GameRunner$1.getCurrentLevel();
          var currentPath = GameRunner$1.getCurrentPath();
          var sceneJSON = currentScene.toJSON();
          var sceneName = currentScene.name;
          localStorage.setItem(TIMESTAMP, timestamp);
          localStorage.setItem(CURRENT_SCENE_NAME, sceneName);
          localStorage.setItem(STATE_SNAPSHOT, state);
          localStorage.setItem(CURRENT_PATH, currentPath);
          localStorage.setItem(CURRENT_SCENE_JSON, sceneJSON);
          return Promise.resolve({
            sceneName: sceneName,
            currentPath: currentPath,
            timestamp: timestamp
          });
        } catch (e) {
          return Promise.reject(e);
        }
      } else {
        return Promise.reject(LOCALSTORAGE_NOT_AVAILABLE);
      }
    }
  }, {
    key: "get",
    value: function get(id) {
      if (Storage.isLocalStorageAvailable()) {
        return localStorage.getItem(id);
      } else {
        return null;
      }
    }
  }, {
    key: "loadCurrentPath",
    value: function loadCurrentPath() {
      if (Storage.isLocalStorageAvailable()) {
        var currentPath = localStorage.getItem(CURRENT_PATH);
        return Promise.resolve(currentPath);
      } else {
        return Promise.reject(LOCALSTORAGE_NOT_AVAILABLE);
      }
    }
  }, {
    key: "loadState",
    value: function loadState() {
      if (Storage.isLocalStorageAvailable()) {
        var state = localStorage.getItem(STATE_SNAPSHOT);
        return Promise.resolve(JSON.parse(state));
      } else {
        return Promise.reject(LOCALSTORAGE_NOT_AVAILABLE);
      }
    }
  }, {
    key: "loadScene",
    value: function loadScene() {
      if (Storage.isLocalStorageAvailable()) {
        var scene = localStorage.getItem(CURRENT_SCENE_JSON);
        return Promise.resolve(JSON.parse(scene));
      } else {
        return Promise.reject(LOCALSTORAGE_NOT_AVAILABLE);
      }
    }
  }], [{
    key: "isLocalStorageAvailable",
    value: function isLocalStorageAvailable() {
      return window && window.localStorage && typeof window.localStorage.setItem === 'function' && typeof window.localStorage.getItem === 'function' && typeof window.localStorage.removeItem === 'function' && typeof window.localStorage.clear === 'function';
    }
  }]);

  return Storage;
}();
var storage = new Storage();var GameRunner = /*#__PURE__*/function () {
  function GameRunner() {
    var _this = this;

    _classCallCheck(this, GameRunner);

    _defineProperty$1(this, "createNewLevel", function (path, options) {
      var classname = _this.get(path);

      var levelConfig = _objectSpread2$1(_objectSpread2$1({}, options), {}, {
        path: path
      });

      var level = new classname(levelConfig);
      subscribe(level);
      return level;
    });

    _defineProperty$1(this, "disposeCurrentLevel", function () {
      unsubscribeAll();

      _this.running.dispose();
    });

    _defineProperty$1(this, "start", function (path) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve, reject) {
        var _options$loading = options.loading,
            loading = _options$loading === void 0 ? false : _options$loading;

        if (!_this.has(path)) {
          reject(PATH_NOT_FOUND);
        }

        if (_this.running) {
          _this.disposeCurrentLevel();
        }

        _this.setCurrentPath(path);

        _this.setCurrentLevel(_this.createNewLevel(path, options));

        if (loading) {
          storage.loadScene().then(_this.getCurrentLevel().parseScene).then(function () {
            _this.getCurrentLevel().prepareScene();

            _this.getCurrentLevel().init();

            resolve(_this.getCurrentLevel());
          });
        } else {
          Physics$1.waitForState(PHYSICS_STATES.READY).then(function () {
            _this.getCurrentLevel().preload().then(function () {
              _this.getCurrentLevel().prepareScene();

              _this.getCurrentLevel().init();

              resolve(_this.getCurrentLevel());
            }).catch(reject);
          });
        }
      });
    });

    this.store = {};
    this.running = null;
  }

  _createClass(GameRunner, [{
    key: "has",
    value: function has(path) {
      return Object.keys(this.store).includes(path);
    }
  }, {
    key: "get",
    value: function get(path) {
      return this.store[path];
    }
  }, {
    key: "getCurrentLevel",
    value: function getCurrentLevel() {
      return this.running;
    }
  }, {
    key: "setCurrentLevel",
    value: function setCurrentLevel(level) {
      this.running = level;
    }
  }, {
    key: "getCurrentPath",
    value: function getCurrentPath() {
      return this.currentPath;
    }
  }, {
    key: "setCurrentPath",
    value: function setCurrentPath(path) {
      this.currentPath = path;
    }
  }, {
    key: "register",
    value: function register(path, classname) {
      try {
        if (GameRunner.isValidClassname(classname)) {
          this.store[path] = classname;
        } else {
          this.store[path] = Level;
        }

        return true;
      } catch (e) {
        return false;
      }
    }
  }], [{
    key: "isValidClassname",
    value: function isValidClassname(classname) {
      return typeof classname === 'function';
    }
  }]);

  return GameRunner;
}();
var GameRunner$1 = new GameRunner();var networkChanged = function networkChanged(isOnline) {
  return {
    type: NETWORK_CHANGED,
    isOnline: isOnline
  };
};var ONLINE_EVENT = 'online';
var OFFLINE_EVENT = 'offline';

var handleOnline = function handleOnline() {
  return dispatch$8(networkChanged(true));
};

var handleOffline = function handleOffline() {
  return dispatch$8(networkChanged(false));
};

var listenToNetworkChanges = function listenToNetworkChanges() {
  window.addEventListener(ONLINE_EVENT, handleOnline);
  window.addEventListener(OFFLINE_EVENT, handleOffline);
};
var stopListeningToNetworkChanges = function stopListeningToNetworkChanges() {
  window.removeEventListener(ONLINE_EVENT, handleOnline);
  window.removeEventListener(OFFLINE_EVENT, handleOffline);
};var QUERY_PREFIX = '?';
var AMPERSAND = '&';
var EQUALS = '=';
var EMPTY = '';
var EMPTY_QUERY = {};
var toQueryString = function toQueryString() {
  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var keys = Object.keys(query);

  if (keys.length == 0) {
    return EMPTY;
  }

  var q = QUERY_PREFIX + keys.map(function (k) {
    return k + EQUALS + query[k] + AMPERSAND;
  }).join(EMPTY);
  return q.endsWith(AMPERSAND) ? q.substr(0, q.length - 1) : q;
};
var parseQuery = function parseQuery() {
  var queryString = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  return queryString.length > 1 ? queryString.replace(QUERY_PREFIX, EMPTY).split(AMPERSAND).map(function (couple) {
    var split = couple.split(EQUALS);
    return _defineProperty$1({}, split[0], split[1]);
  }).reduce(function (acc, param) {
    return _objectSpread2$1(_objectSpread2$1({}, acc), param);
  }, {}) : EMPTY_QUERY;
};var hasLocation = function hasLocation() {
  return window && window.location;
};
var getLocationHash = function getLocationHash() {
  return hasLocation() ? location.hash : HASH;
};
var setLocationHash = function setLocationHash() {
  var hash = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (hasLocation()) {
    location.hash = "".concat(hash).concat(options);
  }
};var Router = /*#__PURE__*/function () {
  function Router() {
    var _this = this;

    _classCallCheck(this, Router);

    _defineProperty$1(this, "setCurrentLevel", function (hash) {
      _this.currentLevel = hash;
      Assets$1.setCurrentLevel(_this.currentLevel);
    });

    _defineProperty$1(this, "getCurrentLevel", function () {
      return _this.currentLevel;
    });

    _defineProperty$1(this, "isValidRoute", function (route) {
      return _this.routes.includes(route);
    });

    _defineProperty$1(this, "handleHashChange", function () {
      requestLoadingScreen();

      _this.startLevel();
    });

    _defineProperty$1(this, "stop", function () {
      _this.removeGlobaWindowEventsListeners();

      unmount();
    });

    _defineProperty$1(this, "startLevel", function () {
      var _Router$extractHashAn = Router.extractHashAndQuery(),
          hash = _Router$extractHashAn.hash,
          query = _Router$extractHashAn.query;

      dispatchLocationPathChange(hash);

      if (_this.isValidRoute(hash)) {
        _this.setCurrentLevel(hash);

        return Assets$1.load(hash).then(function () {
          return GameRunner$1.start(hash, query);
        }).then(function (level) {
          removeLoadingScreen();
          return Promise.resolve(level);
        });
      } else {
        _this.goTo(ROOT, query, hash);

        return Promise.resolve(null);
      }
    });

    _defineProperty$1(this, "handleStartError", function (e) {
      if (e instanceof Array) {
        var features = e.map(function (_ref) {
          var name = _ref.name;
          return name;
        });
        console.error(FEATURE_NOT_SUPPORTED.concat(features));
      } else {
        console.error(e);
      }
    });

    this.routes = [];
    this.currentLevel = ROOT;
  }

  _createClass(Router, [{
    key: "on",
    value: function on(route, classname) {
      if (GameRunner$1.register(route, classname)) {
        this.routes.push(route);
      }
    }
  }, {
    key: "goTo",
    value: function goTo(path) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.getCurrentLevel();

      if (!Router.areRoutesIdentical(origin, path)) {
        setLocationHash(path, toQueryString(options));
      }
    }
  }, {
    key: "setGlobalWindowEventsListeners",
    value: function setGlobalWindowEventsListeners() {
      listenToNetworkChanges();
      window.addEventListener(HASH_CHANGE, this.handleHashChange, false);
      window.addEventListener(BEFORE_UNLOAD, this.stop);
    }
  }, {
    key: "removeGlobaWindowEventsListeners",
    value: function removeGlobaWindowEventsListeners() {
      stopListeningToNetworkChanges();
      window.removeEventListener(HASH_CHANGE, this.handleHashChange);
      window.removeEventListener(BEFORE_UNLOAD, this.stop);
    }
  }, {
    key: "start",
    value: function start(config, assets) {
      var _config$selector = config.selector,
          selector = _config$selector === void 0 ? DEFAULT_SELECTOR : _config$selector;

      var _Router$extractHashAn2 = Router.extractHashAndQuery(),
          hash = _Router$extractHashAn2.hash;

      if (!this.isValidRoute(hash)) {
        setLocationHash(ROOT);
      }

      this.setGlobalWindowEventsListeners();
      Config$1.setConfig(config);
      Config$1.setContainer(selector);
      requestLoadingScreen();
      mount();
      Features$1.setUpPolyfills();
      Assets$1.setAssets(assets);
      return Features$1.checkSupportedFeatures().then(function () {
        return Assets$1.load(hash);
      }).then(this.startLevel).catch(this.handleStartError);
    }
  }], [{
    key: "extractHashAndQuery",
    value: function extractHashAndQuery() {
      var _Router$cleanRoute$sp = Router.cleanRoute(getLocationHash()).split(QUERY_START),
          _Router$cleanRoute$sp2 = _slicedToArray(_Router$cleanRoute$sp, 2),
          hash = _Router$cleanRoute$sp2[0],
          query = _Router$cleanRoute$sp2[1];

      return {
        hash: hash,
        query: parseQuery(query)
      };
    }
  }, {
    key: "cleanRoute",
    value: function cleanRoute() {
      var route = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : HASH;

      if (!route.length) {
        return ROOT;
      }

      return route.split(HASH)[1];
    }
  }]);

  return Router;
}();

_defineProperty$1(Router, "areRoutesIdentical", function (routeA, routeB) {
  return routeA === routeB;
});

var Router$1 = new Router();var showLoadingScreen = function showLoadingScreen() {
  return {
    type: UI_LOADING_SCREEN,
    loadingScreenVisible: true
  };
};
var hideLoadingScreen = function hideLoadingScreen() {
  return {
    type: UI_LOADING_SCREEN,
    loadingScreenVisible: false
  };
};var locationPathChange = function locationPathChange(path) {
  return {
    type: LOCATION_PATH_CHANGE,
    path: path
  };
};var ROOT_ID = '#ui';

var createProps = function createProps() {
  return {
    level: Router$1.getCurrentLevel()
  };
};

var getUIContainer = function getUIContainer() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_ID;
  var rootElement = document.querySelector(id);

  if (!rootElement) {
    rootElement = createElementFromSelector(id);
    document.body.appendChild(rootElement);
  }

  return rootElement;
};
var requestLoadingScreen = function requestLoadingScreen() {
  return dispatch$8(showLoadingScreen());
};
var removeLoadingScreen = function removeLoadingScreen() {
  return dispatch$8(hideLoadingScreen());
};
var dispatchLocationPathChange = function dispatchLocationPathChange(path) {
  return dispatch$8(locationPathChange(path));
};
var mount = function mount() {
  var _Config$ui = Config$1.ui(),
      _Config$ui$root = _Config$ui.root,
      root = _Config$ui$root === void 0 ? BaseUI : _Config$ui$root,
      _Config$ui$enabled = _Config$ui.enabled,
      enabled = _Config$ui$enabled === void 0 ? true : _Config$ui$enabled;

  if (!enabled) return;
  var store = getStore();
  var uiElement = createElement(root, createProps());

  if (store) {
    render(createElement(Provider, {
      store: getStore(),
      children: uiElement
    }), getUIContainer());
  } else {
    render(uiElement, getUIContainer());
  }
};
var unmount = function unmount() {
  var id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ROOT_ID;
  var container = document.querySelector(id); // Rendering null will trigger unmount lifecycle hooks for whole vDOM tree and remove global event listeners.
  // https://github.com/infernojs/inferno#tear-down

  render(null, container); // removing the container as well

  removeElement(id);
};var _excluded$1 = ["Component", "format", "width", "height"];

var Label = /*#__PURE__*/function (_Element) {
  _inherits(Label, _Element);

  var _super = _createSuper(Label);

  function Label(_ref) {
    var _this;

    var Component = _ref.Component,
        _ref$format = _ref.format,
        format = _ref$format === void 0 ? 'png' : _ref$format,
        _width = _ref.width,
        _height = _ref.height,
        options = _objectWithoutProperties(_ref, _excluded$1);

    _classCallCheck(this, Label);

    _this = _super.call(this, options);

    _defineProperty$1(_assertThisInitialized(_this), "buildContainerId", function () {
      return "#".concat(_this.getName());
    });

    _defineProperty$1(_assertThisInitialized(_this), "createSprite", function (element) {
      return function (map) {
        var material = new SpriteMaterial({
          map: map
        });
        var offsetWidth = element.offsetWidth,
            offsetHeight = element.offsetHeight;
        var body = new Sprite$1(material);
        body.scale.x = _this.width || offsetHeight;
        body.scale.y = _this.height || offsetWidth;

        _this.setBody({
          body: body
        });

        _this.setEntityType(ENTITY_TYPES.LABEL);
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "onLabelUpdate", function (domElement) {
      return _this.convertToPng(domElement).then(_this.updateTexture(_this.getName(), domElement)).catch(console.log);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onLabelMount", function (domElement) {
      return _this.convertToPng(domElement).then(_this.updateTexture(_this.getName(), domElement)).then(_this.createSprite(domElement)).catch(console.log);
    });

    _defineProperty$1(_assertThisInitialized(_this), "onLabelUnmount", function () {
      return Images$1.disposeTexture(_this.getName());
    });

    _defineProperty$1(_assertThisInitialized(_this), "updateTexture", function (id, element) {
      return function (dataUrl) {
        var texture = Images$1.get(id);
        var width = element.offsetWidth,
            height = element.offsetHeight;

        if (!texture) {
          var image = new Image();
          texture = new Texture(image);
          Images$1.add(id, texture);
        }

        texture.image.src = dataUrl;
        texture.image.height = height;
        texture.image.width = width;
        texture.needsUpdate = true;
        return Promise.resolve(texture);
      };
    });

    _defineProperty$1(_assertThisInitialized(_this), "convertToPng", function (domElement) {
      return domElement ? toPng(domElement, {
        cacheBust: true
      }) : Promise.reject(LABEL_DOMELEMENT_MISSING);
    });

    var name = _this.options.name;
    _this.Component = Component;
    _this.format = format;
    _this.width = _width;
    _this.height = _height;

    _this.setName(name);

    _this.render(Component);

    return _this;
  }

  _createClass(Label, [{
    key: "render",
    value: function render$1(Component) {
      render(createElement(Component, _objectSpread2$1({
        onUpdate: this.onLabelUpdate,
        onMount: this.onLabelMount,
        onUnmount: this.onLabelUnmount
      }, this.options)), getUIContainer(this.buildContainerId()));
    }
  }, {
    key: "dispose",
    value: function dispose() {
      _get(_getPrototypeOf(Label.prototype), "dispose", this).call(this);

      unmount(this.buildContainerId());
    }
  }]);

  return Label;
}(Element$1);var Beat = /*#__PURE__*/function () {
  function Beat(name) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Beat);

    this.name = name;
    this.buffer = null;
    this.connected = false;
    this.playing = false;
    this.options = options;
    this.init();
    this.connect();
  }

  _createClass(Beat, [{
    key: "init",
    value: function init() {
      this.source = Audio$1.context.createBufferSource();
      this.createVolumeNode();
      this.setBuffer();
      this.source.addEventListener(AUDIO_EVENTS.ENDED, this.onSoundEnded.bind(this));
    }
  }, {
    key: "createVolumeNode",
    value: function createVolumeNode() {
      this.volumeNode = Audio$1.context.createGain();
      this.volumeNode.gain.value = 20;
    }
  }, {
    key: "connect",
    value: function connect() {
      if (this.connected) {
        this.disconnect();
      }

      this.volumeNode.connect(Audio$1.getMasterVolumeNode());
      this.source.connect(this.volumeNode);
      this.connected = true;
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      if (this.connected) {
        this.volumeNode.disconnect();
        this.source.disconnect();
        this.connected = false;
      }
    }
  }, {
    key: "reset",
    value: function reset() {
      this.playing = false;
      var reconnectOnReset = this.options.reconnectOnReset;
      this.disconnect();

      if (reconnectOnReset) {
        this.init();
        this.connect();
      }
    }
  }, {
    key: "dispose",
    value: function dispose() {
      this.stop();
      this.disconnect();
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this.volumeNode.gain.value;
    }
  }, {
    key: "setVolume",
    value: function setVolume(value) {
      this.volumeNode.gain.setValueAtTime(value, Audio$1.context.currentTime);
    }
  }, {
    key: "hasBuffer",
    value: function hasBuffer() {
      return !!this.buffer;
    }
  }, {
    key: "setBuffer",
    value: function setBuffer() {
      var buffer = Audio$1.get(this.name);

      if (!buffer) {
        console.error(AUDIO_UNABLE_TO_LOAD_SOUND);
        return;
      }

      this.buffer = buffer;
      this.source.buffer = buffer;
    }
  }, {
    key: "play",
    value: function play() {
      var volume = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.getVolume();
      var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;
      var ramp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AUDIO_RAMPS.LINEAR;
      if (this.playing) return;
      this.setVolume(0);
      this.source.start();
      this.playing = true;

      if (ramp === AUDIO_RAMPS.LINEAR) {
        this.volumeNode.gain.linearRampToValueAtTime(volume, Audio$1.context.currentTime + delay);
      } else {
        this.volumeNode.gain.exponentialRampToValueAtTime(volume, Audio$1.context.currentTime + delay);
      }
    }
  }, {
    key: "onSoundEnded",
    value: function onSoundEnded() {
      this.reset();
    }
  }, {
    key: "stop",
    value: function stop() {
      var _this = this;

      var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.1;
      var ramp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AUDIO_RAMPS.LINEAR;

      if (ramp === AUDIO_RAMPS.LINEAR) {
        this.volumeNode.gain.linearRampToValueAtTime(0, Audio$1.context.currentTime + delay);
      } else {
        this.volumeNode.gain.exponentialRampToValueAtTime(0, Audio$1.context.currentTime + delay);
      }

      setTimeout(function () {
        _this.source.stop();
      }, delay);
    }
  }, {
    key: "detune",
    value: function detune(value) {
      if (this.source) {
        this.source.detune.value = value;
      }
    }
  }]);

  return Beat;
}();var Sound$1 = /*#__PURE__*/function (_Beat) {
  _inherits(Sound, _Beat);

  var _super = _createSuper(Sound);

  function Sound(name) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Sound);

    var _options$loop = options.loop,
        loop = _options$loop === void 0 ? false : _options$loop,
        _options$autoplay = options.autoplay,
        autoplay = _options$autoplay === void 0 ? false : _options$autoplay,
        _options$reconnectOnR = options.reconnectOnReset,
        reconnectOnReset = _options$reconnectOnR === void 0 ? false : _options$reconnectOnR;
    _this = _super.call(this, name, {
      loop: loop,
      autoplay: autoplay,
      reconnectOnReset: reconnectOnReset
    });
    _this.source.loop = loop;
    _this.target = null;
    _this.pannerNode = null;
    _this.convolverNode = null;

    if (autoplay) {
      _this.play();
    }

    Audio$1.add(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Sound, [{
    key: "createPannerNode",
    value: function createPannerNode() {
      this.pannerNode = Audio$1.context.createPanner();
      this.volumeNode.disconnect();
      this.volumeNode.connect(this.pannerNode);
      this.pannerNode.connect(Audio$1.getMasterVolumeNode());
    }
  }, {
    key: "hasEffect",
    value: function hasEffect() {
      return !!this.convolverNode;
    }
  }, {
    key: "addEffect",
    value: function addEffect(effect) {
      if (!this.hasEffect() && effect) {
        this.convolverNode = Audio$1.context.createConvolver();
        this.mixerNode = Audio$1.createGain();

        if (this.hasPannerNode()) {
          this.pannerNode.disconnect();
          this.pannerNode.connect(this.mixerNode);
        } else {
          this.volumeNode.disconnect();
          this.volumeNode.connect(this.mixerNode);
        } //creating gains


        this.plainGainNode = Audio$1.context.createGain();
        this.convolverGainNode = Audio$1.context.createGain(); //connect mixer to new gains

        this.mixerNode.connect(this.plainGainNode);
        this.mixerNode.connect(this.convolverGainNode);
        this.plainGainNode.connect(Audio$1.getMasterVolumeNode());
        this.convolverGainNode.connect(Audio$1.getMasterVolumeNode());
        this.convolverNode.buffer = Audio$1.get(effect);
        this.convolverGainNode.gain.setValueAtTime(0.7, Audio$1.context.currentTime);
        this.plainGainNode.gain.setValueAtTime(0.3, Audio$1.context.currentTime);
      }
    }
  }, {
    key: "hasPannerNode",
    value: function hasPannerNode() {
      return !!this.pannerNode;
    }
  }, {
    key: "hasTarget",
    value: function hasTarget() {
      return !!this.target;
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      return this.target;
    }
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.target = target;
      this.createPannerNode();
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (this.hasTarget() && this.hasPannerNode()) {
        var p = new Vector3$1();
        p.setFromMatrixPosition(this.target.getBody().matrixWorld);
        var px = p.x,
            py = p.y,
            pz = p.z;
        this.target.getBody().updateMatrixWorld();
        var q = new Vector3$1();
        q.setFromMatrixPosition(this.target.getBody().matrixWorld);
        var dx = q.x - px,
            dy = q.y - py,
            dz = q.z - pz; //setting panner position and velocity using doppler effect.

        try {
          this.panner.setPosition(q.x, q.y, q.z);
          this.panner.setVelocity(dx / dt, dy / dt, dz / dt);
        } catch (e) {// quick and dirty solution.
        }
      }
    }
  }]);

  return Sound;
}(Beat);var BackgroundSound = /*#__PURE__*/function (_Sound) {
  _inherits(BackgroundSound, _Sound);

  var _super = _createSuper(BackgroundSound);

  function BackgroundSound() {
    _classCallCheck(this, BackgroundSound);

    return _super.apply(this, arguments);
  }

  _createClass(BackgroundSound, [{
    key: "update",
    value: function update(dt) {}
  }, {
    key: "createPannerNode",
    value: function createPannerNode() {
      console.log(METHOD_NOT_SUPPORTED);
    }
  }, {
    key: "hasPannerNode",
    value: function hasPannerNode() {
      console.log(METHOD_NOT_SUPPORTED);
    }
  }, {
    key: "hasTarget",
    value: function hasTarget() {
      console.log(METHOD_NOT_SUPPORTED);
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      console.log(METHOD_NOT_SUPPORTED);
    }
  }, {
    key: "setTarget",
    value: function setTarget() {
      console.log(METHOD_NOT_SUPPORTED);
    }
  }]);

  return BackgroundSound;
}(Sound$1);var DirectionalSound = /*#__PURE__*/function (_Sound) {
  _inherits(DirectionalSound, _Sound);

  var _super = _createSuper(DirectionalSound);

  function DirectionalSound(name, angles, options) {
    var _this;

    _classCallCheck(this, DirectionalSound);

    _this = _super.call(this, name);
    var target = options.target;

    if (target) {
      _this.setTarget(target);

      _this.setPannerAngles(angles);
    }

    return _this;
  }

  _createClass(DirectionalSound, [{
    key: "setPannerAngles",
    value: function setPannerAngles(angles) {
      this.pannerNode.coneInnerAngle = angles.innerAngleInDegrees;
      this.pannerNode.coneOuterAngle = angles.outerAngleInDegrees;
      this.pannerNode.coneOuterGain = angles.outerGainFactor;
    }
  }, {
    key: "setPannerOrientation",
    value: function setPannerOrientation() {
      if (this.hasPannerNode()) {
        var vec = new Vector3$1(0, 0, 1);
        var m = this.target.getBody().matrixWorld; // Save the translation column and zero it.

        var mx = m.elements[12],
            my = m.elements[13],
            mz = m.elements[14];
        m.elements[12] = m.elements[13] = m.elements[14] = 0; // Multiply the 0,0,1 vector by the world matrix and normalize the result.

        vec.applyProjection(m);
        vec.normalize();
        this.pannerNode.setOrientation(vec.x, vec.y, vec.z); // Restore the translation column.

        m.elements[12] = mx;
        m.elements[13] = my;
        m.elements[14] = mz;
      }
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(DirectionalSound.prototype), "update", this).call(this, dt);

      this.setPannerOrientation();
    }
  }]);

  return DirectionalSound;
}(Sound$1);var Sound = /*#__PURE__*/function (_Beat) {
  _inherits(Sound, _Beat);

  var _super = _createSuper(Sound);

  function Sound(name) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Sound);

    var _options$loop = options.loop,
        loop = _options$loop === void 0 ? false : _options$loop,
        _options$autoplay = options.autoplay,
        autoplay = _options$autoplay === void 0 ? false : _options$autoplay,
        _options$reconnectOnR = options.reconnectOnReset,
        reconnectOnReset = _options$reconnectOnR === void 0 ? false : _options$reconnectOnR;
    _this = _super.call(this, name, {
      loop: loop,
      autoplay: autoplay,
      reconnectOnReset: reconnectOnReset
    });
    _this.source.loop = loop;
    _this.target = null;
    _this.pannerNode = null;
    _this.convolverNode = null;

    if (autoplay) {
      _this.play();
    }

    Audio$1.add(_assertThisInitialized(_this));
    return _this;
  }

  _createClass(Sound, [{
    key: "createPannerNode",
    value: function createPannerNode() {
      this.pannerNode = Audio$1.context.createPanner();
      this.volumeNode.disconnect();
      this.volumeNode.connect(this.pannerNode);
      this.pannerNode.connect(Audio$1.getMasterVolumeNode());
    }
  }, {
    key: "hasEffect",
    value: function hasEffect() {
      return !!this.convolverNode;
    }
  }, {
    key: "addEffect",
    value: function addEffect(effect) {
      if (!this.hasEffect() && effect) {
        this.convolverNode = Audio$1.context.createConvolver();
        this.mixerNode = Audio$1.createGain();

        if (this.hasPannerNode()) {
          this.pannerNode.disconnect();
          this.pannerNode.connect(this.mixerNode);
        } else {
          this.volumeNode.disconnect();
          this.volumeNode.connect(this.mixerNode);
        } //creating gains


        this.plainGainNode = Audio$1.context.createGain();
        this.convolverGainNode = Audio$1.context.createGain(); //connect mixer to new gains

        this.mixerNode.connect(this.plainGainNode);
        this.mixerNode.connect(this.convolverGainNode);
        this.plainGainNode.connect(Audio$1.getMasterVolumeNode());
        this.convolverGainNode.connect(Audio$1.getMasterVolumeNode());
        this.convolverNode.buffer = Audio$1.get(effect);
        this.convolverGainNode.gain.setValueAtTime(0.7, Audio$1.context.currentTime);
        this.plainGainNode.gain.setValueAtTime(0.3, Audio$1.context.currentTime);
      }
    }
  }, {
    key: "hasPannerNode",
    value: function hasPannerNode() {
      return !!this.pannerNode;
    }
  }, {
    key: "hasTarget",
    value: function hasTarget() {
      return !!this.target;
    }
  }, {
    key: "getTarget",
    value: function getTarget() {
      return this.target;
    }
  }, {
    key: "setTarget",
    value: function setTarget(target) {
      this.target = target;
      this.createPannerNode();
    }
  }, {
    key: "update",
    value: function update(dt) {
      if (this.hasTarget() && this.hasPannerNode()) {
        var p = new Vector3$1();
        p.setFromMatrixPosition(this.target.getBody().matrixWorld);
        var px = p.x,
            py = p.y,
            pz = p.z;
        this.target.getBody().updateMatrixWorld();
        var q = new Vector3$1();
        q.setFromMatrixPosition(this.target.getBody().matrixWorld);
        var dx = q.x - px,
            dy = q.y - py,
            dz = q.z - pz; //setting panner position and velocity using doppler effect.

        try {
          this.panner.setPosition(q.x, q.y, q.z);
          this.panner.setVelocity(dx / dt, dy / dt, dz / dt);
        } catch (e) {// quick and dirty solution.
        }
      }
    }
  }]);

  return Sound;
}(Beat);var Color = /*#__PURE__*/function () {
  _createClass(Color, null, [{
    key: "randomColor",
    value: function randomColor() {
      var asNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var letters = '0123456789ABCDEF'.split('');
      var color = '';

      for (var i = 0; i < 6; i++) {
        color += letters[Math.floor(Math.random() * 16)];
      }

      return asNumber ? Number("0x".concat(color)) : "#".concat(color);
    }
  }, {
    key: "componentToHex",
    value: function componentToHex(c) {
      var hex = c.toString(16);
      return hex.length == 1 ? "0" + hex : hex;
    }
  }, {
    key: "gbToHex",
    value: function gbToHex(r, g, b) {
      return "0x" + Color.componentToHex(r) + Color.componentToHex(g) + Color.componentToHex(b);
    }
  }, {
    key: "getIntValueFromHex",
    value: function getIntValueFromHex(hex) {
      return parseInt(hex, 16);
    }
  }]);

  function Color(color) {
    _classCallCheck(this, Color);

    this.color = new Color$1(color);
  }

  _createClass(Color, [{
    key: "getColor",
    value: function getColor() {
      return this.color;
    }
  }]);

  return Color;
}();var BLOB_TYPE = 'application/javascript';
var createBlob = function createBlob(task) {
  return new Blob(['(', task.toString(), ')()'], {
    type: BLOB_TYPE
  });
};
var createWorker = function createWorker(task, message) {
  if (Features$1.isFeatureSupported(FEATURES.WEBWORKER)) {
    var url = URL.createObjectURL(createBlob(task));
    var worker = new Worker(url); // Won't be needing this anymore

    URL.revokeObjectURL(url);

    if (message) {
      worker.postMessage(message);
    }

    return worker;
  } else {
    console.error(WORKERS_NOT_AVAILABLE);
    return null;
  }
};
var createPromiseWorker = function createPromiseWorker(task, message) {
  return new Promise(function (resolve, reject) {
    var worker = createWorker(task, message);

    if (worker) {
      worker.onmessage = function (data) {
        resolve(data);
        worker.terminate();
      };
    } else {
      reject(WORKERS_NOT_AVAILABLE);
    }
  });
};var workers=/*#__PURE__*/Object.freeze({__proto__:null,createBlob:createBlob,createWorker:createWorker,createPromiseWorker:createPromiseWorker});var HIT_BOX_COLOR = 0xf368e0;
var HIT_BOX_INCREASE = .03;
var DEFAULT_HITBOX_OPTIONS = {
  shadowsEnabled: false
};
var getBoxHitbox = function getBoxHitbox(element) {
  var size = new Vector3$1();
  element.boundingBox.getSize(size);
  var scaledSize = {
    x: size.x + HIT_BOX_INCREASE,
    y: size.y + HIT_BOX_INCREASE,
    z: size.z + HIT_BOX_INCREASE
  };
  var box = new Box(scaledSize.x, scaledSize.y, scaledSize.z, HIT_BOX_COLOR, DEFAULT_HITBOX_OPTIONS); //box.setQuaternion(quaternion);

  box.setWireframe(true);
  box.setWireframeLineWidth(2);
  return box;
};
var getSphereHitbox = function getSphereHitbox(element) {
  var radius = element.boundingSphere.radius;
  var sphere = new Sphere(radius, HIT_BOX_COLOR, DEFAULT_HITBOX_OPTIONS);
  sphere.setWireframe(true);
  sphere.setWireframeLineWidth(2);
  return sphere;
};
var mapColliderTypeToHitbox = function mapColliderTypeToHitbox() {
  var _COLLIDER_TYPES$BOX$C;

  var colliderType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : COLLIDER_TYPES$1.BOX;
  return (_COLLIDER_TYPES$BOX$C = {}, _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.BOX, getBoxHitbox), _defineProperty$1(_COLLIDER_TYPES$BOX$C, COLLIDER_TYPES$1.SPHERE, getSphereHitbox), _COLLIDER_TYPES$BOX$C)[colliderType] || getBoxHitbox;
};
var addHitBox = function addHitBox(element) {
  var colliderType = element.getPhysicsOptions('colliderType');
  var getHitbox = mapColliderTypeToHitbox(colliderType);
  element.add(getHitbox(element));
};var hitbox=/*#__PURE__*/Object.freeze({__proto__:null,getBoxHitbox:getBoxHitbox,getSphereHitbox:getSphereHitbox,mapColliderTypeToHitbox:mapColliderTypeToHitbox,addHitBox:addHitBox});var LabelComponent = /*#__PURE__*/function (_Component) {
  _inherits(LabelComponent, _Component);

  var _super = _createSuper(LabelComponent);

  function LabelComponent(props) {
    var _this;

    _classCallCheck(this, LabelComponent);

    _this = _super.call(this, props);
    _this.element = createRef();
    return _this;
  }

  _createClass(LabelComponent, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.props.onUpdate(this.element.current);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      this.props.onMount(this.element.current);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.props.onUnmount(this.element.current);
    }
  }]);

  return LabelComponent;
}(Component$1);var DEFAULT_NEAR = 0.1;
var DEFAULT_FAR = 100;
var DEFAULT_POSITION = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_TARGET_POSITION = {
  x: 0,
  y: 0,
  z: 0
};
var DEFAULT_INTENSITY$1 = 0.5;
var DEFAULT_MAP_SIZE = 2048;
var DEFAULT_BIAS = -0.0001;
var WHITE = 0xffffff;
var GREEN$1 = 0x2ecc71;

var SpotLight = /*#__PURE__*/function (_Light) {
  _inherits(SpotLight, _Light);

  var _super = _createSuper(SpotLight);

  function SpotLight(options) {
    var _this;

    _classCallCheck(this, SpotLight);

    var _options$color = options.color,
        color = _options$color === void 0 ? WHITE : _options$color,
        _options$intensity = options.intensity,
        intensity = _options$intensity === void 0 ? DEFAULT_INTENSITY$1 : _options$intensity,
        _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('SpotLight') : _options$name;
    _this = _super.call(this, {
      color: color,
      intensity: intensity,
      name: name
    });
    _this.options = options;

    _this.setLight({
      color: color,
      intensity: intensity
    });

    _this.setEntityType(ENTITY_TYPES.LIGHT.SPOT);

    _this.setName(name);

    return _this;
  }

  _createClass(SpotLight, [{
    key: "getTargetMesh",
    value: function getTargetMesh(initialPosition) {
      var geometry = new SphereGeometry(3, 6, 6);
      var material = new MeshBasicMaterial({
        color: 0xeeeeee,
        wireframe: true
      });
      var target = new Element$1({
        geometry: geometry,
        material: material
      });
      target.position(initialPosition);
      return target;
    }
  }, {
    key: "setLight",
    value: function setLight(_ref) {
      var light = _ref.light,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? WHITE : _ref$color,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? DEFAULT_INTENSITY$1 : _ref$intensity;

      if (light) {
        this.setBody(light);
      } else {
        this.setBody(new SpotLight$1(color, intensity));
      }

      if (this.hasBody()) {
        this.postLightCreation();
      }
    }
  }, {
    key: "postLightCreation",
    value: function postLightCreation() {
      var _this$options = this.options,
          _this$options$positio = _this$options.position,
          position = _this$options$positio === void 0 ? DEFAULT_POSITION : _this$options$positio,
          _this$options$target = _this$options.target,
          target = _this$options$target === void 0 ? DEFAULT_TARGET_POSITION : _this$options$target;
      this.setPosition(position);
      this.setTargetPosition(target);
      this.setLightShadows();
      this.addToScene();
    }
  }, {
    key: "setLightShadows",
    value: function setLightShadows() {
      var _this$options2 = this.options,
          _this$options2$near = _this$options2.near,
          near = _this$options2$near === void 0 ? DEFAULT_NEAR : _this$options2$near,
          _this$options2$far = _this$options2.far,
          far = _this$options2$far === void 0 ? DEFAULT_FAR : _this$options2$far,
          _this$options2$mapSiz = _this$options2.mapSize,
          mapSize = _this$options2$mapSiz === void 0 ? DEFAULT_MAP_SIZE : _this$options2$mapSiz,
          _this$options2$bias = _this$options2.bias,
          bias = _this$options2$bias === void 0 ? DEFAULT_BIAS : _this$options2$bias;

      if (Config$1.lights().shadows) {
        this.body.castShadow = true;
        var d = far / 2;
        this.body.shadow.mapSize.height = mapSize;
        this.body.shadow.mapSize.width = mapSize;
        this.body.shadow.camera.left = -d;
        this.body.shadow.camera.right = d;
        this.body.shadow.camera.top = d;
        this.body.shadow.camera.bottom = -d;
        this.body.shadow.camera.near = near;
        this.body.shadow.camera.far = far;
        this.body.shadow.bias = bias;
      }
    }
  }, {
    key: "setTargetPosition",
    value: function setTargetPosition() {
      var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this.target = _objectSpread2$1(_objectSpread2$1({}, this.target), position);
      var _this$target = this.target,
          _this$target$x = _this$target.x,
          x = _this$target$x === void 0 ? 0 : _this$target$x,
          _this$target$y = _this$target.y,
          y = _this$target$y === void 0 ? 0 : _this$target$y,
          _this$target$z = _this$target.z,
          z = _this$target$z === void 0 ? 0 : _this$target$z;
      this.body.target.position.set(x, y, z);
    }
  }, {
    key: "getTargetPosition",
    value: function getTargetPosition() {
      return this.target;
    }
  }, {
    key: "addHelper",
    value: function addHelper() {
      this.helper = new SpotLightHelper(this.body, GREEN$1);
      this.shadowHelper = new CameraHelper(this.body.shadow.camera);
      Scene$1.add(this.helper, null, false);
      Scene$1.add(this.shadowHelper, null, false);
      this.addHolder();
    }
  }, {
    key: "hasTarget",
    value: function hasTarget() {
      return !!this.target;
    }
  }, {
    key: "update",
    value: function update(dt) {
      _get(_getPrototypeOf(SpotLight.prototype), "update", this).call(this, dt);

      if (this.hasHelper()) {
        this.helper.update();
        this.shadowHelper.update();
      }

      if (this.hasHolder()) {
        this.setPosition(this.holder.getPosition(), {
          updateHolder: false
        });
      }
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(SpotLight.prototype), "toJSON", this).call(this)), {}, {
        type: SPOTLIGHT
      });
    }
  }]);

  return SpotLight;
}(Light);var DEFAULT_INTENSITY = 0.5;
var DEFAULT_SKY_COLOR = 0xffffff;
var DEFAULT_GROUND_COLOR = 0x555555;
var GREEN = 0x2ecc71;

var HemisphereLight = /*#__PURE__*/function (_Light) {
  _inherits(HemisphereLight, _Light);

  var _super = _createSuper(HemisphereLight);

  function HemisphereLight() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, HemisphereLight);

    var _options$color = options.color,
        color = _options$color === void 0 ? {
      sky: DEFAULT_SKY_COLOR,
      ground: DEFAULT_GROUND_COLOR
    } : _options$color,
        _options$intensity = options.intensity,
        intensity = _options$intensity === void 0 ? DEFAULT_INTENSITY : _options$intensity,
        _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('HemisphereLight') : _options$name;
    _this = _super.call(this, {
      color: color,
      intensity: intensity,
      name: name
    });
    _this.options = options;

    _this.setLight({
      color: color,
      intensity: intensity
    });

    _this.setEntityType(ENTITY_TYPES.LIGHT.HEMISPHERE);

    _this.setName(name);

    return _this;
  }

  _createClass(HemisphereLight, [{
    key: "setLight",
    value: function setLight(_ref) {
      var light = _ref.light,
          _ref$color = _ref.color,
          color = _ref$color === void 0 ? {
        sky: DEFAULT_SKY_COLOR,
        ground: DEFAULT_GROUND_COLOR
      } : _ref$color,
          _ref$intensity = _ref.intensity,
          intensity = _ref$intensity === void 0 ? DEFAULT_INTENSITY : _ref$intensity;

      if (light) {
        this.setBody(light);
      } else {
        var _color$sky = color.sky,
            sky = _color$sky === void 0 ? DEFAULT_SKY_COLOR : _color$sky,
            _color$ground = color.ground,
            ground = _color$ground === void 0 ? DEFAULT_GROUND_COLOR : _color$ground;
        this.setBody(new HemisphereLight$1(sky, ground, intensity));
      }

      if (this.hasBody()) {
        this.addToScene();
      }
    }
  }, {
    key: "addHelper",
    value: function addHelper() {
      this.helper = new HemisphereLightHelper(this.body, 2, GREEN);
      Scene$1.add(this.helper, null, false);
    }
  }, {
    key: "toJSON",
    value: function toJSON() {
      return _objectSpread2$1(_objectSpread2$1({}, _get(_getPrototypeOf(HemisphereLight.prototype), "toJSON", this).call(this)), {}, {
        type: HEMISPHERELIGHT
      });
    }
  }]);

  return HemisphereLight;
}(Light);var Atmosphere = /*#__PURE__*/function () {
  function Atmosphere() {
    _classCallCheck(this, Atmosphere);

    this.options = {
      side: FrontSide,
      blending: AdditiveBlending,
      transparent: true,
      depthWrite: false
    };
    this.attributes = {};
  }

  _createClass(Atmosphere, null, [{
    key: "vertex",
    value: function vertex() {
      return ['varying vec3 vNormal;', 'void main(){', '	// compute intensity', '	vNormal		= normalize( normalMatrix * normal );', '	// set gl_Position', '	gl_Position	= projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n');
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['uniform float coeficient;', 'uniform float power;', 'uniform vec3  glowColor;', 'varying vec3  vNormal;', 'void main(){', '	float intensity	= pow( coeficient - dot(vNormal, vec3(0.0, 0.0, 1.0)), power );', '	gl_FragColor	= vec4( glowColor * intensity, 1.0 );', '}'].join('\n');
    }
  }, {
    key: "uniforms",
    value: function uniforms() {
      return {
        coeficient: {
          type: "f",
          value: 1.0
        },
        power: {
          type: "f",
          value: 2
        },
        glowColor: {
          type: "c",
          value: new Color$1('pink')
        }
      };
    }
  }]);

  return Atmosphere;
}();var Mirror = /*#__PURE__*/function (_Object3D) {
  _inherits(Mirror, _Object3D);

  var _super = _createSuper(Mirror);

  _createClass(Mirror, [{
    key: "mirroruniforms",
    value: function mirroruniforms() {
      return {
        "mirrorColor": {
          type: "c",
          value: new Color$1(0x7F7F7F)
        },
        "mirrorSampler": {
          type: "t",
          value: null
        },
        "textureMatrix": {
          type: "m4",
          value: new Matrix4()
        }
      };
    }
  }, {
    key: "mirrorvertex",
    value: function mirrorvertex() {
      return ["uniform mat4 textureMatrix;", "varying vec4 mirrorCoord;", "void main() {", "vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);", "vec4 worldPosition = modelMatrix * vec4(position, 1.0);", "mirrorCoord = textureMatrix * worldPosition;", "gl_Position = projectionMatrix * mvPosition;", "}"].join("\n");
    }
  }, {
    key: "mirrorfragment",
    value: function mirrorfragment() {
      return ["uniform vec3 mirrorColor;", "uniform sampler2D mirrorSampler;", "varying vec4 mirrorCoord;", "float blendOverlay(float base, float blend) {", "return(base < 0.5 ? (2.0 * base * blend) : (1.0 - 2.0 * (1.0 - base) * (1.0 - blend)));", "}", "void main() {", "vec4 color = texture2DProj(mirrorSampler, mirrorCoord);", "color = vec4(blendOverlay(mirrorColor.r, color.r), blendOverlay(mirrorColor.g, color.g), blendOverlay(mirrorColor.b, color.b), 1.0);", "gl_FragColor = color;", "}"].join("\n");
    }
  }]);

  function Mirror(renderer, camera, scene, options) {
    var _this;

    _classCallCheck(this, Mirror);

    _this = _super.call(this);
    _this.name = 'mirror_' + _this.id;
    options = options || {};
    _this.matrixNeedsUpdate = true;
    var width = options.textureWidth !== undefined ? options.textureWidth : 512;
    var height = options.textureHeight !== undefined ? options.textureHeight : 512;
    _this.clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;
    var mirrorColor = options.color !== undefined ? new Color$1(options.color) : new Color$1(0x7F7F7F);
    _this.renderer = renderer;
    _this.mirrorPlane = new Plane$1();
    _this.normal = new Vector3$1(0, 0, 1);
    _this.mirrorWorldPosition = new Vector3$1();
    _this.cameraWorldPosition = new Vector3$1();
    _this.rotationMatrix = new Matrix4();
    _this.lookAtPosition = new Vector3$1(0, 0, -1);
    _this.clipPlane = new Vector4(); // For debug only, show the normal and plane of the mirror

    var debugMode = options.debugMode !== undefined ? options.debugMode : false;

    if (debugMode) {
      // var arrow = new ArrowHelper(new Vector3(0, 0, 1), new Vector3(0, 0, 0), 10, 0xffff80);
      // var planeGeometry = new Geometry();
      // planeGeometry.vertices.push(new Vector3(- 10, - 10, 0));
      // planeGeometry.vertices.push(new Vector3(10, - 10, 0));
      // planeGeometry.vertices.push(new Vector3(10, 10, 0));
      // planeGeometry.vertices.push(new Vector3(- 10, 10, 0));
      // planeGeometry.vertices.push(planeGeometry.vertices[ 0 ]);
      // var plane = new Line(planeGeometry, new LineBasicMaterial({ color: 0xffff80 }));
      // this.add(arrow);
      // this.add(plane);
      console.log('[Mage] Mirror is trying to use deprecated geometry.');
    }

    if (camera instanceof PerspectiveCamera) {
      _this.camera = camera;
    } else {
      _this.camera = new PerspectiveCamera();
    }

    _this.textureMatrix = new Matrix4();
    _this.mirrorCamera = _this.camera.clone();
    _this.mirrorCamera.matrixAutoUpdate = true;
    var parameters = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      format: RGBFormat,
      stencilBuffer: false
    };
    _this.renderTarget = new WebGLRenderTarget(width, height, parameters);
    _this.renderTarget2 = new WebGLRenderTarget(width, height, parameters);
    _this.material = new ShaderMaterial({
      fragmentShader: _this.mirrorfragment(),
      vertexShader: _this.mirrorvertex(),
      uniforms: UniformsUtils.clone(_this.mirroruniforms())
    });
    _this.material.uniforms.mirrorSampler.value = _this.renderTarget.texture;
    _this.material.uniforms.mirrorColor.value = mirrorColor;
    _this.material.uniforms.textureMatrix.value = _this.textureMatrix;

    if (!MathUtils.isPowerOfTwo(width) || !MathUtils.isPowerOfTwo(height)) {
      _this.renderTarget.texture.generateMipmaps = false;
      _this.renderTarget2.texture.generateMipmaps = false;
    }

    _this.updateTextureMatrix();

    _this.render();

    return _this;
  }

  _createClass(Mirror, [{
    key: "renderWithMirror",
    value: function renderWithMirror(otherMirror) {
      // update the mirror matrix to mirror the current view
      this.updateTextureMatrix();
      this.matrixNeedsUpdate = false; // set the camera of the other mirror so the mirrored view is the reference view

      var tempCamera = otherMirror.camera;
      otherMirror.camera = this.mirrorCamera; // render the other mirror in temp texture

      otherMirror.renderTemp();
      otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget2.texture; // render the current mirror

      this.render();
      this.matrixNeedsUpdate = true; // restore material and camera of other mirror

      otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget.texture;
      otherMirror.camera = tempCamera; // restore texture matrix of other mirror

      otherMirror.updateTextureMatrix();
    }
  }, {
    key: "renderWithMirror",
    value: function renderWithMirror(otherMirror) {
      // update the mirror matrix to mirror the current view
      this.updateTextureMatrix();
      this.matrixNeedsUpdate = false; // set the camera of the other mirror so the mirrored view is the reference view

      var tempCamera = otherMirror.camera;
      otherMirror.camera = this.mirrorCamera; // render the other mirror in temp texture

      otherMirror.renderTemp();
      otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget2.texture; // render the current mirror

      this.render();
      this.matrixNeedsUpdate = true; // restore material and camera of other mirror

      otherMirror.material.uniforms.mirrorSampler.value = otherMirror.renderTarget.texture;
      otherMirror.camera = tempCamera; // restore texture matrix of other mirror

      otherMirror.updateTextureMatrix();
    }
  }, {
    key: "updateTextureMatrix",
    value: function updateTextureMatrix() {
      this.updateMatrixWorld();
      this.camera.updateMatrixWorld();
      this.mirrorWorldPosition.setFromMatrixPosition(this.matrixWorld);
      this.cameraWorldPosition.setFromMatrixPosition(this.camera.matrixWorld);
      this.rotationMatrix.extractRotation(this.matrixWorld);
      this.normal.set(0, 0, 1);
      this.normal.applyMatrix4(this.rotationMatrix);
      var view = this.mirrorWorldPosition.clone().sub(this.cameraWorldPosition);
      view.reflect(this.normal).negate();
      view.add(this.mirrorWorldPosition);
      this.rotationMatrix.extractRotation(this.camera.matrixWorld);
      this.lookAtPosition.set(0, 0, -1);
      this.lookAtPosition.applyMatrix4(this.rotationMatrix);
      this.lookAtPosition.add(this.cameraWorldPosition);
      var target = this.mirrorWorldPosition.clone().sub(this.lookAtPosition);
      target.reflect(this.normal).negate();
      target.add(this.mirrorWorldPosition);
      this.up.set(0, -1, 0);
      this.up.applyMatrix4(this.rotationMatrix);
      this.up.reflect(this.normal).negate();
      this.mirrorCamera.position.copy(view);
      this.mirrorCamera.up = this.up;
      this.mirrorCamera.lookAt(target);
      this.mirrorCamera.updateProjectionMatrix();
      this.mirrorCamera.updateMatrixWorld();
      this.mirrorCamera.matrixWorldInverse.getInverse(this.mirrorCamera.matrixWorld); // Update the texture matrix

      this.textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
      this.textureMatrix.multiply(this.mirrorCamera.projectionMatrix);
      this.textureMatrix.multiply(this.mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
      // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

      this.mirrorPlane.setFromNormalAndCoplanarPoint(this.normal, this.mirrorWorldPosition);
      this.mirrorPlane.applyMatrix4(this.mirrorCamera.matrixWorldInverse);
      this.clipPlane.set(this.mirrorPlane.normal.x, this.mirrorPlane.normal.y, this.mirrorPlane.normal.z, this.mirrorPlane.constant);
      var q = new Vector4();
      var projectionMatrix = this.mirrorCamera.projectionMatrix;
      q.x = (window.Math.sign(this.clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
      q.y = (window.Math.sign(this.clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
      q.z = -1.0;
      q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

      var c = new Vector4();
      c = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q)); // Replacing the third row of the projection matrix

      projectionMatrix.elements[2] = c.x;
      projectionMatrix.elements[6] = c.y;
      projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;
      projectionMatrix.elements[14] = c.w;
    }
  }, {
    key: "render",
    value: function render() {
      if (this.matrixNeedsUpdate) this.updateTextureMatrix();
      this.matrixNeedsUpdate = true; // Render the mirrored view of the current scene into the target texture

      var scene = this;

      while (scene.parent !== null) {
        scene = scene.parent;
      }

      if (scene !== undefined && scene instanceof Scene$2) {
        // We can't render ourself to ourself
        var visible = this.material.visible;
        this.material.visible = false;
        this.renderer.render(scene, this.mirrorCamera, this.renderTarget, true);
        this.material.visible = visible;
      }
    }
  }]);

  return Mirror;
}(Object3D);var OceanMain = /*#__PURE__*/function () {
  function OceanMain() {
    _classCallCheck(this, OceanMain);
  }

  _createClass(OceanMain, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_displacementMap": {
          type: "t",
          value: null
        },
        "u_normalMap": {
          type: "t",
          value: null
        },
        "u_geometrySize": {
          type: "f",
          value: null
        },
        "u_size": {
          type: "f",
          value: null
        },
        "u_projectionMatrix": {
          type: "m4",
          value: null
        },
        "u_viewMatrix": {
          type: "m4",
          value: null
        },
        "u_cameraPosition": {
          type: "v3",
          value: null
        },
        "u_skyColor": {
          type: "v3",
          value: null
        },
        "u_oceanColor": {
          type: "v3",
          value: null
        },
        "u_sunDirection": {
          type: "v3",
          value: null
        },
        "u_exposure": {
          type: "f",
          value: null
        }
      };
    }
  }, {
    key: "varying",
    value: function varying() {
      return {
        "vPos": {
          type: "v3"
        },
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "vertex",
    value: function vertex() {
      return ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform mat4 u_projectionMatrix;', 'uniform mat4 u_viewMatrix;', 'uniform float u_size;', 'uniform float u_geometrySize;', 'uniform sampler2D u_displacementMap;', 'void main (void) {', 'vec3 newPos = position + texture2D(u_displacementMap, uv).rgb * (u_geometrySize / u_size);', 'vPos = newPos;', 'vUV = uv;', 'gl_Position = u_projectionMatrix * u_viewMatrix * vec4(newPos, 1.0);', '}'].join('\n');
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['precision highp float;', 'varying vec3 vPos;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform sampler2D u_normalMap;', 'uniform vec3 u_cameraPosition;', 'uniform vec3 u_oceanColor;', 'uniform vec3 u_skyColor;', 'uniform vec3 u_sunDirection;', 'uniform float u_exposure;', 'vec3 hdr (vec3 color, float exposure) {', 'return 1.0 - exp(-color * exposure);', '}', 'void main (void) {', 'vec3 normal = texture2D(u_normalMap, vUV).rgb;', 'vec3 view = normalize(u_cameraPosition - vPos);', 'float fresnel = 0.02 + 0.98 * pow(1.0 - dot(normal, view), 5.0);', 'vec3 sky = fresnel * u_skyColor;', 'float diffuse = clamp(dot(normal, normalize(u_sunDirection)), 0.0, 1.0);', 'vec3 water = (1.0 - fresnel) * u_oceanColor * u_skyColor * diffuse;', 'vec3 color = sky + water;', 'gl_FragColor = vec4(hdr(color, u_exposure), 1.0);', '}'].join('\n');
    }
  }]);

  return OceanMain;
}();
var OceanNormals = /*#__PURE__*/function () {
  function OceanNormals() {
    _classCallCheck(this, OceanNormals);
  }

  _createClass(OceanNormals, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_displacementMap": {
          type: "t",
          value: null
        },
        "u_resolution": {
          type: "f",
          value: null
        },
        "u_size": {
          type: "f",
          value: null
        }
      };
    }
  }, {
    key: "varying",
    value: function varying() {
      return {
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['precision highp float;', 'varying vec2 vUV;', 'uniform sampler2D u_displacementMap;', 'uniform float u_resolution;', 'uniform float u_size;', 'void main (void) {', 'float texel = 1.0 / u_resolution;', 'float texelSize = u_size / u_resolution;', 'vec3 center = texture2D(u_displacementMap, vUV).rgb;', 'vec3 right = vec3(texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(texel, 0.0)).rgb - center;', 'vec3 left = vec3(-texelSize, 0.0, 0.0) + texture2D(u_displacementMap, vUV + vec2(-texel, 0.0)).rgb - center;', 'vec3 top = vec3(0.0, 0.0, -texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, -texel)).rgb - center;', 'vec3 bottom = vec3(0.0, 0.0, texelSize) + texture2D(u_displacementMap, vUV + vec2(0.0, texel)).rgb - center;', 'vec3 topRight = cross(right, top);', 'vec3 topLeft = cross(top, left);', 'vec3 bottomLeft = cross(left, bottom);', 'vec3 bottomRight = cross(bottom, right);', 'gl_FragColor = vec4(normalize(topRight + topLeft + bottomLeft + bottomRight), 1.0);', '}'].join('\n');
    }
  }]);

  return OceanNormals;
}();
var OceanSpectrum = /*#__PURE__*/function () {
  function OceanSpectrum() {
    _classCallCheck(this, OceanSpectrum);
  }

  _createClass(OceanSpectrum, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_size": {
          type: "f",
          value: null
        },
        "u_resolution": {
          type: "f",
          value: null
        },
        "u_choppiness": {
          type: "f",
          value: null
        },
        "u_phases": {
          type: "t",
          value: null
        },
        "u_initialSpectrum": {
          type: "t",
          value: null
        }
      };
    }
  }, {
    key: "varying",
    value: function varying() {
      return {
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform float u_size;', 'uniform float u_resolution;', 'uniform float u_choppiness;', 'uniform sampler2D u_phases;', 'uniform sampler2D u_initialSpectrum;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'vec2 multiplyByI (vec2 z) {', 'return vec2(-z[1], z[0]);', '}', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'vec2 phaseVector = vec2(cos(phase), sin(phase));', 'vec2 h0 = texture2D(u_initialSpectrum, vUV).rg;', 'vec2 h0Star = texture2D(u_initialSpectrum, vec2(1.0 - vUV + 1.0 / u_resolution)).rg;', 'h0Star.y *= -1.0;', 'vec2 h = multiplyComplex(h0, phaseVector) + multiplyComplex(h0Star, vec2(phaseVector.x, -phaseVector.y));', 'vec2 hX = -multiplyByI(h * (waveVector.x / length(waveVector))) * u_choppiness;', 'vec2 hZ = -multiplyByI(h * (waveVector.y / length(waveVector))) * u_choppiness;', //no DC term
      'if (waveVector.x == 0.0 && waveVector.y == 0.0) {', 'h = vec2(0.0);', 'hX = vec2(0.0);', 'hZ = vec2(0.0);', '}', 'gl_FragColor = vec4(hX + multiplyByI(h), hZ);', '}'].join('\n');
    }
  }]);

  return OceanSpectrum;
}();
var OceanPhase = /*#__PURE__*/function () {
  function OceanPhase() {
    _classCallCheck(this, OceanPhase);
  }

  _createClass(OceanPhase, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_phases": {
          type: "t",
          value: null
        },
        "u_deltaTime": {
          type: "f",
          value: null
        },
        "u_resolution": {
          type: "f",
          value: null
        },
        "u_size": {
          type: "f",
          value: null
        }
      };
    }
  }, {
    key: "varying",
    value: function varying() {
      return {
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'varying vec2 vUV;', 'uniform sampler2D u_phases;', 'uniform float u_deltaTime;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + k * k / KM * KM));', '}', 'void main (void) {', 'float deltaTime = 1.0 / 60.0;', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 waveVector = (2.0 * PI * vec2(n, m)) / u_size;', 'float phase = texture2D(u_phases, vUV).r;', 'float deltaPhase = omega(length(waveVector)) * u_deltaTime;', 'phase = mod(phase + deltaPhase, 2.0 * PI);', 'gl_FragColor = vec4(phase, 0.0, 0.0, 0.0);', '}'].join('\n');
    }
  }]);

  return OceanPhase;
}();
var OceanInitialSpectrum = /*#__PURE__*/function () {
  function OceanInitialSpectrum() {
    _classCallCheck(this, OceanInitialSpectrum);
  }

  _createClass(OceanInitialSpectrum, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_wind": {
          type: "v2",
          value: new Vector2(10.0, 10.0)
        },
        "u_resolution": {
          type: "f",
          value: 512.0
        },
        "u_size": {
          type: "f",
          value: 250.0
        }
      };
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return ['precision highp float;', '#include <common>', 'const float G = 9.81;', 'const float KM = 370.0;', 'const float CM = 0.23;', 'uniform vec2 u_wind;', 'uniform float u_resolution;', 'uniform float u_size;', 'float omega (float k) {', 'return sqrt(G * k * (1.0 + pow2(k / KM)));', '}', 'float tanh (float x) {', 'return (1.0 - exp(-2.0 * x)) / (1.0 + exp(-2.0 * x));', '}', 'void main (void) {', 'vec2 coordinates = gl_FragCoord.xy - 0.5;', 'float n = (coordinates.x < u_resolution * 0.5) ? coordinates.x : coordinates.x - u_resolution;', 'float m = (coordinates.y < u_resolution * 0.5) ? coordinates.y : coordinates.y - u_resolution;', 'vec2 K = (2.0 * PI * vec2(n, m)) / u_size;', 'float k = length(K);', 'float l_wind = length(u_wind);', 'float Omega = 0.84;', 'float kp = G * pow2(Omega / l_wind);', 'float c = omega(k) / k;', 'float cp = omega(kp) / kp;', 'float Lpm = exp(-1.25 * pow2(kp / k));', 'float gamma = 1.7;', 'float sigma = 0.08 * (1.0 + 4.0 * pow(Omega, -3.0));', 'float Gamma = exp(-pow2(sqrt(k / kp) - 1.0) / 2.0 * pow2(sigma));', 'float Jp = pow(gamma, Gamma);', 'float Fp = Lpm * Jp * exp(-Omega / sqrt(10.0) * (sqrt(k / kp) - 1.0));', 'float alphap = 0.006 * sqrt(Omega);', 'float Bl = 0.5 * alphap * cp / c * Fp;', 'float z0 = 0.000037 * pow2(l_wind) / G * pow(l_wind / cp, 0.9);', 'float uStar = 0.41 * l_wind / log(10.0 / z0);', 'float alpham = 0.01 * ((uStar < CM) ? (1.0 + log(uStar / CM)) : (1.0 + 3.0 * log(uStar / CM)));', 'float Fm = exp(-0.25 * pow2(k / KM - 1.0));', 'float Bh = 0.5 * alpham * CM / c * Fm * Lpm;', 'float a0 = log(2.0) / 4.0;', 'float am = 0.13 * uStar / CM;', 'float Delta = tanh(a0 + 4.0 * pow(c / cp, 2.5) + am * pow(CM / c, 2.5));', 'float cosPhi = dot(normalize(u_wind), normalize(K));', 'float S = (1.0 / (2.0 * PI)) * pow(k, -4.0) * (Bl + Bh) * (1.0 + Delta * (2.0 * cosPhi * cosPhi - 1.0));', 'float dk = 2.0 * PI / u_size;', 'float h = sqrt(S / 2.0) * dk;', 'if (K.x == 0.0 && K.y == 0.0) {', 'h = 0.0;', //no DC term
      '}', 'gl_FragColor = vec4(h, 0.0, 0.0, 0.0);', '}'].join('\n');
    }
  }]);

  return OceanInitialSpectrum;
}();
var OceanSubTransform = /*#__PURE__*/function () {
  function OceanSubTransform() {
    _classCallCheck(this, OceanSubTransform);
  }

  _createClass(OceanSubTransform, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        "u_input": {
          type: "t",
          value: null
        },
        "u_transformSize": {
          type: "f",
          value: 512.0
        },
        "u_subtransformSize": {
          type: "f",
          value: 250.0
        }
      };
    }
  }, {
    key: "varying",
    value: function varying() {
      return {
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "fragment",
    value: function fragment() {
      return [//GPU FFT using a Stockham formulation
      'precision highp float;', '#include <common>', 'uniform sampler2D u_input;', 'uniform float u_transformSize;', 'uniform float u_subtransformSize;', 'varying vec2 vUV;', 'vec2 multiplyComplex (vec2 a, vec2 b) {', 'return vec2(a[0] * b[0] - a[1] * b[1], a[1] * b[0] + a[0] * b[1]);', '}', 'void main (void) {', '#ifdef HORIZONTAL', 'float index = vUV.x * u_transformSize - 0.5;', '#else', 'float index = vUV.y * u_transformSize - 0.5;', '#endif', 'float evenIndex = floor(index / u_subtransformSize) * (u_subtransformSize * 0.5) + mod(index, u_subtransformSize * 0.5);', //transform two complex sequences simultaneously
      '#ifdef HORIZONTAL', 'vec4 even = texture2D(u_input, vec2(evenIndex + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(evenIndex + u_transformSize * 0.5 + 0.5, gl_FragCoord.y) / u_transformSize).rgba;', '#else', 'vec4 even = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + 0.5) / u_transformSize).rgba;', 'vec4 odd = texture2D(u_input, vec2(gl_FragCoord.x, evenIndex + u_transformSize * 0.5 + 0.5) / u_transformSize).rgba;', '#endif', 'float twiddleArgument = -2.0 * PI * (index / u_subtransformSize);', 'vec2 twiddle = vec2(cos(twiddleArgument), sin(twiddleArgument));', 'vec2 outputA = even.xy + multiplyComplex(twiddle, odd.xy);', 'vec2 outputB = even.zw + multiplyComplex(twiddle, odd.zw);', 'gl_FragColor = vec4(outputA, outputB);', '}'].join('\n');
    }
  }]);

  return OceanSubTransform;
}();
var OceanSimVertex = /*#__PURE__*/function () {
  function OceanSimVertex() {
    _classCallCheck(this, OceanSimVertex);
  }

  _createClass(OceanSimVertex, null, [{
    key: "varying",
    value: function varying() {
      return {
        "vUV": {
          type: "v2"
        }
      };
    }
  }, {
    key: "vertex",
    value: function vertex() {
      return ['varying vec2 vUV;', 'void main (void) {', 'vUV = position.xy * 0.5 + 0.5;', 'gl_Position = vec4(position, 1.0 );', '}'].join('\n');
    }
  }]);

  return OceanSimVertex;
}();
var OceanShaders = {};var OceanShader = /*#__PURE__*/function () {
  function OceanShader(renderer, camera, scene, options) {
    _classCallCheck(this, OceanShader);

    // flag used to trigger parameter changes
    this.changed = true;
    this.initial = true; // Assign required parameters as object properties

    this.oceanCamera = new OrthographicCamera(); //camera.clone();

    this.oceanCamera.position.z = 1;
    this.renderer = renderer;
    this.renderer.clearColor(0xffffff);
    this.scene = new Scene$2(); // Assign optional parameters as variables and object properties

    function optionalParameter(value, defaultValue) {
      return value !== undefined ? value : defaultValue;
    }

    options = options || {};
    this.clearColor = optionalParameter(options.CLEAR_COLOR, [1.0, 1.0, 1.0, 0.0]);
    this.geometryOrigin = optionalParameter(options.GEOMETRY_ORIGIN, [-1000.0, -1000.0]);
    this.sunDirectionX = optionalParameter(options.SUN_DIRECTION[0], -1.0);
    this.sunDirectionY = optionalParameter(options.SUN_DIRECTION[1], 1.0);
    this.sunDirectionZ = optionalParameter(options.SUN_DIRECTION[2], 1.0);
    this.oceanColor = optionalParameter(options.OCEAN_COLOR, new Vector3(0.004, 0.016, 0.047));
    this.skyColor = optionalParameter(options.SKY_COLOR, new Vector3(3.2, 9.6, 12.8));
    this.exposure = optionalParameter(options.EXPOSURE, 0.35);
    this.geometryResolution = optionalParameter(options.GEOMETRY_RESOLUTION, 32);
    this.geometrySize = optionalParameter(options.GEOMETRY_SIZE, 2000);
    this.resolution = optionalParameter(options.RESOLUTION, 64);
    this.floatSize = optionalParameter(options.SIZE_OF_FLOAT, 4);
    this.windX = optionalParameter(options.INITIAL_WIND[0], 10.0), this.windY = optionalParameter(options.INITIAL_WIND[1], 10.0), this.size = optionalParameter(options.INITIAL_SIZE, 250.0), this.choppiness = optionalParameter(options.INITIAL_CHOPPINESS, 1.5); //

    this.matrixNeedsUpdate = false; // Setup framebuffer pipeline

    var renderTargetType = optionalParameter(options.USE_HALF_FLOAT, false) ? HalfFloatType : THREE.FloatType;
    var LinearClampParams = {
      minFilter: LinearFilter,
      magFilter: LinearFilter,
      wrapS: ClampToEdgeWrapping,
      wrapT: ClampToEdgeWrapping,
      format: RGBAFormat,
      stencilBuffer: false,
      depthBuffer: false,
      premultiplyAlpha: false,
      type: renderTargetType
    };
    var NearestClampParams = {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      wrapS: ClampToEdgeWrapping,
      wrapT: ClampToEdgeWrapping,
      format: RGBAFormat,
      stencilBuffer: false,
      depthBuffer: false,
      premultiplyAlpha: false,
      type: renderTargetType
    };
    var NearestRepeatParams = {
      minFilter: NearestFilter,
      magFilter: NearestFilter,
      wrapS: RepeatWrapping,
      wrapT: RepeatWrapping,
      format: RGBAFormat,
      stencilBuffer: false,
      depthBuffer: false,
      premultiplyAlpha: false,
      type: renderTargetType
    };
    this.initialSpectrumFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestRepeatParams);
    this.spectrumFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);
    this.pingPhaseFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);
    this.pongPhaseFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);
    this.pingTransformFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);
    this.pongTransformFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, NearestClampParams);
    this.displacementMapFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, LinearClampParams);
    this.normalMapFramebuffer = new WebGLRenderTarget(this.resolution, this.resolution, LinearClampParams); // Define shaders and constant uniforms
    ////////////////////////////////////////
    // 1 - Horizontal wave vertices used for FFT

    this.materialOceanHorizontal = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanSubTransform.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: "#define HORIZONTAL \n" + OceanSubTransform.fragment()
    });
    this.materialOceanHorizontal.uniforms.u_transformSize = {
      type: "f",
      value: this.resolution
    };
    this.materialOceanHorizontal.uniforms.u_subtransformSize = {
      type: "f",
      value: null
    };
    this.materialOceanHorizontal.uniforms.u_input = {
      type: "t",
      value: null
    };
    this.materialOceanHorizontal.depthTest = false; // 2 - Vertical wave vertices used for FFT

    this.materialOceanVertical = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanSubTransform.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: OceanSubTransform.fragment()
    });
    this.materialOceanVertical.uniforms.u_transformSize = {
      type: "f",
      value: this.resolution
    };
    this.materialOceanVertical.uniforms.u_subtransformSize = {
      type: "f",
      value: null
    };
    this.materialOceanVertical.uniforms.u_input = {
      type: "t",
      value: null
    };
    this.materialOceanVertical.depthTest = false; // 3 - Initial spectrum used to generate height map

    this.materialInitialSpectrum = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanInitialSpectrum.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: OceanInitialSpectrum.fragment()
    });
    this.materialInitialSpectrum.uniforms.u_wind = {
      type: "v2",
      value: new Vector2()
    };
    this.materialInitialSpectrum.uniforms.u_resolution = {
      type: "f",
      value: this.resolution
    };
    this.materialInitialSpectrum.depthTest = false; // 4 - Phases used to animate heightmap

    this.materialPhase = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanPhase.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: OceanPhase.fragment()
    });
    this.materialPhase.uniforms.u_resolution = {
      type: "f",
      value: this.resolution
    };
    this.materialPhase.depthTest = false; // 5 - Shader used to update spectrum

    this.materialSpectrum = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanSpectrum.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: OceanSpectrum.fragment()
    });
    this.materialSpectrum.uniforms.u_initialSpectrum = {
      type: "t",
      value: null
    };
    this.materialSpectrum.uniforms.u_resolution = {
      type: "f",
      value: this.resolution
    };
    this.materialSpectrum.depthTest = false; // 6 - Shader used to update spectrum normals

    this.materialNormal = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanNormals.uniforms()),
      vertexShader: OceanSimVertex.vertex(),
      fragmentShader: OceanNormals.fragment()
    });
    this.materialNormal.uniforms.u_displacementMap = {
      type: "t",
      value: null
    };
    this.materialNormal.uniforms.u_resolution = {
      type: "f",
      value: this.resolution
    };
    this.materialNormal.depthTest = false; // 7 - Shader used to update normals

    this.materialOcean = new ShaderMaterial({
      uniforms: UniformsUtils.clone(OceanMain.uniforms()),
      vertexShader: OceanMain.vertex(),
      fragmentShader: OceanMain.fragment()
    }); // this.materialOcean.wireframe = true;

    this.materialOcean.uniforms.u_geometrySize = {
      type: "f",
      value: this.resolution
    };
    this.materialOcean.uniforms.u_displacementMap = {
      type: "t",
      value: this.displacementMapFramebuffer.texture
    };
    this.materialOcean.uniforms.u_normalMap = {
      type: "t",
      value: this.normalMapFramebuffer.texture
    };
    this.materialOcean.uniforms.u_oceanColor = {
      type: "v3",
      value: this.oceanColor
    };
    this.materialOcean.uniforms.u_skyColor = {
      type: "v3",
      value: this.skyColor
    };
    this.materialOcean.uniforms.u_sunDirection = {
      type: "v3",
      value: new Vector3(this.sunDirectionX, this.sunDirectionY, this.sunDirectionZ)
    };
    this.materialOcean.uniforms.u_exposure = {
      type: "f",
      value: this.exposure
    }; // Disable blending to prevent default premultiplied alpha values

    this.materialOceanHorizontal.blending = 0;
    this.materialOceanVertical.blending = 0;
    this.materialInitialSpectrum.blending = 0;
    this.materialPhase.blending = 0;
    this.materialSpectrum.blending = 0;
    this.materialNormal.blending = 0;
    this.materialOcean.blending = 0; // Create the simulation plane

    this.screenQuad = new Mesh(new PlaneGeometry(2, 2));
    this.scene.add(this.screenQuad); // Initialise spectrum data

    this.generateSeedPhaseTexture(); // Generate the ocean mesh

    this.generateMesh();
  }

  _createClass(OceanShader, [{
    key: "generateMesh",
    value: function generateMesh() {
      var geometry = new PlaneGeometry(this.geometrySize, this.geometrySize, this.geometryResolution, this.geometryResolution);
      geometry.rotateX(-Math.PI / 2);
      this.oceanMesh = new Mesh(geometry, this.materialOcean);
    }
  }, {
    key: "update",
    value: function update() {
      this.scene.overrideMaterial = null;
      if (this.changed) this.renderInitialSpectrum();
      this.renderWavePhase();
      this.renderSpectrum();
      this.renderSpectrumFFT();
      this.renderNormalMap();
      this.scene.overrideMaterial = null;
    }
  }, {
    key: "generateSeedPhaseTexture",
    value: function generateSeedPhaseTexture() {
      // Setup the seed texture
      this.pingPhase = true;
      var phaseArray = new Float32Array(this.resolution * this.resolution * 4);

      for (var i = 0; i < this.resolution; i++) {
        for (var j = 0; j < this.resolution; j++) {
          phaseArray[i * this.resolution * 4 + j * 4] = Math.random() * 2.0 * Math.PI;
          phaseArray[i * this.resolution * 4 + j * 4 + 1] = 0.0;
          phaseArray[i * this.resolution * 4 + j * 4 + 2] = 0.0;
          phaseArray[i * this.resolution * 4 + j * 4 + 3] = 0.0;
        }
      }

      this.pingPhaseTexture = new DataTexture(phaseArray, this.resolution, this.resolution, THREE.RGBAFormat);
      this.pingPhaseTexture.wrapS = ClampToEdgeWrapping;
      this.pingPhaseTexture.wrapT = ClampToEdgeWrapping;
      this.pingPhaseTexture.type = FloatType;
      this.pingPhaseTexture.needsUpdate = true;
    }
  }, {
    key: "renderInitialSpectrum",
    value: function renderInitialSpectrum() {
      this.scene.overrideMaterial = this.materialInitialSpectrum;
      this.materialInitialSpectrum.uniforms.u_wind.value.set(this.windX, this.windY);
      this.materialInitialSpectrum.uniforms.u_size.value = this.size;
      this.renderer.render(this.scene, this.oceanCamera, this.initialSpectrumFramebuffer, true);
    }
  }, {
    key: "renderWavePhase",
    value: function renderWavePhase() {
      this.scene.overrideMaterial = this.materialPhase;
      this.screenQuad.material = this.materialPhase;

      if (this.initial) {
        this.materialPhase.uniforms.u_phases.value = this.pingPhaseTexture;
        this.initial = false;
      } else {
        this.materialPhase.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;
      }

      this.materialPhase.uniforms.u_deltaTime.value = this.deltaTime;
      this.materialPhase.uniforms.u_size.value = this.size;
      this.renderer.render(this.scene, this.oceanCamera, this.pingPhase ? this.pongPhaseFramebuffer : this.pingPhaseFramebuffer);
      this.pingPhase = !this.pingPhase;
    }
  }, {
    key: "renderSpectrum",
    value: function renderSpectrum() {
      this.scene.overrideMaterial = this.materialSpectrum;
      this.materialSpectrum.uniforms.u_initialSpectrum.value = this.initialSpectrumFramebuffer.texture;
      this.materialSpectrum.uniforms.u_phases.value = this.pingPhase ? this.pingPhaseFramebuffer.texture : this.pongPhaseFramebuffer.texture;
      this.materialSpectrum.uniforms.u_choppiness.value = this.choppiness;
      this.materialSpectrum.uniforms.u_size.value = this.size;
      this.renderer.render(this.scene, this.oceanCamera, this.spectrumFramebuffer);
    }
  }, {
    key: "renderSpectrumFFT",
    value: function renderSpectrumFFT() {
      // GPU FFT using Stockham formulation
      var iterations = Math.log(this.resolution) / Math.log(2); // log2

      this.scene.overrideMaterial = this.materialOceanHorizontal;

      for (var i = 0; i < iterations; i++) {
        if (i === 0) {
          this.materialOceanHorizontal.uniforms.u_input.value = this.spectrumFramebuffer.texture;
          this.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);
        } else if (i % 2 === 1) {
          this.materialOceanHorizontal.uniforms.u_input.value = this.pingTransformFramebuffer.texture;
          this.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.pongTransformFramebuffer);
        } else {
          this.materialOceanHorizontal.uniforms.u_input.value = this.pongTransformFramebuffer.texture;
          this.materialOceanHorizontal.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);
        }
      }

      this.scene.overrideMaterial = this.materialOceanVertical;

      for (var i = iterations; i < iterations * 2; i++) {
        if (i === iterations * 2 - 1) {
          this.materialOceanVertical.uniforms.u_input.value = iterations % 2 === 0 ? this.pingTransformFramebuffer.texture : this.pongTransformFramebuffer.texture;
          this.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.displacementMapFramebuffer);
        } else if (i % 2 === 1) {
          this.materialOceanVertical.uniforms.u_input.value = this.pingTransformFramebuffer.texture;
          this.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.pongTransformFramebuffer);
        } else {
          this.materialOceanVertical.uniforms.u_input.value = this.pongTransformFramebuffer.texture;
          this.materialOceanVertical.uniforms.u_subtransformSize.value = Math.pow(2, i % iterations + 1);
          this.renderer.render(this.scene, this.oceanCamera, this.pingTransformFramebuffer);
        }
      }
    }
  }, {
    key: "renderNormalMap",
    value: function renderNormalMap() {
      this.scene.overrideMaterial = this.materialNormal;
      if (this.changed) this.materialNormal.uniforms.u_size.value = this.size;
      this.materialNormal.uniforms.u_displacementMap.value = this.displacementMapFramebuffer.texture;
      this.renderer.render(this.scene, this.oceanCamera, this.normalMapFramebuffer, true);
    }
  }]);

  return OceanShader;
}();

var Ocean = /*#__PURE__*/function () {
  function Ocean() {
    _classCallCheck(this, Ocean);

    var gsize = options.geometrySize || 512,
        res = options.resolution || 1024,
        gres = res / 2,
        origx = -gsize / 2,
        origz = -gsize / 2;
    this.ocean = new OceanShader(renderer, camera, scene, {
      USE_HALF_FLOAT: true,
      INITIAL_SIZE: options.initial.size || 256.0,
      INITIAL_WIND: options.initial.wind || [10.0, 10.0],
      INITIAL_CHOPPINESS: options.initial.choppiness || 1.5,
      CLEAR_COLOR: options.clearColor || [1.0, 1.0, 1.0, 0.0],
      GEOMETRY_ORIGIN: [origx, origz],
      SUN_DIRECTION: options.sunDirection || [-1.0, 1.0, 1.0],
      OCEAN_COLOR: options.oceanColor || new Vector3(0.004, 0.016, 0.047),
      SKY_COLOR: options.skyColor || new Vector3(3.2, 9.6, 12.8),
      EXPOSURE: options.exposure || 0.35,
      GEOMETRY_RESOLUTION: gres,
      GEOMETRY_SIZE: gsize,
      RESOLUTION: res
    });
    this.ocean.lastTime = new Date().getTime();
    this.ocean.materialOcean.uniforms.u_projectionMatrix = {
      type: "m4",
      value: camera.projectionMatrix
    };
    this.ocean.materialOcean.uniforms.u_viewMatrix = {
      type: "m4",
      value: camera.matrixWorldInverse
    };
    this.ocean.materialOcean.uniforms.u_cameraPosition = {
      type: "v3",
      value: camera.position
    };
  }

  _createClass(Ocean, [{
    key: "render",
    value: function render() {
      var currentTime = new Date().getTime();
      this.ocean.deltaTime = (currentTime - this.ocean.lastTime) / 1000 || 0.0;
      this.ocean.lastTime = currentTime;
      this.ocean.update(this.ocean.deltaTime);
      this.ocean.overrideMaterial = this.ocean.materialOcean;

      if (this.ocean.changed) {
        this.ocean.materialOcean.uniforms.u_size.value = this.ocean.size;
        this.ocean.materialOcean.uniforms.u_sunDirection.value.set(this.ocean.sunDirectionX, this.ocean.sunDirectionY, this.ocean.sunDirectionZ);
        this.ocean.materialOcean.uniforms.u_exposure.value = this.ocean.exposure;
        this.ocean.changed = false;
      }

      this.ocean.materialOcean.uniforms.u_normalMap.value = this.ocean.normalMapFramebuffer.texture;
      this.ocean.materialOcean.uniforms.u_displacementMap.value = this.ocean.displacementMapFramebuffer.texture;
      this.ocean.materialOcean.uniforms.u_projectionMatrix.value = camera.projectionMatrix;
      this.ocean.materialOcean.uniforms.u_viewMatrix.value = camera.matrixWorldInverse;
      this.ocean.materialOcean.uniforms.u_cameraPosition.value = camera.position;
      this.ocean.materialOcean.depthTest = true;
    }
  }]);

  return Ocean;
}();var WaterMesh = function WaterMesh(geometry, options) {
  Mesh.call(this, geometry);
  var scope = this;
  options = options || {};
  var textureWidth = options.textureWidth !== undefined ? options.textureWidth : 512;
  var textureHeight = options.textureHeight !== undefined ? options.textureHeight : 512;
  var clipBias = options.clipBias !== undefined ? options.clipBias : 0.0;
  var alpha = options.alpha !== undefined ? options.alpha : 1.0;
  var time = options.time !== undefined ? options.time : 0.0;
  var normalSampler = options.waterNormals !== undefined ? options.waterNormals : null;
  var sunDirection = options.sunDirection !== undefined ? options.sunDirection : new Vector3$1(0.70707, 0.70707, 0.0);
  var sunColor = new Color$1(options.sunColor !== undefined ? options.sunColor : 0xffffff);
  var waterColor = new Color$1(options.waterColor !== undefined ? options.waterColor : 0x7F7F7F);
  var eye = options.eye !== undefined ? options.eye : new Vector3$1(0, 0, 0);
  var distortionScale = options.distortionScale !== undefined ? options.distortionScale : 20.0;
  var side = options.side !== undefined ? options.side : FrontSide;
  var fog = options.fog !== undefined ? options.fog : false; //

  var mirrorPlane = new Plane$1();
  var normal = new Vector3$1();
  var mirrorWorldPosition = new Vector3$1();
  var cameraWorldPosition = new Vector3$1();
  var rotationMatrix = new Matrix4();
  var lookAtPosition = new Vector3$1(0, 0, -1);
  var clipPlane = new Vector4();
  var view = new Vector3$1();
  var target = new Vector3$1();
  var q = new Vector4();
  var textureMatrix = new Matrix4();
  var mirrorCamera = new PerspectiveCamera();
  var parameters = {
    minFilter: LinearFilter,
    magFilter: LinearFilter,
    format: RGBFormat
  };
  var renderTarget = new WebGLRenderTarget(textureWidth, textureHeight, parameters);

  if (!MathUtils.isPowerOfTwo(textureWidth) || !MathUtils.isPowerOfTwo(textureHeight)) {
    renderTarget.texture.generateMipmaps = false;
  }

  var mirrorShader = {
    uniforms: UniformsUtils.merge([UniformsLib['fog'], UniformsLib['lights'], {
      'normalSampler': {
        value: null
      },
      'mirrorSampler': {
        value: null
      },
      'alpha': {
        value: 1.0
      },
      'time': {
        value: 0.0
      },
      'size': {
        value: 1.0
      },
      'distortionScale': {
        value: 20.0
      },
      'textureMatrix': {
        value: new Matrix4()
      },
      'sunColor': {
        value: new Color$1(0x7F7F7F)
      },
      'sunDirection': {
        value: new Vector3$1(0.70707, 0.70707, 0)
      },
      'eye': {
        value: new Vector3$1()
      },
      'waterColor': {
        value: new Color$1(0x555555)
      }
    }]),
    vertexShader: ['uniform mat4 textureMatrix;', 'uniform float time;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', '#include <common>', '#include <fog_pars_vertex>', '#include <shadowmap_pars_vertex>', '#include <logdepthbuf_pars_vertex>', 'void main() {', '	mirrorCoord = modelMatrix * vec4( position, 1.0 );', '	worldPosition = mirrorCoord.xyzw;', '	mirrorCoord = textureMatrix * mirrorCoord;', '	vec4 mvPosition =  modelViewMatrix * vec4( position, 1.0 );', '	gl_Position = projectionMatrix * mvPosition;', '#include <beginnormal_vertex>', '#include <defaultnormal_vertex>', '#include <logdepthbuf_vertex>', '#include <fog_vertex>', '#include <shadowmap_vertex>', '}'].join('\n'),
    fragmentShader: ['uniform sampler2D mirrorSampler;', 'uniform float alpha;', 'uniform float time;', 'uniform float size;', 'uniform float distortionScale;', 'uniform sampler2D normalSampler;', 'uniform vec3 sunColor;', 'uniform vec3 sunDirection;', 'uniform vec3 eye;', 'uniform vec3 waterColor;', 'varying vec4 mirrorCoord;', 'varying vec4 worldPosition;', 'vec4 getNoise( vec2 uv ) {', '	vec2 uv0 = ( uv / 103.0 ) + vec2(time / 17.0, time / 29.0);', '	vec2 uv1 = uv / 107.0-vec2( time / -19.0, time / 31.0 );', '	vec2 uv2 = uv / vec2( 8907.0, 9803.0 ) + vec2( time / 101.0, time / 97.0 );', '	vec2 uv3 = uv / vec2( 1091.0, 1027.0 ) - vec2( time / 109.0, time / -113.0 );', '	vec4 noise = texture2D( normalSampler, uv0 ) +', '		texture2D( normalSampler, uv1 ) +', '		texture2D( normalSampler, uv2 ) +', '		texture2D( normalSampler, uv3 );', '	return noise * 0.5 - 1.0;', '}', 'void sunLight( const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor ) {', '	vec3 reflection = normalize( reflect( -sunDirection, surfaceNormal ) );', '	float direction = max( 0.0, dot( eyeDirection, reflection ) );', '	specularColor += pow( direction, shiny ) * sunColor * spec;', '	diffuseColor += max( dot( sunDirection, surfaceNormal ), 0.0 ) * sunColor * diffuse;', '}', '#include <common>', '#include <packing>', '#include <bsdfs>', '#include <fog_pars_fragment>', '#include <logdepthbuf_pars_fragment>', '#include <lights_pars_begin>', '#include <shadowmap_pars_fragment>', '#include <shadowmask_pars_fragment>', 'void main() {', '#include <logdepthbuf_fragment>', '	vec4 noise = getNoise( worldPosition.xz * size );', '	vec3 surfaceNormal = normalize( noise.xzy * vec3( 1.5, 1.0, 1.5 ) );', '	vec3 diffuseLight = vec3(0.0);', '	vec3 specularLight = vec3(0.0);', '	vec3 worldToEye = eye-worldPosition.xyz;', '	vec3 eyeDirection = normalize( worldToEye );', '	sunLight( surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight );', '	float distance = length(worldToEye);', '	vec2 distortion = surfaceNormal.xz * ( 0.001 + 1.0 / distance ) * distortionScale;', '	vec3 reflectionSample = vec3( texture2D( mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion ) );', '	float theta = max( dot( eyeDirection, surfaceNormal ), 0.0 );', '	float rf0 = 0.3;', '	float reflectance = rf0 + ( 1.0 - rf0 ) * pow( ( 1.0 - theta ), 5.0 );', '	vec3 scatter = max( 0.0, dot( surfaceNormal, eyeDirection ) ) * waterColor;', '	vec3 albedo = mix( ( sunColor * diffuseLight * 0.3 + scatter ) * getShadowMask(), ( vec3( 0.1 ) + reflectionSample * 0.9 + reflectionSample * specularLight ), reflectance);', '	vec3 outgoingLight = albedo;', '	gl_FragColor = vec4( outgoingLight, alpha );', '#include <tonemapping_fragment>', '#include <fog_fragment>', '}'].join('\n')
  };
  var material = new ShaderMaterial({
    fragmentShader: mirrorShader.fragmentShader,
    vertexShader: mirrorShader.vertexShader,
    uniforms: UniformsUtils.clone(mirrorShader.uniforms),
    lights: true,
    side: side,
    fog: fog
  });
  material.uniforms['mirrorSampler'].value = renderTarget.texture;
  material.uniforms['textureMatrix'].value = textureMatrix;
  material.uniforms['alpha'].value = alpha;
  material.uniforms['time'].value = time;
  material.uniforms['normalSampler'].value = normalSampler;
  material.uniforms['sunColor'].value = sunColor;
  material.uniforms['waterColor'].value = waterColor;
  material.uniforms['sunDirection'].value = sunDirection;
  material.uniforms['distortionScale'].value = distortionScale;
  material.uniforms['eye'].value = eye;
  scope.material = material;

  scope.onBeforeRender = function (renderer, scene, camera) {
    mirrorWorldPosition.setFromMatrixPosition(scope.matrixWorld);
    cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
    rotationMatrix.extractRotation(scope.matrixWorld);
    normal.set(0, 0, 1);
    normal.applyMatrix4(rotationMatrix);
    view.subVectors(mirrorWorldPosition, cameraWorldPosition); // Avoid rendering when mirror is facing away

    if (view.dot(normal) > 0) return;
    view.reflect(normal).negate();
    view.add(mirrorWorldPosition);
    rotationMatrix.extractRotation(camera.matrixWorld);
    lookAtPosition.set(0, 0, -1);
    lookAtPosition.applyMatrix4(rotationMatrix);
    lookAtPosition.add(cameraWorldPosition);
    target.subVectors(mirrorWorldPosition, lookAtPosition);
    target.reflect(normal).negate();
    target.add(mirrorWorldPosition);
    mirrorCamera.position.copy(view);
    mirrorCamera.up.set(0, 1, 0);
    mirrorCamera.up.applyMatrix4(rotationMatrix);
    mirrorCamera.up.reflect(normal);
    mirrorCamera.lookAt(target);
    mirrorCamera.far = camera.far; // Used in WebGLBackground

    mirrorCamera.updateMatrixWorld();
    mirrorCamera.projectionMatrix.copy(camera.projectionMatrix); // Update the texture matrix

    textureMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
    textureMatrix.multiply(mirrorCamera.projectionMatrix);
    textureMatrix.multiply(mirrorCamera.matrixWorldInverse); // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
    // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf

    mirrorPlane.setFromNormalAndCoplanarPoint(normal, mirrorWorldPosition);
    mirrorPlane.applyMatrix4(mirrorCamera.matrixWorldInverse);
    clipPlane.set(mirrorPlane.normal.x, mirrorPlane.normal.y, mirrorPlane.normal.z, mirrorPlane.constant);
    var projectionMatrix = mirrorCamera.projectionMatrix;
    q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
    q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
    q.z = -1.0;
    q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14]; // Calculate the scaled plane vector

    clipPlane.multiplyScalar(2.0 / clipPlane.dot(q)); // Replacing the third row of the projection matrix

    projectionMatrix.elements[2] = clipPlane.x;
    projectionMatrix.elements[6] = clipPlane.y;
    projectionMatrix.elements[10] = clipPlane.z + 1.0 - clipBias;
    projectionMatrix.elements[14] = clipPlane.w;
    eye.setFromMatrixPosition(camera.matrixWorld); // Render

    if (renderer.outputEncoding !== LinearEncoding) {
      console.warn('THREE.WaterMesh: WebGLRenderer must use LinearEncoding as outputEncoding.');

      scope.onBeforeRender = function () {};

      return;
    }

    if (renderer.toneMapping !== NoToneMapping) {
      console.warn('THREE.WaterMesh: WebGLRenderer must use NoToneMapping as toneMapping.');

      scope.onBeforeRender = function () {};

      return;
    }

    var currentRenderTarget = renderer.getRenderTarget();
    var currentXrEnabled = renderer.xr.enabled;
    var currentShadowAutoUpdate = renderer.shadowMap.autoUpdate;
    scope.visible = false;
    renderer.xr.enabled = false; // Avoid camera modification and recursion

    renderer.shadowMap.autoUpdate = false; // Avoid re-computing shadows

    renderer.setRenderTarget(renderTarget);
    renderer.state.buffers.depth.setMask(true); // make sure the depth buffer is writable so it can be properly cleared, see #18897

    if (renderer.autoClear === false) renderer.clear();
    renderer.render(scene, mirrorCamera);
    scope.visible = true;
    renderer.xr.enabled = currentXrEnabled;
    renderer.shadowMap.autoUpdate = currentShadowAutoUpdate;
    renderer.setRenderTarget(currentRenderTarget); // Restore viewport

    var viewport = camera.viewport;

    if (viewport !== undefined) {
      renderer.state.viewport(viewport);
    }
  };
};

WaterMesh.prototype = Object.create(Mesh.prototype);
WaterMesh.prototype.constructor = WaterMesh;
var DEFAULT_WATER_HEIGHT = 512;
var DEFAULT_WATER_WIDTH = 512;
var DEFAULT_WATER_ALPHA = 1.0;
var DEFAULT_WATER_DISTORTION_SCALE = 3.7;

var Water = /*#__PURE__*/function (_Element) {
  _inherits(Water, _Element);

  var _super = _createSuper(Water);

  function Water() {
    var _thisSuper, _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Water);

    _this = _super.call(this, options);

    _defineProperty$1(_assertThisInitialized(_this), "update", function (dt) {
      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(Water.prototype)), "update", _thisSuper).call(_thisSuper, dt);

      _this.getBody().material.uniforms.time.value += dt; //1.0 / 60.0;
    });

    var texture = options.texture,
        textureNormalName = options.textureNormalName,
        _options$width = options.width,
        width = _options$width === void 0 ? DEFAULT_WATER_WIDTH : _options$width,
        _options$height = options.height,
        height = _options$height === void 0 ? DEFAULT_WATER_HEIGHT : _options$height,
        _options$textureWidth = options.textureWidth,
        textureWidth = _options$textureWidth === void 0 ? DEFAULT_WATER_WIDTH : _options$textureWidth,
        _options$textureHeigh = options.textureHeight,
        textureHeight = _options$textureHeigh === void 0 ? DEFAULT_WATER_HEIGHT : _options$textureHeigh,
        _options$alpha = options.alpha,
        alpha = _options$alpha === void 0 ? DEFAULT_WATER_ALPHA : _options$alpha,
        _options$distortionSc = options.distortionScale,
        distortionScale = _options$distortionSc === void 0 ? DEFAULT_WATER_DISTORTION_SCALE : _options$distortionSc;
    var waterNormals = texture || Images$1.get(textureNormalName || 'waterNormal');
    waterNormals.wrapS = waterNormals.wrapT = RepeatWrapping$1;
    var body = new WaterMesh(new PlaneGeometry(width * 500, height * 500), {
      textureWidth: textureWidth,
      textureHeight: textureHeight,
      waterNormals: waterNormals,
      alpha: alpha,
      sunDirection: new Vector3$1(-0.5773502691896258, 0.5773502691896258, -0.5773502691896258),
      sunColor: 0xffffff,
      waterColor: 0x001e0f,
      distortionScale: distortionScale,
      fog: Scene$1.getScene().fog !== undefined
    });

    _this.setBody({
      body: body
    });

    _this.setEntityType(ENTITY_TYPES.MESH);

    _this.setRotation({
      x: -Math.PI / 2
    });

    return _this;
  }

  _createClass(Water, [{
    key: "setSize",
    value: function setSize(size) {
      this.getBody().material.uniforms.size.value = clamp(size, 0.1, 100);
    }
  }]);

  return Water;
}(Element$1);var SkyShader = /*#__PURE__*/function () {
  function SkyShader() {
    _classCallCheck(this, SkyShader);
  }

  _createClass(SkyShader, null, [{
    key: "uniforms",
    value: function uniforms() {
      return {
        luminance: {
          value: 1
        },
        turbidity: {
          value: 2
        },
        rayleigh: {
          value: 1
        },
        mieCoefficient: {
          value: 0.005
        },
        mieDirectionalG: {
          value: 0.8
        },
        sunPosition: {
          value: new Vector3$1()
        }
      };
    }
  }, {
    key: "vertexShader",
    value: function vertexShader() {
      return ['uniform vec3 sunPosition;', 'uniform float rayleigh;', 'uniform float turbidity;', 'uniform float mieCoefficient;', 'varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );', // constants for atmospheric scattering
      'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', // wavelength of used primaries, according to preetham
      'const vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );', // this pre-calcuation replaces older TotalRayleigh(vec3 lambda) function:
      // (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn))
      'const vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );', // mie stuff
      // K coefficient for the primaries
      'const float v = 4.0;', 'const vec3 K = vec3( 0.686, 0.678, 0.666 );', // MieConst = pi * pow( ( 2.0 * pi ) / lambda, vec3( v - 2.0 ) ) * K
      'const vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );', // earth shadow hack
      // cutoffAngle = pi / 1.95;
      'const float cutoffAngle = 1.6110731556870734;', 'const float steepness = 1.5;', 'const float EE = 1000.0;', 'float sunIntensity( float zenithAngleCos ) {', '    zenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );', '    return EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );', '}', 'vec3 totalMie( float T ) {', '    float c = ( 0.2 * T ) * 10E-18;', '    return 0.434 * c * MieConst;', '}', 'void main() {', '    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );', '    vWorldPosition = worldPosition.xyz;', '    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '    gl_Position.z = gl_Position.w;', // set z to camera.far
      '    vSunDirection = normalize( sunPosition );', '    vSunE = sunIntensity( dot( vSunDirection, up ) );', '    vSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );', '    float rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );', // extinction (absorbtion + out scattering)
      // rayleigh coefficients
      '    vBetaR = totalRayleigh * rayleighCoefficient;', // mie coefficients
      '    vBetaM = totalMie( turbidity ) * mieCoefficient;', '}'].join('\n');
    }
  }, {
    key: "fragmentShader",
    value: function fragmentShader() {
      return ['varying vec3 vWorldPosition;', 'varying vec3 vSunDirection;', 'varying float vSunfade;', 'varying vec3 vBetaR;', 'varying vec3 vBetaM;', 'varying float vSunE;', 'uniform float luminance;', 'uniform float mieDirectionalG;', 'const vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );', // constants for atmospheric scattering
      'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003;', // refractive index of air
      'const float N = 2.545E25;', // number of molecules per unit volume for air at
      // 288.15K and 1013mb (sea level -45 celsius)
      // optical length at zenith for molecules
      'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;', 'const vec3 up = vec3( 0.0, 1.0, 0.0 );', // 66 arc seconds -> degrees, and the cosine of that
      'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', // 3.0 / ( 16.0 * pi )
      'const float THREE_OVER_SIXTEENPI = 0.05968310365946075;', // 1.0 / ( 4.0 * pi )
      'const float ONE_OVER_FOURPI = 0.07957747154594767;', 'float rayleighPhase( float cosTheta ) {', '    return THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );', '}', 'float hgPhase( float cosTheta, float g ) {', '    float g2 = pow( g, 2.0 );', '    float inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );', '    return ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );', '}', // Filmic ToneMapping http://filmicgames.com/archives/75
      'const float A = 0.15;', 'const float B = 0.50;', 'const float C = 0.10;', 'const float D = 0.20;', 'const float E = 0.02;', 'const float F = 0.30;', 'const float whiteScale = 1.0748724675633854;', // 1.0 / Uncharted2Tonemap(1000.0)
      'vec3 Uncharted2Tonemap( vec3 x ) {', '    return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;', '}', 'void main() {', // optical length
      // cutoff angle at 90 to avoid singularity in next formula.
      '    float zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );', '    float inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );', '    float sR = rayleighZenithLength * inverse;', '    float sM = mieZenithLength * inverse;', // combined extinction factor
      '    vec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );', // in scattering
      '    float cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );', '    float rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );', '    vec3 betaRTheta = vBetaR * rPhase;', '    float mPhase = hgPhase( cosTheta, mieDirectionalG );', '    vec3 betaMTheta = vBetaM * mPhase;', '    vec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );', '    Lin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );', // nightsky
      '    vec3 direction = normalize( vWorldPosition - cameraPos );', '    float theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]', '    float phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]', '    vec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );', '    vec3 L0 = vec3( 0.1 ) * Fex;', // composition + solar disc
      '    float sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );', '    L0 += ( vSunE * 19000.0 * Fex ) * sundisk;', '    vec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );', '    vec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );', '    vec3 color = curr * whiteScale;', '    vec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );', '    gl_FragColor = vec4( retColor, 1.0 );', '}'].join('\n');
    }
  }]);

  return SkyShader;
}();
var DEFAULT_SCALE = 10000;
var DEFAULT_TURBIDITY = 10;
var DEFAULT_RALEIGH = .8;
var DEFAULT_MIE_COEFFICIENT = 0.005;
var DEFAULT_MIE_DIRECTIONAL_G = .8;
var DEFAULT_SUN_INCLINATION = .49;
var DEFAULT_SUN_AZIMUTH = 0.205;
var DEFAULT_SUN_DISTANCE = 100;

var Sky = /*#__PURE__*/function (_Element) {
  _inherits(Sky, _Element);

  var _super = _createSuper(Sky);

  function Sky() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Sky);

    _this = _super.call(this, options);
    var _options$scale = options.scale,
        scale = _options$scale === void 0 ? DEFAULT_SCALE : _options$scale,
        _options$turbidity = options.turbidity,
        turbidity = _options$turbidity === void 0 ? DEFAULT_TURBIDITY : _options$turbidity,
        _options$rayleigh = options.rayleigh,
        rayleigh = _options$rayleigh === void 0 ? DEFAULT_RALEIGH : _options$rayleigh,
        _options$mieCoefficie = options.mieCoefficient,
        mieCoefficient = _options$mieCoefficie === void 0 ? DEFAULT_MIE_COEFFICIENT : _options$mieCoefficie,
        _options$mieDirection = options.mieDirectionalG,
        mieDirectionalG = _options$mieDirection === void 0 ? DEFAULT_MIE_DIRECTIONAL_G : _options$mieDirection,
        _options$sunInclinati = options.sunInclination,
        sunInclination = _options$sunInclinati === void 0 ? DEFAULT_SUN_INCLINATION : _options$sunInclinati,
        _options$sunAzimuth = options.sunAzimuth,
        sunAzimuth = _options$sunAzimuth === void 0 ? DEFAULT_SUN_AZIMUTH : _options$sunAzimuth,
        _options$sunDistance = options.sunDistance,
        sunDistance = _options$sunDistance === void 0 ? DEFAULT_SUN_DISTANCE : _options$sunDistance;
    var material = new ShaderMaterial({
      fragmentShader: SkyShader.fragmentShader(),
      vertexShader: SkyShader.vertexShader(),
      uniforms: UniformsUtils.clone(SkyShader.uniforms()),
      side: BackSide
    });
    var body = new Mesh(new BoxGeometry(1, 1, 1), material);

    _this.setBody({
      body: body
    });

    _this.setEntityType(ENTITY_TYPES.EFFECT.SCENERY);

    _this.setScale({
      x: scale,
      y: scale,
      z: scale
    });

    _this.seTurbidity(turbidity);

    _this.setRayleigh(rayleigh);

    _this.setMieCoefficient(mieCoefficient);

    _this.setMieDirectionalG(mieDirectionalG);

    _this.setSun(sunInclination, sunAzimuth, sunDistance);

    return _this;
  }

  _createClass(Sky, [{
    key: "seTurbidity",
    value: function seTurbidity(value) {
      this.getBody().material.uniforms.turbidity.value = value;
    }
  }, {
    key: "setRayleigh",
    value: function setRayleigh(value) {
      this.getBody().material.uniforms.rayleigh.value = value;
    }
  }, {
    key: "setLuminance",
    value: function setLuminance(value) {
      this.getBody().material.uniforms.luminance.value = value;
    }
  }, {
    key: "setMieCoefficient",
    value: function setMieCoefficient(value) {
      this.getBody().material.uniforms.mieCoefficient.value = value;
    }
  }, {
    key: "setMieDirectionalG",
    value: function setMieDirectionalG(value) {
      this.getBody().material.uniforms.mieDirectionalG.value = value;
    }
  }, {
    key: "setSun",
    value: function setSun(inclination, azimuth, distance) {
      var theta = Math.PI * (inclination - 0.5);
      var phi = 2 * Math.PI * (azimuth - 0.5);
      var x = distance * Math.cos(phi);
      var y = distance * Math.sin(phi) * Math.sin(theta);
      var z = distance * Math.sin(phi) * Math.cos(theta); // this.position.set(x, y, z);

      var position = new Vector3$1(x, y, z);
      this.getBody().material.uniforms.sunPosition.value.copy(position);
    }
  }]);

  return Sky;
}(Element$1);var _excluded = ["name", "texture"];

var Skybox = /*#__PURE__*/function (_Element) {
  _inherits(Skybox, _Element);

  var _super = _createSuper(Skybox);

  function Skybox(options) {
    var _this;

    _classCallCheck(this, Skybox);

    var _options$name = options.name,
        name = _options$name === void 0 ? generateRandomName('Skybox') : _options$name,
        _options$texture = options.texture,
        texture = _options$texture === void 0 ? 'skybox' : _options$texture,
        rest = _objectWithoutProperties(options, _excluded);

    _this = _super.call(this, _objectSpread2$1({
      name: name,
      texture: texture
    }, rest));
    _this.cubeMap = typeof texture === 'string' ? Images$1.get(texture) : texture;
    var material = new MeshBasicMaterial({
      envMap: _this.cubeMap,
      side: BackSide
    });
    var geometry = new BoxGeometry(1000000, 1000000, 1000000);

    _this.setBody({
      material: material,
      geometry: geometry
    });

    return _this;
  }

  return Skybox;
}(Element$1);var Shaders = /*#__PURE__*/function () {
  function Shaders() {
    var _this = this;

    _classCallCheck(this, Shaders);

    _defineProperty$1(this, "get", function (id) {
      return _this.map[id] || false;
    });

    this.map = {
      Atmosphere: Atmosphere,
      Mirror: Mirror,
      Ocean: Ocean,
      OceanShaders: OceanShaders,
      Skybox: Skybox,
      Sky: Sky,
      Water: Water
    };
    this.shaders = {};
    this.numShaders = 0;
    this.shadersLoaded = 0;
  }

  _createClass(Shaders, [{
    key: "create",
    value: function create(name, params) {
      this.map[name] = {
        name: name,
        vertex: params.vertex || "",
        fragment: params.fragment || "",
        options: params.options || {},
        attributes: params.attributes || {},
        uniforms: params.uniforms || {},
        instance: params.instance || false
      };
    }
  }, {
    key: "add",
    value: function add(name, shader) {
      this.map[name] = shader;
    }
  }]);

  return Shaders;
}();
var Shaders$1 = new Shaders();var Shader = function Shader(name, attributes, uniforms, options) {
  _classCallCheck(this, Shader);

  this.instance = Shaders$1.get(name);

  if (!this.instance) {
    this.name = this.shader.name;
    this.vertex = this.shader.vertex;
    this.fragment = this.shader.fragment;
    this.attributes = attributes ? attributes : this.shader.attributes;
    this.uniforms = uniforms ? uniforms : this.shader.uniforms; //creating shader options

    var object = {
      'attributes': this.attributes,
      'uniforms': this.uniforms,
      'vertexShader': this.shader.vertex,
      'fragmentShader': this.shader.fragment
    }; //storing user options in shader options

    var opt = options ? options : this.shader.options;

    for (o in opt) {
      object[o] = opt[o];
    } //creating the actual material


    this.material = new ShaderMaterial(object);
  } else {
    this.instance = this.shader.instance;
  }
};var constants = _objectSpread2$1(_objectSpread2$1({}, lib_constants), light_contants);

/***/ }),

/***/ "./node_modules/xferno/dist/xferno.js":
/*!********************************************!*\
  !*** ./node_modules/xferno/dist/xferno.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

!function(e,t){ true?t(exports,__webpack_require__(/*! inferno */ "./node_modules/inferno/index.esm.js")):0}(this,(function(e,t){"use strict";var n=function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")};function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=function(e,t,n){return t&&r(e.prototype,t),n&&r(e,n),e};function i(e,t,n){return e(n={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&n.path)}},n.exports),n.exports}var u=i((function(e){function t(n,r){return e.exports=t=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e},t(n,r)}e.exports=t}));var a=function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&u(e,t)},c=i((function(e){function t(n){return"function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?e.exports=t=function(e){return typeof e}:e.exports=t=function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},t(n)}e.exports=t}));var s=function(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e};var l=function(e,t){return!t||"object"!==c(t)&&"function"!=typeof t?s(e):t},f=i((function(e){function t(n){return e.exports=t=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)},t(n)}e.exports=t}));function p(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=f(e);if(t){var o=f(this).constructor;n=Reflect.construct(r,arguments,o)}else n=r.apply(this,arguments);return l(this,n)}}var d=function(e){a(r,e);var t=p(r);function r(e,o){var i;return n(this,r),(i=t.call(this,e,o)).childContext={store:e.store},i}return o(r,[{key:"getChildContext",value:function(){return this.childContext}},{key:"render",value:function(){return this.props.children}}]),r}(t.Component);var h=function(e){if(Array.isArray(e))return e};var y=function(e,t){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e)){var n=[],r=!0,o=!1,i=void 0;try{for(var u,a=e[Symbol.iterator]();!(r=(u=a.next()).done)&&(n.push(u.value),!t||n.length!==t);r=!0);}catch(e){o=!0,i=e}finally{try{r||null==a.return||a.return()}finally{if(o)throw i}}return n}};var m=function(e,t){(null==t||t>e.length)&&(t=e.length);for(var n=0,r=new Array(t);n<t;n++)r[n]=e[n];return r};var v=function(e,t){if(e){if("string"==typeof e)return m(e,t);var n=Object.prototype.toString.call(e).slice(8,-1);return"Object"===n&&e.constructor&&(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?m(e,t):void 0}};var C=function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")};var b,g,S=function(e,t){return h(e)||y(e,t)||v(e,t)||C()};function k(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t))return e.length===t.length&&e.every((function(e,n){return e===t[n]}));if("object"==typeof e&&"object"==typeof t){var n=Object.entries(e),r=Object.entries(t);return n.length===r.length&&n.every((function(e,t){var n=S(e,2),o=n[0],i=n[1],u=S(r[t],2),a=u[0],c=u[1];return o===a&&i===c}))}return!1}function w(e){var t=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}();return function(){var n,r=f(e);if(t){var o=f(this).constructor;n=Reflect.construct(r,arguments,o)}else n=r.apply(this,arguments);return l(this,n)}}!function(e){e[e.HtmlElement=1]="HtmlElement",e[e.ComponentUnknown=2]="ComponentUnknown",e[e.ComponentClass=4]="ComponentClass",e[e.ComponentFunction=8]="ComponentFunction",e[e.Text=16]="Text",e[e.SvgElement=32]="SvgElement",e[e.InputElement=64]="InputElement",e[e.TextareaElement=128]="TextareaElement",e[e.SelectElement=256]="SelectElement",e[e.Void=512]="Void",e[e.Portal=1024]="Portal",e[e.ReCreate=2048]="ReCreate",e[e.ContentEditable=4096]="ContentEditable",e[e.Fragment=8192]="Fragment",e[e.InUse=16384]="InUse",e[e.ForwardRef=32768]="ForwardRef",e[e.Normalized=65536]="Normalized",e[e.ForwardRefComponent=32776]="ForwardRefComponent",e[e.FormElement=448]="FormElement",e[e.Element=481]="Element",e[e.Component=14]="Component",e[e.DOMRef=2033]="DOMRef",e[e.InUseOrNormalized=81920]="InUseOrNormalized",e[e.ClearInUse=-16385]="ClearInUse",e[e.ComponentKnown=12]="ComponentKnown"}(b||(b={})),function(e){e[e.UnknownChildren=0]="UnknownChildren",e[e.HasInvalidChildren=1]="HasInvalidChildren",e[e.HasVNodeChildren=2]="HasVNodeChildren",e[e.HasNonKeyedChildren=4]="HasNonKeyedChildren",e[e.HasKeyedChildren=8]="HasKeyedChildren",e[e.HasTextChildren=16]="HasTextChildren",e[e.MultipleChildren=12]="MultipleChildren"}(g||(g={}));var x,R={};function E(e,t,n){var r=t.child,o=t.childProps,i=x;x=e;try{return r(o||R,n)}finally{x=i}}function N(e){var t=0,n=[],r=void 0,o=!0;e.state={};var i={renderResult:void 0,getStoreState(){if(!r){var t=e.context.store;e.state.storeState=t.getState(),r=t.subscribe((function(){e.setState((function(e){return e.storeState=t.getState(),e}))}))}return e.state.storeState},getHook(e,r){var i=function(e){var r=t++,o=n[r];return o&&k(o.watchList,e)?(o.isNew=!1,o):(o&&o.dispose&&o.dispose(),o={id:r,isNew:!0,watchList:e},n[r]=o,o)}(e),u=i.value;return r(i),o=o||!k(i.value,u),i.value},shouldComponentUpdate(n,r,u){o=!k(e.props.childProps,n.childProps),e.state=r,t=0;var a=E(e,n,u);return o&&(i.renderResult=a),o},dispose(){r&&r(),n.forEach((function(e){return e&&e.dispose&&e.dispose()}))}};return i}var H=function(e){a(r,e);var t=w(r);function r(e,o){return n(this,r),t.call(this,e,o)}return o(r,[{key:"dispose",value:function(){this.tracker&&this.tracker.dispose(),this.state=void 0,this.tracker=void 0}},{key:"componentWillReceiveProps",value:function(e){e.child!==this.props.child&&this.dispose()}},{key:"componentWillUnmount",value:function(){this.dispose()}},{key:"getHook",value:function(e,t){return this.tracker||(this.tracker=N(this)),this.tracker.getHook(e,t)}},{key:"shouldComponentUpdate",value:function(e,t,n){return!this.tracker||this.tracker.shouldComponentUpdate(e,t,n)}},{key:"render",value:function(){return this.tracker?this.tracker.renderResult:E(this,this.props,this.context)}}]),r}(t.Component),O=t.createVNode,j=t.normalizeProps,P=t.createTextVNode,U=t.createFragment;e.ReduxStoreProvider=d,e.createComponentVNode=function(e,n,r,o,i){return n.prototype instanceof t.Component?t.createComponentVNode(e,n,r,o,i):t.createComponentVNode(b.ComponentUnknown,H,{child:n,childProps:r},o,i)},e.createFragment=U,e.createTextVNode=P,e.createVNode=O,e.normalizeProps=j,e.useDispatch=function(){return x.context.store.dispatch},e.useDisposable=function(e,t){return x.getHook(t,(function(t){if(t.isNew){var n=e();t.value=n.value,t.dispose=n.dispose}}))},e.useEffect=function(e,t){return x.getHook(t,(function(t){t.isNew&&(t.dispose=e())}))},e.useMemo=function(e,t){return x.getHook(t,(function(t){t.isNew&&(t.value=e())}))},e.useSelector=function(e){return x.getHook(0,(function(t){t.value=e(x.tracker.getStoreState())}))},e.useState=function(e){return x.getHook(0,(function(t){if(t.isNew){x.state[t.id]="function"==typeof e?e():e;var n=x;t.$setState=function(e){var r=n.state,o=r[t.id],i="function"==typeof e?e(r[t.id]):e;if(o!==i)return n.setState((function(e){return e[t.id]=i,e}))}}t.value=[x.state[t.id],t.$setState]}))},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=xferno.js.map


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var __webpack_exports__ = {};
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var mage_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! mage-engine */ "./node_modules/mage-engine/dist/mage.js");
/* harmony import */ var _levels_Main__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./levels/Main */ "./src/levels/Main/index.js");
/* harmony import */ var _ui_root__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ui/root */ "./src/ui/root.js");
/* harmony import */ var _ui_reducers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ui/reducers */ "./src/ui/reducers/index.js");




var SHADOW_TYPES = mage_engine__WEBPACK_IMPORTED_MODULE_0__.constants.SHADOW_TYPES; // const ASSETS_MODELS_BASE_PATH = 'assets/models';
// const ASSETS_TEXTURES_BASE_PATH = 'assets/textures';

var assets = {};
var config = {
  screen: {
    h: window ? window.innerHeight : 800,
    w: window ? window.innerWidth : 600,
    ratio: window ? window.innerWidth / window.innerHeight : 600 / 800,
    frameRate: 120,
    alpha: true
  },
  postprocessing: {
    enabled: true
  },
  lights: {
    shadows: true,
    shadowType: SHADOW_TYPES.HARD,
    textureAnisotropy: 1
  },
  physics: {
    enabled: false,
    path: 'ammo.js',
    gravity: {
      x: 0,
      y: -9.8,
      z: 0
    },
    fixedUpdate: 60
  },
  tween: {
    enabled: false
  },
  camera: {
    fov: 75,
    near: 0.1,
    far: 300
  },
  ui: {
    root: _ui_root__WEBPACK_IMPORTED_MODULE_2__.default
  },
  selector: '#democontainer'
};
window.addEventListener('load', function () {
  mage_engine__WEBPACK_IMPORTED_MODULE_0__.store.createStore(_ui_reducers__WEBPACK_IMPORTED_MODULE_3__.default, {}, true);
  mage_engine__WEBPACK_IMPORTED_MODULE_0__.Router.on('/', _levels_Main__WEBPACK_IMPORTED_MODULE_1__.default);
  mage_engine__WEBPACK_IMPORTED_MODULE_0__.Router.start(config, assets);
});
})();

// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!************************!*\
  !*** ./src/style.scss ***!
  \************************/
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin

})();

/******/ })()
;